/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Boot everything we need for this project
	 * We are using Gulp webpack to include scripts because
	 * its supper simple
	 */

	__webpack_require__(1);

	window.$ = window.jQuery = __webpack_require__(3);

	__webpack_require__(4);

	__webpack_require__(5);

	window.Popper = __webpack_require__(6);

	__webpack_require__(7);

	__webpack_require__(8);

	__webpack_require__(9);

	__webpack_require__(10);

	__webpack_require__(12);

	__webpack_require__(13);

	__webpack_require__(14);

	__webpack_require__(15)

	__webpack_require__(16);

	__webpack_require__(17);

	__webpack_require__(19);

	__webpack_require__(21); // Masonary + isotope + portfolio filter

	__webpack_require__(30);

	__webpack_require__(31);

	__webpack_require__(33);

	__webpack_require__(34);

	__webpack_require__(36);

	__webpack_require__(37);

	__webpack_require__(212);

	__webpack_require__(214);

	__webpack_require__(215);

	__webpack_require__(217);

	__webpack_require__(218);


	// PAPER VEVERSION : 1.2

	__webpack_require__(219);

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	var NProgress = __webpack_require__(2);
	document.addEventListener('DOMContentLoaded', function() {
	    NProgress.start();
	});
	window.addEventListener('load', function() {
	    var body = document.body;
	    var loader = document.getElementById('loader');
	    body.classList.add('loaded');
	    loader.classList.add('loader-fade');
	    NProgress.done();
	}, true);

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
	 * @license MIT */

	;(function(root, factory) {

	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof exports === 'object') {
	    module.exports = factory();
	  } else {
	    root.NProgress = factory();
	  }

	})(this, function() {
	  var NProgress = {};

	  NProgress.version = '0.2.0';

	  var Settings = NProgress.settings = {
	    minimum: 0.08,
	    easing: 'ease',
	    positionUsing: '',
	    speed: 200,
	    trickle: true,
	    trickleRate: 0.02,
	    trickleSpeed: 800,
	    showSpinner: true,
	    barSelector: '[role="bar"]',
	    spinnerSelector: '[role="spinner"]',
	    parent: 'body',
	    template: '<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'
	  };

	  /**
	   * Updates configuration.
	   *
	   *     NProgress.configure({
	   *       minimum: 0.1
	   *     });
	   */
	  NProgress.configure = function(options) {
	    var key, value;
	    for (key in options) {
	      value = options[key];
	      if (value !== undefined && options.hasOwnProperty(key)) Settings[key] = value;
	    }

	    return this;
	  };

	  /**
	   * Last number.
	   */

	  NProgress.status = null;

	  /**
	   * Sets the progress bar status, where `n` is a number from `0.0` to `1.0`.
	   *
	   *     NProgress.set(0.4);
	   *     NProgress.set(1.0);
	   */

	  NProgress.set = function(n) {
	    var started = NProgress.isStarted();

	    n = clamp(n, Settings.minimum, 1);
	    NProgress.status = (n === 1 ? null : n);

	    var progress = NProgress.render(!started),
	        bar      = progress.querySelector(Settings.barSelector),
	        speed    = Settings.speed,
	        ease     = Settings.easing;

	    progress.offsetWidth; /* Repaint */

	    queue(function(next) {
	      // Set positionUsing if it hasn't already been set
	      if (Settings.positionUsing === '') Settings.positionUsing = NProgress.getPositioningCSS();

	      // Add transition
	      css(bar, barPositionCSS(n, speed, ease));

	      if (n === 1) {
	        // Fade out
	        css(progress, { 
	          transition: 'none', 
	          opacity: 1 
	        });
	        progress.offsetWidth; /* Repaint */

	        setTimeout(function() {
	          css(progress, { 
	            transition: 'all ' + speed + 'ms linear', 
	            opacity: 0 
	          });
	          setTimeout(function() {
	            NProgress.remove();
	            next();
	          }, speed);
	        }, speed);
	      } else {
	        setTimeout(next, speed);
	      }
	    });

	    return this;
	  };

	  NProgress.isStarted = function() {
	    return typeof NProgress.status === 'number';
	  };

	  /**
	   * Shows the progress bar.
	   * This is the same as setting the status to 0%, except that it doesn't go backwards.
	   *
	   *     NProgress.start();
	   *
	   */
	  NProgress.start = function() {
	    if (!NProgress.status) NProgress.set(0);

	    var work = function() {
	      setTimeout(function() {
	        if (!NProgress.status) return;
	        NProgress.trickle();
	        work();
	      }, Settings.trickleSpeed);
	    };

	    if (Settings.trickle) work();

	    return this;
	  };

	  /**
	   * Hides the progress bar.
	   * This is the *sort of* the same as setting the status to 100%, with the
	   * difference being `done()` makes some placebo effect of some realistic motion.
	   *
	   *     NProgress.done();
	   *
	   * If `true` is passed, it will show the progress bar even if its hidden.
	   *
	   *     NProgress.done(true);
	   */

	  NProgress.done = function(force) {
	    if (!force && !NProgress.status) return this;

	    return NProgress.inc(0.3 + 0.5 * Math.random()).set(1);
	  };

	  /**
	   * Increments by a random amount.
	   */

	  NProgress.inc = function(amount) {
	    var n = NProgress.status;

	    if (!n) {
	      return NProgress.start();
	    } else {
	      if (typeof amount !== 'number') {
	        amount = (1 - n) * clamp(Math.random() * n, 0.1, 0.95);
	      }

	      n = clamp(n + amount, 0, 0.994);
	      return NProgress.set(n);
	    }
	  };

	  NProgress.trickle = function() {
	    return NProgress.inc(Math.random() * Settings.trickleRate);
	  };

	  /**
	   * Waits for all supplied jQuery promises and
	   * increases the progress as the promises resolve.
	   *
	   * @param $promise jQUery Promise
	   */
	  (function() {
	    var initial = 0, current = 0;

	    NProgress.promise = function($promise) {
	      if (!$promise || $promise.state() === "resolved") {
	        return this;
	      }

	      if (current === 0) {
	        NProgress.start();
	      }

	      initial++;
	      current++;

	      $promise.always(function() {
	        current--;
	        if (current === 0) {
	            initial = 0;
	            NProgress.done();
	        } else {
	            NProgress.set((initial - current) / initial);
	        }
	      });

	      return this;
	    };

	  })();

	  /**
	   * (Internal) renders the progress bar markup based on the `template`
	   * setting.
	   */

	  NProgress.render = function(fromStart) {
	    if (NProgress.isRendered()) return document.getElementById('nprogress');

	    addClass(document.documentElement, 'nprogress-busy');
	    
	    var progress = document.createElement('div');
	    progress.id = 'nprogress';
	    progress.innerHTML = Settings.template;

	    var bar      = progress.querySelector(Settings.barSelector),
	        perc     = fromStart ? '-100' : toBarPerc(NProgress.status || 0),
	        parent   = document.querySelector(Settings.parent),
	        spinner;
	    
	    css(bar, {
	      transition: 'all 0 linear',
	      transform: 'translate3d(' + perc + '%,0,0)'
	    });

	    if (!Settings.showSpinner) {
	      spinner = progress.querySelector(Settings.spinnerSelector);
	      spinner && removeElement(spinner);
	    }

	    if (parent != document.body) {
	      addClass(parent, 'nprogress-custom-parent');
	    }

	    parent.appendChild(progress);
	    return progress;
	  };

	  /**
	   * Removes the element. Opposite of render().
	   */

	  NProgress.remove = function() {
	    removeClass(document.documentElement, 'nprogress-busy');
	    removeClass(document.querySelector(Settings.parent), 'nprogress-custom-parent');
	    var progress = document.getElementById('nprogress');
	    progress && removeElement(progress);
	  };

	  /**
	   * Checks if the progress bar is rendered.
	   */

	  NProgress.isRendered = function() {
	    return !!document.getElementById('nprogress');
	  };

	  /**
	   * Determine which positioning CSS rule to use.
	   */

	  NProgress.getPositioningCSS = function() {
	    // Sniff on document.body.style
	    var bodyStyle = document.body.style;

	    // Sniff prefixes
	    var vendorPrefix = ('WebkitTransform' in bodyStyle) ? 'Webkit' :
	                       ('MozTransform' in bodyStyle) ? 'Moz' :
	                       ('msTransform' in bodyStyle) ? 'ms' :
	                       ('OTransform' in bodyStyle) ? 'O' : '';

	    if (vendorPrefix + 'Perspective' in bodyStyle) {
	      // Modern browsers with 3D support, e.g. Webkit, IE10
	      return 'translate3d';
	    } else if (vendorPrefix + 'Transform' in bodyStyle) {
	      // Browsers without 3D support, e.g. IE9
	      return 'translate';
	    } else {
	      // Browsers without translate() support, e.g. IE7-8
	      return 'margin';
	    }
	  };

	  /**
	   * Helpers
	   */

	  function clamp(n, min, max) {
	    if (n < min) return min;
	    if (n > max) return max;
	    return n;
	  }

	  /**
	   * (Internal) converts a percentage (`0..1`) to a bar translateX
	   * percentage (`-100%..0%`).
	   */

	  function toBarPerc(n) {
	    return (-1 + n) * 100;
	  }


	  /**
	   * (Internal) returns the correct CSS for changing the bar's
	   * position given an n percentage, and speed and ease from Settings
	   */

	  function barPositionCSS(n, speed, ease) {
	    var barCSS;

	    if (Settings.positionUsing === 'translate3d') {
	      barCSS = { transform: 'translate3d('+toBarPerc(n)+'%,0,0)' };
	    } else if (Settings.positionUsing === 'translate') {
	      barCSS = { transform: 'translate('+toBarPerc(n)+'%,0)' };
	    } else {
	      barCSS = { 'margin-left': toBarPerc(n)+'%' };
	    }

	    barCSS.transition = 'all '+speed+'ms '+ease;

	    return barCSS;
	  }

	  /**
	   * (Internal) Queues a function to be executed.
	   */

	  var queue = (function() {
	    var pending = [];
	    
	    function next() {
	      var fn = pending.shift();
	      if (fn) {
	        fn(next);
	      }
	    }

	    return function(fn) {
	      pending.push(fn);
	      if (pending.length == 1) next();
	    };
	  })();

	  /**
	   * (Internal) Applies css properties to an element, similar to the jQuery 
	   * css method.
	   *
	   * While this helper does assist with vendor prefixed property names, it 
	   * does not perform any manipulation of values prior to setting styles.
	   */

	  var css = (function() {
	    var cssPrefixes = [ 'Webkit', 'O', 'Moz', 'ms' ],
	        cssProps    = {};

	    function camelCase(string) {
	      return string.replace(/^-ms-/, 'ms-').replace(/-([\da-z])/gi, function(match, letter) {
	        return letter.toUpperCase();
	      });
	    }

	    function getVendorProp(name) {
	      var style = document.body.style;
	      if (name in style) return name;

	      var i = cssPrefixes.length,
	          capName = name.charAt(0).toUpperCase() + name.slice(1),
	          vendorName;
	      while (i--) {
	        vendorName = cssPrefixes[i] + capName;
	        if (vendorName in style) return vendorName;
	      }

	      return name;
	    }

	    function getStyleProp(name) {
	      name = camelCase(name);
	      return cssProps[name] || (cssProps[name] = getVendorProp(name));
	    }

	    function applyCss(element, prop, value) {
	      prop = getStyleProp(prop);
	      element.style[prop] = value;
	    }

	    return function(element, properties) {
	      var args = arguments,
	          prop, 
	          value;

	      if (args.length == 2) {
	        for (prop in properties) {
	          value = properties[prop];
	          if (value !== undefined && properties.hasOwnProperty(prop)) applyCss(element, prop, value);
	        }
	      } else {
	        applyCss(element, args[1], args[2]);
	      }
	    }
	  })();

	  /**
	   * (Internal) Determines if an element or space separated list of class names contains a class name.
	   */

	  function hasClass(element, name) {
	    var list = typeof element == 'string' ? element : classList(element);
	    return list.indexOf(' ' + name + ' ') >= 0;
	  }

	  /**
	   * (Internal) Adds a class to an element.
	   */

	  function addClass(element, name) {
	    var oldList = classList(element),
	        newList = oldList + name;

	    if (hasClass(oldList, name)) return; 

	    // Trim the opening space.
	    element.className = newList.substring(1);
	  }

	  /**
	   * (Internal) Removes a class from an element.
	   */

	  function removeClass(element, name) {
	    var oldList = classList(element),
	        newList;

	    if (!hasClass(element, name)) return;

	    // Replace the class name.
	    newList = oldList.replace(' ' + name + ' ', ' ');

	    // Trim the opening and closing spaces.
	    element.className = newList.substring(1, newList.length - 1);
	  }

	  /**
	   * (Internal) Gets a space separated list of the class names on the element. 
	   * The list is wrapped with a single space on each end to facilitate finding 
	   * matches within the list.
	   */

	  function classList(element) {
	    return (' ' + (element.className || '') + ' ').replace(/\s+/gi, ' ');
	  }

	  /**
	   * (Internal) Removes an element from the DOM.
	   */

	  function removeElement(element) {
	    element && element.parentNode && element.parentNode.removeChild(element);
	  }

	  return NProgress;
	});



/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery JavaScript Library v3.2.1
	 * https://jquery.com/
	 *
	 * Includes Sizzle.js
	 * https://sizzlejs.com/
	 *
	 * Copyright JS Foundation and other contributors
	 * Released under the MIT license
	 * https://jquery.org/license
	 *
	 * Date: 2017-03-20T18:59Z
	 */
	( function( global, factory ) {

		"use strict";

		if ( typeof module === "object" && typeof module.exports === "object" ) {

			// For CommonJS and CommonJS-like environments where a proper `window`
			// is present, execute the factory and get jQuery.
			// For environments that do not have a `window` with a `document`
			// (such as Node.js), expose a factory as module.exports.
			// This accentuates the need for the creation of a real `window`.
			// e.g. var jQuery = require("jquery")(window);
			// See ticket #14549 for more info.
			module.exports = global.document ?
				factory( global, true ) :
				function( w ) {
					if ( !w.document ) {
						throw new Error( "jQuery requires a window with a document" );
					}
					return factory( w );
				};
		} else {
			factory( global );
		}

	// Pass this if window is not defined yet
	} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

	// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
	// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
	// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
	// enough that all such attempts are guarded in a try block.
	"use strict";

	var arr = [];

	var document = window.document;

	var getProto = Object.getPrototypeOf;

	var slice = arr.slice;

	var concat = arr.concat;

	var push = arr.push;

	var indexOf = arr.indexOf;

	var class2type = {};

	var toString = class2type.toString;

	var hasOwn = class2type.hasOwnProperty;

	var fnToString = hasOwn.toString;

	var ObjectFunctionString = fnToString.call( Object );

	var support = {};



		function DOMEval( code, doc ) {
			doc = doc || document;

			var script = doc.createElement( "script" );

			script.text = code;
			doc.head.appendChild( script ).parentNode.removeChild( script );
		}
	/* global Symbol */
	// Defining this global in .eslintrc.json would create a danger of using the global
	// unguarded in another place, it seems safer to define global only for this module



	var
		version = "3.2.1",

		// Define a local copy of jQuery
		jQuery = function( selector, context ) {

			// The jQuery object is actually just the init constructor 'enhanced'
			// Need init if jQuery is called (just allow error to be thrown if not included)
			return new jQuery.fn.init( selector, context );
		},

		// Support: Android <=4.0 only
		// Make sure we trim BOM and NBSP
		rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

		// Matches dashed string for camelizing
		rmsPrefix = /^-ms-/,
		rdashAlpha = /-([a-z])/g,

		// Used by jQuery.camelCase as callback to replace()
		fcamelCase = function( all, letter ) {
			return letter.toUpperCase();
		};

	jQuery.fn = jQuery.prototype = {

		// The current version of jQuery being used
		jquery: version,

		constructor: jQuery,

		// The default length of a jQuery object is 0
		length: 0,

		toArray: function() {
			return slice.call( this );
		},

		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function( num ) {

			// Return all the elements in a clean array
			if ( num == null ) {
				return slice.call( this );
			}

			// Return just the one element from the set
			return num < 0 ? this[ num + this.length ] : this[ num ];
		},

		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function( elems ) {

			// Build a new jQuery matched element set
			var ret = jQuery.merge( this.constructor(), elems );

			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;

			// Return the newly-formed element set
			return ret;
		},

		// Execute a callback for every element in the matched set.
		each: function( callback ) {
			return jQuery.each( this, callback );
		},

		map: function( callback ) {
			return this.pushStack( jQuery.map( this, function( elem, i ) {
				return callback.call( elem, i, elem );
			} ) );
		},

		slice: function() {
			return this.pushStack( slice.apply( this, arguments ) );
		},

		first: function() {
			return this.eq( 0 );
		},

		last: function() {
			return this.eq( -1 );
		},

		eq: function( i ) {
			var len = this.length,
				j = +i + ( i < 0 ? len : 0 );
			return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
		},

		end: function() {
			return this.prevObject || this.constructor();
		},

		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};

	jQuery.extend = jQuery.fn.extend = function() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[ 0 ] || {},
			i = 1,
			length = arguments.length,
			deep = false;

		// Handle a deep copy situation
		if ( typeof target === "boolean" ) {
			deep = target;

			// Skip the boolean and the target
			target = arguments[ i ] || {};
			i++;
		}

		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
			target = {};
		}

		// Extend jQuery itself if only one argument is passed
		if ( i === length ) {
			target = this;
			i--;
		}

		for ( ; i < length; i++ ) {

			// Only deal with non-null/undefined values
			if ( ( options = arguments[ i ] ) != null ) {

				// Extend the base object
				for ( name in options ) {
					src = target[ name ];
					copy = options[ name ];

					// Prevent never-ending loop
					if ( target === copy ) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
						( copyIsArray = Array.isArray( copy ) ) ) ) {

						if ( copyIsArray ) {
							copyIsArray = false;
							clone = src && Array.isArray( src ) ? src : [];

						} else {
							clone = src && jQuery.isPlainObject( src ) ? src : {};
						}

						// Never move original objects, clone them
						target[ name ] = jQuery.extend( deep, clone, copy );

					// Don't bring in undefined values
					} else if ( copy !== undefined ) {
						target[ name ] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};

	jQuery.extend( {

		// Unique for each copy of jQuery on the page
		expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

		// Assume jQuery is ready without the ready module
		isReady: true,

		error: function( msg ) {
			throw new Error( msg );
		},

		noop: function() {},

		isFunction: function( obj ) {
			return jQuery.type( obj ) === "function";
		},

		isWindow: function( obj ) {
			return obj != null && obj === obj.window;
		},

		isNumeric: function( obj ) {

			// As of jQuery 3.0, isNumeric is limited to
			// strings and numbers (primitives or objects)
			// that can be coerced to finite numbers (gh-2662)
			var type = jQuery.type( obj );
			return ( type === "number" || type === "string" ) &&

				// parseFloat NaNs numeric-cast false positives ("")
				// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
				// subtraction forces infinities to NaN
				!isNaN( obj - parseFloat( obj ) );
		},

		isPlainObject: function( obj ) {
			var proto, Ctor;

			// Detect obvious negatives
			// Use toString instead of jQuery.type to catch host objects
			if ( !obj || toString.call( obj ) !== "[object Object]" ) {
				return false;
			}

			proto = getProto( obj );

			// Objects with no prototype (e.g., `Object.create( null )`) are plain
			if ( !proto ) {
				return true;
			}

			// Objects with prototype are plain iff they were constructed by a global Object function
			Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
			return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
		},

		isEmptyObject: function( obj ) {

			/* eslint-disable no-unused-vars */
			// See https://github.com/eslint/eslint/issues/6125
			var name;

			for ( name in obj ) {
				return false;
			}
			return true;
		},

		type: function( obj ) {
			if ( obj == null ) {
				return obj + "";
			}

			// Support: Android <=2.3 only (functionish RegExp)
			return typeof obj === "object" || typeof obj === "function" ?
				class2type[ toString.call( obj ) ] || "object" :
				typeof obj;
		},

		// Evaluates a script in a global context
		globalEval: function( code ) {
			DOMEval( code );
		},

		// Convert dashed to camelCase; used by the css and data modules
		// Support: IE <=9 - 11, Edge 12 - 13
		// Microsoft forgot to hump their vendor prefix (#9572)
		camelCase: function( string ) {
			return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
		},

		each: function( obj, callback ) {
			var length, i = 0;

			if ( isArrayLike( obj ) ) {
				length = obj.length;
				for ( ; i < length; i++ ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			}

			return obj;
		},

		// Support: Android <=4.0 only
		trim: function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},

		// results is for internal usage only
		makeArray: function( arr, results ) {
			var ret = results || [];

			if ( arr != null ) {
				if ( isArrayLike( Object( arr ) ) ) {
					jQuery.merge( ret,
						typeof arr === "string" ?
						[ arr ] : arr
					);
				} else {
					push.call( ret, arr );
				}
			}

			return ret;
		},

		inArray: function( elem, arr, i ) {
			return arr == null ? -1 : indexOf.call( arr, elem, i );
		},

		// Support: Android <=4.0 only, PhantomJS 1 only
		// push.apply(_, arraylike) throws on ancient WebKit
		merge: function( first, second ) {
			var len = +second.length,
				j = 0,
				i = first.length;

			for ( ; j < len; j++ ) {
				first[ i++ ] = second[ j ];
			}

			first.length = i;

			return first;
		},

		grep: function( elems, callback, invert ) {
			var callbackInverse,
				matches = [],
				i = 0,
				length = elems.length,
				callbackExpect = !invert;

			// Go through the array, only saving the items
			// that pass the validator function
			for ( ; i < length; i++ ) {
				callbackInverse = !callback( elems[ i ], i );
				if ( callbackInverse !== callbackExpect ) {
					matches.push( elems[ i ] );
				}
			}

			return matches;
		},

		// arg is for internal usage only
		map: function( elems, callback, arg ) {
			var length, value,
				i = 0,
				ret = [];

			// Go through the array, translating each of the items to their new values
			if ( isArrayLike( elems ) ) {
				length = elems.length;
				for ( ; i < length; i++ ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}

			// Go through every key on the object,
			} else {
				for ( i in elems ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}
			}

			// Flatten any nested arrays
			return concat.apply( [], ret );
		},

		// A global GUID counter for objects
		guid: 1,

		// Bind a function to a context, optionally partially applying any
		// arguments.
		proxy: function( fn, context ) {
			var tmp, args, proxy;

			if ( typeof context === "string" ) {
				tmp = fn[ context ];
				context = fn;
				fn = tmp;
			}

			// Quick check to determine if target is callable, in the spec
			// this throws a TypeError, but we will just return undefined.
			if ( !jQuery.isFunction( fn ) ) {
				return undefined;
			}

			// Simulated bind
			args = slice.call( arguments, 2 );
			proxy = function() {
				return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
			};

			// Set the guid of unique handler to the same of original handler, so it can be removed
			proxy.guid = fn.guid = fn.guid || jQuery.guid++;

			return proxy;
		},

		now: Date.now,

		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	} );

	if ( typeof Symbol === "function" ) {
		jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
	}

	// Populate the class2type map
	jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );

	function isArrayLike( obj ) {

		// Support: real iOS 8.2 only (not reproducible in simulator)
		// `in` check used to prevent JIT error (gh-2145)
		// hasOwn isn't used here due to false negatives
		// regarding Nodelist length in IE
		var length = !!obj && "length" in obj && obj.length,
			type = jQuery.type( obj );

		if ( type === "function" || jQuery.isWindow( obj ) ) {
			return false;
		}

		return type === "array" || length === 0 ||
			typeof length === "number" && length > 0 && ( length - 1 ) in obj;
	}
	var Sizzle =
	/*!
	 * Sizzle CSS Selector Engine v2.3.3
	 * https://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2016-08-08
	 */
	(function( window ) {

	var i,
		support,
		Expr,
		getText,
		isXML,
		tokenize,
		compile,
		select,
		outermostContext,
		sortInput,
		hasDuplicate,

		// Local document vars
		setDocument,
		document,
		docElem,
		documentIsHTML,
		rbuggyQSA,
		rbuggyMatches,
		matches,
		contains,

		// Instance-specific data
		expando = "sizzle" + 1 * new Date(),
		preferredDoc = window.document,
		dirruns = 0,
		done = 0,
		classCache = createCache(),
		tokenCache = createCache(),
		compilerCache = createCache(),
		sortOrder = function( a, b ) {
			if ( a === b ) {
				hasDuplicate = true;
			}
			return 0;
		},

		// Instance methods
		hasOwn = ({}).hasOwnProperty,
		arr = [],
		pop = arr.pop,
		push_native = arr.push,
		push = arr.push,
		slice = arr.slice,
		// Use a stripped-down indexOf as it's faster than native
		// https://jsperf.com/thor-indexof-vs-for/5
		indexOf = function( list, elem ) {
			var i = 0,
				len = list.length;
			for ( ; i < len; i++ ) {
				if ( list[i] === elem ) {
					return i;
				}
			}
			return -1;
		},

		booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

		// Regular expressions

		// http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",

		// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
			// Operator (capture 2)
			"*([*^$|!~]?=)" + whitespace +
			// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
			"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
			"*\\]",

		pseudos = ":(" + identifier + ")(?:\\((" +
			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
			// 1. quoted (capture 3; capture 4 or capture 5)
			"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
			// 2. simple (capture 6)
			"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
			// 3. anything else (capture 2)
			".*" +
			")\\)|)",

		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp( whitespace + "+", "g" ),
		rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
		rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

		rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

		rpseudo = new RegExp( pseudos ),
		ridentifier = new RegExp( "^" + identifier + "$" ),

		matchExpr = {
			"ID": new RegExp( "^#(" + identifier + ")" ),
			"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
			"TAG": new RegExp( "^(" + identifier + "|[*])" ),
			"ATTR": new RegExp( "^" + attributes ),
			"PSEUDO": new RegExp( "^" + pseudos ),
			"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
				"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
				"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
			"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
				whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
		},

		rinputs = /^(?:input|select|textarea|button)$/i,
		rheader = /^h\d$/i,

		rnative = /^[^{]+\{\s*\[native \w/,

		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

		rsibling = /[+~]/,

		// CSS escapes
		// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
		funescape = function( _, escaped, escapedWhitespace ) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ?
				escaped :
				high < 0 ?
					// BMP codepoint
					String.fromCharCode( high + 0x10000 ) :
					// Supplemental Plane codepoint (surrogate pair)
					String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
		},

		// CSS string/identifier serialization
		// https://drafts.csswg.org/cssom/#common-serializing-idioms
		rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
		fcssescape = function( ch, asCodePoint ) {
			if ( asCodePoint ) {

				// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
				if ( ch === "\0" ) {
					return "\uFFFD";
				}

				// Control characters and (dependent upon position) numbers get escaped as code points
				return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
			}

			// Other potentially-special ASCII characters get backslash-escaped
			return "\\" + ch;
		},

		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE
		unloadHandler = function() {
			setDocument();
		},

		disabledAncestor = addCombinator(
			function( elem ) {
				return elem.disabled === true && ("form" in elem || "label" in elem);
			},
			{ dir: "parentNode", next: "legend" }
		);

	// Optimize for push.apply( _, NodeList )
	try {
		push.apply(
			(arr = slice.call( preferredDoc.childNodes )),
			preferredDoc.childNodes
		);
		// Support: Android<4.0
		// Detect silently failing push.apply
		arr[ preferredDoc.childNodes.length ].nodeType;
	} catch ( e ) {
		push = { apply: arr.length ?

			// Leverage slice if possible
			function( target, els ) {
				push_native.apply( target, slice.call(els) );
			} :

			// Support: IE<9
			// Otherwise append directly
			function( target, els ) {
				var j = target.length,
					i = 0;
				// Can't trust NodeList.length
				while ( (target[j++] = els[i++]) ) {}
				target.length = j - 1;
			}
		};
	}

	function Sizzle( selector, context, results, seed ) {
		var m, i, elem, nid, match, groups, newSelector,
			newContext = context && context.ownerDocument,

			// nodeType defaults to 9, since context defaults to document
			nodeType = context ? context.nodeType : 9;

		results = results || [];

		// Return early from calls with invalid selector or context
		if ( typeof selector !== "string" || !selector ||
			nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

			return results;
		}

		// Try to shortcut find operations (as opposed to filters) in HTML documents
		if ( !seed ) {

			if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
				setDocument( context );
			}
			context = context || document;

			if ( documentIsHTML ) {

				// If the selector is sufficiently simple, try using a "get*By*" DOM method
				// (excepting DocumentFragment context, where the methods don't exist)
				if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

					// ID selector
					if ( (m = match[1]) ) {

						// Document context
						if ( nodeType === 9 ) {
							if ( (elem = context.getElementById( m )) ) {

								// Support: IE, Opera, Webkit
								// TODO: identify versions
								// getElementById can match elements by name instead of ID
								if ( elem.id === m ) {
									results.push( elem );
									return results;
								}
							} else {
								return results;
							}

						// Element context
						} else {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( newContext && (elem = newContext.getElementById( m )) &&
								contains( context, elem ) &&
								elem.id === m ) {

								results.push( elem );
								return results;
							}
						}

					// Type selector
					} else if ( match[2] ) {
						push.apply( results, context.getElementsByTagName( selector ) );
						return results;

					// Class selector
					} else if ( (m = match[3]) && support.getElementsByClassName &&
						context.getElementsByClassName ) {

						push.apply( results, context.getElementsByClassName( m ) );
						return results;
					}
				}

				// Take advantage of querySelectorAll
				if ( support.qsa &&
					!compilerCache[ selector + " " ] &&
					(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

					if ( nodeType !== 1 ) {
						newContext = context;
						newSelector = selector;

					// qSA looks outside Element context, which is not what we want
					// Thanks to Andrew Dupont for this workaround technique
					// Support: IE <=8
					// Exclude object elements
					} else if ( context.nodeName.toLowerCase() !== "object" ) {

						// Capture the context ID, setting it first if necessary
						if ( (nid = context.getAttribute( "id" )) ) {
							nid = nid.replace( rcssescape, fcssescape );
						} else {
							context.setAttribute( "id", (nid = expando) );
						}

						// Prefix every selector in the list
						groups = tokenize( selector );
						i = groups.length;
						while ( i-- ) {
							groups[i] = "#" + nid + " " + toSelector( groups[i] );
						}
						newSelector = groups.join( "," );

						// Expand context for sibling selectors
						newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
							context;
					}

					if ( newSelector ) {
						try {
							push.apply( results,
								newContext.querySelectorAll( newSelector )
							);
							return results;
						} catch ( qsaError ) {
						} finally {
							if ( nid === expando ) {
								context.removeAttribute( "id" );
							}
						}
					}
				}
			}
		}

		// All others
		return select( selector.replace( rtrim, "$1" ), context, results, seed );
	}

	/**
	 * Create key-value caches of limited size
	 * @returns {function(string, object)} Returns the Object data after storing it on itself with
	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	 *	deleting the oldest entry
	 */
	function createCache() {
		var keys = [];

		function cache( key, value ) {
			// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
			if ( keys.push( key + " " ) > Expr.cacheLength ) {
				// Only keep the most recent entries
				delete cache[ keys.shift() ];
			}
			return (cache[ key + " " ] = value);
		}
		return cache;
	}

	/**
	 * Mark a function for special use by Sizzle
	 * @param {Function} fn The function to mark
	 */
	function markFunction( fn ) {
		fn[ expando ] = true;
		return fn;
	}

	/**
	 * Support testing using an element
	 * @param {Function} fn Passed the created element and returns a boolean result
	 */
	function assert( fn ) {
		var el = document.createElement("fieldset");

		try {
			return !!fn( el );
		} catch (e) {
			return false;
		} finally {
			// Remove from its parent by default
			if ( el.parentNode ) {
				el.parentNode.removeChild( el );
			}
			// release memory in IE
			el = null;
		}
	}

	/**
	 * Adds the same handler for all of the specified attrs
	 * @param {String} attrs Pipe-separated list of attributes
	 * @param {Function} handler The method that will be applied
	 */
	function addHandle( attrs, handler ) {
		var arr = attrs.split("|"),
			i = arr.length;

		while ( i-- ) {
			Expr.attrHandle[ arr[i] ] = handler;
		}
	}

	/**
	 * Checks document order of two siblings
	 * @param {Element} a
	 * @param {Element} b
	 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	 */
	function siblingCheck( a, b ) {
		var cur = b && a,
			diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
				a.sourceIndex - b.sourceIndex;

		// Use IE sourceIndex if available on both nodes
		if ( diff ) {
			return diff;
		}

		// Check if b follows a
		if ( cur ) {
			while ( (cur = cur.nextSibling) ) {
				if ( cur === b ) {
					return -1;
				}
			}
		}

		return a ? 1 : -1;
	}

	/**
	 * Returns a function to use in pseudos for input types
	 * @param {String} type
	 */
	function createInputPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for buttons
	 * @param {String} type
	 */
	function createButtonPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for :enabled/:disabled
	 * @param {Boolean} disabled true for :disabled; false for :enabled
	 */
	function createDisabledPseudo( disabled ) {

		// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
		return function( elem ) {

			// Only certain elements can match :enabled or :disabled
			// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
			// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
			if ( "form" in elem ) {

				// Check for inherited disabledness on relevant non-disabled elements:
				// * listed form-associated elements in a disabled fieldset
				//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
				//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
				// * option elements in a disabled optgroup
				//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
				// All such elements have a "form" property.
				if ( elem.parentNode && elem.disabled === false ) {

					// Option elements defer to a parent optgroup if present
					if ( "label" in elem ) {
						if ( "label" in elem.parentNode ) {
							return elem.parentNode.disabled === disabled;
						} else {
							return elem.disabled === disabled;
						}
					}

					// Support: IE 6 - 11
					// Use the isDisabled shortcut property to check for disabled fieldset ancestors
					return elem.isDisabled === disabled ||

						// Where there is no isDisabled, check manually
						/* jshint -W018 */
						elem.isDisabled !== !disabled &&
							disabledAncestor( elem ) === disabled;
				}

				return elem.disabled === disabled;

			// Try to winnow out elements that can't be disabled before trusting the disabled property.
			// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
			// even exist on them, let alone have a boolean value.
			} else if ( "label" in elem ) {
				return elem.disabled === disabled;
			}

			// Remaining elements are neither :enabled nor :disabled
			return false;
		};
	}

	/**
	 * Returns a function to use in pseudos for positionals
	 * @param {Function} fn
	 */
	function createPositionalPseudo( fn ) {
		return markFunction(function( argument ) {
			argument = +argument;
			return markFunction(function( seed, matches ) {
				var j,
					matchIndexes = fn( [], seed.length, argument ),
					i = matchIndexes.length;

				// Match elements found at the specified indexes
				while ( i-- ) {
					if ( seed[ (j = matchIndexes[i]) ] ) {
						seed[j] = !(matches[j] = seed[j]);
					}
				}
			});
		});
	}

	/**
	 * Checks a node for validity as a Sizzle context
	 * @param {Element|Object=} context
	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	 */
	function testContext( context ) {
		return context && typeof context.getElementsByTagName !== "undefined" && context;
	}

	// Expose support vars for convenience
	support = Sizzle.support = {};

	/**
	 * Detects XML nodes
	 * @param {Element|Object} elem An element or a document
	 * @returns {Boolean} True iff elem is a non-HTML XML node
	 */
	isXML = Sizzle.isXML = function( elem ) {
		// documentElement is verified for cases where it doesn't yet exist
		// (such as loading iframes in IE - #4833)
		var documentElement = elem && (elem.ownerDocument || elem).documentElement;
		return documentElement ? documentElement.nodeName !== "HTML" : false;
	};

	/**
	 * Sets document-related variables once based on the current document
	 * @param {Element|Object} [doc] An element or document object to use to set the document
	 * @returns {Object} Returns the current document
	 */
	setDocument = Sizzle.setDocument = function( node ) {
		var hasCompare, subWindow,
			doc = node ? node.ownerDocument || node : preferredDoc;

		// Return early if doc is invalid or already selected
		if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
			return document;
		}

		// Update global variables
		document = doc;
		docElem = document.documentElement;
		documentIsHTML = !isXML( document );

		// Support: IE 9-11, Edge
		// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
		if ( preferredDoc !== document &&
			(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

			// Support: IE 11, Edge
			if ( subWindow.addEventListener ) {
				subWindow.addEventListener( "unload", unloadHandler, false );

			// Support: IE 9 - 10 only
			} else if ( subWindow.attachEvent ) {
				subWindow.attachEvent( "onunload", unloadHandler );
			}
		}

		/* Attributes
		---------------------------------------------------------------------- */

		// Support: IE<8
		// Verify that getAttribute really returns attributes and not properties
		// (excepting IE8 booleans)
		support.attributes = assert(function( el ) {
			el.className = "i";
			return !el.getAttribute("className");
		});

		/* getElement(s)By*
		---------------------------------------------------------------------- */

		// Check if getElementsByTagName("*") returns only elements
		support.getElementsByTagName = assert(function( el ) {
			el.appendChild( document.createComment("") );
			return !el.getElementsByTagName("*").length;
		});

		// Support: IE<9
		support.getElementsByClassName = rnative.test( document.getElementsByClassName );

		// Support: IE<10
		// Check if getElementById returns elements by name
		// The broken getElementById methods don't pick up programmatically-set names,
		// so use a roundabout getElementsByName test
		support.getById = assert(function( el ) {
			docElem.appendChild( el ).id = expando;
			return !document.getElementsByName || !document.getElementsByName( expando ).length;
		});

		// ID filter and find
		if ( support.getById ) {
			Expr.filter["ID"] = function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					return elem.getAttribute("id") === attrId;
				};
			};
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var elem = context.getElementById( id );
					return elem ? [ elem ] : [];
				}
			};
		} else {
			Expr.filter["ID"] =  function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== "undefined" &&
						elem.getAttributeNode("id");
					return node && node.value === attrId;
				};
			};

			// Support: IE 6 - 7 only
			// getElementById is not reliable as a find shortcut
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var node, i, elems,
						elem = context.getElementById( id );

					if ( elem ) {

						// Verify the id attribute
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}

						// Fall back on getElementsByName
						elems = context.getElementsByName( id );
						i = 0;
						while ( (elem = elems[i++]) ) {
							node = elem.getAttributeNode("id");
							if ( node && node.value === id ) {
								return [ elem ];
							}
						}
					}

					return [];
				}
			};
		}

		// Tag
		Expr.find["TAG"] = support.getElementsByTagName ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== "undefined" ) {
					return context.getElementsByTagName( tag );

				// DocumentFragment nodes don't have gEBTN
				} else if ( support.qsa ) {
					return context.querySelectorAll( tag );
				}
			} :

			function( tag, context ) {
				var elem,
					tmp = [],
					i = 0,
					// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
					results = context.getElementsByTagName( tag );

				// Filter out possible comments
				if ( tag === "*" ) {
					while ( (elem = results[i++]) ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}

					return tmp;
				}
				return results;
			};

		// Class
		Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
			if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
				return context.getElementsByClassName( className );
			}
		};

		/* QSA/matchesSelector
		---------------------------------------------------------------------- */

		// QSA and matchesSelector support

		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
		rbuggyMatches = [];

		// qSa(:focus) reports false when true (Chrome 21)
		// We allow this because of a bug in IE8/9 that throws an error
		// whenever `document.activeElement` is accessed on an iframe
		// So, we allow :focus to pass through QSA all the time to avoid the IE error
		// See https://bugs.jquery.com/ticket/13378
		rbuggyQSA = [];

		if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
			// Build QSA regex
			// Regex strategy adopted from Diego Perini
			assert(function( el ) {
				// Select is set to empty string on purpose
				// This is to test IE's treatment of not explicitly
				// setting a boolean content attribute,
				// since its presence should be enough
				// https://bugs.jquery.com/ticket/12359
				docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
					"<select id='" + expando + "-\r\\' msallowcapture=''>" +
					"<option selected=''></option></select>";

				// Support: IE8, Opera 11-12.16
				// Nothing should be selected when empty strings follow ^= or $= or *=
				// The test attribute must be unknown in Opera but "safe" for WinRT
				// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
				if ( el.querySelectorAll("[msallowcapture^='']").length ) {
					rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
				}

				// Support: IE8
				// Boolean attributes and "value" are not treated correctly
				if ( !el.querySelectorAll("[selected]").length ) {
					rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
				}

				// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
				if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
					rbuggyQSA.push("~=");
				}

				// Webkit/Opera - :checked should return selected option elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				// IE8 throws error here and will not see later tests
				if ( !el.querySelectorAll(":checked").length ) {
					rbuggyQSA.push(":checked");
				}

				// Support: Safari 8+, iOS 8+
				// https://bugs.webkit.org/show_bug.cgi?id=136851
				// In-page `selector#id sibling-combinator selector` fails
				if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
					rbuggyQSA.push(".#.+[+~]");
				}
			});

			assert(function( el ) {
				el.innerHTML = "<a href='' disabled='disabled'></a>" +
					"<select disabled='disabled'><option/></select>";

				// Support: Windows 8 Native Apps
				// The type and name attributes are restricted during .innerHTML assignment
				var input = document.createElement("input");
				input.setAttribute( "type", "hidden" );
				el.appendChild( input ).setAttribute( "name", "D" );

				// Support: IE8
				// Enforce case-sensitivity of name attribute
				if ( el.querySelectorAll("[name=d]").length ) {
					rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
				}

				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
				// IE8 throws error here and will not see later tests
				if ( el.querySelectorAll(":enabled").length !== 2 ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}

				// Support: IE9-11+
				// IE's :disabled selector does not pick up the children of disabled fieldsets
				docElem.appendChild( el ).disabled = true;
				if ( el.querySelectorAll(":disabled").length !== 2 ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}

				// Opera 10-11 does not throw on post-comma invalid pseudos
				el.querySelectorAll("*,:x");
				rbuggyQSA.push(",.*:");
			});
		}

		if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
			docElem.webkitMatchesSelector ||
			docElem.mozMatchesSelector ||
			docElem.oMatchesSelector ||
			docElem.msMatchesSelector) )) ) {

			assert(function( el ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				support.disconnectedMatch = matches.call( el, "*" );

				// This should fail with an exception
				// Gecko does not error, returns false instead
				matches.call( el, "[s!='']:x" );
				rbuggyMatches.push( "!=", pseudos );
			});
		}

		rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
		rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

		/* Contains
		---------------------------------------------------------------------- */
		hasCompare = rnative.test( docElem.compareDocumentPosition );

		// Element contains another
		// Purposefully self-exclusive
		// As in, an element does not contain itself
		contains = hasCompare || rnative.test( docElem.contains ) ?
			function( a, b ) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
					bup = b && b.parentNode;
				return a === bup || !!( bup && bup.nodeType === 1 && (
					adown.contains ?
						adown.contains( bup ) :
						a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
				));
			} :
			function( a, b ) {
				if ( b ) {
					while ( (b = b.parentNode) ) {
						if ( b === a ) {
							return true;
						}
					}
				}
				return false;
			};

		/* Sorting
		---------------------------------------------------------------------- */

		// Document order sorting
		sortOrder = hasCompare ?
		function( a, b ) {

			// Flag for duplicate removal
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			// Sort on method existence if only one input has compareDocumentPosition
			var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
			if ( compare ) {
				return compare;
			}

			// Calculate position if both inputs belong to the same document
			compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
				a.compareDocumentPosition( b ) :

				// Otherwise we know they are disconnected
				1;

			// Disconnected nodes
			if ( compare & 1 ||
				(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

				// Choose the first element that is related to our preferred document
				if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
					return -1;
				}
				if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
					return 1;
				}

				// Maintain original order
				return sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
			}

			return compare & 4 ? -1 : 1;
		} :
		function( a, b ) {
			// Exit early if the nodes are identical
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			var cur,
				i = 0,
				aup = a.parentNode,
				bup = b.parentNode,
				ap = [ a ],
				bp = [ b ];

			// Parentless nodes are either documents or disconnected
			if ( !aup || !bup ) {
				return a === document ? -1 :
					b === document ? 1 :
					aup ? -1 :
					bup ? 1 :
					sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;

			// If the nodes are siblings, we can do a quick check
			} else if ( aup === bup ) {
				return siblingCheck( a, b );
			}

			// Otherwise we need full lists of their ancestors for comparison
			cur = a;
			while ( (cur = cur.parentNode) ) {
				ap.unshift( cur );
			}
			cur = b;
			while ( (cur = cur.parentNode) ) {
				bp.unshift( cur );
			}

			// Walk down the tree looking for a discrepancy
			while ( ap[i] === bp[i] ) {
				i++;
			}

			return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck( ap[i], bp[i] ) :

				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 :
				bp[i] === preferredDoc ? 1 :
				0;
		};

		return document;
	};

	Sizzle.matches = function( expr, elements ) {
		return Sizzle( expr, null, null, elements );
	};

	Sizzle.matchesSelector = function( elem, expr ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		// Make sure that attribute selectors are quoted
		expr = expr.replace( rattributeQuotes, "='$1']" );

		if ( support.matchesSelector && documentIsHTML &&
			!compilerCache[ expr + " " ] &&
			( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
			( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

			try {
				var ret = matches.call( elem, expr );

				// IE 9's matchesSelector returns false on disconnected nodes
				if ( ret || support.disconnectedMatch ||
						// As well, disconnected nodes are said to be in a document
						// fragment in IE 9
						elem.document && elem.document.nodeType !== 11 ) {
					return ret;
				}
			} catch (e) {}
		}

		return Sizzle( expr, document, null, [ elem ] ).length > 0;
	};

	Sizzle.contains = function( context, elem ) {
		// Set document vars if needed
		if ( ( context.ownerDocument || context ) !== document ) {
			setDocument( context );
		}
		return contains( context, elem );
	};

	Sizzle.attr = function( elem, name ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		var fn = Expr.attrHandle[ name.toLowerCase() ],
			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
				fn( elem, name, !documentIsHTML ) :
				undefined;

		return val !== undefined ?
			val :
			support.attributes || !documentIsHTML ?
				elem.getAttribute( name ) :
				(val = elem.getAttributeNode(name)) && val.specified ?
					val.value :
					null;
	};

	Sizzle.escape = function( sel ) {
		return (sel + "").replace( rcssescape, fcssescape );
	};

	Sizzle.error = function( msg ) {
		throw new Error( "Syntax error, unrecognized expression: " + msg );
	};

	/**
	 * Document sorting and removing duplicates
	 * @param {ArrayLike} results
	 */
	Sizzle.uniqueSort = function( results ) {
		var elem,
			duplicates = [],
			j = 0,
			i = 0;

		// Unless we *know* we can detect duplicates, assume their presence
		hasDuplicate = !support.detectDuplicates;
		sortInput = !support.sortStable && results.slice( 0 );
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			while ( (elem = results[i++]) ) {
				if ( elem === results[ i ] ) {
					j = duplicates.push( i );
				}
			}
			while ( j-- ) {
				results.splice( duplicates[ j ], 1 );
			}
		}

		// Clear input after sorting to release objects
		// See https://github.com/jquery/sizzle/pull/225
		sortInput = null;

		return results;
	};

	/**
	 * Utility function for retrieving the text value of an array of DOM nodes
	 * @param {Array|Element} elem
	 */
	getText = Sizzle.getText = function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;

		if ( !nodeType ) {
			// If no nodeType, this is expected to be an array
			while ( (node = elem[i++]) ) {
				// Do not traverse comment nodes
				ret += getText( node );
			}
		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (jQuery #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes

		return ret;
	};

	Expr = Sizzle.selectors = {

		// Can be adjusted by the user
		cacheLength: 50,

		createPseudo: markFunction,

		match: matchExpr,

		attrHandle: {},

		find: {},

		relative: {
			">": { dir: "parentNode", first: true },
			" ": { dir: "parentNode" },
			"+": { dir: "previousSibling", first: true },
			"~": { dir: "previousSibling" }
		},

		preFilter: {
			"ATTR": function( match ) {
				match[1] = match[1].replace( runescape, funescape );

				// Move the given value to match[3] whether quoted or unquoted
				match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

				if ( match[2] === "~=" ) {
					match[3] = " " + match[3] + " ";
				}

				return match.slice( 0, 4 );
			},

			"CHILD": function( match ) {
				/* matches from matchExpr["CHILD"]
					1 type (only|nth|...)
					2 what (child|of-type)
					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
					4 xn-component of xn+y argument ([+-]?\d*n|)
					5 sign of xn-component
					6 x of xn-component
					7 sign of y-component
					8 y of y-component
				*/
				match[1] = match[1].toLowerCase();

				if ( match[1].slice( 0, 3 ) === "nth" ) {
					// nth-* requires argument
					if ( !match[3] ) {
						Sizzle.error( match[0] );
					}

					// numeric x and y parameters for Expr.filter.CHILD
					// remember that false/true cast respectively to 0/1
					match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
					match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

				// other types prohibit arguments
				} else if ( match[3] ) {
					Sizzle.error( match[0] );
				}

				return match;
			},

			"PSEUDO": function( match ) {
				var excess,
					unquoted = !match[6] && match[2];

				if ( matchExpr["CHILD"].test( match[0] ) ) {
					return null;
				}

				// Accept quoted arguments as-is
				if ( match[3] ) {
					match[2] = match[4] || match[5] || "";

				// Strip excess characters from unquoted arguments
				} else if ( unquoted && rpseudo.test( unquoted ) &&
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &&
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

					// excess is a negative index
					match[0] = match[0].slice( 0, excess );
					match[2] = unquoted.slice( 0, excess );
				}

				// Return only captures needed by the pseudo filter method (type and argument)
				return match.slice( 0, 3 );
			}
		},

		filter: {

			"TAG": function( nodeNameSelector ) {
				var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
				return nodeNameSelector === "*" ?
					function() { return true; } :
					function( elem ) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
			},

			"CLASS": function( className ) {
				var pattern = classCache[ className + " " ];

				return pattern ||
					(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
					classCache( className, function( elem ) {
						return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
					});
			},

			"ATTR": function( name, operator, check ) {
				return function( elem ) {
					var result = Sizzle.attr( elem, name );

					if ( result == null ) {
						return operator === "!=";
					}
					if ( !operator ) {
						return true;
					}

					result += "";

					return operator === "=" ? result === check :
						operator === "!=" ? result !== check :
						operator === "^=" ? check && result.indexOf( check ) === 0 :
						operator === "*=" ? check && result.indexOf( check ) > -1 :
						operator === "$=" ? check && result.slice( -check.length ) === check :
						operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
						operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
						false;
				};
			},

			"CHILD": function( type, what, argument, first, last ) {
				var simple = type.slice( 0, 3 ) !== "nth",
					forward = type.slice( -4 ) !== "last",
					ofType = what === "of-type";

				return first === 1 && last === 0 ?

					// Shortcut for :nth-*(n)
					function( elem ) {
						return !!elem.parentNode;
					} :

					function( elem, context, xml ) {
						var cache, uniqueCache, outerCache, node, nodeIndex, start,
							dir = simple !== forward ? "nextSibling" : "previousSibling",
							parent = elem.parentNode,
							name = ofType && elem.nodeName.toLowerCase(),
							useCache = !xml && !ofType,
							diff = false;

						if ( parent ) {

							// :(first|last|only)-(child|of-type)
							if ( simple ) {
								while ( dir ) {
									node = elem;
									while ( (node = node[ dir ]) ) {
										if ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) {

											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}

							start = [ forward ? parent.firstChild : parent.lastChild ];

							// non-xml :nth-child(...) stores cache data on `parent`
							if ( forward && useCache ) {

								// Seek `elem` from a previously-cached index

								// ...in a gzip-friendly way
								node = parent;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex && cache[ 2 ];
								node = nodeIndex && parent.childNodes[ nodeIndex ];

								while ( (node = ++nodeIndex && node && node[ dir ] ||

									// Fallback to seeking `elem` from the start
									(diff = nodeIndex = 0) || start.pop()) ) {

									// When found, cache indexes on `parent` and break
									if ( node.nodeType === 1 && ++diff && node === elem ) {
										uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
										break;
									}
								}

							} else {
								// Use previously-cached element index if available
								if ( useCache ) {
									// ...in a gzip-friendly way
									node = elem;
									outerCache = node[ expando ] || (node[ expando ] = {});

									// Support: IE <9 only
									// Defend against cloned attroperties (jQuery gh-1709)
									uniqueCache = outerCache[ node.uniqueID ] ||
										(outerCache[ node.uniqueID ] = {});

									cache = uniqueCache[ type ] || [];
									nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
									diff = nodeIndex;
								}

								// xml :nth-child(...)
								// or :nth-last-child(...) or :nth(-last)?-of-type(...)
								if ( diff === false ) {
									// Use the same loop as above to seek `elem` from the start
									while ( (node = ++nodeIndex && node && node[ dir ] ||
										(diff = nodeIndex = 0) || start.pop()) ) {

										if ( ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) &&
											++diff ) {

											// Cache the index of each encountered element
											if ( useCache ) {
												outerCache = node[ expando ] || (node[ expando ] = {});

												// Support: IE <9 only
												// Defend against cloned attroperties (jQuery gh-1709)
												uniqueCache = outerCache[ node.uniqueID ] ||
													(outerCache[ node.uniqueID ] = {});

												uniqueCache[ type ] = [ dirruns, diff ];
											}

											if ( node === elem ) {
												break;
											}
										}
									}
								}
							}

							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || ( diff % first === 0 && diff / first >= 0 );
						}
					};
			},

			"PSEUDO": function( pseudo, argument ) {
				// pseudo-class names are case-insensitive
				// http://www.w3.org/TR/selectors/#pseudo-classes
				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
				// Remember that setFilters inherits from pseudos
				var args,
					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
						Sizzle.error( "unsupported pseudo: " + pseudo );

				// The user may use createPseudo to indicate that
				// arguments are needed to create the filter function
				// just as Sizzle does
				if ( fn[ expando ] ) {
					return fn( argument );
				}

				// But maintain support for old signatures
				if ( fn.length > 1 ) {
					args = [ pseudo, pseudo, "", argument ];
					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
						markFunction(function( seed, matches ) {
							var idx,
								matched = fn( seed, argument ),
								i = matched.length;
							while ( i-- ) {
								idx = indexOf( seed, matched[i] );
								seed[ idx ] = !( matches[ idx ] = matched[i] );
							}
						}) :
						function( elem ) {
							return fn( elem, 0, args );
						};
				}

				return fn;
			}
		},

		pseudos: {
			// Potentially complex pseudos
			"not": markFunction(function( selector ) {
				// Trim the selector passed to compile
				// to avoid treating leading and trailing
				// spaces as combinators
				var input = [],
					results = [],
					matcher = compile( selector.replace( rtrim, "$1" ) );

				return matcher[ expando ] ?
					markFunction(function( seed, matches, context, xml ) {
						var elem,
							unmatched = matcher( seed, null, xml, [] ),
							i = seed.length;

						// Match elements unmatched by `matcher`
						while ( i-- ) {
							if ( (elem = unmatched[i]) ) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) :
					function( elem, context, xml ) {
						input[0] = elem;
						matcher( input, null, xml, results );
						// Don't keep the element (issue #299)
						input[0] = null;
						return !results.pop();
					};
			}),

			"has": markFunction(function( selector ) {
				return function( elem ) {
					return Sizzle( selector, elem ).length > 0;
				};
			}),

			"contains": markFunction(function( text ) {
				text = text.replace( runescape, funescape );
				return function( elem ) {
					return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
				};
			}),

			// "Whether an element is represented by a :lang() selector
			// is based solely on the element's language value
			// being equal to the identifier C,
			// or beginning with the identifier C immediately followed by "-".
			// The matching of C against the element's language value is performed case-insensitively.
			// The identifier C does not have to be a valid language name."
			// http://www.w3.org/TR/selectors/#lang-pseudo
			"lang": markFunction( function( lang ) {
				// lang value must be a valid identifier
				if ( !ridentifier.test(lang || "") ) {
					Sizzle.error( "unsupported lang: " + lang );
				}
				lang = lang.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					var elemLang;
					do {
						if ( (elemLang = documentIsHTML ?
							elem.lang :
							elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

							elemLang = elemLang.toLowerCase();
							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
						}
					} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
					return false;
				};
			}),

			// Miscellaneous
			"target": function( elem ) {
				var hash = window.location && window.location.hash;
				return hash && hash.slice( 1 ) === elem.id;
			},

			"root": function( elem ) {
				return elem === docElem;
			},

			"focus": function( elem ) {
				return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
			},

			// Boolean properties
			"enabled": createDisabledPseudo( false ),
			"disabled": createDisabledPseudo( true ),

			"checked": function( elem ) {
				// In CSS3, :checked should return both checked and selected elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				var nodeName = elem.nodeName.toLowerCase();
				return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
			},

			"selected": function( elem ) {
				// Accessing this property makes selected-by-default
				// options in Safari work properly
				if ( elem.parentNode ) {
					elem.parentNode.selectedIndex;
				}

				return elem.selected === true;
			},

			// Contents
			"empty": function( elem ) {
				// http://www.w3.org/TR/selectors/#empty-pseudo
				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
				//   but not by others (comment: 8; processing instruction: 7; etc.)
				// nodeType < 6 works because attributes (2) do not appear as children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					if ( elem.nodeType < 6 ) {
						return false;
					}
				}
				return true;
			},

			"parent": function( elem ) {
				return !Expr.pseudos["empty"]( elem );
			},

			// Element/input types
			"header": function( elem ) {
				return rheader.test( elem.nodeName );
			},

			"input": function( elem ) {
				return rinputs.test( elem.nodeName );
			},

			"button": function( elem ) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === "button" || name === "button";
			},

			"text": function( elem ) {
				var attr;
				return elem.nodeName.toLowerCase() === "input" &&
					elem.type === "text" &&

					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
			},

			// Position-in-collection
			"first": createPositionalPseudo(function() {
				return [ 0 ];
			}),

			"last": createPositionalPseudo(function( matchIndexes, length ) {
				return [ length - 1 ];
			}),

			"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
				return [ argument < 0 ? argument + length : argument ];
			}),

			"even": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 0;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"odd": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 1;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; --i >= 0; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; ++i < length; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			})
		}
	};

	Expr.pseudos["nth"] = Expr.pseudos["eq"];

	// Add button/input type pseudos
	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
		Expr.pseudos[ i ] = createInputPseudo( i );
	}
	for ( i in { submit: true, reset: true } ) {
		Expr.pseudos[ i ] = createButtonPseudo( i );
	}

	// Easy API for creating new setFilters
	function setFilters() {}
	setFilters.prototype = Expr.filters = Expr.pseudos;
	Expr.setFilters = new setFilters();

	tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
		var matched, match, tokens, type,
			soFar, groups, preFilters,
			cached = tokenCache[ selector + " " ];

		if ( cached ) {
			return parseOnly ? 0 : cached.slice( 0 );
		}

		soFar = selector;
		groups = [];
		preFilters = Expr.preFilter;

		while ( soFar ) {

			// Comma and first run
			if ( !matched || (match = rcomma.exec( soFar )) ) {
				if ( match ) {
					// Don't consume trailing commas as valid
					soFar = soFar.slice( match[0].length ) || soFar;
				}
				groups.push( (tokens = []) );
			}

			matched = false;

			// Combinators
			if ( (match = rcombinators.exec( soFar )) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					// Cast descendant combinators to space
					type: match[0].replace( rtrim, " " )
				});
				soFar = soFar.slice( matched.length );
			}

			// Filters
			for ( type in Expr.filter ) {
				if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
					(match = preFilters[ type ]( match ))) ) {
					matched = match.shift();
					tokens.push({
						value: matched,
						type: type,
						matches: match
					});
					soFar = soFar.slice( matched.length );
				}
			}

			if ( !matched ) {
				break;
			}
		}

		// Return the length of the invalid excess
		// if we're just parsing
		// Otherwise, throw an error or return tokens
		return parseOnly ?
			soFar.length :
			soFar ?
				Sizzle.error( selector ) :
				// Cache the tokens
				tokenCache( selector, groups ).slice( 0 );
	};

	function toSelector( tokens ) {
		var i = 0,
			len = tokens.length,
			selector = "";
		for ( ; i < len; i++ ) {
			selector += tokens[i].value;
		}
		return selector;
	}

	function addCombinator( matcher, combinator, base ) {
		var dir = combinator.dir,
			skip = combinator.next,
			key = skip || dir,
			checkNonElements = base && key === "parentNode",
			doneName = done++;

		return combinator.first ?
			// Check against closest ancestor/preceding element
			function( elem, context, xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						return matcher( elem, context, xml );
					}
				}
				return false;
			} :

			// Check against all ancestor/preceding elements
			function( elem, context, xml ) {
				var oldCache, uniqueCache, outerCache,
					newCache = [ dirruns, doneName ];

				// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
				if ( xml ) {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							if ( matcher( elem, context, xml ) ) {
								return true;
							}
						}
					}
				} else {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							outerCache = elem[ expando ] || (elem[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

							if ( skip && skip === elem.nodeName.toLowerCase() ) {
								elem = elem[ dir ] || elem;
							} else if ( (oldCache = uniqueCache[ key ]) &&
								oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

								// Assign to newCache so results back-propagate to previous elements
								return (newCache[ 2 ] = oldCache[ 2 ]);
							} else {
								// Reuse newcache so results back-propagate to previous elements
								uniqueCache[ key ] = newCache;

								// A match means we're done; a fail means we have to keep checking
								if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
									return true;
								}
							}
						}
					}
				}
				return false;
			};
	}

	function elementMatcher( matchers ) {
		return matchers.length > 1 ?
			function( elem, context, xml ) {
				var i = matchers.length;
				while ( i-- ) {
					if ( !matchers[i]( elem, context, xml ) ) {
						return false;
					}
				}
				return true;
			} :
			matchers[0];
	}

	function multipleContexts( selector, contexts, results ) {
		var i = 0,
			len = contexts.length;
		for ( ; i < len; i++ ) {
			Sizzle( selector, contexts[i], results );
		}
		return results;
	}

	function condense( unmatched, map, filter, context, xml ) {
		var elem,
			newUnmatched = [],
			i = 0,
			len = unmatched.length,
			mapped = map != null;

		for ( ; i < len; i++ ) {
			if ( (elem = unmatched[i]) ) {
				if ( !filter || filter( elem, context, xml ) ) {
					newUnmatched.push( elem );
					if ( mapped ) {
						map.push( i );
					}
				}
			}
		}

		return newUnmatched;
	}

	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
		if ( postFilter && !postFilter[ expando ] ) {
			postFilter = setMatcher( postFilter );
		}
		if ( postFinder && !postFinder[ expando ] ) {
			postFinder = setMatcher( postFinder, postSelector );
		}
		return markFunction(function( seed, results, context, xml ) {
			var temp, i, elem,
				preMap = [],
				postMap = [],
				preexisting = results.length,

				// Get initial elements from seed or context
				elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && ( seed || !selector ) ?
					condense( elems, preMap, preFilter, context, xml ) :
					elems,

				matcherOut = matcher ?
					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
					postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

						// ...intermediate processing is necessary
						[] :

						// ...otherwise use results directly
						results :
					matcherIn;

			// Find primary matches
			if ( matcher ) {
				matcher( matcherIn, matcherOut, context, xml );
			}

			// Apply postFilter
			if ( postFilter ) {
				temp = condense( matcherOut, postMap );
				postFilter( temp, [], context, xml );

				// Un-match failing elements by moving them back to matcherIn
				i = temp.length;
				while ( i-- ) {
					if ( (elem = temp[i]) ) {
						matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
					}
				}
			}

			if ( seed ) {
				if ( postFinder || preFilter ) {
					if ( postFinder ) {
						// Get the final matcherOut by condensing this intermediate into postFinder contexts
						temp = [];
						i = matcherOut.length;
						while ( i-- ) {
							if ( (elem = matcherOut[i]) ) {
								// Restore matcherIn since elem is not yet a final match
								temp.push( (matcherIn[i] = elem) );
							}
						}
						postFinder( null, (matcherOut = []), temp, xml );
					}

					// Move matched elements from seed to results to keep them synchronized
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) &&
							(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

							seed[temp] = !(results[temp] = elem);
						}
					}
				}

			// Add elements to results, through postFinder if defined
			} else {
				matcherOut = condense(
					matcherOut === results ?
						matcherOut.splice( preexisting, matcherOut.length ) :
						matcherOut
				);
				if ( postFinder ) {
					postFinder( null, results, matcherOut, xml );
				} else {
					push.apply( results, matcherOut );
				}
			}
		});
	}

	function matcherFromTokens( tokens ) {
		var checkContext, matcher, j,
			len = tokens.length,
			leadingRelative = Expr.relative[ tokens[0].type ],
			implicitRelative = leadingRelative || Expr.relative[" "],
			i = leadingRelative ? 1 : 0,

			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator( function( elem ) {
				return elem === checkContext;
			}, implicitRelative, true ),
			matchAnyContext = addCombinator( function( elem ) {
				return indexOf( checkContext, elem ) > -1;
			}, implicitRelative, true ),
			matchers = [ function( elem, context, xml ) {
				var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
					(checkContext = context).nodeType ?
						matchContext( elem, context, xml ) :
						matchAnyContext( elem, context, xml ) );
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			} ];

		for ( ; i < len; i++ ) {
			if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
				matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
			} else {
				matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

				// Return special upon seeing a positional matcher
				if ( matcher[ expando ] ) {
					// Find the next relative operator (if any) for proper handling
					j = ++i;
					for ( ; j < len; j++ ) {
						if ( Expr.relative[ tokens[j].type ] ) {
							break;
						}
					}
					return setMatcher(
						i > 1 && elementMatcher( matchers ),
						i > 1 && toSelector(
							// If the preceding token was a descendant combinator, insert an implicit any-element `*`
							tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
						).replace( rtrim, "$1" ),
						matcher,
						i < j && matcherFromTokens( tokens.slice( i, j ) ),
						j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
						j < len && toSelector( tokens )
					);
				}
				matchers.push( matcher );
			}
		}

		return elementMatcher( matchers );
	}

	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
		var bySet = setMatchers.length > 0,
			byElement = elementMatchers.length > 0,
			superMatcher = function( seed, context, xml, results, outermost ) {
				var elem, j, matcher,
					matchedCount = 0,
					i = "0",
					unmatched = seed && [],
					setMatched = [],
					contextBackup = outermostContext,
					// We must always have either seed elements or outermost context
					elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
					// Use integer dirruns iff this is the outermost matcher
					dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
					len = elems.length;

				if ( outermost ) {
					outermostContext = context === document || context || outermost;
				}

				// Add elements passing elementMatchers directly to results
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
					if ( byElement && elem ) {
						j = 0;
						if ( !context && elem.ownerDocument !== document ) {
							setDocument( elem );
							xml = !documentIsHTML;
						}
						while ( (matcher = elementMatchers[j++]) ) {
							if ( matcher( elem, context || document, xml) ) {
								results.push( elem );
								break;
							}
						}
						if ( outermost ) {
							dirruns = dirrunsUnique;
						}
					}

					// Track unmatched elements for set filters
					if ( bySet ) {
						// They will have gone through all possible matchers
						if ( (elem = !matcher && elem) ) {
							matchedCount--;
						}

						// Lengthen the array for every element, matched or not
						if ( seed ) {
							unmatched.push( elem );
						}
					}
				}

				// `i` is now the count of elements visited above, and adding it to `matchedCount`
				// makes the latter nonnegative.
				matchedCount += i;

				// Apply set filters to unmatched elements
				// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
				// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
				// no element matchers and no seed.
				// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
				// case, which will result in a "00" `matchedCount` that differs from `i` but is also
				// numerically zero.
				if ( bySet && i !== matchedCount ) {
					j = 0;
					while ( (matcher = setMatchers[j++]) ) {
						matcher( unmatched, setMatched, context, xml );
					}

					if ( seed ) {
						// Reintegrate element matches to eliminate the need for sorting
						if ( matchedCount > 0 ) {
							while ( i-- ) {
								if ( !(unmatched[i] || setMatched[i]) ) {
									setMatched[i] = pop.call( results );
								}
							}
						}

						// Discard index placeholder values to get only actual matches
						setMatched = condense( setMatched );
					}

					// Add matches to results
					push.apply( results, setMatched );

					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if ( outermost && !seed && setMatched.length > 0 &&
						( matchedCount + setMatchers.length ) > 1 ) {

						Sizzle.uniqueSort( results );
					}
				}

				// Override manipulation of globals by nested matchers
				if ( outermost ) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}

				return unmatched;
			};

		return bySet ?
			markFunction( superMatcher ) :
			superMatcher;
	}

	compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
		var i,
			setMatchers = [],
			elementMatchers = [],
			cached = compilerCache[ selector + " " ];

		if ( !cached ) {
			// Generate a function of recursive functions that can be used to check each element
			if ( !match ) {
				match = tokenize( selector );
			}
			i = match.length;
			while ( i-- ) {
				cached = matcherFromTokens( match[i] );
				if ( cached[ expando ] ) {
					setMatchers.push( cached );
				} else {
					elementMatchers.push( cached );
				}
			}

			// Cache the compiled function
			cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

			// Save selector and tokenization
			cached.selector = selector;
		}
		return cached;
	};

	/**
	 * A low-level selection function that works with Sizzle's compiled
	 *  selector functions
	 * @param {String|Function} selector A selector or a pre-compiled
	 *  selector function built with Sizzle.compile
	 * @param {Element} context
	 * @param {Array} [results]
	 * @param {Array} [seed] A set of elements to match against
	 */
	select = Sizzle.select = function( selector, context, results, seed ) {
		var i, tokens, token, type, find,
			compiled = typeof selector === "function" && selector,
			match = !seed && tokenize( (selector = compiled.selector || selector) );

		results = results || [];

		// Try to minimize operations if there is only one selector in the list and no seed
		// (the latter of which guarantees us context)
		if ( match.length === 1 ) {

			// Reduce context if the leading compound selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;

				// Precompiled matchers will still verify ancestry, so step up a level
				} else if ( compiled ) {
					context = context.parentNode;
				}

				selector = selector.slice( tokens.shift().value.length );
			}

			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];

				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
					)) ) {

						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}

						break;
					}
				}
			}
		}

		// Compile and execute a filtering function if one is not provided
		// Provide `match` to avoid retokenization if we modified the selector above
		( compiled || compile( selector, match ) )(
			seed,
			context,
			!documentIsHTML,
			results,
			!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
		);
		return results;
	};

	// One-time assignments

	// Sort stability
	support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

	// Support: Chrome 14-35+
	// Always assume duplicates if they aren't passed to the comparison function
	support.detectDuplicates = !!hasDuplicate;

	// Initialize against the default document
	setDocument();

	// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	// Detached nodes confoundingly follow *each other*
	support.sortDetached = assert(function( el ) {
		// Should return 1, but returns 4 (following)
		return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
	});

	// Support: IE<8
	// Prevent attribute/property "interpolation"
	// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	if ( !assert(function( el ) {
		el.innerHTML = "<a href='#'></a>";
		return el.firstChild.getAttribute("href") === "#" ;
	}) ) {
		addHandle( "type|href|height|width", function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
			}
		});
	}

	// Support: IE<9
	// Use defaultValue in place of getAttribute("value")
	if ( !support.attributes || !assert(function( el ) {
		el.innerHTML = "<input/>";
		el.firstChild.setAttribute( "value", "" );
		return el.firstChild.getAttribute( "value" ) === "";
	}) ) {
		addHandle( "value", function( elem, name, isXML ) {
			if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
				return elem.defaultValue;
			}
		});
	}

	// Support: IE<9
	// Use getAttributeNode to fetch booleans when getAttribute lies
	if ( !assert(function( el ) {
		return el.getAttribute("disabled") == null;
	}) ) {
		addHandle( booleans, function( elem, name, isXML ) {
			var val;
			if ( !isXML ) {
				return elem[ name ] === true ? name.toLowerCase() :
						(val = elem.getAttributeNode( name )) && val.specified ?
						val.value :
					null;
			}
		});
	}

	return Sizzle;

	})( window );



	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;

	// Deprecated
	jQuery.expr[ ":" ] = jQuery.expr.pseudos;
	jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;
	jQuery.escapeSelector = Sizzle.escape;




	var dir = function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;

		while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	};


	var siblings = function( n, elem ) {
		var matched = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}

		return matched;
	};


	var rneedsContext = jQuery.expr.match.needsContext;



	function nodeName( elem, name ) {

	  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

	};
	var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



	var risSimple = /^.[^:#\[\.,]*$/;

	// Implement the identical functionality for filter and not
	function winnow( elements, qualifier, not ) {
		if ( jQuery.isFunction( qualifier ) ) {
			return jQuery.grep( elements, function( elem, i ) {
				return !!qualifier.call( elem, i, elem ) !== not;
			} );
		}

		// Single element
		if ( qualifier.nodeType ) {
			return jQuery.grep( elements, function( elem ) {
				return ( elem === qualifier ) !== not;
			} );
		}

		// Arraylike of elements (jQuery, arguments, Array)
		if ( typeof qualifier !== "string" ) {
			return jQuery.grep( elements, function( elem ) {
				return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
			} );
		}

		// Simple selector that can be filtered directly, removing non-Elements
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		// Complex selector, compare the two sets, removing non-Elements
		qualifier = jQuery.filter( qualifier, elements );
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;
		} );
	}

	jQuery.filter = function( expr, elems, not ) {
		var elem = elems[ 0 ];

		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		if ( elems.length === 1 && elem.nodeType === 1 ) {
			return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
		}

		return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		} ) );
	};

	jQuery.fn.extend( {
		find: function( selector ) {
			var i, ret,
				len = this.length,
				self = this;

			if ( typeof selector !== "string" ) {
				return this.pushStack( jQuery( selector ).filter( function() {
					for ( i = 0; i < len; i++ ) {
						if ( jQuery.contains( self[ i ], this ) ) {
							return true;
						}
					}
				} ) );
			}

			ret = this.pushStack( [] );

			for ( i = 0; i < len; i++ ) {
				jQuery.find( selector, self[ i ], ret );
			}

			return len > 1 ? jQuery.uniqueSort( ret ) : ret;
		},
		filter: function( selector ) {
			return this.pushStack( winnow( this, selector || [], false ) );
		},
		not: function( selector ) {
			return this.pushStack( winnow( this, selector || [], true ) );
		},
		is: function( selector ) {
			return !!winnow(
				this,

				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				typeof selector === "string" && rneedsContext.test( selector ) ?
					jQuery( selector ) :
					selector || [],
				false
			).length;
		}
	} );


	// Initialize a jQuery object


	// A central reference to the root jQuery(document)
	var rootjQuery,

		// A simple way to check for HTML strings
		// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
		// Strict HTML recognition (#11290: must start with <)
		// Shortcut simple #id case for speed
		rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

		init = jQuery.fn.init = function( selector, context, root ) {
			var match, elem;

			// HANDLE: $(""), $(null), $(undefined), $(false)
			if ( !selector ) {
				return this;
			}

			// Method init() accepts an alternate rootjQuery
			// so migrate can support jQuery.sub (gh-2101)
			root = root || rootjQuery;

			// Handle HTML strings
			if ( typeof selector === "string" ) {
				if ( selector[ 0 ] === "<" &&
					selector[ selector.length - 1 ] === ">" &&
					selector.length >= 3 ) {

					// Assume that strings that start and end with <> are HTML and skip the regex check
					match = [ null, selector, null ];

				} else {
					match = rquickExpr.exec( selector );
				}

				// Match html or make sure no context is specified for #id
				if ( match && ( match[ 1 ] || !context ) ) {

					// HANDLE: $(html) -> $(array)
					if ( match[ 1 ] ) {
						context = context instanceof jQuery ? context[ 0 ] : context;

						// Option to run scripts is true for back-compat
						// Intentionally let the error be thrown if parseHTML is not present
						jQuery.merge( this, jQuery.parseHTML(
							match[ 1 ],
							context && context.nodeType ? context.ownerDocument || context : document,
							true
						) );

						// HANDLE: $(html, props)
						if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
							for ( match in context ) {

								// Properties of context are called as methods if possible
								if ( jQuery.isFunction( this[ match ] ) ) {
									this[ match ]( context[ match ] );

								// ...and otherwise set as attributes
								} else {
									this.attr( match, context[ match ] );
								}
							}
						}

						return this;

					// HANDLE: $(#id)
					} else {
						elem = document.getElementById( match[ 2 ] );

						if ( elem ) {

							// Inject the element directly into the jQuery object
							this[ 0 ] = elem;
							this.length = 1;
						}
						return this;
					}

				// HANDLE: $(expr, $(...))
				} else if ( !context || context.jquery ) {
					return ( context || root ).find( selector );

				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
				} else {
					return this.constructor( context ).find( selector );
				}

			// HANDLE: $(DOMElement)
			} else if ( selector.nodeType ) {
				this[ 0 ] = selector;
				this.length = 1;
				return this;

			// HANDLE: $(function)
			// Shortcut for document ready
			} else if ( jQuery.isFunction( selector ) ) {
				return root.ready !== undefined ?
					root.ready( selector ) :

					// Execute immediately if ready is not present
					selector( jQuery );
			}

			return jQuery.makeArray( selector, this );
		};

	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;

	// Initialize central reference
	rootjQuery = jQuery( document );


	var rparentsprev = /^(?:parents|prev(?:Until|All))/,

		// Methods guaranteed to produce a unique set when starting from a unique set
		guaranteedUnique = {
			children: true,
			contents: true,
			next: true,
			prev: true
		};

	jQuery.fn.extend( {
		has: function( target ) {
			var targets = jQuery( target, this ),
				l = targets.length;

			return this.filter( function() {
				var i = 0;
				for ( ; i < l; i++ ) {
					if ( jQuery.contains( this, targets[ i ] ) ) {
						return true;
					}
				}
			} );
		},

		closest: function( selectors, context ) {
			var cur,
				i = 0,
				l = this.length,
				matched = [],
				targets = typeof selectors !== "string" && jQuery( selectors );

			// Positional selectors never match, since there's no _selection_ context
			if ( !rneedsContext.test( selectors ) ) {
				for ( ; i < l; i++ ) {
					for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

						// Always skip document fragments
						if ( cur.nodeType < 11 && ( targets ?
							targets.index( cur ) > -1 :

							// Don't pass non-elements to Sizzle
							cur.nodeType === 1 &&
								jQuery.find.matchesSelector( cur, selectors ) ) ) {

							matched.push( cur );
							break;
						}
					}
				}
			}

			return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
		},

		// Determine the position of an element within the set
		index: function( elem ) {

			// No argument, return index in parent
			if ( !elem ) {
				return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
			}

			// Index in selector
			if ( typeof elem === "string" ) {
				return indexOf.call( jQuery( elem ), this[ 0 ] );
			}

			// Locate the position of the desired element
			return indexOf.call( this,

				// If it receives a jQuery object, the first element is used
				elem.jquery ? elem[ 0 ] : elem
			);
		},

		add: function( selector, context ) {
			return this.pushStack(
				jQuery.uniqueSort(
					jQuery.merge( this.get(), jQuery( selector, context ) )
				)
			);
		},

		addBack: function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter( selector )
			);
		}
	} );

	function sibling( cur, dir ) {
		while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
		return cur;
	}

	jQuery.each( {
		parent: function( elem ) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function( elem ) {
			return dir( elem, "parentNode" );
		},
		parentsUntil: function( elem, i, until ) {
			return dir( elem, "parentNode", until );
		},
		next: function( elem ) {
			return sibling( elem, "nextSibling" );
		},
		prev: function( elem ) {
			return sibling( elem, "previousSibling" );
		},
		nextAll: function( elem ) {
			return dir( elem, "nextSibling" );
		},
		prevAll: function( elem ) {
			return dir( elem, "previousSibling" );
		},
		nextUntil: function( elem, i, until ) {
			return dir( elem, "nextSibling", until );
		},
		prevUntil: function( elem, i, until ) {
			return dir( elem, "previousSibling", until );
		},
		siblings: function( elem ) {
			return siblings( ( elem.parentNode || {} ).firstChild, elem );
		},
		children: function( elem ) {
			return siblings( elem.firstChild );
		},
		contents: function( elem ) {
	        if ( nodeName( elem, "iframe" ) ) {
	            return elem.contentDocument;
	        }

	        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
	        // Treat the template element as a regular one in browsers that
	        // don't support it.
	        if ( nodeName( elem, "template" ) ) {
	            elem = elem.content || elem;
	        }

	        return jQuery.merge( [], elem.childNodes );
		}
	}, function( name, fn ) {
		jQuery.fn[ name ] = function( until, selector ) {
			var matched = jQuery.map( this, fn, until );

			if ( name.slice( -5 ) !== "Until" ) {
				selector = until;
			}

			if ( selector && typeof selector === "string" ) {
				matched = jQuery.filter( selector, matched );
			}

			if ( this.length > 1 ) {

				// Remove duplicates
				if ( !guaranteedUnique[ name ] ) {
					jQuery.uniqueSort( matched );
				}

				// Reverse order for parents* and prev-derivatives
				if ( rparentsprev.test( name ) ) {
					matched.reverse();
				}
			}

			return this.pushStack( matched );
		};
	} );
	var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



	// Convert String-formatted options into Object-formatted ones
	function createOptions( options ) {
		var object = {};
		jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
			object[ flag ] = true;
		} );
		return object;
	}

	/*
	 * Create a callback list using the following parameters:
	 *
	 *	options: an optional list of space-separated options that will change how
	 *			the callback list behaves or a more traditional option object
	 *
	 * By default a callback list will act like an event callback list and can be
	 * "fired" multiple times.
	 *
	 * Possible options:
	 *
	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
	 *
	 *	memory:			will keep track of previous values and will call any callback added
	 *					after the list has been fired right away with the latest "memorized"
	 *					values (like a Deferred)
	 *
	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	 *
	 *	stopOnFalse:	interrupt callings when a callback returns false
	 *
	 */
	jQuery.Callbacks = function( options ) {

		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ?
			createOptions( options ) :
			jQuery.extend( {}, options );

		var // Flag to know if list is currently firing
			firing,

			// Last fire value for non-forgettable lists
			memory,

			// Flag to know if list was already fired
			fired,

			// Flag to prevent firing
			locked,

			// Actual callback list
			list = [],

			// Queue of execution data for repeatable lists
			queue = [],

			// Index of currently firing callback (modified by add/remove as needed)
			firingIndex = -1,

			// Fire callbacks
			fire = function() {

				// Enforce single-firing
				locked = locked || options.once;

				// Execute callbacks for all pending executions,
				// respecting firingIndex overrides and runtime changes
				fired = firing = true;
				for ( ; queue.length; firingIndex = -1 ) {
					memory = queue.shift();
					while ( ++firingIndex < list.length ) {

						// Run callback and check for early termination
						if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
							options.stopOnFalse ) {

							// Jump to end and forget the data so .add doesn't re-fire
							firingIndex = list.length;
							memory = false;
						}
					}
				}

				// Forget the data if we're done with it
				if ( !options.memory ) {
					memory = false;
				}

				firing = false;

				// Clean up if we're done firing for good
				if ( locked ) {

					// Keep an empty list if we have data for future add calls
					if ( memory ) {
						list = [];

					// Otherwise, this object is spent
					} else {
						list = "";
					}
				}
			},

			// Actual Callbacks object
			self = {

				// Add a callback or a collection of callbacks to the list
				add: function() {
					if ( list ) {

						// If we have memory from a past run, we should fire after adding
						if ( memory && !firing ) {
							firingIndex = list.length - 1;
							queue.push( memory );
						}

						( function add( args ) {
							jQuery.each( args, function( _, arg ) {
								if ( jQuery.isFunction( arg ) ) {
									if ( !options.unique || !self.has( arg ) ) {
										list.push( arg );
									}
								} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {

									// Inspect recursively
									add( arg );
								}
							} );
						} )( arguments );

						if ( memory && !firing ) {
							fire();
						}
					}
					return this;
				},

				// Remove a callback from the list
				remove: function() {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );

							// Handle firing indexes
							if ( index <= firingIndex ) {
								firingIndex--;
							}
						}
					} );
					return this;
				},

				// Check if a given callback is in the list.
				// If no argument is given, return whether or not list has callbacks attached.
				has: function( fn ) {
					return fn ?
						jQuery.inArray( fn, list ) > -1 :
						list.length > 0;
				},

				// Remove all callbacks from the list
				empty: function() {
					if ( list ) {
						list = [];
					}
					return this;
				},

				// Disable .fire and .add
				// Abort any current/pending executions
				// Clear all callbacks and values
				disable: function() {
					locked = queue = [];
					list = memory = "";
					return this;
				},
				disabled: function() {
					return !list;
				},

				// Disable .fire
				// Also disable .add unless we have memory (since it would have no effect)
				// Abort any pending executions
				lock: function() {
					locked = queue = [];
					if ( !memory && !firing ) {
						list = memory = "";
					}
					return this;
				},
				locked: function() {
					return !!locked;
				},

				// Call all callbacks with the given context and arguments
				fireWith: function( context, args ) {
					if ( !locked ) {
						args = args || [];
						args = [ context, args.slice ? args.slice() : args ];
						queue.push( args );
						if ( !firing ) {
							fire();
						}
					}
					return this;
				},

				// Call all the callbacks with the given arguments
				fire: function() {
					self.fireWith( this, arguments );
					return this;
				},

				// To know if the callbacks have already been called at least once
				fired: function() {
					return !!fired;
				}
			};

		return self;
	};


	function Identity( v ) {
		return v;
	}
	function Thrower( ex ) {
		throw ex;
	}

	function adoptValue( value, resolve, reject, noValue ) {
		var method;

		try {

			// Check for promise aspect first to privilege synchronous behavior
			if ( value && jQuery.isFunction( ( method = value.promise ) ) ) {
				method.call( value ).done( resolve ).fail( reject );

			// Other thenables
			} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {
				method.call( value, resolve, reject );

			// Other non-thenables
			} else {

				// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
				// * false: [ value ].slice( 0 ) => resolve( value )
				// * true: [ value ].slice( 1 ) => resolve()
				resolve.apply( undefined, [ value ].slice( noValue ) );
			}

		// For Promises/A+, convert exceptions into rejections
		// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
		// Deferred#then to conditionally suppress rejection.
		} catch ( value ) {

			// Support: Android 4.0 only
			// Strict mode functions invoked without .call/.apply get global-object context
			reject.apply( undefined, [ value ] );
		}
	}

	jQuery.extend( {

		Deferred: function( func ) {
			var tuples = [

					// action, add listener, callbacks,
					// ... .then handlers, argument index, [final state]
					[ "notify", "progress", jQuery.Callbacks( "memory" ),
						jQuery.Callbacks( "memory" ), 2 ],
					[ "resolve", "done", jQuery.Callbacks( "once memory" ),
						jQuery.Callbacks( "once memory" ), 0, "resolved" ],
					[ "reject", "fail", jQuery.Callbacks( "once memory" ),
						jQuery.Callbacks( "once memory" ), 1, "rejected" ]
				],
				state = "pending",
				promise = {
					state: function() {
						return state;
					},
					always: function() {
						deferred.done( arguments ).fail( arguments );
						return this;
					},
					"catch": function( fn ) {
						return promise.then( null, fn );
					},

					// Keep pipe for back-compat
					pipe: function( /* fnDone, fnFail, fnProgress */ ) {
						var fns = arguments;

						return jQuery.Deferred( function( newDefer ) {
							jQuery.each( tuples, function( i, tuple ) {

								// Map tuples (progress, done, fail) to arguments (done, fail, progress)
								var fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

								// deferred.progress(function() { bind to newDefer or newDefer.notify })
								// deferred.done(function() { bind to newDefer or newDefer.resolve })
								// deferred.fail(function() { bind to newDefer or newDefer.reject })
								deferred[ tuple[ 1 ] ]( function() {
									var returned = fn && fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise()
											.progress( newDefer.notify )
											.done( newDefer.resolve )
											.fail( newDefer.reject );
									} else {
										newDefer[ tuple[ 0 ] + "With" ](
											this,
											fn ? [ returned ] : arguments
										);
									}
								} );
							} );
							fns = null;
						} ).promise();
					},
					then: function( onFulfilled, onRejected, onProgress ) {
						var maxDepth = 0;
						function resolve( depth, deferred, handler, special ) {
							return function() {
								var that = this,
									args = arguments,
									mightThrow = function() {
										var returned, then;

										// Support: Promises/A+ section 2.3.3.3.3
										// https://promisesaplus.com/#point-59
										// Ignore double-resolution attempts
										if ( depth < maxDepth ) {
											return;
										}

										returned = handler.apply( that, args );

										// Support: Promises/A+ section 2.3.1
										// https://promisesaplus.com/#point-48
										if ( returned === deferred.promise() ) {
											throw new TypeError( "Thenable self-resolution" );
										}

										// Support: Promises/A+ sections 2.3.3.1, 3.5
										// https://promisesaplus.com/#point-54
										// https://promisesaplus.com/#point-75
										// Retrieve `then` only once
										then = returned &&

											// Support: Promises/A+ section 2.3.4
											// https://promisesaplus.com/#point-64
											// Only check objects and functions for thenability
											( typeof returned === "object" ||
												typeof returned === "function" ) &&
											returned.then;

										// Handle a returned thenable
										if ( jQuery.isFunction( then ) ) {

											// Special processors (notify) just wait for resolution
											if ( special ) {
												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special )
												);

											// Normal processors (resolve) also hook into progress
											} else {

												// ...and disregard older resolution values
												maxDepth++;

												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special ),
													resolve( maxDepth, deferred, Identity,
														deferred.notifyWith )
												);
											}

										// Handle all other returned values
										} else {

											// Only substitute handlers pass on context
											// and multiple values (non-spec behavior)
											if ( handler !== Identity ) {
												that = undefined;
												args = [ returned ];
											}

											// Process the value(s)
											// Default process is resolve
											( special || deferred.resolveWith )( that, args );
										}
									},

									// Only normal processors (resolve) catch and reject exceptions
									process = special ?
										mightThrow :
										function() {
											try {
												mightThrow();
											} catch ( e ) {

												if ( jQuery.Deferred.exceptionHook ) {
													jQuery.Deferred.exceptionHook( e,
														process.stackTrace );
												}

												// Support: Promises/A+ section 2.3.3.3.4.1
												// https://promisesaplus.com/#point-61
												// Ignore post-resolution exceptions
												if ( depth + 1 >= maxDepth ) {

													// Only substitute handlers pass on context
													// and multiple values (non-spec behavior)
													if ( handler !== Thrower ) {
														that = undefined;
														args = [ e ];
													}

													deferred.rejectWith( that, args );
												}
											}
										};

								// Support: Promises/A+ section 2.3.3.3.1
								// https://promisesaplus.com/#point-57
								// Re-resolve promises immediately to dodge false rejection from
								// subsequent errors
								if ( depth ) {
									process();
								} else {

									// Call an optional hook to record the stack, in case of exception
									// since it's otherwise lost when execution goes async
									if ( jQuery.Deferred.getStackHook ) {
										process.stackTrace = jQuery.Deferred.getStackHook();
									}
									window.setTimeout( process );
								}
							};
						}

						return jQuery.Deferred( function( newDefer ) {

							// progress_handlers.add( ... )
							tuples[ 0 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									jQuery.isFunction( onProgress ) ?
										onProgress :
										Identity,
									newDefer.notifyWith
								)
							);

							// fulfilled_handlers.add( ... )
							tuples[ 1 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									jQuery.isFunction( onFulfilled ) ?
										onFulfilled :
										Identity
								)
							);

							// rejected_handlers.add( ... )
							tuples[ 2 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									jQuery.isFunction( onRejected ) ?
										onRejected :
										Thrower
								)
							);
						} ).promise();
					},

					// Get a promise for this deferred
					// If obj is provided, the promise aspect is added to the object
					promise: function( obj ) {
						return obj != null ? jQuery.extend( obj, promise ) : promise;
					}
				},
				deferred = {};

			// Add list-specific methods
			jQuery.each( tuples, function( i, tuple ) {
				var list = tuple[ 2 ],
					stateString = tuple[ 5 ];

				// promise.progress = list.add
				// promise.done = list.add
				// promise.fail = list.add
				promise[ tuple[ 1 ] ] = list.add;

				// Handle state
				if ( stateString ) {
					list.add(
						function() {

							// state = "resolved" (i.e., fulfilled)
							// state = "rejected"
							state = stateString;
						},

						// rejected_callbacks.disable
						// fulfilled_callbacks.disable
						tuples[ 3 - i ][ 2 ].disable,

						// progress_callbacks.lock
						tuples[ 0 ][ 2 ].lock
					);
				}

				// progress_handlers.fire
				// fulfilled_handlers.fire
				// rejected_handlers.fire
				list.add( tuple[ 3 ].fire );

				// deferred.notify = function() { deferred.notifyWith(...) }
				// deferred.resolve = function() { deferred.resolveWith(...) }
				// deferred.reject = function() { deferred.rejectWith(...) }
				deferred[ tuple[ 0 ] ] = function() {
					deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
					return this;
				};

				// deferred.notifyWith = list.fireWith
				// deferred.resolveWith = list.fireWith
				// deferred.rejectWith = list.fireWith
				deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
			} );

			// Make the deferred a promise
			promise.promise( deferred );

			// Call given func if any
			if ( func ) {
				func.call( deferred, deferred );
			}

			// All done!
			return deferred;
		},

		// Deferred helper
		when: function( singleValue ) {
			var

				// count of uncompleted subordinates
				remaining = arguments.length,

				// count of unprocessed arguments
				i = remaining,

				// subordinate fulfillment data
				resolveContexts = Array( i ),
				resolveValues = slice.call( arguments ),

				// the master Deferred
				master = jQuery.Deferred(),

				// subordinate callback factory
				updateFunc = function( i ) {
					return function( value ) {
						resolveContexts[ i ] = this;
						resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
						if ( !( --remaining ) ) {
							master.resolveWith( resolveContexts, resolveValues );
						}
					};
				};

			// Single- and empty arguments are adopted like Promise.resolve
			if ( remaining <= 1 ) {
				adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
					!remaining );

				// Use .then() to unwrap secondary thenables (cf. gh-3000)
				if ( master.state() === "pending" ||
					jQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

					return master.then();
				}
			}

			// Multiple arguments are aggregated like Promise.all array elements
			while ( i-- ) {
				adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
			}

			return master.promise();
		}
	} );


	// These usually indicate a programmer mistake during development,
	// warn about them ASAP rather than swallowing them by default.
	var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

	jQuery.Deferred.exceptionHook = function( error, stack ) {

		// Support: IE 8 - 9 only
		// Console exists when dev tools are open, which can happen at any time
		if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
			window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
		}
	};




	jQuery.readyException = function( error ) {
		window.setTimeout( function() {
			throw error;
		} );
	};




	// The deferred used on DOM ready
	var readyList = jQuery.Deferred();

	jQuery.fn.ready = function( fn ) {

		readyList
			.then( fn )

			// Wrap jQuery.readyException in a function so that the lookup
			// happens at the time of error handling instead of callback
			// registration.
			.catch( function( error ) {
				jQuery.readyException( error );
			} );

		return this;
	};

	jQuery.extend( {

		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,

		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,

		// Handle when the DOM is ready
		ready: function( wait ) {

			// Abort if there are pending holds or we're already ready
			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
				return;
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}

			// If there are functions bound, to execute
			readyList.resolveWith( document, [ jQuery ] );
		}
	} );

	jQuery.ready.then = readyList.then;

	// The ready event handler and self cleanup method
	function completed() {
		document.removeEventListener( "DOMContentLoaded", completed );
		window.removeEventListener( "load", completed );
		jQuery.ready();
	}

	// Catch cases where $(document).ready() is called
	// after the browser event has already occurred.
	// Support: IE <=9 - 10 only
	// Older IE sometimes signals "interactive" too soon
	if ( document.readyState === "complete" ||
		( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

		// Handle it asynchronously to allow scripts the opportunity to delay ready
		window.setTimeout( jQuery.ready );

	} else {

		// Use the handy event callback
		document.addEventListener( "DOMContentLoaded", completed );

		// A fallback to window.onload, that will always work
		window.addEventListener( "load", completed );
	}




	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i = 0,
			len = elems.length,
			bulk = key == null;

		// Sets many values
		if ( jQuery.type( key ) === "object" ) {
			chainable = true;
			for ( i in key ) {
				access( elems, fn, i, key[ i ], true, emptyGet, raw );
			}

		// Sets one value
		} else if ( value !== undefined ) {
			chainable = true;

			if ( !jQuery.isFunction( value ) ) {
				raw = true;
			}

			if ( bulk ) {

				// Bulk operations run against the entire set
				if ( raw ) {
					fn.call( elems, value );
					fn = null;

				// ...except when executing function values
				} else {
					bulk = fn;
					fn = function( elem, key, value ) {
						return bulk.call( jQuery( elem ), value );
					};
				}
			}

			if ( fn ) {
				for ( ; i < len; i++ ) {
					fn(
						elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
					);
				}
			}
		}

		if ( chainable ) {
			return elems;
		}

		// Gets
		if ( bulk ) {
			return fn.call( elems );
		}

		return len ? fn( elems[ 0 ], key ) : emptyGet;
	};
	var acceptData = function( owner ) {

		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
	};




	function Data() {
		this.expando = jQuery.expando + Data.uid++;
	}

	Data.uid = 1;

	Data.prototype = {

		cache: function( owner ) {

			// Check if the owner object already has a cache
			var value = owner[ this.expando ];

			// If not, create one
			if ( !value ) {
				value = {};

				// We can accept data for non-element nodes in modern browsers,
				// but we should not, see #8335.
				// Always return an empty object.
				if ( acceptData( owner ) ) {

					// If it is a node unlikely to be stringify-ed or looped over
					// use plain assignment
					if ( owner.nodeType ) {
						owner[ this.expando ] = value;

					// Otherwise secure it in a non-enumerable property
					// configurable must be true to allow the property to be
					// deleted when data is removed
					} else {
						Object.defineProperty( owner, this.expando, {
							value: value,
							configurable: true
						} );
					}
				}
			}

			return value;
		},
		set: function( owner, data, value ) {
			var prop,
				cache = this.cache( owner );

			// Handle: [ owner, key, value ] args
			// Always use camelCase key (gh-2257)
			if ( typeof data === "string" ) {
				cache[ jQuery.camelCase( data ) ] = value;

			// Handle: [ owner, { properties } ] args
			} else {

				// Copy the properties one-by-one to the cache object
				for ( prop in data ) {
					cache[ jQuery.camelCase( prop ) ] = data[ prop ];
				}
			}
			return cache;
		},
		get: function( owner, key ) {
			return key === undefined ?
				this.cache( owner ) :

				// Always use camelCase key (gh-2257)
				owner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];
		},
		access: function( owner, key, value ) {

			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if ( key === undefined ||
					( ( key && typeof key === "string" ) && value === undefined ) ) {

				return this.get( owner, key );
			}

			// When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set( owner, key, value );

			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function( owner, key ) {
			var i,
				cache = owner[ this.expando ];

			if ( cache === undefined ) {
				return;
			}

			if ( key !== undefined ) {

				// Support array or space separated string of keys
				if ( Array.isArray( key ) ) {

					// If key is an array of keys...
					// We always set camelCase keys, so remove that.
					key = key.map( jQuery.camelCase );
				} else {
					key = jQuery.camelCase( key );

					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					key = key in cache ?
						[ key ] :
						( key.match( rnothtmlwhite ) || [] );
				}

				i = key.length;

				while ( i-- ) {
					delete cache[ key[ i ] ];
				}
			}

			// Remove the expando if there's no more data
			if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

				// Support: Chrome <=35 - 45
				// Webkit & Blink performance suffers when deleting properties
				// from DOM nodes, so set to undefined instead
				// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
				if ( owner.nodeType ) {
					owner[ this.expando ] = undefined;
				} else {
					delete owner[ this.expando ];
				}
			}
		},
		hasData: function( owner ) {
			var cache = owner[ this.expando ];
			return cache !== undefined && !jQuery.isEmptyObject( cache );
		}
	};
	var dataPriv = new Data();

	var dataUser = new Data();



	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		rmultiDash = /[A-Z]/g;

	function getData( data ) {
		if ( data === "true" ) {
			return true;
		}

		if ( data === "false" ) {
			return false;
		}

		if ( data === "null" ) {
			return null;
		}

		// Only convert to a number if it doesn't change the string
		if ( data === +data + "" ) {
			return +data;
		}

		if ( rbrace.test( data ) ) {
			return JSON.parse( data );
		}

		return data;
	}

	function dataAttr( elem, key, data ) {
		var name;

		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if ( data === undefined && elem.nodeType === 1 ) {
			name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
			data = elem.getAttribute( name );

			if ( typeof data === "string" ) {
				try {
					data = getData( data );
				} catch ( e ) {}

				// Make sure we set the data so it isn't changed later
				dataUser.set( elem, key, data );
			} else {
				data = undefined;
			}
		}
		return data;
	}

	jQuery.extend( {
		hasData: function( elem ) {
			return dataUser.hasData( elem ) || dataPriv.hasData( elem );
		},

		data: function( elem, name, data ) {
			return dataUser.access( elem, name, data );
		},

		removeData: function( elem, name ) {
			dataUser.remove( elem, name );
		},

		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to dataPriv methods, these can be deprecated.
		_data: function( elem, name, data ) {
			return dataPriv.access( elem, name, data );
		},

		_removeData: function( elem, name ) {
			dataPriv.remove( elem, name );
		}
	} );

	jQuery.fn.extend( {
		data: function( key, value ) {
			var i, name, data,
				elem = this[ 0 ],
				attrs = elem && elem.attributes;

			// Gets all values
			if ( key === undefined ) {
				if ( this.length ) {
					data = dataUser.get( elem );

					if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
						i = attrs.length;
						while ( i-- ) {

							// Support: IE 11 only
							// The attrs elements can be null (#14894)
							if ( attrs[ i ] ) {
								name = attrs[ i ].name;
								if ( name.indexOf( "data-" ) === 0 ) {
									name = jQuery.camelCase( name.slice( 5 ) );
									dataAttr( elem, name, data[ name ] );
								}
							}
						}
						dataPriv.set( elem, "hasDataAttrs", true );
					}
				}

				return data;
			}

			// Sets multiple values
			if ( typeof key === "object" ) {
				return this.each( function() {
					dataUser.set( this, key );
				} );
			}

			return access( this, function( value ) {
				var data;

				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if ( elem && value === undefined ) {

					// Attempt to get data from the cache
					// The key will always be camelCased in Data
					data = dataUser.get( elem, key );
					if ( data !== undefined ) {
						return data;
					}

					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr( elem, key );
					if ( data !== undefined ) {
						return data;
					}

					// We tried really hard, but the data doesn't exist.
					return;
				}

				// Set the data...
				this.each( function() {

					// We always store the camelCased key
					dataUser.set( this, key, value );
				} );
			}, null, value, arguments.length > 1, null, true );
		},

		removeData: function( key ) {
			return this.each( function() {
				dataUser.remove( this, key );
			} );
		}
	} );


	jQuery.extend( {
		queue: function( elem, type, data ) {
			var queue;

			if ( elem ) {
				type = ( type || "fx" ) + "queue";
				queue = dataPriv.get( elem, type );

				// Speed up dequeue by getting out quickly if this is just a lookup
				if ( data ) {
					if ( !queue || Array.isArray( data ) ) {
						queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
					} else {
						queue.push( data );
					}
				}
				return queue || [];
			}
		},

		dequeue: function( elem, type ) {
			type = type || "fx";

			var queue = jQuery.queue( elem, type ),
				startLength = queue.length,
				fn = queue.shift(),
				hooks = jQuery._queueHooks( elem, type ),
				next = function() {
					jQuery.dequeue( elem, type );
				};

			// If the fx queue is dequeued, always remove the progress sentinel
			if ( fn === "inprogress" ) {
				fn = queue.shift();
				startLength--;
			}

			if ( fn ) {

				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if ( type === "fx" ) {
					queue.unshift( "inprogress" );
				}

				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call( elem, next, hooks );
			}

			if ( !startLength && hooks ) {
				hooks.empty.fire();
			}
		},

		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function( elem, type ) {
			var key = type + "queueHooks";
			return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
				empty: jQuery.Callbacks( "once memory" ).add( function() {
					dataPriv.remove( elem, [ type + "queue", key ] );
				} )
			} );
		}
	} );

	jQuery.fn.extend( {
		queue: function( type, data ) {
			var setter = 2;

			if ( typeof type !== "string" ) {
				data = type;
				type = "fx";
				setter--;
			}

			if ( arguments.length < setter ) {
				return jQuery.queue( this[ 0 ], type );
			}

			return data === undefined ?
				this :
				this.each( function() {
					var queue = jQuery.queue( this, type, data );

					// Ensure a hooks for this queue
					jQuery._queueHooks( this, type );

					if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
						jQuery.dequeue( this, type );
					}
				} );
		},
		dequeue: function( type ) {
			return this.each( function() {
				jQuery.dequeue( this, type );
			} );
		},
		clearQueue: function( type ) {
			return this.queue( type || "fx", [] );
		},

		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function( type, obj ) {
			var tmp,
				count = 1,
				defer = jQuery.Deferred(),
				elements = this,
				i = this.length,
				resolve = function() {
					if ( !( --count ) ) {
						defer.resolveWith( elements, [ elements ] );
					}
				};

			if ( typeof type !== "string" ) {
				obj = type;
				type = undefined;
			}
			type = type || "fx";

			while ( i-- ) {
				tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
				if ( tmp && tmp.empty ) {
					count++;
					tmp.empty.add( resolve );
				}
			}
			resolve();
			return defer.promise( obj );
		}
	} );
	var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

	var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


	var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

	var isHiddenWithinTree = function( elem, el ) {

			// isHiddenWithinTree might be called from jQuery#filter function;
			// in that case, element will be second argument
			elem = el || elem;

			// Inline style trumps all
			return elem.style.display === "none" ||
				elem.style.display === "" &&

				// Otherwise, check computed style
				// Support: Firefox <=43 - 45
				// Disconnected elements can have computed display: none, so first confirm that elem is
				// in the document.
				jQuery.contains( elem.ownerDocument, elem ) &&

				jQuery.css( elem, "display" ) === "none";
		};

	var swap = function( elem, options, callback, args ) {
		var ret, name,
			old = {};

		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		ret = callback.apply( elem, args || [] );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}

		return ret;
	};




	function adjustCSS( elem, prop, valueParts, tween ) {
		var adjusted,
			scale = 1,
			maxIterations = 20,
			currentValue = tween ?
				function() {
					return tween.cur();
				} :
				function() {
					return jQuery.css( elem, prop, "" );
				},
			initial = currentValue(),
			unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

			// Starting value computation is required for potential unit mismatches
			initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
				rcssNum.exec( jQuery.css( elem, prop ) );

		if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

			// Trust units reported by jQuery.css
			unit = unit || initialInUnit[ 3 ];

			// Make sure we update the tween properties later on
			valueParts = valueParts || [];

			// Iteratively approximate from a nonzero starting point
			initialInUnit = +initial || 1;

			do {

				// If previous iteration zeroed out, double until we get *something*.
				// Use string for doubling so we don't accidentally see scale as unchanged below
				scale = scale || ".5";

				// Adjust and apply
				initialInUnit = initialInUnit / scale;
				jQuery.style( elem, prop, initialInUnit + unit );

			// Update scale, tolerating zero or NaN from tween.cur()
			// Break the loop if scale is unchanged or perfect, or if we've just had enough.
			} while (
				scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
			);
		}

		if ( valueParts ) {
			initialInUnit = +initialInUnit || +initial || 0;

			// Apply relative offset (+=/-=) if specified
			adjusted = valueParts[ 1 ] ?
				initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
				+valueParts[ 2 ];
			if ( tween ) {
				tween.unit = unit;
				tween.start = initialInUnit;
				tween.end = adjusted;
			}
		}
		return adjusted;
	}


	var defaultDisplayMap = {};

	function getDefaultDisplay( elem ) {
		var temp,
			doc = elem.ownerDocument,
			nodeName = elem.nodeName,
			display = defaultDisplayMap[ nodeName ];

		if ( display ) {
			return display;
		}

		temp = doc.body.appendChild( doc.createElement( nodeName ) );
		display = jQuery.css( temp, "display" );

		temp.parentNode.removeChild( temp );

		if ( display === "none" ) {
			display = "block";
		}
		defaultDisplayMap[ nodeName ] = display;

		return display;
	}

	function showHide( elements, show ) {
		var display, elem,
			values = [],
			index = 0,
			length = elements.length;

		// Determine new display value for elements that need to change
		for ( ; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}

			display = elem.style.display;
			if ( show ) {

				// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
				// check is required in this first loop unless we have a nonempty display value (either
				// inline or about-to-be-restored)
				if ( display === "none" ) {
					values[ index ] = dataPriv.get( elem, "display" ) || null;
					if ( !values[ index ] ) {
						elem.style.display = "";
					}
				}
				if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
					values[ index ] = getDefaultDisplay( elem );
				}
			} else {
				if ( display !== "none" ) {
					values[ index ] = "none";

					// Remember what we're overwriting
					dataPriv.set( elem, "display", display );
				}
			}
		}

		// Set the display of the elements in a second loop to avoid constant reflow
		for ( index = 0; index < length; index++ ) {
			if ( values[ index ] != null ) {
				elements[ index ].style.display = values[ index ];
			}
		}

		return elements;
	}

	jQuery.fn.extend( {
		show: function() {
			return showHide( this, true );
		},
		hide: function() {
			return showHide( this );
		},
		toggle: function( state ) {
			if ( typeof state === "boolean" ) {
				return state ? this.show() : this.hide();
			}

			return this.each( function() {
				if ( isHiddenWithinTree( this ) ) {
					jQuery( this ).show();
				} else {
					jQuery( this ).hide();
				}
			} );
		}
	} );
	var rcheckableType = ( /^(?:checkbox|radio)$/i );

	var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );

	var rscriptType = ( /^$|\/(?:java|ecma)script/i );



	// We have to close these tags to support XHTML (#13200)
	var wrapMap = {

		// Support: IE <=9 only
		option: [ 1, "<select multiple='multiple'>", "</select>" ],

		// XHTML parsers do not magically insert elements in the
		// same way that tag soup parsers do. So we cannot shorten
		// this by omitting <tbody> or other required elements.
		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		_default: [ 0, "", "" ]
	};

	// Support: IE <=9 only
	wrapMap.optgroup = wrapMap.option;

	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;


	function getAll( context, tag ) {

		// Support: IE <=9 - 11 only
		// Use typeof to avoid zero-argument method invocation on host objects (#15151)
		var ret;

		if ( typeof context.getElementsByTagName !== "undefined" ) {
			ret = context.getElementsByTagName( tag || "*" );

		} else if ( typeof context.querySelectorAll !== "undefined" ) {
			ret = context.querySelectorAll( tag || "*" );

		} else {
			ret = [];
		}

		if ( tag === undefined || tag && nodeName( context, tag ) ) {
			return jQuery.merge( [ context ], ret );
		}

		return ret;
	}


	// Mark scripts as having already been evaluated
	function setGlobalEval( elems, refElements ) {
		var i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			dataPriv.set(
				elems[ i ],
				"globalEval",
				!refElements || dataPriv.get( refElements[ i ], "globalEval" )
			);
		}
	}


	var rhtml = /<|&#?\w+;/;

	function buildFragment( elems, context, scripts, selection, ignored ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {

					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while ( ( elem = nodes[ i++ ] ) ) {

			// Skip elements already in the context collection (trac-4087)
			if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
				if ( ignored ) {
					ignored.push( elem );
				}
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( ( elem = tmp[ j++ ] ) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		return fragment;
	}


	( function() {
		var fragment = document.createDocumentFragment(),
			div = fragment.appendChild( document.createElement( "div" ) ),
			input = document.createElement( "input" );

		// Support: Android 4.0 - 4.3 only
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// `name` and `type` must use .setAttribute for WWA (#14901)
		input.setAttribute( "type", "radio" );
		input.setAttribute( "checked", "checked" );
		input.setAttribute( "name", "t" );

		div.appendChild( input );

		// Support: Android <=4.1 only
		// Older WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

		// Support: IE <=11 only
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
	} )();
	var documentElement = document.documentElement;



	var
		rkeyEvent = /^key/,
		rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
		rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

	function returnTrue() {
		return true;
	}

	function returnFalse() {
		return false;
	}

	// Support: IE <=9 only
	// See #13393 for more info
	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch ( err ) { }
	}

	function on( elem, types, selector, data, fn, one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {

			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {

				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				on( elem, type, selector, data, types[ type ], one );
			}
			return elem;
		}

		if ( data == null && fn == null ) {

			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {

				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {

				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return elem;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {

				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};

			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return elem.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		} );
	}

	/*
	 * Helper functions for managing events -- not part of the public interface.
	 * Props to Dean Edwards' addEvent library for many of the ideas.
	 */
	jQuery.event = {

		global: {},

		add: function( elem, types, handler, data, selector ) {

			var handleObjIn, eventHandle, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.get( elem );

			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if ( !elemData ) {
				return;
			}

			// Caller can pass in an object of custom data in lieu of the handler
			if ( handler.handler ) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}

			// Ensure that invalid selectors throw exceptions at attach time
			// Evaluate against documentElement in case elem is a non-element node (e.g., document)
			if ( selector ) {
				jQuery.find.matchesSelector( documentElement, selector );
			}

			// Make sure that the handler has a unique ID, used to find/remove it later
			if ( !handler.guid ) {
				handler.guid = jQuery.guid++;
			}

			// Init the element's event structure and main handler, if this is the first
			if ( !( events = elemData.events ) ) {
				events = elemData.events = {};
			}
			if ( !( eventHandle = elemData.handle ) ) {
				eventHandle = elemData.handle = function( e ) {

					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
						jQuery.event.dispatch.apply( elem, arguments ) : undefined;
				};
			}

			// Handle multiple events separated by a space
			types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

				// There *must* be a type, no attaching namespace-only handlers
				if ( !type ) {
					continue;
				}

				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[ type ] || {};

				// If selector defined, determine special event api type, otherwise given type
				type = ( selector ? special.delegateType : special.bindType ) || type;

				// Update special based on newly reset type
				special = jQuery.event.special[ type ] || {};

				// handleObj is passed to all event handlers
				handleObj = jQuery.extend( {
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
					namespace: namespaces.join( "." )
				}, handleObjIn );

				// Init the event handler queue if we're the first
				if ( !( handlers = events[ type ] ) ) {
					handlers = events[ type ] = [];
					handlers.delegateCount = 0;

					// Only use addEventListener if the special events handler returns false
					if ( !special.setup ||
						special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

						if ( elem.addEventListener ) {
							elem.addEventListener( type, eventHandle );
						}
					}
				}

				if ( special.add ) {
					special.add.call( elem, handleObj );

					if ( !handleObj.handler.guid ) {
						handleObj.handler.guid = handler.guid;
					}
				}

				// Add to the element's handler list, delegates in front
				if ( selector ) {
					handlers.splice( handlers.delegateCount++, 0, handleObj );
				} else {
					handlers.push( handleObj );
				}

				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[ type ] = true;
			}

		},

		// Detach an event or set of events from an element
		remove: function( elem, types, handler, selector, mappedTypes ) {

			var j, origCount, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

			if ( !elemData || !( events = elemData.events ) ) {
				return;
			}

			// Once for each type.namespace in types; type may be omitted
			types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

				// Unbind all events (on this namespace, if provided) for the element
				if ( !type ) {
					for ( type in events ) {
						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
					}
					continue;
				}

				special = jQuery.event.special[ type ] || {};
				type = ( selector ? special.delegateType : special.bindType ) || type;
				handlers = events[ type ] || [];
				tmp = tmp[ 2 ] &&
					new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

				// Remove matching events
				origCount = j = handlers.length;
				while ( j-- ) {
					handleObj = handlers[ j ];

					if ( ( mappedTypes || origType === handleObj.origType ) &&
						( !handler || handler.guid === handleObj.guid ) &&
						( !tmp || tmp.test( handleObj.namespace ) ) &&
						( !selector || selector === handleObj.selector ||
							selector === "**" && handleObj.selector ) ) {
						handlers.splice( j, 1 );

						if ( handleObj.selector ) {
							handlers.delegateCount--;
						}
						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}
				}

				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if ( origCount && !handlers.length ) {
					if ( !special.teardown ||
						special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

						jQuery.removeEvent( elem, type, elemData.handle );
					}

					delete events[ type ];
				}
			}

			// Remove data and the expando if it's no longer used
			if ( jQuery.isEmptyObject( events ) ) {
				dataPriv.remove( elem, "handle events" );
			}
		},

		dispatch: function( nativeEvent ) {

			// Make a writable jQuery.Event from the native event object
			var event = jQuery.event.fix( nativeEvent );

			var i, j, ret, matched, handleObj, handlerQueue,
				args = new Array( arguments.length ),
				handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
				special = jQuery.event.special[ event.type ] || {};

			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[ 0 ] = event;

			for ( i = 1; i < arguments.length; i++ ) {
				args[ i ] = arguments[ i ];
			}

			event.delegateTarget = this;

			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
				return;
			}

			// Determine handlers
			handlerQueue = jQuery.event.handlers.call( this, event, handlers );

			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
				event.currentTarget = matched.elem;

				j = 0;
				while ( ( handleObj = matched.handlers[ j++ ] ) &&
					!event.isImmediatePropagationStopped() ) {

					// Triggered event must either 1) have no namespace, or 2) have namespace(s)
					// a subset or equal to those in the bound event (both can have no namespace).
					if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

						event.handleObj = handleObj;
						event.data = handleObj.data;

						ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
							handleObj.handler ).apply( matched.elem, args );

						if ( ret !== undefined ) {
							if ( ( event.result = ret ) === false ) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}

			// Call the postDispatch hook for the mapped type
			if ( special.postDispatch ) {
				special.postDispatch.call( this, event );
			}

			return event.result;
		},

		handlers: function( event, handlers ) {
			var i, handleObj, sel, matchedHandlers, matchedSelectors,
				handlerQueue = [],
				delegateCount = handlers.delegateCount,
				cur = event.target;

			// Find delegate handlers
			if ( delegateCount &&

				// Support: IE <=9
				// Black-hole SVG <use> instance trees (trac-13180)
				cur.nodeType &&

				// Support: Firefox <=42
				// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
				// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
				// Support: IE 11 only
				// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
				!( event.type === "click" && event.button >= 1 ) ) {

				for ( ; cur !== this; cur = cur.parentNode || this ) {

					// Don't check non-elements (#13208)
					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
						matchedHandlers = [];
						matchedSelectors = {};
						for ( i = 0; i < delegateCount; i++ ) {
							handleObj = handlers[ i ];

							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";

							if ( matchedSelectors[ sel ] === undefined ) {
								matchedSelectors[ sel ] = handleObj.needsContext ?
									jQuery( sel, this ).index( cur ) > -1 :
									jQuery.find( sel, this, null, [ cur ] ).length;
							}
							if ( matchedSelectors[ sel ] ) {
								matchedHandlers.push( handleObj );
							}
						}
						if ( matchedHandlers.length ) {
							handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
						}
					}
				}
			}

			// Add the remaining (directly-bound) handlers
			cur = this;
			if ( delegateCount < handlers.length ) {
				handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
			}

			return handlerQueue;
		},

		addProp: function( name, hook ) {
			Object.defineProperty( jQuery.Event.prototype, name, {
				enumerable: true,
				configurable: true,

				get: jQuery.isFunction( hook ) ?
					function() {
						if ( this.originalEvent ) {
								return hook( this.originalEvent );
						}
					} :
					function() {
						if ( this.originalEvent ) {
								return this.originalEvent[ name ];
						}
					},

				set: function( value ) {
					Object.defineProperty( this, name, {
						enumerable: true,
						configurable: true,
						writable: true,
						value: value
					} );
				}
			} );
		},

		fix: function( originalEvent ) {
			return originalEvent[ jQuery.expando ] ?
				originalEvent :
				new jQuery.Event( originalEvent );
		},

		special: {
			load: {

				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {

				// Fire native event if possible so blur/focus sequence is correct
				trigger: function() {
					if ( this !== safeActiveElement() && this.focus ) {
						this.focus();
						return false;
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function() {
					if ( this === safeActiveElement() && this.blur ) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
			click: {

				// For checkbox, fire native event so checked state will be right
				trigger: function() {
					if ( this.type === "checkbox" && this.click && nodeName( this, "input" ) ) {
						this.click();
						return false;
					}
				},

				// For cross-browser consistency, don't fire native .click() on links
				_default: function( event ) {
					return nodeName( event.target, "a" );
				}
			},

			beforeunload: {
				postDispatch: function( event ) {

					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if ( event.result !== undefined && event.originalEvent ) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		}
	};

	jQuery.removeEvent = function( elem, type, handle ) {

		// This "if" is needed for plain objects
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle );
		}
	};

	jQuery.Event = function( src, props ) {

		// Allow instantiation without the 'new' keyword
		if ( !( this instanceof jQuery.Event ) ) {
			return new jQuery.Event( src, props );
		}

		// Event object
		if ( src && src.type ) {
			this.originalEvent = src;
			this.type = src.type;

			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented ||
					src.defaultPrevented === undefined &&

					// Support: Android <=2.3 only
					src.returnValue === false ?
				returnTrue :
				returnFalse;

			// Create target properties
			// Support: Safari <=6 - 7 only
			// Target should not be a text node (#504, #13143)
			this.target = ( src.target && src.target.nodeType === 3 ) ?
				src.target.parentNode :
				src.target;

			this.currentTarget = src.currentTarget;
			this.relatedTarget = src.relatedTarget;

		// Event type
		} else {
			this.type = src;
		}

		// Put explicitly provided properties onto the event object
		if ( props ) {
			jQuery.extend( this, props );
		}

		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || jQuery.now();

		// Mark it as fixed
		this[ jQuery.expando ] = true;
	};

	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		constructor: jQuery.Event,
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,
		isSimulated: false,

		preventDefault: function() {
			var e = this.originalEvent;

			this.isDefaultPrevented = returnTrue;

			if ( e && !this.isSimulated ) {
				e.preventDefault();
			}
		},
		stopPropagation: function() {
			var e = this.originalEvent;

			this.isPropagationStopped = returnTrue;

			if ( e && !this.isSimulated ) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function() {
			var e = this.originalEvent;

			this.isImmediatePropagationStopped = returnTrue;

			if ( e && !this.isSimulated ) {
				e.stopImmediatePropagation();
			}

			this.stopPropagation();
		}
	};

	// Includes all common event props including KeyEvent and MouseEvent specific props
	jQuery.each( {
		altKey: true,
		bubbles: true,
		cancelable: true,
		changedTouches: true,
		ctrlKey: true,
		detail: true,
		eventPhase: true,
		metaKey: true,
		pageX: true,
		pageY: true,
		shiftKey: true,
		view: true,
		"char": true,
		charCode: true,
		key: true,
		keyCode: true,
		button: true,
		buttons: true,
		clientX: true,
		clientY: true,
		offsetX: true,
		offsetY: true,
		pointerId: true,
		pointerType: true,
		screenX: true,
		screenY: true,
		targetTouches: true,
		toElement: true,
		touches: true,

		which: function( event ) {
			var button = event.button;

			// Add which for key events
			if ( event.which == null && rkeyEvent.test( event.type ) ) {
				return event.charCode != null ? event.charCode : event.keyCode;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
				if ( button & 1 ) {
					return 1;
				}

				if ( button & 2 ) {
					return 3;
				}

				if ( button & 4 ) {
					return 2;
				}

				return 0;
			}

			return event.which;
		}
	}, jQuery.event.addProp );

	// Create mouseenter/leave events using mouseover/out and event-time checks
	// so that event delegation works in jQuery.
	// Do the same for pointerenter/pointerleave and pointerover/pointerout
	//
	// Support: Safari 7 only
	// Safari sends mouseenter too often; see:
	// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
	// for the description of the bug (it existed in older Chrome versions as well).
	jQuery.each( {
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function( orig, fix ) {
		jQuery.event.special[ orig ] = {
			delegateType: fix,
			bindType: fix,

			handle: function( event ) {
				var ret,
					target = this,
					related = event.relatedTarget,
					handleObj = event.handleObj;

				// For mouseenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply( this, arguments );
					event.type = fix;
				}
				return ret;
			}
		};
	} );

	jQuery.fn.extend( {

		on: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn );
		},
		one: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn, 1 );
		},
		off: function( types, selector, fn ) {
			var handleObj, type;
			if ( types && types.preventDefault && types.handleObj ) {

				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery( types.delegateTarget ).off(
					handleObj.namespace ?
						handleObj.origType + "." + handleObj.namespace :
						handleObj.origType,
					handleObj.selector,
					handleObj.handler
				);
				return this;
			}
			if ( typeof types === "object" ) {

				// ( types-object [, selector] )
				for ( type in types ) {
					this.off( type, selector, types[ type ] );
				}
				return this;
			}
			if ( selector === false || typeof selector === "function" ) {

				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if ( fn === false ) {
				fn = returnFalse;
			}
			return this.each( function() {
				jQuery.event.remove( this, types, fn, selector );
			} );
		}
	} );


	var

		/* eslint-disable max-len */

		// See https://github.com/eslint/eslint/issues/3229
		rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

		/* eslint-enable */

		// Support: IE <=10 - 11, Edge 12 - 13
		// In IE/Edge using regex groups here causes severe slowdowns.
		// See https://connect.microsoft.com/IE/feedback/details/1736512/
		rnoInnerhtml = /<script|<style|<link/i,

		// checked="checked" or checked
		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
		rscriptTypeMasked = /^true\/(.*)/,
		rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

	// Prefer a tbody over its parent table for containing new rows
	function manipulationTarget( elem, content ) {
		if ( nodeName( elem, "table" ) &&
			nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

			return jQuery( ">tbody", elem )[ 0 ] || elem;
		}

		return elem;
	}

	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript( elem ) {
		elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
		return elem;
	}
	function restoreScript( elem ) {
		var match = rscriptTypeMasked.exec( elem.type );

		if ( match ) {
			elem.type = match[ 1 ];
		} else {
			elem.removeAttribute( "type" );
		}

		return elem;
	}

	function cloneCopyEvent( src, dest ) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

		if ( dest.nodeType !== 1 ) {
			return;
		}

		// 1. Copy private data: events, handlers, etc.
		if ( dataPriv.hasData( src ) ) {
			pdataOld = dataPriv.access( src );
			pdataCur = dataPriv.set( dest, pdataOld );
			events = pdataOld.events;

			if ( events ) {
				delete pdataCur.handle;
				pdataCur.events = {};

				for ( type in events ) {
					for ( i = 0, l = events[ type ].length; i < l; i++ ) {
						jQuery.event.add( dest, type, events[ type ][ i ] );
					}
				}
			}
		}

		// 2. Copy user data
		if ( dataUser.hasData( src ) ) {
			udataOld = dataUser.access( src );
			udataCur = jQuery.extend( {}, udataOld );

			dataUser.set( dest, udataCur );
		}
	}

	// Fix IE bugs, see support tests
	function fixInput( src, dest ) {
		var nodeName = dest.nodeName.toLowerCase();

		// Fails to persist the checked state of a cloned checkbox or radio button.
		if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
			dest.checked = src.checked;

		// Fails to return the selected option to the default selected state when cloning options
		} else if ( nodeName === "input" || nodeName === "textarea" ) {
			dest.defaultValue = src.defaultValue;
		}
	}

	function domManip( collection, args, callback, ignored ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = collection.length,
			iNoClone = l - 1,
			value = args[ 0 ],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return collection.each( function( index ) {
				var self = collection.eq( index );
				if ( isFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				domManip( self, args, callback, ignored );
			} );
		}

		if ( l ) {
			fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			// Require either new content or an interest in ignored elements to invoke the callback
			if ( first || ignored ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item
				// instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {

							// Support: Android <=4.0 only, PhantomJS 1 only
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( collection[ i ], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!dataPriv.access( node, "globalEval" ) &&
							jQuery.contains( doc, node ) ) {

							if ( node.src ) {

								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								DOMEval( node.textContent.replace( rcleanScript, "" ), doc );
							}
						}
					}
				}
			}
		}

		return collection;
	}

	function remove( elem, selector, keepData ) {
		var node,
			nodes = selector ? jQuery.filter( selector, elem ) : elem,
			i = 0;

		for ( ; ( node = nodes[ i ] ) != null; i++ ) {
			if ( !keepData && node.nodeType === 1 ) {
				jQuery.cleanData( getAll( node ) );
			}

			if ( node.parentNode ) {
				if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
					setGlobalEval( getAll( node, "script" ) );
				}
				node.parentNode.removeChild( node );
			}
		}

		return elem;
	}

	jQuery.extend( {
		htmlPrefilter: function( html ) {
			return html.replace( rxhtmlTag, "<$1></$2>" );
		},

		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
			var i, l, srcElements, destElements,
				clone = elem.cloneNode( true ),
				inPage = jQuery.contains( elem.ownerDocument, elem );

			// Fix IE cloning issues
			if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
					!jQuery.isXMLDoc( elem ) ) {

				// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
				destElements = getAll( clone );
				srcElements = getAll( elem );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					fixInput( srcElements[ i ], destElements[ i ] );
				}
			}

			// Copy the events from the original to the clone
			if ( dataAndEvents ) {
				if ( deepDataAndEvents ) {
					srcElements = srcElements || getAll( elem );
					destElements = destElements || getAll( clone );

					for ( i = 0, l = srcElements.length; i < l; i++ ) {
						cloneCopyEvent( srcElements[ i ], destElements[ i ] );
					}
				} else {
					cloneCopyEvent( elem, clone );
				}
			}

			// Preserve script evaluation history
			destElements = getAll( clone, "script" );
			if ( destElements.length > 0 ) {
				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
			}

			// Return the cloned set
			return clone;
		},

		cleanData: function( elems ) {
			var data, elem, type,
				special = jQuery.event.special,
				i = 0;

			for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
				if ( acceptData( elem ) ) {
					if ( ( data = elem[ dataPriv.expando ] ) ) {
						if ( data.events ) {
							for ( type in data.events ) {
								if ( special[ type ] ) {
									jQuery.event.remove( elem, type );

								// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent( elem, type, data.handle );
								}
							}
						}

						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataPriv.expando ] = undefined;
					}
					if ( elem[ dataUser.expando ] ) {

						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataUser.expando ] = undefined;
					}
				}
			}
		}
	} );

	jQuery.fn.extend( {
		detach: function( selector ) {
			return remove( this, selector, true );
		},

		remove: function( selector ) {
			return remove( this, selector );
		},

		text: function( value ) {
			return access( this, function( value ) {
				return value === undefined ?
					jQuery.text( this ) :
					this.empty().each( function() {
						if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
							this.textContent = value;
						}
					} );
			}, null, value, arguments.length );
		},

		append: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.appendChild( elem );
				}
			} );
		},

		prepend: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.insertBefore( elem, target.firstChild );
				}
			} );
		},

		before: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this );
				}
			} );
		},

		after: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this.nextSibling );
				}
			} );
		},

		empty: function() {
			var elem,
				i = 0;

			for ( ; ( elem = this[ i ] ) != null; i++ ) {
				if ( elem.nodeType === 1 ) {

					// Prevent memory leaks
					jQuery.cleanData( getAll( elem, false ) );

					// Remove any remaining nodes
					elem.textContent = "";
				}
			}

			return this;
		},

		clone: function( dataAndEvents, deepDataAndEvents ) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

			return this.map( function() {
				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
			} );
		},

		html: function( value ) {
			return access( this, function( value ) {
				var elem = this[ 0 ] || {},
					i = 0,
					l = this.length;

				if ( value === undefined && elem.nodeType === 1 ) {
					return elem.innerHTML;
				}

				// See if we can take a shortcut and just use innerHTML
				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
					!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

					value = jQuery.htmlPrefilter( value );

					try {
						for ( ; i < l; i++ ) {
							elem = this[ i ] || {};

							// Remove element nodes and prevent memory leaks
							if ( elem.nodeType === 1 ) {
								jQuery.cleanData( getAll( elem, false ) );
								elem.innerHTML = value;
							}
						}

						elem = 0;

					// If using innerHTML throws an exception, use the fallback method
					} catch ( e ) {}
				}

				if ( elem ) {
					this.empty().append( value );
				}
			}, null, value, arguments.length );
		},

		replaceWith: function() {
			var ignored = [];

			// Make the changes, replacing each non-ignored context element with the new content
			return domManip( this, arguments, function( elem ) {
				var parent = this.parentNode;

				if ( jQuery.inArray( this, ignored ) < 0 ) {
					jQuery.cleanData( getAll( this ) );
					if ( parent ) {
						parent.replaceChild( elem, this );
					}
				}

			// Force callback invocation
			}, ignored );
		}
	} );

	jQuery.each( {
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function( name, original ) {
		jQuery.fn[ name ] = function( selector ) {
			var elems,
				ret = [],
				insert = jQuery( selector ),
				last = insert.length - 1,
				i = 0;

			for ( ; i <= last; i++ ) {
				elems = i === last ? this : this.clone( true );
				jQuery( insert[ i ] )[ original ]( elems );

				// Support: Android <=4.0 only, PhantomJS 1 only
				// .get() because push.apply(_, arraylike) throws on ancient WebKit
				push.apply( ret, elems.get() );
			}

			return this.pushStack( ret );
		};
	} );
	var rmargin = ( /^margin/ );

	var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

	var getStyles = function( elem ) {

			// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
			// IE throws on elements created in popups
			// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
			var view = elem.ownerDocument.defaultView;

			if ( !view || !view.opener ) {
				view = window;
			}

			return view.getComputedStyle( elem );
		};



	( function() {

		// Executing both pixelPosition & boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computeStyleTests() {

			// This is a singleton, we need to execute it only once
			if ( !div ) {
				return;
			}

			div.style.cssText =
				"box-sizing:border-box;" +
				"position:relative;display:block;" +
				"margin:auto;border:1px;padding:1px;" +
				"top:1%;width:50%";
			div.innerHTML = "";
			documentElement.appendChild( container );

			var divStyle = window.getComputedStyle( div );
			pixelPositionVal = divStyle.top !== "1%";

			// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
			reliableMarginLeftVal = divStyle.marginLeft === "2px";
			boxSizingReliableVal = divStyle.width === "4px";

			// Support: Android 4.0 - 4.3 only
			// Some styles come back with percentage values, even though they shouldn't
			div.style.marginRight = "50%";
			pixelMarginRightVal = divStyle.marginRight === "4px";

			documentElement.removeChild( container );

			// Nullify the div so it wouldn't be stored in the memory and
			// it will also be a sign that checks already performed
			div = null;
		}

		var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
			container = document.createElement( "div" ),
			div = document.createElement( "div" );

		// Finish early in limited (non-browser) environments
		if ( !div.style ) {
			return;
		}

		// Support: IE <=9 - 11 only
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = "content-box";
		div.cloneNode( true ).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";

		container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
			"padding:0;margin-top:1px;position:absolute";
		container.appendChild( div );

		jQuery.extend( support, {
			pixelPosition: function() {
				computeStyleTests();
				return pixelPositionVal;
			},
			boxSizingReliable: function() {
				computeStyleTests();
				return boxSizingReliableVal;
			},
			pixelMarginRight: function() {
				computeStyleTests();
				return pixelMarginRightVal;
			},
			reliableMarginLeft: function() {
				computeStyleTests();
				return reliableMarginLeftVal;
			}
		} );
	} )();


	function curCSS( elem, name, computed ) {
		var width, minWidth, maxWidth, ret,

			// Support: Firefox 51+
			// Retrieving style before computed somehow
			// fixes an issue with getting wrong values
			// on detached elements
			style = elem.style;

		computed = computed || getStyles( elem );

		// getPropertyValue is needed for:
		//   .css('filter') (IE 9 only, #12537)
		//   .css('--customProperty) (#3144)
		if ( computed ) {
			ret = computed.getPropertyValue( name ) || computed[ name ];

			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}

			// A tribute to the "awesome hack by Dean Edwards"
			// Android Browser returns percentage for some values,
			// but width seems to be reliably pixels.
			// This is against the CSSOM draft spec:
			// https://drafts.csswg.org/cssom/#resolved-values
			if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret !== undefined ?

			// Support: IE <=9 - 11 only
			// IE returns zIndex value as an integer.
			ret + "" :
			ret;
	}


	function addGetHookIf( conditionFn, hookFn ) {

		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function() {
				if ( conditionFn() ) {

					// Hook not needed (or it's not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}

				// Hook needed; redefine it so that the support test is not executed again.
				return ( this.get = hookFn ).apply( this, arguments );
			}
		};
	}


	var

		// Swappable if display is none or starts with table
		// except "table", "table-cell", or "table-caption"
		// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
		rdisplayswap = /^(none|table(?!-c[ea]).+)/,
		rcustomProp = /^--/,
		cssShow = { position: "absolute", visibility: "hidden", display: "block" },
		cssNormalTransform = {
			letterSpacing: "0",
			fontWeight: "400"
		},

		cssPrefixes = [ "Webkit", "Moz", "ms" ],
		emptyStyle = document.createElement( "div" ).style;

	// Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName( name ) {

		// Shortcut for names that are not vendor prefixed
		if ( name in emptyStyle ) {
			return name;
		}

		// Check for vendor prefixed names
		var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
			i = cssPrefixes.length;

		while ( i-- ) {
			name = cssPrefixes[ i ] + capName;
			if ( name in emptyStyle ) {
				return name;
			}
		}
	}

	// Return a property mapped along what jQuery.cssProps suggests or to
	// a vendor prefixed property.
	function finalPropName( name ) {
		var ret = jQuery.cssProps[ name ];
		if ( !ret ) {
			ret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;
		}
		return ret;
	}

	function setPositiveNumber( elem, value, subtract ) {

		// Any relative (+/-) values have already been
		// normalized at this point
		var matches = rcssNum.exec( value );
		return matches ?

			// Guard against undefined "subtract", e.g., when used as in cssHooks
			Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
			value;
	}

	function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
		var i,
			val = 0;

		// If we already have the right measurement, avoid augmentation
		if ( extra === ( isBorderBox ? "border" : "content" ) ) {
			i = 4;

		// Otherwise initialize for horizontal or vertical properties
		} else {
			i = name === "width" ? 1 : 0;
		}

		for ( ; i < 4; i += 2 ) {

			// Both box models exclude margin, so add it if we want it
			if ( extra === "margin" ) {
				val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
			}

			if ( isBorderBox ) {

				// border-box includes padding, so remove it if we want content
				if ( extra === "content" ) {
					val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
				}

				// At this point, extra isn't border nor margin, so remove border
				if ( extra !== "margin" ) {
					val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			} else {

				// At this point, extra isn't content, so add padding
				val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

				// At this point, extra isn't content nor padding, so add border
				if ( extra !== "padding" ) {
					val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			}
		}

		return val;
	}

	function getWidthOrHeight( elem, name, extra ) {

		// Start with computed style
		var valueIsBorderBox,
			styles = getStyles( elem ),
			val = curCSS( elem, name, styles ),
			isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test( val ) ) {
			return val;
		}

		// Check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ name ] );

		// Fall back to offsetWidth/Height when value is "auto"
		// This happens for inline elements with no explicit setting (gh-3571)
		if ( val === "auto" ) {
			val = elem[ "offset" + name[ 0 ].toUpperCase() + name.slice( 1 ) ];
		}

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;

		// Use the active box-sizing model to add/subtract irrelevant styles
		return ( val +
			augmentWidthOrHeight(
				elem,
				name,
				extra || ( isBorderBox ? "border" : "content" ),
				valueIsBorderBox,
				styles
			)
		) + "px";
	}

	jQuery.extend( {

		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function( elem, computed ) {
					if ( computed ) {

						// We should always get a number back from opacity
						var ret = curCSS( elem, "opacity" );
						return ret === "" ? "1" : ret;
					}
				}
			}
		},

		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"animationIterationCount": true,
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},

		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {
			"float": "cssFloat"
		},

		// Get and set the style property on a DOM Node
		style: function( elem, name, value, extra ) {

			// Don't set styles on text and comment nodes
			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
				return;
			}

			// Make sure that we're working with the right name
			var ret, type, hooks,
				origName = jQuery.camelCase( name ),
				isCustomProp = rcustomProp.test( name ),
				style = elem.style;

			// Make sure that we're working with the right name. We don't
			// want to query the value if it is a CSS custom property
			// since they are user-defined.
			if ( !isCustomProp ) {
				name = finalPropName( origName );
			}

			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// Check if we're setting a value
			if ( value !== undefined ) {
				type = typeof value;

				// Convert "+=" or "-=" to relative numbers (#7345)
				if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
					value = adjustCSS( elem, name, ret );

					// Fixes bug #9237
					type = "number";
				}

				// Make sure that null and NaN values aren't set (#7116)
				if ( value == null || value !== value ) {
					return;
				}

				// If a number was passed in, add the unit (except for certain CSS properties)
				if ( type === "number" ) {
					value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
				}

				// background-* props affect original clone's values
				if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
					style[ name ] = "inherit";
				}

				// If a hook was provided, use that value, otherwise just set the specified value
				if ( !hooks || !( "set" in hooks ) ||
					( value = hooks.set( elem, value, extra ) ) !== undefined ) {

					if ( isCustomProp ) {
						style.setProperty( name, value );
					} else {
						style[ name ] = value;
					}
				}

			} else {

				// If a hook was provided get the non-computed value from there
				if ( hooks && "get" in hooks &&
					( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

					return ret;
				}

				// Otherwise just get the value from the style object
				return style[ name ];
			}
		},

		css: function( elem, name, extra, styles ) {
			var val, num, hooks,
				origName = jQuery.camelCase( name ),
				isCustomProp = rcustomProp.test( name );

			// Make sure that we're working with the right name. We don't
			// want to modify the value if it is a CSS custom property
			// since they are user-defined.
			if ( !isCustomProp ) {
				name = finalPropName( origName );
			}

			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// If a hook was provided get the computed value from there
			if ( hooks && "get" in hooks ) {
				val = hooks.get( elem, true, extra );
			}

			// Otherwise, if a way to get the computed value exists, use that
			if ( val === undefined ) {
				val = curCSS( elem, name, styles );
			}

			// Convert "normal" to computed value
			if ( val === "normal" && name in cssNormalTransform ) {
				val = cssNormalTransform[ name ];
			}

			// Make numeric if forced or a qualifier was provided and val looks numeric
			if ( extra === "" || extra ) {
				num = parseFloat( val );
				return extra === true || isFinite( num ) ? num || 0 : val;
			}

			return val;
		}
	} );

	jQuery.each( [ "height", "width" ], function( i, name ) {
		jQuery.cssHooks[ name ] = {
			get: function( elem, computed, extra ) {
				if ( computed ) {

					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

						// Support: Safari 8+
						// Table columns in Safari have non-zero offsetWidth & zero
						// getBoundingClientRect().width unless display is changed.
						// Support: IE <=11 only
						// Running getBoundingClientRect on a disconnected node
						// in IE throws an error.
						( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
							swap( elem, cssShow, function() {
								return getWidthOrHeight( elem, name, extra );
							} ) :
							getWidthOrHeight( elem, name, extra );
				}
			},

			set: function( elem, value, extra ) {
				var matches,
					styles = extra && getStyles( elem ),
					subtract = extra && augmentWidthOrHeight(
						elem,
						name,
						extra,
						jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
						styles
					);

				// Convert to pixels if value adjustment is needed
				if ( subtract && ( matches = rcssNum.exec( value ) ) &&
					( matches[ 3 ] || "px" ) !== "px" ) {

					elem.style[ name ] = value;
					value = jQuery.css( elem, name );
				}

				return setPositiveNumber( elem, value, subtract );
			}
		};
	} );

	jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
		function( elem, computed ) {
			if ( computed ) {
				return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
					elem.getBoundingClientRect().left -
						swap( elem, { marginLeft: 0 }, function() {
							return elem.getBoundingClientRect().left;
						} )
					) + "px";
			}
		}
	);

	// These hooks are used by animate to expand properties
	jQuery.each( {
		margin: "",
		padding: "",
		border: "Width"
	}, function( prefix, suffix ) {
		jQuery.cssHooks[ prefix + suffix ] = {
			expand: function( value ) {
				var i = 0,
					expanded = {},

					// Assumes a single number if not a string
					parts = typeof value === "string" ? value.split( " " ) : [ value ];

				for ( ; i < 4; i++ ) {
					expanded[ prefix + cssExpand[ i ] + suffix ] =
						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
				}

				return expanded;
			}
		};

		if ( !rmargin.test( prefix ) ) {
			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
		}
	} );

	jQuery.fn.extend( {
		css: function( name, value ) {
			return access( this, function( elem, name, value ) {
				var styles, len,
					map = {},
					i = 0;

				if ( Array.isArray( name ) ) {
					styles = getStyles( elem );
					len = name.length;

					for ( ; i < len; i++ ) {
						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
					}

					return map;
				}

				return value !== undefined ?
					jQuery.style( elem, name, value ) :
					jQuery.css( elem, name );
			}, name, value, arguments.length > 1 );
		}
	} );


	function Tween( elem, options, prop, end, easing ) {
		return new Tween.prototype.init( elem, options, prop, end, easing );
	}
	jQuery.Tween = Tween;

	Tween.prototype = {
		constructor: Tween,
		init: function( elem, options, prop, end, easing, unit ) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || jQuery.easing._default;
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
		},
		cur: function() {
			var hooks = Tween.propHooks[ this.prop ];

			return hooks && hooks.get ?
				hooks.get( this ) :
				Tween.propHooks._default.get( this );
		},
		run: function( percent ) {
			var eased,
				hooks = Tween.propHooks[ this.prop ];

			if ( this.options.duration ) {
				this.pos = eased = jQuery.easing[ this.easing ](
					percent, this.options.duration * percent, 0, 1, this.options.duration
				);
			} else {
				this.pos = eased = percent;
			}
			this.now = ( this.end - this.start ) * eased + this.start;

			if ( this.options.step ) {
				this.options.step.call( this.elem, this.now, this );
			}

			if ( hooks && hooks.set ) {
				hooks.set( this );
			} else {
				Tween.propHooks._default.set( this );
			}
			return this;
		}
	};

	Tween.prototype.init.prototype = Tween.prototype;

	Tween.propHooks = {
		_default: {
			get: function( tween ) {
				var result;

				// Use a property on the element directly when it is not a DOM element,
				// or when there is no matching style property that exists.
				if ( tween.elem.nodeType !== 1 ||
					tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
					return tween.elem[ tween.prop ];
				}

				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery.css( tween.elem, tween.prop, "" );

				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function( tween ) {

				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if ( jQuery.fx.step[ tween.prop ] ) {
					jQuery.fx.step[ tween.prop ]( tween );
				} else if ( tween.elem.nodeType === 1 &&
					( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
						jQuery.cssHooks[ tween.prop ] ) ) {
					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
				} else {
					tween.elem[ tween.prop ] = tween.now;
				}
			}
		}
	};

	// Support: IE <=9 only
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function( tween ) {
			if ( tween.elem.nodeType && tween.elem.parentNode ) {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	};

	jQuery.easing = {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return 0.5 - Math.cos( p * Math.PI ) / 2;
		},
		_default: "swing"
	};

	jQuery.fx = Tween.prototype.init;

	// Back compat <1.8 extension point
	jQuery.fx.step = {};




	var
		fxNow, inProgress,
		rfxtypes = /^(?:toggle|show|hide)$/,
		rrun = /queueHooks$/;

	function schedule() {
		if ( inProgress ) {
			if ( document.hidden === false && window.requestAnimationFrame ) {
				window.requestAnimationFrame( schedule );
			} else {
				window.setTimeout( schedule, jQuery.fx.interval );
			}

			jQuery.fx.tick();
		}
	}

	// Animations created synchronously will run synchronously
	function createFxNow() {
		window.setTimeout( function() {
			fxNow = undefined;
		} );
		return ( fxNow = jQuery.now() );
	}

	// Generate parameters to create a standard animation
	function genFx( type, includeWidth ) {
		var which,
			i = 0,
			attrs = { height: type };

		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for ( ; i < 4; i += 2 - includeWidth ) {
			which = cssExpand[ i ];
			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
		}

		if ( includeWidth ) {
			attrs.opacity = attrs.width = type;
		}

		return attrs;
	}

	function createTween( value, prop, animation ) {
		var tween,
			collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
			index = 0,
			length = collection.length;
		for ( ; index < length; index++ ) {
			if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

				// We're done with this property
				return tween;
			}
		}
	}

	function defaultPrefilter( elem, props, opts ) {
		var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
			isBox = "width" in props || "height" in props,
			anim = this,
			orig = {},
			style = elem.style,
			hidden = elem.nodeType && isHiddenWithinTree( elem ),
			dataShow = dataPriv.get( elem, "fxshow" );

		// Queue-skipping animations hijack the fx hooks
		if ( !opts.queue ) {
			hooks = jQuery._queueHooks( elem, "fx" );
			if ( hooks.unqueued == null ) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function() {
					if ( !hooks.unqueued ) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;

			anim.always( function() {

				// Ensure the complete handler is called before this completes
				anim.always( function() {
					hooks.unqueued--;
					if ( !jQuery.queue( elem, "fx" ).length ) {
						hooks.empty.fire();
					}
				} );
			} );
		}

		// Detect show/hide animations
		for ( prop in props ) {
			value = props[ prop ];
			if ( rfxtypes.test( value ) ) {
				delete props[ prop ];
				toggle = toggle || value === "toggle";
				if ( value === ( hidden ? "hide" : "show" ) ) {

					// Pretend to be hidden if this is a "show" and
					// there is still data from a stopped show/hide
					if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
						hidden = true;

					// Ignore all other no-op show/hide data
					} else {
						continue;
					}
				}
				orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
			}
		}

		// Bail out if this is a no-op like .hide().hide()
		propTween = !jQuery.isEmptyObject( props );
		if ( !propTween && jQuery.isEmptyObject( orig ) ) {
			return;
		}

		// Restrict "overflow" and "display" styles during box animations
		if ( isBox && elem.nodeType === 1 ) {

			// Support: IE <=9 - 11, Edge 12 - 13
			// Record all 3 overflow attributes because IE does not infer the shorthand
			// from identically-valued overflowX and overflowY
			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

			// Identify a display type, preferring old show/hide data over the CSS cascade
			restoreDisplay = dataShow && dataShow.display;
			if ( restoreDisplay == null ) {
				restoreDisplay = dataPriv.get( elem, "display" );
			}
			display = jQuery.css( elem, "display" );
			if ( display === "none" ) {
				if ( restoreDisplay ) {
					display = restoreDisplay;
				} else {

					// Get nonempty value(s) by temporarily forcing visibility
					showHide( [ elem ], true );
					restoreDisplay = elem.style.display || restoreDisplay;
					display = jQuery.css( elem, "display" );
					showHide( [ elem ] );
				}
			}

			// Animate inline elements as inline-block
			if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
				if ( jQuery.css( elem, "float" ) === "none" ) {

					// Restore the original display value at the end of pure show/hide animations
					if ( !propTween ) {
						anim.done( function() {
							style.display = restoreDisplay;
						} );
						if ( restoreDisplay == null ) {
							display = style.display;
							restoreDisplay = display === "none" ? "" : display;
						}
					}
					style.display = "inline-block";
				}
			}
		}

		if ( opts.overflow ) {
			style.overflow = "hidden";
			anim.always( function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			} );
		}

		// Implement show/hide animations
		propTween = false;
		for ( prop in orig ) {

			// General show/hide setup for this element animation
			if ( !propTween ) {
				if ( dataShow ) {
					if ( "hidden" in dataShow ) {
						hidden = dataShow.hidden;
					}
				} else {
					dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
				}

				// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
				if ( toggle ) {
					dataShow.hidden = !hidden;
				}

				// Show elements before animating them
				if ( hidden ) {
					showHide( [ elem ], true );
				}

				/* eslint-disable no-loop-func */

				anim.done( function() {

				/* eslint-enable no-loop-func */

					// The final step of a "hide" animation is actually hiding the element
					if ( !hidden ) {
						showHide( [ elem ] );
					}
					dataPriv.remove( elem, "fxshow" );
					for ( prop in orig ) {
						jQuery.style( elem, prop, orig[ prop ] );
					}
				} );
			}

			// Per-property setup
			propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = propTween.start;
				if ( hidden ) {
					propTween.end = propTween.start;
					propTween.start = 0;
				}
			}
		}
	}

	function propFilter( props, specialEasing ) {
		var index, name, easing, value, hooks;

		// camelCase, specialEasing and expand cssHook pass
		for ( index in props ) {
			name = jQuery.camelCase( index );
			easing = specialEasing[ name ];
			value = props[ index ];
			if ( Array.isArray( value ) ) {
				easing = value[ 1 ];
				value = props[ index ] = value[ 0 ];
			}

			if ( index !== name ) {
				props[ name ] = value;
				delete props[ index ];
			}

			hooks = jQuery.cssHooks[ name ];
			if ( hooks && "expand" in hooks ) {
				value = hooks.expand( value );
				delete props[ name ];

				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for ( index in value ) {
					if ( !( index in props ) ) {
						props[ index ] = value[ index ];
						specialEasing[ index ] = easing;
					}
				}
			} else {
				specialEasing[ name ] = easing;
			}
		}
	}

	function Animation( elem, properties, options ) {
		var result,
			stopped,
			index = 0,
			length = Animation.prefilters.length,
			deferred = jQuery.Deferred().always( function() {

				// Don't match elem in the :animated selector
				delete tick.elem;
			} ),
			tick = function() {
				if ( stopped ) {
					return false;
				}
				var currentTime = fxNow || createFxNow(),
					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

					// Support: Android 2.3 only
					// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
					temp = remaining / animation.duration || 0,
					percent = 1 - temp,
					index = 0,
					length = animation.tweens.length;

				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( percent );
				}

				deferred.notifyWith( elem, [ animation, percent, remaining ] );

				// If there's more to do, yield
				if ( percent < 1 && length ) {
					return remaining;
				}

				// If this was an empty animation, synthesize a final progress notification
				if ( !length ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
				}

				// Resolve the animation and report its conclusion
				deferred.resolveWith( elem, [ animation ] );
				return false;
			},
			animation = deferred.promise( {
				elem: elem,
				props: jQuery.extend( {}, properties ),
				opts: jQuery.extend( true, {
					specialEasing: {},
					easing: jQuery.easing._default
				}, options ),
				originalProperties: properties,
				originalOptions: options,
				startTime: fxNow || createFxNow(),
				duration: options.duration,
				tweens: [],
				createTween: function( prop, end ) {
					var tween = jQuery.Tween( elem, animation.opts, prop, end,
							animation.opts.specialEasing[ prop ] || animation.opts.easing );
					animation.tweens.push( tween );
					return tween;
				},
				stop: function( gotoEnd ) {
					var index = 0,

						// If we are going to the end, we want to run all the tweens
						// otherwise we skip this part
						length = gotoEnd ? animation.tweens.length : 0;
					if ( stopped ) {
						return this;
					}
					stopped = true;
					for ( ; index < length; index++ ) {
						animation.tweens[ index ].run( 1 );
					}

					// Resolve when we played the last frame; otherwise, reject
					if ( gotoEnd ) {
						deferred.notifyWith( elem, [ animation, 1, 0 ] );
						deferred.resolveWith( elem, [ animation, gotoEnd ] );
					} else {
						deferred.rejectWith( elem, [ animation, gotoEnd ] );
					}
					return this;
				}
			} ),
			props = animation.props;

		propFilter( props, animation.opts.specialEasing );

		for ( ; index < length; index++ ) {
			result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
			if ( result ) {
				if ( jQuery.isFunction( result.stop ) ) {
					jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
						jQuery.proxy( result.stop, result );
				}
				return result;
			}
		}

		jQuery.map( props, createTween, animation );

		if ( jQuery.isFunction( animation.opts.start ) ) {
			animation.opts.start.call( elem, animation );
		}

		// Attach callbacks from options
		animation
			.progress( animation.opts.progress )
			.done( animation.opts.done, animation.opts.complete )
			.fail( animation.opts.fail )
			.always( animation.opts.always );

		jQuery.fx.timer(
			jQuery.extend( tick, {
				elem: elem,
				anim: animation,
				queue: animation.opts.queue
			} )
		);

		return animation;
	}

	jQuery.Animation = jQuery.extend( Animation, {

		tweeners: {
			"*": [ function( prop, value ) {
				var tween = this.createTween( prop, value );
				adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
				return tween;
			} ]
		},

		tweener: function( props, callback ) {
			if ( jQuery.isFunction( props ) ) {
				callback = props;
				props = [ "*" ];
			} else {
				props = props.match( rnothtmlwhite );
			}

			var prop,
				index = 0,
				length = props.length;

			for ( ; index < length; index++ ) {
				prop = props[ index ];
				Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
				Animation.tweeners[ prop ].unshift( callback );
			}
		},

		prefilters: [ defaultPrefilter ],

		prefilter: function( callback, prepend ) {
			if ( prepend ) {
				Animation.prefilters.unshift( callback );
			} else {
				Animation.prefilters.push( callback );
			}
		}
	} );

	jQuery.speed = function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
		};

		// Go to the end state if fx are off
		if ( jQuery.fx.off ) {
			opt.duration = 0;

		} else {
			if ( typeof opt.duration !== "number" ) {
				if ( opt.duration in jQuery.fx.speeds ) {
					opt.duration = jQuery.fx.speeds[ opt.duration ];

				} else {
					opt.duration = jQuery.fx.speeds._default;
				}
			}
		}

		// Normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function() {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}

			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			}
		};

		return opt;
	};

	jQuery.fn.extend( {
		fadeTo: function( speed, to, easing, callback ) {

			// Show any hidden elements after setting opacity to 0
			return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

				// Animate to the value specified
				.end().animate( { opacity: to }, speed, easing, callback );
		},
		animate: function( prop, speed, easing, callback ) {
			var empty = jQuery.isEmptyObject( prop ),
				optall = jQuery.speed( speed, easing, callback ),
				doAnimation = function() {

					// Operate on a copy of prop so per-property easing won't be lost
					var anim = Animation( this, jQuery.extend( {}, prop ), optall );

					// Empty animations, or finishing resolves immediately
					if ( empty || dataPriv.get( this, "finish" ) ) {
						anim.stop( true );
					}
				};
				doAnimation.finish = doAnimation;

			return empty || optall.queue === false ?
				this.each( doAnimation ) :
				this.queue( optall.queue, doAnimation );
		},
		stop: function( type, clearQueue, gotoEnd ) {
			var stopQueue = function( hooks ) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop( gotoEnd );
			};

			if ( typeof type !== "string" ) {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if ( clearQueue && type !== false ) {
				this.queue( type || "fx", [] );
			}

			return this.each( function() {
				var dequeue = true,
					index = type != null && type + "queueHooks",
					timers = jQuery.timers,
					data = dataPriv.get( this );

				if ( index ) {
					if ( data[ index ] && data[ index ].stop ) {
						stopQueue( data[ index ] );
					}
				} else {
					for ( index in data ) {
						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
							stopQueue( data[ index ] );
						}
					}
				}

				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this &&
						( type == null || timers[ index ].queue === type ) ) {

						timers[ index ].anim.stop( gotoEnd );
						dequeue = false;
						timers.splice( index, 1 );
					}
				}

				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if ( dequeue || !gotoEnd ) {
					jQuery.dequeue( this, type );
				}
			} );
		},
		finish: function( type ) {
			if ( type !== false ) {
				type = type || "fx";
			}
			return this.each( function() {
				var index,
					data = dataPriv.get( this ),
					queue = data[ type + "queue" ],
					hooks = data[ type + "queueHooks" ],
					timers = jQuery.timers,
					length = queue ? queue.length : 0;

				// Enable finishing flag on private data
				data.finish = true;

				// Empty the queue first
				jQuery.queue( this, type, [] );

				if ( hooks && hooks.stop ) {
					hooks.stop.call( this, true );
				}

				// Look for any active animations, and finish them
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
						timers[ index ].anim.stop( true );
						timers.splice( index, 1 );
					}
				}

				// Look for any animations in the old queue and finish them
				for ( index = 0; index < length; index++ ) {
					if ( queue[ index ] && queue[ index ].finish ) {
						queue[ index ].finish.call( this );
					}
				}

				// Turn off finishing flag
				delete data.finish;
			} );
		}
	} );

	jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
		var cssFn = jQuery.fn[ name ];
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return speed == null || typeof speed === "boolean" ?
				cssFn.apply( this, arguments ) :
				this.animate( genFx( name, true ), speed, easing, callback );
		};
	} );

	// Generate shortcuts for custom animations
	jQuery.each( {
		slideDown: genFx( "show" ),
		slideUp: genFx( "hide" ),
		slideToggle: genFx( "toggle" ),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function( name, props ) {
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return this.animate( props, speed, easing, callback );
		};
	} );

	jQuery.timers = [];
	jQuery.fx.tick = function() {
		var timer,
			i = 0,
			timers = jQuery.timers;

		fxNow = jQuery.now();

		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];

			// Run the timer and safely remove it when done (allowing for external removal)
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}

		if ( !timers.length ) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};

	jQuery.fx.timer = function( timer ) {
		jQuery.timers.push( timer );
		jQuery.fx.start();
	};

	jQuery.fx.interval = 13;
	jQuery.fx.start = function() {
		if ( inProgress ) {
			return;
		}

		inProgress = true;
		schedule();
	};

	jQuery.fx.stop = function() {
		inProgress = null;
	};

	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,

		// Default speed
		_default: 400
	};


	// Based off of the plugin by Clint Helfers, with permission.
	// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = window.setTimeout( next, time );
			hooks.stop = function() {
				window.clearTimeout( timeout );
			};
		} );
	};


	( function() {
		var input = document.createElement( "input" ),
			select = document.createElement( "select" ),
			opt = select.appendChild( document.createElement( "option" ) );

		input.type = "checkbox";

		// Support: Android <=4.3 only
		// Default value for a checkbox should be "on"
		support.checkOn = input.value !== "";

		// Support: IE <=11 only
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;

		// Support: IE <=11 only
		// An input loses its value after becoming a radio
		input = document.createElement( "input" );
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	} )();


	var boolHook,
		attrHandle = jQuery.expr.attrHandle;

	jQuery.fn.extend( {
		attr: function( name, value ) {
			return access( this, jQuery.attr, name, value, arguments.length > 1 );
		},

		removeAttr: function( name ) {
			return this.each( function() {
				jQuery.removeAttr( this, name );
			} );
		}
	} );

	jQuery.extend( {
		attr: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;

			// Don't get/set attributes on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			// Fallback to prop when attributes are not supported
			if ( typeof elem.getAttribute === "undefined" ) {
				return jQuery.prop( elem, name, value );
			}

			// Attribute hooks are determined by the lowercase version
			// Grab necessary hook if one is defined
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
				hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
					( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
			}

			if ( value !== undefined ) {
				if ( value === null ) {
					jQuery.removeAttr( elem, name );
					return;
				}

				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}

				elem.setAttribute( name, value + "" );
				return value;
			}

			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}

			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ? undefined : ret;
		},

		attrHooks: {
			type: {
				set: function( elem, value ) {
					if ( !support.radioValue && value === "radio" &&
						nodeName( elem, "input" ) ) {
						var val = elem.value;
						elem.setAttribute( "type", value );
						if ( val ) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		},

		removeAttr: function( elem, value ) {
			var name,
				i = 0,

				// Attribute names can contain non-HTML whitespace characters
				// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
				attrNames = value && value.match( rnothtmlwhite );

			if ( attrNames && elem.nodeType === 1 ) {
				while ( ( name = attrNames[ i++ ] ) ) {
					elem.removeAttribute( name );
				}
			}
		}
	} );

	// Hooks for boolean attributes
	boolHook = {
		set: function( elem, value, name ) {
			if ( value === false ) {

				// Remove boolean attributes when set to false
				jQuery.removeAttr( elem, name );
			} else {
				elem.setAttribute( name, name );
			}
			return name;
		}
	};

	jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
		var getter = attrHandle[ name ] || jQuery.find.attr;

		attrHandle[ name ] = function( elem, name, isXML ) {
			var ret, handle,
				lowercaseName = name.toLowerCase();

			if ( !isXML ) {

				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[ lowercaseName ];
				attrHandle[ lowercaseName ] = ret;
				ret = getter( elem, name, isXML ) != null ?
					lowercaseName :
					null;
				attrHandle[ lowercaseName ] = handle;
			}
			return ret;
		};
	} );




	var rfocusable = /^(?:input|select|textarea|button)$/i,
		rclickable = /^(?:a|area)$/i;

	jQuery.fn.extend( {
		prop: function( name, value ) {
			return access( this, jQuery.prop, name, value, arguments.length > 1 );
		},

		removeProp: function( name ) {
			return this.each( function() {
				delete this[ jQuery.propFix[ name ] || name ];
			} );
		}
	} );

	jQuery.extend( {
		prop: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;

			// Don't get/set properties on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

				// Fix name and attach hooks
				name = jQuery.propFix[ name ] || name;
				hooks = jQuery.propHooks[ name ];
			}

			if ( value !== undefined ) {
				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}

				return ( elem[ name ] = value );
			}

			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}

			return elem[ name ];
		},

		propHooks: {
			tabIndex: {
				get: function( elem ) {

					// Support: IE <=9 - 11 only
					// elem.tabIndex doesn't always return the
					// correct value when it hasn't been explicitly set
					// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
					// Use proper attribute retrieval(#12072)
					var tabindex = jQuery.find.attr( elem, "tabindex" );

					if ( tabindex ) {
						return parseInt( tabindex, 10 );
					}

					if (
						rfocusable.test( elem.nodeName ) ||
						rclickable.test( elem.nodeName ) &&
						elem.href
					) {
						return 0;
					}

					return -1;
				}
			}
		},

		propFix: {
			"for": "htmlFor",
			"class": "className"
		}
	} );

	// Support: IE <=11 only
	// Accessing the selectedIndex property
	// forces the browser to respect setting selected
	// on the option
	// The getter ensures a default option is selected
	// when in an optgroup
	// eslint rule "no-unused-expressions" is disabled for this code
	// since it considers such accessions noop
	if ( !support.optSelected ) {
		jQuery.propHooks.selected = {
			get: function( elem ) {

				/* eslint no-unused-expressions: "off" */

				var parent = elem.parentNode;
				if ( parent && parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
				return null;
			},
			set: function( elem ) {

				/* eslint no-unused-expressions: "off" */

				var parent = elem.parentNode;
				if ( parent ) {
					parent.selectedIndex;

					if ( parent.parentNode ) {
						parent.parentNode.selectedIndex;
					}
				}
			}
		};
	}

	jQuery.each( [
		"tabIndex",
		"readOnly",
		"maxLength",
		"cellSpacing",
		"cellPadding",
		"rowSpan",
		"colSpan",
		"useMap",
		"frameBorder",
		"contentEditable"
	], function() {
		jQuery.propFix[ this.toLowerCase() ] = this;
	} );




		// Strip and collapse whitespace according to HTML spec
		// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace
		function stripAndCollapse( value ) {
			var tokens = value.match( rnothtmlwhite ) || [];
			return tokens.join( " " );
		}


	function getClass( elem ) {
		return elem.getAttribute && elem.getAttribute( "class" ) || "";
	}

	jQuery.fn.extend( {
		addClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;

			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
				} );
			}

			if ( typeof value === "string" && value ) {
				classes = value.match( rnothtmlwhite ) || [];

				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );
					cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {
							if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
								cur += clazz + " ";
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = stripAndCollapse( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}

			return this;
		},

		removeClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;

			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
				} );
			}

			if ( !arguments.length ) {
				return this.attr( "class", "" );
			}

			if ( typeof value === "string" && value ) {
				classes = value.match( rnothtmlwhite ) || [];

				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );

					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {

							// Remove *all* instances
							while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
								cur = cur.replace( " " + clazz + " ", " " );
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = stripAndCollapse( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}

			return this;
		},

		toggleClass: function( value, stateVal ) {
			var type = typeof value;

			if ( typeof stateVal === "boolean" && type === "string" ) {
				return stateVal ? this.addClass( value ) : this.removeClass( value );
			}

			if ( jQuery.isFunction( value ) ) {
				return this.each( function( i ) {
					jQuery( this ).toggleClass(
						value.call( this, i, getClass( this ), stateVal ),
						stateVal
					);
				} );
			}

			return this.each( function() {
				var className, i, self, classNames;

				if ( type === "string" ) {

					// Toggle individual class names
					i = 0;
					self = jQuery( this );
					classNames = value.match( rnothtmlwhite ) || [];

					while ( ( className = classNames[ i++ ] ) ) {

						// Check each className given, space separated list
						if ( self.hasClass( className ) ) {
							self.removeClass( className );
						} else {
							self.addClass( className );
						}
					}

				// Toggle whole class name
				} else if ( value === undefined || type === "boolean" ) {
					className = getClass( this );
					if ( className ) {

						// Store className if set
						dataPriv.set( this, "__className__", className );
					}

					// If the element has a class name or if we're passed `false`,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					if ( this.setAttribute ) {
						this.setAttribute( "class",
							className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
						);
					}
				}
			} );
		},

		hasClass: function( selector ) {
			var className, elem,
				i = 0;

			className = " " + selector + " ";
			while ( ( elem = this[ i++ ] ) ) {
				if ( elem.nodeType === 1 &&
					( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
						return true;
				}
			}

			return false;
		}
	} );




	var rreturn = /\r/g;

	jQuery.fn.extend( {
		val: function( value ) {
			var hooks, ret, isFunction,
				elem = this[ 0 ];

			if ( !arguments.length ) {
				if ( elem ) {
					hooks = jQuery.valHooks[ elem.type ] ||
						jQuery.valHooks[ elem.nodeName.toLowerCase() ];

					if ( hooks &&
						"get" in hooks &&
						( ret = hooks.get( elem, "value" ) ) !== undefined
					) {
						return ret;
					}

					ret = elem.value;

					// Handle most common string cases
					if ( typeof ret === "string" ) {
						return ret.replace( rreturn, "" );
					}

					// Handle cases where value is null/undef or number
					return ret == null ? "" : ret;
				}

				return;
			}

			isFunction = jQuery.isFunction( value );

			return this.each( function( i ) {
				var val;

				if ( this.nodeType !== 1 ) {
					return;
				}

				if ( isFunction ) {
					val = value.call( this, i, jQuery( this ).val() );
				} else {
					val = value;
				}

				// Treat null/undefined as ""; convert numbers to string
				if ( val == null ) {
					val = "";

				} else if ( typeof val === "number" ) {
					val += "";

				} else if ( Array.isArray( val ) ) {
					val = jQuery.map( val, function( value ) {
						return value == null ? "" : value + "";
					} );
				}

				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

				// If set returns undefined, fall back to normal setting
				if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
					this.value = val;
				}
			} );
		}
	} );

	jQuery.extend( {
		valHooks: {
			option: {
				get: function( elem ) {

					var val = jQuery.find.attr( elem, "value" );
					return val != null ?
						val :

						// Support: IE <=10 - 11 only
						// option.text throws exceptions (#14686, #14858)
						// Strip and collapse whitespace
						// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
						stripAndCollapse( jQuery.text( elem ) );
				}
			},
			select: {
				get: function( elem ) {
					var value, option, i,
						options = elem.options,
						index = elem.selectedIndex,
						one = elem.type === "select-one",
						values = one ? null : [],
						max = one ? index + 1 : options.length;

					if ( index < 0 ) {
						i = max;

					} else {
						i = one ? index : 0;
					}

					// Loop through all the selected options
					for ( ; i < max; i++ ) {
						option = options[ i ];

						// Support: IE <=9 only
						// IE8-9 doesn't update selected after form reset (#2551)
						if ( ( option.selected || i === index ) &&

								// Don't return options that are disabled or in a disabled optgroup
								!option.disabled &&
								( !option.parentNode.disabled ||
									!nodeName( option.parentNode, "optgroup" ) ) ) {

							// Get the specific value for the option
							value = jQuery( option ).val();

							// We don't need an array for one selects
							if ( one ) {
								return value;
							}

							// Multi-Selects return an array
							values.push( value );
						}
					}

					return values;
				},

				set: function( elem, value ) {
					var optionSet, option,
						options = elem.options,
						values = jQuery.makeArray( value ),
						i = options.length;

					while ( i-- ) {
						option = options[ i ];

						/* eslint-disable no-cond-assign */

						if ( option.selected =
							jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
						) {
							optionSet = true;
						}

						/* eslint-enable no-cond-assign */
					}

					// Force browsers to behave consistently when non-matching value is set
					if ( !optionSet ) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	} );

	// Radios and checkboxes getter/setter
	jQuery.each( [ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			set: function( elem, value ) {
				if ( Array.isArray( value ) ) {
					return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
				}
			}
		};
		if ( !support.checkOn ) {
			jQuery.valHooks[ this ].get = function( elem ) {
				return elem.getAttribute( "value" ) === null ? "on" : elem.value;
			};
		}
	} );




	// Return jQuery for attributes-only inclusion


	var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

	jQuery.extend( jQuery.event, {

		trigger: function( event, data, elem, onlyHandlers ) {

			var i, cur, tmp, bubbleType, ontype, handle, special,
				eventPath = [ elem || document ],
				type = hasOwn.call( event, "type" ) ? event.type : event,
				namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

			cur = tmp = elem = elem || document;

			// Don't do events on text and comment nodes
			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
				return;
			}

			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
				return;
			}

			if ( type.indexOf( "." ) > -1 ) {

				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split( "." );
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf( ":" ) < 0 && "on" + type;

			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[ jQuery.expando ] ?
				event :
				new jQuery.Event( type, typeof event === "object" && event );

			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join( "." );
			event.rnamespace = event.namespace ?
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
				null;

			// Clean up the event in case it is being reused
			event.result = undefined;
			if ( !event.target ) {
				event.target = elem;
			}

			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ?
				[ event ] :
				jQuery.makeArray( data, [ event ] );

			// Allow special events to draw outside the lines
			special = jQuery.event.special[ type ] || {};
			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
				return;
			}

			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

				bubbleType = special.delegateType || type;
				if ( !rfocusMorph.test( bubbleType + type ) ) {
					cur = cur.parentNode;
				}
				for ( ; cur; cur = cur.parentNode ) {
					eventPath.push( cur );
					tmp = cur;
				}

				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if ( tmp === ( elem.ownerDocument || document ) ) {
					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
				}
			}

			// Fire handlers on the event path
			i = 0;
			while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {

				event.type = i > 1 ?
					bubbleType :
					special.bindType || type;

				// jQuery handler
				handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
					dataPriv.get( cur, "handle" );
				if ( handle ) {
					handle.apply( cur, data );
				}

				// Native handler
				handle = ontype && cur[ ontype ];
				if ( handle && handle.apply && acceptData( cur ) ) {
					event.result = handle.apply( cur, data );
					if ( event.result === false ) {
						event.preventDefault();
					}
				}
			}
			event.type = type;

			// If nobody prevented the default action, do it now
			if ( !onlyHandlers && !event.isDefaultPrevented() ) {

				if ( ( !special._default ||
					special._default.apply( eventPath.pop(), data ) === false ) &&
					acceptData( elem ) ) {

					// Call a native DOM method on the target with the same name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ ontype ];

						if ( tmp ) {
							elem[ ontype ] = null;
						}

						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;
						elem[ type ]();
						jQuery.event.triggered = undefined;

						if ( tmp ) {
							elem[ ontype ] = tmp;
						}
					}
				}
			}

			return event.result;
		},

		// Piggyback on a donor event to simulate a different one
		// Used only for `focus(in | out)` events
		simulate: function( type, elem, event ) {
			var e = jQuery.extend(
				new jQuery.Event(),
				event,
				{
					type: type,
					isSimulated: true
				}
			);

			jQuery.event.trigger( e, null, elem );
		}

	} );

	jQuery.fn.extend( {

		trigger: function( type, data ) {
			return this.each( function() {
				jQuery.event.trigger( type, data, this );
			} );
		},
		triggerHandler: function( type, data ) {
			var elem = this[ 0 ];
			if ( elem ) {
				return jQuery.event.trigger( type, data, elem, true );
			}
		}
	} );


	jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
		"change select submit keydown keypress keyup contextmenu" ).split( " " ),
		function( i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	} );

	jQuery.fn.extend( {
		hover: function( fnOver, fnOut ) {
			return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
		}
	} );




	support.focusin = "onfocusin" in window;


	// Support: Firefox <=44
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
	if ( !support.focusin ) {
		jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
			};

			jQuery.event.special[ fix ] = {
				setup: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix );

					if ( !attaches ) {
						doc.addEventListener( orig, handler, true );
					}
					dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
				},
				teardown: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix ) - 1;

					if ( !attaches ) {
						doc.removeEventListener( orig, handler, true );
						dataPriv.remove( doc, fix );

					} else {
						dataPriv.access( doc, fix, attaches );
					}
				}
			};
		} );
	}
	var location = window.location;

	var nonce = jQuery.now();

	var rquery = ( /\?/ );



	// Cross-browser xml parsing
	jQuery.parseXML = function( data ) {
		var xml;
		if ( !data || typeof data !== "string" ) {
			return null;
		}

		// Support: IE 9 - 11 only
		// IE throws on parseFromString with invalid input.
		try {
			xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
		} catch ( e ) {
			xml = undefined;
		}

		if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	};


	var
		rbracket = /\[\]$/,
		rCRLF = /\r?\n/g,
		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
		rsubmittable = /^(?:input|select|textarea|keygen)/i;

	function buildParams( prefix, obj, traditional, add ) {
		var name;

		if ( Array.isArray( obj ) ) {

			// Serialize array item.
			jQuery.each( obj, function( i, v ) {
				if ( traditional || rbracket.test( prefix ) ) {

					// Treat each array item as a scalar.
					add( prefix, v );

				} else {

					// Item is non-scalar (array or object), encode its numeric index.
					buildParams(
						prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
						v,
						traditional,
						add
					);
				}
			} );

		} else if ( !traditional && jQuery.type( obj ) === "object" ) {

			// Serialize object item.
			for ( name in obj ) {
				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
			}

		} else {

			// Serialize scalar item.
			add( prefix, obj );
		}
	}

	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function( a, traditional ) {
		var prefix,
			s = [],
			add = function( key, valueOrFunction ) {

				// If value is a function, invoke it and use its return value
				var value = jQuery.isFunction( valueOrFunction ) ?
					valueOrFunction() :
					valueOrFunction;

				s[ s.length ] = encodeURIComponent( key ) + "=" +
					encodeURIComponent( value == null ? "" : value );
			};

		// If an array was passed in, assume that it is an array of form elements.
		if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			} );

		} else {

			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}

		// Return the resulting serialization
		return s.join( "&" );
	};

	jQuery.fn.extend( {
		serialize: function() {
			return jQuery.param( this.serializeArray() );
		},
		serializeArray: function() {
			return this.map( function() {

				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop( this, "elements" );
				return elements ? jQuery.makeArray( elements ) : this;
			} )
			.filter( function() {
				var type = this.type;

				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery( this ).is( ":disabled" ) &&
					rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
					( this.checked || !rcheckableType.test( type ) );
			} )
			.map( function( i, elem ) {
				var val = jQuery( this ).val();

				if ( val == null ) {
					return null;
				}

				if ( Array.isArray( val ) ) {
					return jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					} );
				}

				return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
			} ).get();
		}
	} );


	var
		r20 = /%20/g,
		rhash = /#.*$/,
		rantiCache = /([?&])_=[^&]*/,
		rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

		// #7653, #8125, #8152: local protocol detection
		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		rnoContent = /^(?:GET|HEAD)$/,
		rprotocol = /^\/\//,

		/* Prefilters
		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
		 * 2) These are called:
		 *    - BEFORE asking for a transport
		 *    - AFTER param serialization (s.data is a string if s.processData is true)
		 * 3) key is the dataType
		 * 4) the catchall symbol "*" can be used
		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
		 */
		prefilters = {},

		/* Transports bindings
		 * 1) key is the dataType
		 * 2) the catchall symbol "*" can be used
		 * 3) selection will start with transport dataType and THEN go to "*" if needed
		 */
		transports = {},

		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
		allTypes = "*/".concat( "*" ),

		// Anchor tag for parsing the document origin
		originAnchor = document.createElement( "a" );
		originAnchor.href = location.href;

	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports( structure ) {

		// dataTypeExpression is optional and defaults to "*"
		return function( dataTypeExpression, func ) {

			if ( typeof dataTypeExpression !== "string" ) {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}

			var dataType,
				i = 0,
				dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

			if ( jQuery.isFunction( func ) ) {

				// For each dataType in the dataTypeExpression
				while ( ( dataType = dataTypes[ i++ ] ) ) {

					// Prepend if requested
					if ( dataType[ 0 ] === "+" ) {
						dataType = dataType.slice( 1 ) || "*";
						( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

					// Otherwise append
					} else {
						( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
					}
				}
			}
		};
	}

	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

		var inspected = {},
			seekingTransport = ( structure === transports );

		function inspect( dataType ) {
			var selected;
			inspected[ dataType ] = true;
			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
				if ( typeof dataTypeOrTransport === "string" &&
					!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

					options.dataTypes.unshift( dataTypeOrTransport );
					inspect( dataTypeOrTransport );
					return false;
				} else if ( seekingTransport ) {
					return !( selected = dataTypeOrTransport );
				}
			} );
			return selected;
		}

		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
	}

	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend( target, src ) {
		var key, deep,
			flatOptions = jQuery.ajaxSettings.flatOptions || {};

		for ( key in src ) {
			if ( src[ key ] !== undefined ) {
				( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
			}
		}
		if ( deep ) {
			jQuery.extend( true, target, deep );
		}

		return target;
	}

	/* Handles responses to an ajax request:
	 * - finds the right dataType (mediates between content-type and expected dataType)
	 * - returns the corresponding response
	 */
	function ajaxHandleResponses( s, jqXHR, responses ) {

		var ct, type, finalDataType, firstDataType,
			contents = s.contents,
			dataTypes = s.dataTypes;

		// Remove auto dataType and get content-type in the process
		while ( dataTypes[ 0 ] === "*" ) {
			dataTypes.shift();
			if ( ct === undefined ) {
				ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
			}
		}

		// Check if we're dealing with a known content-type
		if ( ct ) {
			for ( type in contents ) {
				if ( contents[ type ] && contents[ type ].test( ct ) ) {
					dataTypes.unshift( type );
					break;
				}
			}
		}

		// Check to see if we have a response for the expected dataType
		if ( dataTypes[ 0 ] in responses ) {
			finalDataType = dataTypes[ 0 ];
		} else {

			// Try convertible dataTypes
			for ( type in responses ) {
				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
					finalDataType = type;
					break;
				}
				if ( !firstDataType ) {
					firstDataType = type;
				}
			}

			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}

		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if ( finalDataType ) {
			if ( finalDataType !== dataTypes[ 0 ] ) {
				dataTypes.unshift( finalDataType );
			}
			return responses[ finalDataType ];
		}
	}

	/* Chain conversions given the request and the original response
	 * Also sets the responseXXX fields on the jqXHR instance
	 */
	function ajaxConvert( s, response, jqXHR, isSuccess ) {
		var conv2, current, conv, tmp, prev,
			converters = {},

			// Work with a copy of dataTypes in case we need to modify it for conversion
			dataTypes = s.dataTypes.slice();

		// Create converters map with lowercased keys
		if ( dataTypes[ 1 ] ) {
			for ( conv in s.converters ) {
				converters[ conv.toLowerCase() ] = s.converters[ conv ];
			}
		}

		current = dataTypes.shift();

		// Convert to each sequential dataType
		while ( current ) {

			if ( s.responseFields[ current ] ) {
				jqXHR[ s.responseFields[ current ] ] = response;
			}

			// Apply the dataFilter if provided
			if ( !prev && isSuccess && s.dataFilter ) {
				response = s.dataFilter( response, s.dataType );
			}

			prev = current;
			current = dataTypes.shift();

			if ( current ) {

				// There's only work to do if current dataType is non-auto
				if ( current === "*" ) {

					current = prev;

				// Convert response if prev dataType is non-auto and differs from current
				} else if ( prev !== "*" && prev !== current ) {

					// Seek a direct converter
					conv = converters[ prev + " " + current ] || converters[ "* " + current ];

					// If none found, seek a pair
					if ( !conv ) {
						for ( conv2 in converters ) {

							// If conv2 outputs current
							tmp = conv2.split( " " );
							if ( tmp[ 1 ] === current ) {

								// If prev can be converted to accepted input
								conv = converters[ prev + " " + tmp[ 0 ] ] ||
									converters[ "* " + tmp[ 0 ] ];
								if ( conv ) {

									// Condense equivalence converters
									if ( conv === true ) {
										conv = converters[ conv2 ];

									// Otherwise, insert the intermediate dataType
									} else if ( converters[ conv2 ] !== true ) {
										current = tmp[ 0 ];
										dataTypes.unshift( tmp[ 1 ] );
									}
									break;
								}
							}
						}
					}

					// Apply converter (if not an equivalence)
					if ( conv !== true ) {

						// Unless errors are allowed to bubble, catch and return them
						if ( conv && s.throws ) {
							response = conv( response );
						} else {
							try {
								response = conv( response );
							} catch ( e ) {
								return {
									state: "parsererror",
									error: conv ? e : "No conversion from " + prev + " to " + current
								};
							}
						}
					}
				}
			}
		}

		return { state: "success", data: response };
	}

	jQuery.extend( {

		// Counter for holding the number of active queries
		active: 0,

		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},

		ajaxSettings: {
			url: location.href,
			type: "GET",
			isLocal: rlocalProtocol.test( location.protocol ),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",

			/*
			timeout: 0,
			data: null,
			dataType: null,
			username: null,
			password: null,
			cache: null,
			throws: false,
			traditional: false,
			headers: {},
			*/

			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},

			contents: {
				xml: /\bxml\b/,
				html: /\bhtml/,
				json: /\bjson\b/
			},

			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},

			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {

				// Convert anything to text
				"* text": String,

				// Text to html (true = no transformation)
				"text html": true,

				// Evaluate text as a json expression
				"text json": JSON.parse,

				// Parse text as xml
				"text xml": jQuery.parseXML
			},

			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},

		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function( target, settings ) {
			return settings ?

				// Building a settings object
				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

				// Extending ajaxSettings
				ajaxExtend( jQuery.ajaxSettings, target );
		},

		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
		ajaxTransport: addToPrefiltersOrTransports( transports ),

		// Main method
		ajax: function( url, options ) {

			// If url is an object, simulate pre-1.5 signature
			if ( typeof url === "object" ) {
				options = url;
				url = undefined;
			}

			// Force options to be an object
			options = options || {};

			var transport,

				// URL without anti-cache param
				cacheURL,

				// Response headers
				responseHeadersString,
				responseHeaders,

				// timeout handle
				timeoutTimer,

				// Url cleanup var
				urlAnchor,

				// Request state (becomes false upon send and true upon completion)
				completed,

				// To know if global events are to be dispatched
				fireGlobals,

				// Loop variable
				i,

				// uncached part of the url
				uncached,

				// Create the final options object
				s = jQuery.ajaxSetup( {}, options ),

				// Callbacks context
				callbackContext = s.context || s,

				// Context for global events is callbackContext if it is a DOM node or jQuery collection
				globalEventContext = s.context &&
					( callbackContext.nodeType || callbackContext.jquery ) ?
						jQuery( callbackContext ) :
						jQuery.event,

				// Deferreds
				deferred = jQuery.Deferred(),
				completeDeferred = jQuery.Callbacks( "once memory" ),

				// Status-dependent callbacks
				statusCode = s.statusCode || {},

				// Headers (they are sent all at once)
				requestHeaders = {},
				requestHeadersNames = {},

				// Default abort message
				strAbort = "canceled",

				// Fake xhr
				jqXHR = {
					readyState: 0,

					// Builds headers hashtable if needed
					getResponseHeader: function( key ) {
						var match;
						if ( completed ) {
							if ( !responseHeaders ) {
								responseHeaders = {};
								while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
									responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
								}
							}
							match = responseHeaders[ key.toLowerCase() ];
						}
						return match == null ? null : match;
					},

					// Raw string
					getAllResponseHeaders: function() {
						return completed ? responseHeadersString : null;
					},

					// Caches the header
					setRequestHeader: function( name, value ) {
						if ( completed == null ) {
							name = requestHeadersNames[ name.toLowerCase() ] =
								requestHeadersNames[ name.toLowerCase() ] || name;
							requestHeaders[ name ] = value;
						}
						return this;
					},

					// Overrides response content-type header
					overrideMimeType: function( type ) {
						if ( completed == null ) {
							s.mimeType = type;
						}
						return this;
					},

					// Status-dependent callbacks
					statusCode: function( map ) {
						var code;
						if ( map ) {
							if ( completed ) {

								// Execute the appropriate callbacks
								jqXHR.always( map[ jqXHR.status ] );
							} else {

								// Lazy-add the new callbacks in a way that preserves old ones
								for ( code in map ) {
									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
								}
							}
						}
						return this;
					},

					// Cancel the request
					abort: function( statusText ) {
						var finalText = statusText || strAbort;
						if ( transport ) {
							transport.abort( finalText );
						}
						done( 0, finalText );
						return this;
					}
				};

			// Attach deferreds
			deferred.promise( jqXHR );

			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ( ( url || s.url || location.href ) + "" )
				.replace( rprotocol, location.protocol + "//" );

			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;

			// Extract dataTypes list
			s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

			// A cross-domain request is in order when the origin doesn't match the current origin.
			if ( s.crossDomain == null ) {
				urlAnchor = document.createElement( "a" );

				// Support: IE <=8 - 11, Edge 12 - 13
				// IE throws exception on accessing the href property if url is malformed,
				// e.g. http://example.com:80x/
				try {
					urlAnchor.href = s.url;

					// Support: IE <=8 - 11 only
					// Anchor's host property isn't correctly set when s.url is relative
					urlAnchor.href = urlAnchor.href;
					s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
						urlAnchor.protocol + "//" + urlAnchor.host;
				} catch ( e ) {

					// If there is an error parsing the URL, assume it is crossDomain,
					// it can be rejected by the transport if it is invalid
					s.crossDomain = true;
				}
			}

			// Convert data if not already a string
			if ( s.data && s.processData && typeof s.data !== "string" ) {
				s.data = jQuery.param( s.data, s.traditional );
			}

			// Apply prefilters
			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

			// If request was aborted inside a prefilter, stop there
			if ( completed ) {
				return jqXHR;
			}

			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event && s.global;

			// Watch for a new set of requests
			if ( fireGlobals && jQuery.active++ === 0 ) {
				jQuery.event.trigger( "ajaxStart" );
			}

			// Uppercase the type
			s.type = s.type.toUpperCase();

			// Determine if request has content
			s.hasContent = !rnoContent.test( s.type );

			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			// Remove hash to simplify url manipulation
			cacheURL = s.url.replace( rhash, "" );

			// More options handling for requests with no content
			if ( !s.hasContent ) {

				// Remember the hash so we can put it back
				uncached = s.url.slice( cacheURL.length );

				// If data is available, append data to url
				if ( s.data ) {
					cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}

				// Add or update anti-cache param if needed
				if ( s.cache === false ) {
					cacheURL = cacheURL.replace( rantiCache, "$1" );
					uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
				}

				// Put hash and anti-cache on the URL that will be requested (gh-1732)
				s.url = cacheURL + uncached;

			// Change '%20' to '+' if this is encoded form body content (gh-2658)
			} else if ( s.data && s.processData &&
				( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
				s.data = s.data.replace( r20, "+" );
			}

			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if ( s.ifModified ) {
				if ( jQuery.lastModified[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
				}
				if ( jQuery.etag[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
				}
			}

			// Set the correct header, if data is being sent
			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
				jqXHR.setRequestHeader( "Content-Type", s.contentType );
			}

			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader(
				"Accept",
				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
					s.accepts[ s.dataTypes[ 0 ] ] +
						( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
					s.accepts[ "*" ]
			);

			// Check for headers option
			for ( i in s.headers ) {
				jqXHR.setRequestHeader( i, s.headers[ i ] );
			}

			// Allow custom headers/mimetypes and early abort
			if ( s.beforeSend &&
				( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

				// Abort if not done already and return
				return jqXHR.abort();
			}

			// Aborting is no longer a cancellation
			strAbort = "abort";

			// Install callbacks on deferreds
			completeDeferred.add( s.complete );
			jqXHR.done( s.success );
			jqXHR.fail( s.error );

			// Get transport
			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

			// If no transport, we auto-abort
			if ( !transport ) {
				done( -1, "No Transport" );
			} else {
				jqXHR.readyState = 1;

				// Send global event
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
				}

				// If request was aborted inside ajaxSend, stop there
				if ( completed ) {
					return jqXHR;
				}

				// Timeout
				if ( s.async && s.timeout > 0 ) {
					timeoutTimer = window.setTimeout( function() {
						jqXHR.abort( "timeout" );
					}, s.timeout );
				}

				try {
					completed = false;
					transport.send( requestHeaders, done );
				} catch ( e ) {

					// Rethrow post-completion exceptions
					if ( completed ) {
						throw e;
					}

					// Propagate others as results
					done( -1, e );
				}
			}

			// Callback for when everything is done
			function done( status, nativeStatusText, responses, headers ) {
				var isSuccess, success, error, response, modified,
					statusText = nativeStatusText;

				// Ignore repeat invocations
				if ( completed ) {
					return;
				}

				completed = true;

				// Clear timeout if it exists
				if ( timeoutTimer ) {
					window.clearTimeout( timeoutTimer );
				}

				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;

				// Cache response headers
				responseHeadersString = headers || "";

				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;

				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;

				// Get response data
				if ( responses ) {
					response = ajaxHandleResponses( s, jqXHR, responses );
				}

				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert( s, response, jqXHR, isSuccess );

				// If successful, handle type chaining
				if ( isSuccess ) {

					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if ( s.ifModified ) {
						modified = jqXHR.getResponseHeader( "Last-Modified" );
						if ( modified ) {
							jQuery.lastModified[ cacheURL ] = modified;
						}
						modified = jqXHR.getResponseHeader( "etag" );
						if ( modified ) {
							jQuery.etag[ cacheURL ] = modified;
						}
					}

					// if no content
					if ( status === 204 || s.type === "HEAD" ) {
						statusText = "nocontent";

					// if not modified
					} else if ( status === 304 ) {
						statusText = "notmodified";

					// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {

					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if ( status || !statusText ) {
						statusText = "error";
						if ( status < 0 ) {
							status = 0;
						}
					}
				}

				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = ( nativeStatusText || statusText ) + "";

				// Success/Error
				if ( isSuccess ) {
					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
				} else {
					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
				}

				// Status-dependent callbacks
				jqXHR.statusCode( statusCode );
				statusCode = undefined;

				if ( fireGlobals ) {
					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
						[ jqXHR, s, isSuccess ? success : error ] );
				}

				// Complete
				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

					// Handle the global AJAX counter
					if ( !( --jQuery.active ) ) {
						jQuery.event.trigger( "ajaxStop" );
					}
				}
			}

			return jqXHR;
		},

		getJSON: function( url, data, callback ) {
			return jQuery.get( url, data, callback, "json" );
		},

		getScript: function( url, callback ) {
			return jQuery.get( url, undefined, callback, "script" );
		}
	} );

	jQuery.each( [ "get", "post" ], function( i, method ) {
		jQuery[ method ] = function( url, data, callback, type ) {

			// Shift arguments if data argument was omitted
			if ( jQuery.isFunction( data ) ) {
				type = type || callback;
				callback = data;
				data = undefined;
			}

			// The url can be an options object (which then must have .url)
			return jQuery.ajax( jQuery.extend( {
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			}, jQuery.isPlainObject( url ) && url ) );
		};
	} );


	jQuery._evalUrl = function( url ) {
		return jQuery.ajax( {
			url: url,

			// Make this explicit, since user can override this through ajaxSetup (#11264)
			type: "GET",
			dataType: "script",
			cache: true,
			async: false,
			global: false,
			"throws": true
		} );
	};


	jQuery.fn.extend( {
		wrapAll: function( html ) {
			var wrap;

			if ( this[ 0 ] ) {
				if ( jQuery.isFunction( html ) ) {
					html = html.call( this[ 0 ] );
				}

				// The elements to wrap the target around
				wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

				if ( this[ 0 ].parentNode ) {
					wrap.insertBefore( this[ 0 ] );
				}

				wrap.map( function() {
					var elem = this;

					while ( elem.firstElementChild ) {
						elem = elem.firstElementChild;
					}

					return elem;
				} ).append( this );
			}

			return this;
		},

		wrapInner: function( html ) {
			if ( jQuery.isFunction( html ) ) {
				return this.each( function( i ) {
					jQuery( this ).wrapInner( html.call( this, i ) );
				} );
			}

			return this.each( function() {
				var self = jQuery( this ),
					contents = self.contents();

				if ( contents.length ) {
					contents.wrapAll( html );

				} else {
					self.append( html );
				}
			} );
		},

		wrap: function( html ) {
			var isFunction = jQuery.isFunction( html );

			return this.each( function( i ) {
				jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
			} );
		},

		unwrap: function( selector ) {
			this.parent( selector ).not( "body" ).each( function() {
				jQuery( this ).replaceWith( this.childNodes );
			} );
			return this;
		}
	} );


	jQuery.expr.pseudos.hidden = function( elem ) {
		return !jQuery.expr.pseudos.visible( elem );
	};
	jQuery.expr.pseudos.visible = function( elem ) {
		return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
	};




	jQuery.ajaxSettings.xhr = function() {
		try {
			return new window.XMLHttpRequest();
		} catch ( e ) {}
	};

	var xhrSuccessStatus = {

			// File protocol always yields status code 0, assume 200
			0: 200,

			// Support: IE <=9 only
			// #1450: sometimes IE returns 1223 when it should be 204
			1223: 204
		},
		xhrSupported = jQuery.ajaxSettings.xhr();

	support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
	support.ajax = xhrSupported = !!xhrSupported;

	jQuery.ajaxTransport( function( options ) {
		var callback, errorCallback;

		// Cross domain only allowed if supported through XMLHttpRequest
		if ( support.cors || xhrSupported && !options.crossDomain ) {
			return {
				send: function( headers, complete ) {
					var i,
						xhr = options.xhr();

					xhr.open(
						options.type,
						options.url,
						options.async,
						options.username,
						options.password
					);

					// Apply custom fields if provided
					if ( options.xhrFields ) {
						for ( i in options.xhrFields ) {
							xhr[ i ] = options.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( options.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( options.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}

					// Set headers
					for ( i in headers ) {
						xhr.setRequestHeader( i, headers[ i ] );
					}

					// Callback
					callback = function( type ) {
						return function() {
							if ( callback ) {
								callback = errorCallback = xhr.onload =
									xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

								if ( type === "abort" ) {
									xhr.abort();
								} else if ( type === "error" ) {

									// Support: IE <=9 only
									// On a manual native abort, IE9 throws
									// errors on any property access that is not readyState
									if ( typeof xhr.status !== "number" ) {
										complete( 0, "error" );
									} else {
										complete(

											// File: protocol always yields status 0; see #8605, #14207
											xhr.status,
											xhr.statusText
										);
									}
								} else {
									complete(
										xhrSuccessStatus[ xhr.status ] || xhr.status,
										xhr.statusText,

										// Support: IE <=9 only
										// IE9 has no XHR2 but throws on binary (trac-11426)
										// For XHR2 non-text, let the caller handle it (gh-2498)
										( xhr.responseType || "text" ) !== "text"  ||
										typeof xhr.responseText !== "string" ?
											{ binary: xhr.response } :
											{ text: xhr.responseText },
										xhr.getAllResponseHeaders()
									);
								}
							}
						};
					};

					// Listen to events
					xhr.onload = callback();
					errorCallback = xhr.onerror = callback( "error" );

					// Support: IE 9 only
					// Use onreadystatechange to replace onabort
					// to handle uncaught aborts
					if ( xhr.onabort !== undefined ) {
						xhr.onabort = errorCallback;
					} else {
						xhr.onreadystatechange = function() {

							// Check readyState before timeout as it changes
							if ( xhr.readyState === 4 ) {

								// Allow onerror to be called first,
								// but that will not handle a native abort
								// Also, save errorCallback to a variable
								// as xhr.onerror cannot be accessed
								window.setTimeout( function() {
									if ( callback ) {
										errorCallback();
									}
								} );
							}
						};
					}

					// Create the abort callback
					callback = callback( "abort" );

					try {

						// Do send the request (this may raise an exception)
						xhr.send( options.hasContent && options.data || null );
					} catch ( e ) {

						// #14683: Only rethrow if this hasn't been notified as an error yet
						if ( callback ) {
							throw e;
						}
					}
				},

				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );




	// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
	jQuery.ajaxPrefilter( function( s ) {
		if ( s.crossDomain ) {
			s.contents.script = false;
		}
	} );

	// Install script dataType
	jQuery.ajaxSetup( {
		accepts: {
			script: "text/javascript, application/javascript, " +
				"application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /\b(?:java|ecma)script\b/
		},
		converters: {
			"text script": function( text ) {
				jQuery.globalEval( text );
				return text;
			}
		}
	} );

	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter( "script", function( s ) {
		if ( s.cache === undefined ) {
			s.cache = false;
		}
		if ( s.crossDomain ) {
			s.type = "GET";
		}
	} );

	// Bind script tag hack transport
	jQuery.ajaxTransport( "script", function( s ) {

		// This transport only deals with cross domain requests
		if ( s.crossDomain ) {
			var script, callback;
			return {
				send: function( _, complete ) {
					script = jQuery( "<script>" ).prop( {
						charset: s.scriptCharset,
						src: s.url
					} ).on(
						"load error",
						callback = function( evt ) {
							script.remove();
							callback = null;
							if ( evt ) {
								complete( evt.type === "error" ? 404 : 200, evt.type );
							}
						}
					);

					// Use native DOM manipulation to avoid our domManip AJAX trickery
					document.head.appendChild( script[ 0 ] );
				},
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );




	var oldCallbacks = [],
		rjsonp = /(=)\?(?=&|$)|\?\?/;

	// Default jsonp settings
	jQuery.ajaxSetup( {
		jsonp: "callback",
		jsonpCallback: function() {
			var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
			this[ callback ] = true;
			return callback;
		}
	} );

	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

		var callbackName, overwritten, responseContainer,
			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
				"url" :
				typeof s.data === "string" &&
					( s.contentType || "" )
						.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
					rjsonp.test( s.data ) && "data"
			);

		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
				s.jsonpCallback() :
				s.jsonpCallback;

			// Insert callback into url or form data
			if ( jsonProp ) {
				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
			} else if ( s.jsonp !== false ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
			}

			// Use data converter to retrieve json after script execution
			s.converters[ "script json" ] = function() {
				if ( !responseContainer ) {
					jQuery.error( callbackName + " was not called" );
				}
				return responseContainer[ 0 ];
			};

			// Force json dataType
			s.dataTypes[ 0 ] = "json";

			// Install callback
			overwritten = window[ callbackName ];
			window[ callbackName ] = function() {
				responseContainer = arguments;
			};

			// Clean-up function (fires after converters)
			jqXHR.always( function() {

				// If previous value didn't exist - remove it
				if ( overwritten === undefined ) {
					jQuery( window ).removeProp( callbackName );

				// Otherwise restore preexisting value
				} else {
					window[ callbackName ] = overwritten;
				}

				// Save back as free
				if ( s[ callbackName ] ) {

					// Make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;

					// Save the callback name for future use
					oldCallbacks.push( callbackName );
				}

				// Call if it was a function and we have a response
				if ( responseContainer && jQuery.isFunction( overwritten ) ) {
					overwritten( responseContainer[ 0 ] );
				}

				responseContainer = overwritten = undefined;
			} );

			// Delegate to script
			return "script";
		}
	} );




	// Support: Safari 8 only
	// In Safari 8 documents created via document.implementation.createHTMLDocument
	// collapse sibling forms: the second one becomes a child of the first one.
	// Because of that, this security measure has to be disabled in Safari 8.
	// https://bugs.webkit.org/show_bug.cgi?id=137337
	support.createHTMLDocument = ( function() {
		var body = document.implementation.createHTMLDocument( "" ).body;
		body.innerHTML = "<form></form><form></form>";
		return body.childNodes.length === 2;
	} )();


	// Argument "data" should be string of html
	// context (optional): If specified, the fragment will be created in this context,
	// defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function( data, context, keepScripts ) {
		if ( typeof data !== "string" ) {
			return [];
		}
		if ( typeof context === "boolean" ) {
			keepScripts = context;
			context = false;
		}

		var base, parsed, scripts;

		if ( !context ) {

			// Stop scripts or inline event handlers from being executed immediately
			// by using document.implementation
			if ( support.createHTMLDocument ) {
				context = document.implementation.createHTMLDocument( "" );

				// Set the base href for the created document
				// so any parsed elements with URLs
				// are based on the document's URL (gh-2965)
				base = context.createElement( "base" );
				base.href = document.location.href;
				context.head.appendChild( base );
			} else {
				context = document;
			}
		}

		parsed = rsingleTag.exec( data );
		scripts = !keepScripts && [];

		// Single tag
		if ( parsed ) {
			return [ context.createElement( parsed[ 1 ] ) ];
		}

		parsed = buildFragment( [ data ], context, scripts );

		if ( scripts && scripts.length ) {
			jQuery( scripts ).remove();
		}

		return jQuery.merge( [], parsed.childNodes );
	};


	/**
	 * Load a url into a page
	 */
	jQuery.fn.load = function( url, params, callback ) {
		var selector, type, response,
			self = this,
			off = url.indexOf( " " );

		if ( off > -1 ) {
			selector = stripAndCollapse( url.slice( off ) );
			url = url.slice( 0, off );
		}

		// If it's a function
		if ( jQuery.isFunction( params ) ) {

			// We assume that it's the callback
			callback = params;
			params = undefined;

		// Otherwise, build a param string
		} else if ( params && typeof params === "object" ) {
			type = "POST";
		}

		// If we have elements to modify, make the request
		if ( self.length > 0 ) {
			jQuery.ajax( {
				url: url,

				// If "type" variable is undefined, then "GET" method will be used.
				// Make value of this field explicit since
				// user can override it through ajaxSetup method
				type: type || "GET",
				dataType: "html",
				data: params
			} ).done( function( responseText ) {

				// Save response for use in complete callback
				response = arguments;

				self.html( selector ?

					// If a selector was specified, locate the right elements in a dummy div
					// Exclude scripts to avoid IE 'Permission Denied' errors
					jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

					// Otherwise use the full result
					responseText );

			// If the request succeeds, this function gets "data", "status", "jqXHR"
			// but they are ignored because response was set above.
			// If it fails, this function gets "jqXHR", "status", "error"
			} ).always( callback && function( jqXHR, status ) {
				self.each( function() {
					callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
				} );
			} );
		}

		return this;
	};




	// Attach a bunch of functions for handling common AJAX events
	jQuery.each( [
		"ajaxStart",
		"ajaxStop",
		"ajaxComplete",
		"ajaxError",
		"ajaxSuccess",
		"ajaxSend"
	], function( i, type ) {
		jQuery.fn[ type ] = function( fn ) {
			return this.on( type, fn );
		};
	} );




	jQuery.expr.pseudos.animated = function( elem ) {
		return jQuery.grep( jQuery.timers, function( fn ) {
			return elem === fn.elem;
		} ).length;
	};




	jQuery.offset = {
		setOffset: function( elem, options, i ) {
			var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
				position = jQuery.css( elem, "position" ),
				curElem = jQuery( elem ),
				props = {};

			// Set position first, in-case top/left are set even on static elem
			if ( position === "static" ) {
				elem.style.position = "relative";
			}

			curOffset = curElem.offset();
			curCSSTop = jQuery.css( elem, "top" );
			curCSSLeft = jQuery.css( elem, "left" );
			calculatePosition = ( position === "absolute" || position === "fixed" ) &&
				( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if ( calculatePosition ) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;

			} else {
				curTop = parseFloat( curCSSTop ) || 0;
				curLeft = parseFloat( curCSSLeft ) || 0;
			}

			if ( jQuery.isFunction( options ) ) {

				// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
				options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
			}

			if ( options.top != null ) {
				props.top = ( options.top - curOffset.top ) + curTop;
			}
			if ( options.left != null ) {
				props.left = ( options.left - curOffset.left ) + curLeft;
			}

			if ( "using" in options ) {
				options.using.call( elem, props );

			} else {
				curElem.css( props );
			}
		}
	};

	jQuery.fn.extend( {
		offset: function( options ) {

			// Preserve chaining for setter
			if ( arguments.length ) {
				return options === undefined ?
					this :
					this.each( function( i ) {
						jQuery.offset.setOffset( this, options, i );
					} );
			}

			var doc, docElem, rect, win,
				elem = this[ 0 ];

			if ( !elem ) {
				return;
			}

			// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
			// Support: IE <=11 only
			// Running getBoundingClientRect on a
			// disconnected node in IE throws an error
			if ( !elem.getClientRects().length ) {
				return { top: 0, left: 0 };
			}

			rect = elem.getBoundingClientRect();

			doc = elem.ownerDocument;
			docElem = doc.documentElement;
			win = doc.defaultView;

			return {
				top: rect.top + win.pageYOffset - docElem.clientTop,
				left: rect.left + win.pageXOffset - docElem.clientLeft
			};
		},

		position: function() {
			if ( !this[ 0 ] ) {
				return;
			}

			var offsetParent, offset,
				elem = this[ 0 ],
				parentOffset = { top: 0, left: 0 };

			// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
			// because it is its only offset parent
			if ( jQuery.css( elem, "position" ) === "fixed" ) {

				// Assume getBoundingClientRect is there when computed position is fixed
				offset = elem.getBoundingClientRect();

			} else {

				// Get *real* offsetParent
				offsetParent = this.offsetParent();

				// Get correct offsets
				offset = this.offset();
				if ( !nodeName( offsetParent[ 0 ], "html" ) ) {
					parentOffset = offsetParent.offset();
				}

				// Add offsetParent borders
				parentOffset = {
					top: parentOffset.top + jQuery.css( offsetParent[ 0 ], "borderTopWidth", true ),
					left: parentOffset.left + jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true )
				};
			}

			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
				left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
			};
		},

		// This method will return documentElement in the following cases:
		// 1) For the element inside the iframe without offsetParent, this method will return
		//    documentElement of the parent window
		// 2) For the hidden or detached element
		// 3) For body or html element, i.e. in case of the html node - it will return itself
		//
		// but those exceptions were never presented as a real life use-cases
		// and might be considered as more preferable results.
		//
		// This logic, however, is not guaranteed and can change at any point in the future
		offsetParent: function() {
			return this.map( function() {
				var offsetParent = this.offsetParent;

				while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
					offsetParent = offsetParent.offsetParent;
				}

				return offsetParent || documentElement;
			} );
		}
	} );

	// Create scrollLeft and scrollTop methods
	jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
		var top = "pageYOffset" === prop;

		jQuery.fn[ method ] = function( val ) {
			return access( this, function( elem, method, val ) {

				// Coalesce documents and windows
				var win;
				if ( jQuery.isWindow( elem ) ) {
					win = elem;
				} else if ( elem.nodeType === 9 ) {
					win = elem.defaultView;
				}

				if ( val === undefined ) {
					return win ? win[ prop ] : elem[ method ];
				}

				if ( win ) {
					win.scrollTo(
						!top ? val : win.pageXOffset,
						top ? val : win.pageYOffset
					);

				} else {
					elem[ method ] = val;
				}
			}, method, val, arguments.length );
		};
	} );

	// Support: Safari <=7 - 9.1, Chrome <=37 - 49
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each( [ "top", "left" ], function( i, prop ) {
		jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
			function( elem, computed ) {
				if ( computed ) {
					computed = curCSS( elem, prop );

					// If curCSS returns percentage, fallback to offset
					return rnumnonpx.test( computed ) ?
						jQuery( elem ).position()[ prop ] + "px" :
						computed;
				}
			}
		);
	} );


	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
		jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
			function( defaultExtra, funcName ) {

			// Margin is only for outerHeight, outerWidth
			jQuery.fn[ funcName ] = function( margin, value ) {
				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

				return access( this, function( elem, type, value ) {
					var doc;

					if ( jQuery.isWindow( elem ) ) {

						// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
						return funcName.indexOf( "outer" ) === 0 ?
							elem[ "inner" + name ] :
							elem.document.documentElement[ "client" + name ];
					}

					// Get document width or height
					if ( elem.nodeType === 9 ) {
						doc = elem.documentElement;

						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(
							elem.body[ "scroll" + name ], doc[ "scroll" + name ],
							elem.body[ "offset" + name ], doc[ "offset" + name ],
							doc[ "client" + name ]
						);
					}

					return value === undefined ?

						// Get width or height on the element, requesting but not forcing parseFloat
						jQuery.css( elem, type, extra ) :

						// Set width or height on the element
						jQuery.style( elem, type, value, extra );
				}, type, chainable ? margin : undefined, chainable );
			};
		} );
	} );


	jQuery.fn.extend( {

		bind: function( types, data, fn ) {
			return this.on( types, null, data, fn );
		},
		unbind: function( types, fn ) {
			return this.off( types, null, fn );
		},

		delegate: function( selector, types, data, fn ) {
			return this.on( types, selector, data, fn );
		},
		undelegate: function( selector, types, fn ) {

			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ?
				this.off( selector, "**" ) :
				this.off( types, selector || "**", fn );
		}
	} );

	jQuery.holdReady = function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	};
	jQuery.isArray = Array.isArray;
	jQuery.parseJSON = JSON.parse;
	jQuery.nodeName = nodeName;




	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.

	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

	if ( true ) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return jQuery;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}




	var

		// Map over jQuery in case of overwrite
		_jQuery = window.jQuery,

		// Map over the $ in case of overwrite
		_$ = window.$;

	jQuery.noConflict = function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	};

	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if ( !noGlobal ) {
		window.jQuery = window.$ = jQuery;
	}




	return jQuery;
	} );


/***/ }),
/* 4 */
/***/ (function(module, exports) {

	/*! modernizr 3.5.0 (Custom Build) | MIT *
	 * https://modernizr.com/download/?-applicationcache-backgrounds-borderimage-borderradius-boxshadow-cors-cssanimations-csscolumns-cssgradients-cssreflections-cssremunit-cssscrollbar-csstransforms-csstransforms3d-csstransitions-devicemotion_deviceorientation-fileinput-filereader-filesystem-flexbox-flexboxlegacy-fontface-formattribute-formvalidation-fullscreen-generatedcontent-hashchange-history-hsla-ie8compat-input-inputtypes-json-localstorage-multiplebgs-opacity-overflowscrolling-placeholder-postmessage-rgba-sessionstorage-strictmode-textshadow-domprefixes-hasevent-prefixed-prefixes-setclasses-testallprops-testprop-teststyles !*/
	!function(e,t,n){function r(e){var t=S.className,n=Modernizr._config.classPrefix||"";if(C&&(t=t.baseVal),Modernizr._config.enableJSClass){var r=new RegExp("(^|\\s)"+n+"no-js(\\s|$)");t=t.replace(r,"$1"+n+"js$2")}Modernizr._config.enableClasses&&(t+=" "+n+e.join(" "+n),C?S.className.baseVal=t:S.className=t)}function i(e,t){return typeof e===t}function o(){var e,t,n,r,o,s,a;for(var d in x)if(x.hasOwnProperty(d)){if(e=[],t=x[d],t.name&&(e.push(t.name.toLowerCase()),t.options&&t.options.aliases&&t.options.aliases.length))for(n=0;n<t.options.aliases.length;n++)e.push(t.options.aliases[n].toLowerCase());for(r=i(t.fn,"function")?t.fn():t.fn,o=0;o<e.length;o++)s=e[o],a=s.split("."),1===a.length?Modernizr[a[0]]=r:(!Modernizr[a[0]]||Modernizr[a[0]]instanceof Boolean||(Modernizr[a[0]]=new Boolean(Modernizr[a[0]])),Modernizr[a[0]][a[1]]=r),b.push((r?"":"no-")+a.join("-"))}}function s(){return"function"!=typeof t.createElement?t.createElement(arguments[0]):C?t.createElementNS.call(t,"http://www.w3.org/2000/svg",arguments[0]):t.createElement.apply(t,arguments)}function a(e){return e.replace(/([a-z])-([a-z])/g,function(e,t,n){return t+n.toUpperCase()}).replace(/^-/,"")}function d(e,t){return!!~(""+e).indexOf(t)}function l(){var e=t.body;return e||(e=s(C?"svg":"body"),e.fake=!0),e}function u(e,n,r,i){var o,a,d,u,c="modernizr",f=s("div"),p=l();if(parseInt(r,10))for(;r--;)d=s("div"),d.id=i?i[r]:c+(r+1),f.appendChild(d);return o=s("style"),o.type="text/css",o.id="s"+c,(p.fake?p:f).appendChild(o),p.appendChild(f),o.styleSheet?o.styleSheet.cssText=e:o.appendChild(t.createTextNode(e)),f.id=c,p.fake&&(p.style.background="",p.style.overflow="hidden",u=S.style.overflow,S.style.overflow="hidden",S.appendChild(p)),a=n(f,e),p.fake?(p.parentNode.removeChild(p),S.style.overflow=u,S.offsetHeight):f.parentNode.removeChild(f),!!a}function c(e,t){return function(){return e.apply(t,arguments)}}function f(e,t,n){var r;for(var o in e)if(e[o]in t)return n===!1?e[o]:(r=t[e[o]],i(r,"function")?c(r,n||t):r);return!1}function p(t,n,r){var i;if("getComputedStyle"in e){i=getComputedStyle.call(e,t,n);var o=e.console;if(null!==i)r&&(i=i.getPropertyValue(r));else if(o){var s=o.error?"error":"log";o[s].call(o,"getComputedStyle returning null, its possible modernizr test results are inaccurate")}}else i=!n&&t.currentStyle&&t.currentStyle[r];return i}function m(e){return e.replace(/([A-Z])/g,function(e,t){return"-"+t.toLowerCase()}).replace(/^ms-/,"-ms-")}function h(t,r){var i=t.length;if("CSS"in e&&"supports"in e.CSS){for(;i--;)if(e.CSS.supports(m(t[i]),r))return!0;return!1}if("CSSSupportsRule"in e){for(var o=[];i--;)o.push("("+m(t[i])+":"+r+")");return o=o.join(" or "),u("@supports ("+o+") { #modernizr { position: absolute; } }",function(e){return"absolute"==p(e,null,"position")})}return n}function g(e,t,r,o){function l(){c&&(delete I.style,delete I.modElem)}if(o=i(o,"undefined")?!1:o,!i(r,"undefined")){var u=h(e,r);if(!i(u,"undefined"))return u}for(var c,f,p,m,g,v=["modernizr","tspan","samp"];!I.style&&v.length;)c=!0,I.modElem=s(v.shift()),I.style=I.modElem.style;for(p=e.length,f=0;p>f;f++)if(m=e[f],g=I.style[m],d(m,"-")&&(m=a(m)),I.style[m]!==n){if(o||i(r,"undefined"))return l(),"pfx"==t?m:!0;try{I.style[m]=r}catch(y){}if(I.style[m]!=g)return l(),"pfx"==t?m:!0}return l(),!1}function v(e,t,n,r,o){var s=e.charAt(0).toUpperCase()+e.slice(1),a=(e+" "+M.join(s+" ")+s).split(" ");return i(t,"string")||i(t,"undefined")?g(a,t,r,o):(a=(e+" "+z.join(s+" ")+s).split(" "),f(a,t,n))}function y(e,t,r){return v(e,n,n,t,r)}var b=[],x=[],T={_version:"3.5.0",_config:{classPrefix:"",enableClasses:!0,enableJSClass:!0,usePrefixes:!0},_q:[],on:function(e,t){var n=this;setTimeout(function(){t(n[e])},0)},addTest:function(e,t,n){x.push({name:e,fn:t,options:n})},addAsyncTest:function(e){x.push({name:null,fn:e})}},Modernizr=function(){};Modernizr.prototype=T,Modernizr=new Modernizr,Modernizr.addTest("applicationcache","applicationCache"in e),Modernizr.addTest("cors","XMLHttpRequest"in e&&"withCredentials"in new XMLHttpRequest),Modernizr.addTest("ie8compat",!e.addEventListener&&!!t.documentMode&&7===t.documentMode),Modernizr.addTest("history",function(){var t=navigator.userAgent;return-1===t.indexOf("Android 2.")&&-1===t.indexOf("Android 4.0")||-1===t.indexOf("Mobile Safari")||-1!==t.indexOf("Chrome")||-1!==t.indexOf("Windows Phone")||"file:"===location.protocol?e.history&&"pushState"in e.history:!1}),Modernizr.addTest("json","JSON"in e&&"parse"in JSON&&"stringify"in JSON),Modernizr.addTest("postmessage","postMessage"in e),Modernizr.addTest("strictmode",function(){"use strict";return!this}()),Modernizr.addTest("devicemotion","DeviceMotionEvent"in e),Modernizr.addTest("deviceorientation","DeviceOrientationEvent"in e),Modernizr.addTest("filereader",!!(e.File&&e.FileList&&e.FileReader)),Modernizr.addTest("localstorage",function(){var e="modernizr";try{return localStorage.setItem(e,e),localStorage.removeItem(e),!0}catch(t){return!1}}),Modernizr.addTest("sessionstorage",function(){var e="modernizr";try{return sessionStorage.setItem(e,e),sessionStorage.removeItem(e),!0}catch(t){return!1}});var w=T._config.usePrefixes?" -webkit- -moz- -o- -ms- ".split(" "):["",""];T._prefixes=w;var S=t.documentElement,C="svg"===S.nodeName.toLowerCase(),k="Moz O ms Webkit",z=T._config.usePrefixes?k.toLowerCase().split(" "):[];T._domPrefixes=z;var A=function(){function e(e,t){var i;return e?(t&&"string"!=typeof t||(t=s(t||"div")),e="on"+e,i=e in t,!i&&r&&(t.setAttribute||(t=s("div")),t.setAttribute(e,""),i="function"==typeof t[e],t[e]!==n&&(t[e]=n),t.removeAttribute(e)),i):!1}var r=!("onblur"in t.documentElement);return e}();T.hasEvent=A,Modernizr.addTest("hashchange",function(){return A("hashchange",e)===!1?!1:t.documentMode===n||t.documentMode>7}),Modernizr.addTest("cssgradients",function(){for(var e,t="background-image:",n="gradient(linear,left top,right bottom,from(#9f9),to(white));",r="",i=0,o=w.length-1;o>i;i++)e=0===i?"to ":"",r+=t+w[i]+"linear-gradient("+e+"left top, #9f9, white);";Modernizr._config.usePrefixes&&(r+=t+"-webkit-"+n);var a=s("a"),d=a.style;return d.cssText=r,(""+d.backgroundImage).indexOf("gradient")>-1}),Modernizr.addTest("multiplebgs",function(){var e=s("a").style;return e.cssText="background:url(https://),url(https://),red url(https://)",/(url\s*\(.*?){3}/.test(e.background)}),Modernizr.addTest("opacity",function(){var e=s("a").style;return e.cssText=w.join("opacity:.55;"),/^0.55$/.test(e.opacity)}),Modernizr.addTest("cssremunit",function(){var e=s("a").style;try{e.fontSize="3rem"}catch(t){}return/rem/.test(e.fontSize)}),Modernizr.addTest("rgba",function(){var e=s("a").style;return e.cssText="background-color:rgba(150,255,150,.5)",(""+e.backgroundColor).indexOf("rgba")>-1}),Modernizr.addTest("fileinput",function(){if(navigator.userAgent.match(/(Android (1.0|1.1|1.5|1.6|2.0|2.1))|(Windows Phone (OS 7|8.0))|(XBLWP)|(ZuneWP)|(w(eb)?OSBrowser)|(webOS)|(Kindle\/(1.0|2.0|2.5|3.0))/))return!1;var e=s("input");return e.type="file",!e.disabled}),Modernizr.addTest("formattribute",function(){var e,n=s("form"),r=s("input"),i=s("div"),o="formtest"+(new Date).getTime(),a=!1;n.id=o;try{r.setAttribute("form",o)}catch(d){t.createAttribute&&(e=t.createAttribute("form"),e.nodeValue=o,r.setAttributeNode(e))}return i.appendChild(n),i.appendChild(r),S.appendChild(i),a=n.elements&&1===n.elements.length&&r.form==n,i.parentNode.removeChild(i),a}),Modernizr.addTest("placeholder","placeholder"in s("input")&&"placeholder"in s("textarea"));var _=s("input"),E="autocomplete autofocus list placeholder max min multiple pattern required step".split(" "),O={};Modernizr.input=function(t){for(var n=0,r=t.length;r>n;n++)O[t[n]]=!!(t[n]in _);return O.list&&(O.list=!(!s("datalist")||!e.HTMLDataListElement)),O}(E);var P="search tel url email datetime date month week time datetime-local number range color".split(" "),L={};Modernizr.inputtypes=function(e){for(var r,i,o,s=e.length,a="1)",d=0;s>d;d++)_.setAttribute("type",r=e[d]),o="text"!==_.type&&"style"in _,o&&(_.value=a,_.style.cssText="position:absolute;visibility:hidden;",/^range$/.test(r)&&_.style.WebkitAppearance!==n?(S.appendChild(_),i=t.defaultView,o=i.getComputedStyle&&"textfield"!==i.getComputedStyle(_,null).WebkitAppearance&&0!==_.offsetHeight,S.removeChild(_)):/^(search|tel)$/.test(r)||(o=/^(url|email)$/.test(r)?_.checkValidity&&_.checkValidity()===!1:_.value!=a)),L[e[d]]=!!o;return L}(P),Modernizr.addTest("hsla",function(){var e=s("a").style;return e.cssText="background-color:hsla(120,40%,100%,.5)",d(e.backgroundColor,"rgba")||d(e.backgroundColor,"hsla")});var R="CSS"in e&&"supports"in e.CSS,N="supportsCSS"in e;Modernizr.addTest("supports",R||N);var M=T._config.usePrefixes?k.split(" "):[];T._cssomPrefixes=M;var B=function(t){var r,i=w.length,o=e.CSSRule;if("undefined"==typeof o)return n;if(!t)return!1;if(t=t.replace(/^@/,""),r=t.replace(/-/g,"_").toUpperCase()+"_RULE",r in o)return"@"+t;for(var s=0;i>s;s++){var a=w[s],d=a.toUpperCase()+"_"+r;if(d in o)return"@-"+a.toLowerCase()+"-"+t}return!1};T.atRule=B;var W=T.testStyles=u,j=function(){var e=navigator.userAgent,t=e.match(/w(eb)?osbrowser/gi),n=e.match(/windows phone/gi)&&e.match(/iemobile\/([0-9])+/gi)&&parseFloat(RegExp.$1)>=9;return t||n}();j?Modernizr.addTest("fontface",!1):W('@font-face {font-family:"font";src:url("https://")}',function(e,n){var r=t.getElementById("smodernizr"),i=r.sheet||r.styleSheet,o=i?i.cssRules&&i.cssRules[0]?i.cssRules[0].cssText:i.cssText||"":"",s=/src/i.test(o)&&0===o.indexOf(n.split(" ")[0]);Modernizr.addTest("fontface",s)}),W('#modernizr{font:0/0 a}#modernizr:after{content:":)";visibility:hidden;font:7px/1 a}',function(e){Modernizr.addTest("generatedcontent",e.offsetHeight>=6)}),W("#modernizr{overflow: scroll; width: 40px; height: 40px; }#"+w.join("scrollbar{width:10px} #modernizr::").split("#").slice(1).join("#")+"scrollbar{width:10px}",function(e){Modernizr.addTest("cssscrollbar","scrollWidth"in e&&30==e.scrollWidth)}),Modernizr.addTest("formvalidation",function(){var t=s("form");if(!("checkValidity"in t&&"addEventListener"in t))return!1;if("reportValidity"in t)return!0;var n,r=!1;return Modernizr.formvalidationapi=!0,t.addEventListener("submit",function(t){(!e.opera||e.operamini)&&t.preventDefault(),t.stopPropagation()},!1),t.innerHTML='<input name="modTest" required="required" /><button></button>',W("#modernizr form{position:absolute;top:-99999em}",function(e){e.appendChild(t),n=t.getElementsByTagName("input")[0],n.addEventListener("invalid",function(e){r=!0,e.preventDefault(),e.stopPropagation()},!1),Modernizr.formvalidationmessage=!!n.validationMessage,t.getElementsByTagName("button")[0].click()}),r});var q={elem:s("modernizr")};Modernizr._q.push(function(){delete q.elem});var I={style:q.elem.style};Modernizr._q.unshift(function(){delete I.style});var V=T.testProp=function(e,t,r){return g([e],n,t,r)};Modernizr.addTest("textshadow",V("textShadow","1px 1px")),T.testAllProps=v;var F=T.prefixed=function(e,t,n){return 0===e.indexOf("@")?B(e):(-1!=e.indexOf("-")&&(e=a(e)),t?v(e,t,n):v(e,"pfx"))};Modernizr.addTest("fullscreen",!(!F("exitFullscreen",t,!1)&&!F("cancelFullScreen",t,!1))),Modernizr.addTest("filesystem",!!F("requestFileSystem",e)),T.testAllProps=y,Modernizr.addTest("cssanimations",y("animationName","a",!0)),Modernizr.addTest("backgroundsize",y("backgroundSize","100%",!0)),Modernizr.addTest("borderradius",y("borderRadius","0px",!0)),Modernizr.addTest("borderimage",y("borderImage","url() 1",!0)),Modernizr.addTest("boxshadow",y("boxShadow","1px 1px",!0)),function(){Modernizr.addTest("csscolumns",function(){var e=!1,t=y("columnCount");try{e=!!t,e&&(e=new Boolean(e))}catch(n){}return e});for(var e,t,n=["Width","Span","Fill","Gap","Rule","RuleColor","RuleStyle","RuleWidth","BreakBefore","BreakAfter","BreakInside"],r=0;r<n.length;r++)e=n[r].toLowerCase(),t=y("column"+n[r]),("breakbefore"===e||"breakafter"===e||"breakinside"==e)&&(t=t||y(n[r])),Modernizr.addTest("csscolumns."+e,t)}(),Modernizr.addTest("flexbox",y("flexBasis","1px",!0)),Modernizr.addTest("flexboxlegacy",y("boxDirection","reverse",!0)),Modernizr.addTest("overflowscrolling",y("overflowScrolling","touch",!0)),Modernizr.addTest("cssreflections",y("boxReflect","above",!0)),Modernizr.addTest("csstransforms",function(){return-1===navigator.userAgent.indexOf("Android 2.")&&y("transform","scale(1)",!0)}),Modernizr.addTest("csstransforms3d",function(){var e=!!y("perspective","1px",!0),t=Modernizr._config.usePrefixes;if(e&&(!t||"webkitPerspective"in S.style)){var n,r="#modernizr{width:0;height:0}";Modernizr.supports?n="@supports (perspective: 1px)":(n="@media (transform-3d)",t&&(n+=",(-webkit-transform-3d)")),n+="{#modernizr{width:7px;height:18px;margin:0;padding:0;border:0}}",W(r+n,function(t){e=7===t.offsetWidth&&18===t.offsetHeight})}return e}),Modernizr.addTest("csstransitions",y("transition","all",!0)),o(),r(b),delete T.addTest,delete T.addAsyncTest;for(var H=0;H<Modernizr._q.length;H++)Modernizr._q[H]();e.Modernizr=Modernizr}(window,document);

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * jQuery Easing v1.4.1 - http://gsgd.co.uk/sandbox/jquery/easing/
	 * Open source under the BSD License.
	 * Copyright © 2008 George McGinley Smith
	 * All rights reserved.
	 * https://raw.github.com/gdsmith/jquery-easing/master/LICENSE
	 */

	(function (factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(3)], __WEBPACK_AMD_DEFINE_RESULT__ = function ($) {
	            return factory($);
	        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof module === "object" && typeof module.exports === "object") {
	        exports = factory(require('jquery'));
	    } else {
	        factory(jQuery);
	    }
	})(function ($) {

	// Preserve the original jQuery "swing" easing as "jswing"
	    $.easing.jswing = $.easing.swing;

	    var pow = Math.pow,
	        sqrt = Math.sqrt,
	        sin = Math.sin,
	        cos = Math.cos,
	        PI = Math.PI,
	        c1 = 1.70158,
	        c2 = c1 * 1.525,
	        c3 = c1 + 1,
	        c4 = ( 2 * PI ) / 3,
	        c5 = ( 2 * PI ) / 4.5;

	// x is the fraction of animation progress, in the range 0..1
	    function bounceOut(x) {
	        var n1 = 7.5625,
	            d1 = 2.75;
	        if (x < 1 / d1) {
	            return n1 * x * x;
	        } else if (x < 2 / d1) {
	            return n1 * (x -= (1.5 / d1)) * x + 0.75;
	        } else if (x < 2.5 / d1) {
	            return n1 * (x -= (2.25 / d1)) * x + 0.9375;
	        } else {
	            return n1 * (x -= (2.625 / d1)) * x + 0.984375;
	        }
	    }

	    $.extend($.easing,
	        {
	            def: 'easeOutQuad',
	            swing: function (x) {
	                return $.easing[$.easing.def](x);
	            },
	            easeInQuad: function (x) {
	                return x * x;
	            },
	            easeOutQuad: function (x) {
	                return 1 - ( 1 - x ) * ( 1 - x );
	            },
	            easeInOutQuad: function (x) {
	                return x < 0.5 ?
	                    2 * x * x :
	                    1 - pow(-2 * x + 2, 2) / 2;
	            },
	            easeInCubic: function (x) {
	                return x * x * x;
	            },
	            easeOutCubic: function (x) {
	                return 1 - pow(1 - x, 3);
	            },
	            easeInOutCubic: function (x) {
	                return x < 0.5 ?
	                    4 * x * x * x :
	                    1 - pow(-2 * x + 2, 3) / 2;
	            },
	            easeInQuart: function (x) {
	                return x * x * x * x;
	            },
	            easeOutQuart: function (x) {
	                return 1 - pow(1 - x, 4);
	            },
	            easeInOutQuart: function (x) {
	                return x < 0.5 ?
	                    8 * x * x * x * x :
	                    1 - pow(-2 * x + 2, 4) / 2;
	            },
	            easeInQuint: function (x) {
	                return x * x * x * x * x;
	            },
	            easeOutQuint: function (x) {
	                return 1 - pow(1 - x, 5);
	            },
	            easeInOutQuint: function (x) {
	                return x < 0.5 ?
	                    16 * x * x * x * x * x :
	                    1 - pow(-2 * x + 2, 5) / 2;
	            },
	            easeInSine: function (x) {
	                return 1 - cos(x * PI / 2);
	            },
	            easeOutSine: function (x) {
	                return sin(x * PI / 2);
	            },
	            easeInOutSine: function (x) {
	                return -( cos(PI * x) - 1 ) / 2;
	            },
	            easeInExpo: function (x) {
	                return x === 0 ? 0 : pow(2, 10 * x - 10);
	            },
	            easeOutExpo: function (x) {
	                return x === 1 ? 1 : 1 - pow(2, -10 * x);
	            },
	            easeInOutExpo: function (x) {
	                return x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ?
	                    pow(2, 20 * x - 10) / 2 :
	                    ( 2 - pow(2, -20 * x + 10) ) / 2;
	            },
	            easeInCirc: function (x) {
	                return 1 - sqrt(1 - pow(x, 2));
	            },
	            easeOutCirc: function (x) {
	                return sqrt(1 - pow(x - 1, 2));
	            },
	            easeInOutCirc: function (x) {
	                return x < 0.5 ?
	                    ( 1 - sqrt(1 - pow(2 * x, 2)) ) / 2 :
	                    ( sqrt(1 - pow(-2 * x + 2, 2)) + 1 ) / 2;
	            },
	            easeInElastic: function (x) {
	                return x === 0 ? 0 : x === 1 ? 1 :
	                    -pow(2, 10 * x - 10) * sin(( x * 10 - 10.75 ) * c4);
	            },
	            easeOutElastic: function (x) {
	                return x === 0 ? 0 : x === 1 ? 1 :
	                    pow(2, -10 * x) * sin(( x * 10 - 0.75 ) * c4) + 1;
	            },
	            easeInOutElastic: function (x) {
	                return x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ?
	                    -( pow(2, 20 * x - 10) * sin(( 20 * x - 11.125 ) * c5)) / 2 :
	                    pow(2, -20 * x + 10) * sin(( 20 * x - 11.125 ) * c5) / 2 + 1;
	            },
	            easeInBack: function (x) {
	                return c3 * x * x * x - c1 * x * x;
	            },
	            easeOutBack: function (x) {
	                return 1 + c3 * pow(x - 1, 3) + c1 * pow(x - 1, 2);
	            },
	            easeInOutBack: function (x) {
	                return x < 0.5 ?
	                    ( pow(2 * x, 2) * ( ( c2 + 1 ) * 2 * x - c2 ) ) / 2 :
	                    ( pow(2 * x - 2, 2) * ( ( c2 + 1 ) * ( x * 2 - 2 ) + c2 ) + 2 ) / 2;
	            },
	            easeInBounce: function (x) {
	                return 1 - bounceOut(1 - x);
	            },
	            easeOutBounce: bounceOut,
	            easeInOutBounce: function (x) {
	                return x < 0.5 ?
	                    ( 1 - bounceOut(1 - 2 * x) ) / 2 :
	                    ( 1 + bounceOut(2 * x - 1) ) / 2;
	            }
	        });

	});


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**!
	 * @fileOverview Kickass library to create and place poppers near their reference elements.
	 * @version 1.12.9
	 * @license
	 * Copyright (c) 2016 Federico Zivolo and contributors
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in all
	 * copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 * SOFTWARE.
	 */
	(function (global, factory) {
		 true ? module.exports = factory() :
		typeof define === 'function' && define.amd ? define(factory) :
		(global.Popper = factory());
	}(this, (function () { 'use strict';

	var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';
	var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
	var timeoutDuration = 0;
	for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
	  if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
	    timeoutDuration = 1;
	    break;
	  }
	}

	function microtaskDebounce(fn) {
	  var called = false;
	  return function () {
	    if (called) {
	      return;
	    }
	    called = true;
	    window.Promise.resolve().then(function () {
	      called = false;
	      fn();
	    });
	  };
	}

	function taskDebounce(fn) {
	  var scheduled = false;
	  return function () {
	    if (!scheduled) {
	      scheduled = true;
	      setTimeout(function () {
	        scheduled = false;
	        fn();
	      }, timeoutDuration);
	    }
	  };
	}

	var supportsMicroTasks = isBrowser && window.Promise;

	/**
	* Create a debounced version of a method, that's asynchronously deferred
	* but called in the minimum time possible.
	*
	* @method
	* @memberof Popper.Utils
	* @argument {Function} fn
	* @returns {Function}
	*/
	var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;

	/**
	 * Check if the given variable is a function
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Any} functionToCheck - variable to check
	 * @returns {Boolean} answer to: is a function?
	 */
	function isFunction(functionToCheck) {
	  var getType = {};
	  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
	}

	/**
	 * Get CSS computed property of the given element
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Eement} element
	 * @argument {String} property
	 */
	function getStyleComputedProperty(element, property) {
	  if (element.nodeType !== 1) {
	    return [];
	  }
	  // NOTE: 1 DOM access here
	  var css = getComputedStyle(element, null);
	  return property ? css[property] : css;
	}

	/**
	 * Returns the parentNode or the host of the element
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element
	 * @returns {Element} parent
	 */
	function getParentNode(element) {
	  if (element.nodeName === 'HTML') {
	    return element;
	  }
	  return element.parentNode || element.host;
	}

	/**
	 * Returns the scrolling parent of the given element
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element
	 * @returns {Element} scroll parent
	 */
	function getScrollParent(element) {
	  // Return body, `getScroll` will take care to get the correct `scrollTop` from it
	  if (!element) {
	    return document.body;
	  }

	  switch (element.nodeName) {
	    case 'HTML':
	    case 'BODY':
	      return element.ownerDocument.body;
	    case '#document':
	      return element.body;
	  }

	  // Firefox want us to check `-x` and `-y` variations as well

	  var _getStyleComputedProp = getStyleComputedProperty(element),
	      overflow = _getStyleComputedProp.overflow,
	      overflowX = _getStyleComputedProp.overflowX,
	      overflowY = _getStyleComputedProp.overflowY;

	  if (/(auto|scroll)/.test(overflow + overflowY + overflowX)) {
	    return element;
	  }

	  return getScrollParent(getParentNode(element));
	}

	/**
	 * Returns the offset parent of the given element
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element
	 * @returns {Element} offset parent
	 */
	function getOffsetParent(element) {
	  // NOTE: 1 DOM access here
	  var offsetParent = element && element.offsetParent;
	  var nodeName = offsetParent && offsetParent.nodeName;

	  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
	    if (element) {
	      return element.ownerDocument.documentElement;
	    }

	    return document.documentElement;
	  }

	  // .offsetParent will return the closest TD or TABLE in case
	  // no offsetParent is present, I hate this job...
	  if (['TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
	    return getOffsetParent(offsetParent);
	  }

	  return offsetParent;
	}

	function isOffsetContainer(element) {
	  var nodeName = element.nodeName;

	  if (nodeName === 'BODY') {
	    return false;
	  }
	  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
	}

	/**
	 * Finds the root node (document, shadowDOM root) of the given element
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} node
	 * @returns {Element} root node
	 */
	function getRoot(node) {
	  if (node.parentNode !== null) {
	    return getRoot(node.parentNode);
	  }

	  return node;
	}

	/**
	 * Finds the offset parent common to the two provided nodes
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element1
	 * @argument {Element} element2
	 * @returns {Element} common offset parent
	 */
	function findCommonOffsetParent(element1, element2) {
	  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
	  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
	    return document.documentElement;
	  }

	  // Here we make sure to give as "start" the element that comes first in the DOM
	  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
	  var start = order ? element1 : element2;
	  var end = order ? element2 : element1;

	  // Get common ancestor container
	  var range = document.createRange();
	  range.setStart(start, 0);
	  range.setEnd(end, 0);
	  var commonAncestorContainer = range.commonAncestorContainer;

	  // Both nodes are inside #document

	  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
	    if (isOffsetContainer(commonAncestorContainer)) {
	      return commonAncestorContainer;
	    }

	    return getOffsetParent(commonAncestorContainer);
	  }

	  // one of the nodes is inside shadowDOM, find which one
	  var element1root = getRoot(element1);
	  if (element1root.host) {
	    return findCommonOffsetParent(element1root.host, element2);
	  } else {
	    return findCommonOffsetParent(element1, getRoot(element2).host);
	  }
	}

	/**
	 * Gets the scroll value of the given element in the given side (top and left)
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element
	 * @argument {String} side `top` or `left`
	 * @returns {number} amount of scrolled pixels
	 */
	function getScroll(element) {
	  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

	  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
	  var nodeName = element.nodeName;

	  if (nodeName === 'BODY' || nodeName === 'HTML') {
	    var html = element.ownerDocument.documentElement;
	    var scrollingElement = element.ownerDocument.scrollingElement || html;
	    return scrollingElement[upperSide];
	  }

	  return element[upperSide];
	}

	/*
	 * Sum or subtract the element scroll values (left and top) from a given rect object
	 * @method
	 * @memberof Popper.Utils
	 * @param {Object} rect - Rect object you want to change
	 * @param {HTMLElement} element - The element from the function reads the scroll values
	 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
	 * @return {Object} rect - The modifier rect object
	 */
	function includeScroll(rect, element) {
	  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

	  var scrollTop = getScroll(element, 'top');
	  var scrollLeft = getScroll(element, 'left');
	  var modifier = subtract ? -1 : 1;
	  rect.top += scrollTop * modifier;
	  rect.bottom += scrollTop * modifier;
	  rect.left += scrollLeft * modifier;
	  rect.right += scrollLeft * modifier;
	  return rect;
	}

	/*
	 * Helper to detect borders of a given element
	 * @method
	 * @memberof Popper.Utils
	 * @param {CSSStyleDeclaration} styles
	 * Result of `getStyleComputedProperty` on the given element
	 * @param {String} axis - `x` or `y`
	 * @return {number} borders - The borders size of the given axis
	 */

	function getBordersSize(styles, axis) {
	  var sideA = axis === 'x' ? 'Left' : 'Top';
	  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

	  return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);
	}

	/**
	 * Tells if you are running Internet Explorer 10
	 * @method
	 * @memberof Popper.Utils
	 * @returns {Boolean} isIE10
	 */
	var isIE10 = undefined;

	var isIE10$1 = function () {
	  if (isIE10 === undefined) {
	    isIE10 = navigator.appVersion.indexOf('MSIE 10') !== -1;
	  }
	  return isIE10;
	};

	function getSize(axis, body, html, computedStyle) {
	  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE10$1() ? html['offset' + axis] + computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')] + computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')] : 0);
	}

	function getWindowSizes() {
	  var body = document.body;
	  var html = document.documentElement;
	  var computedStyle = isIE10$1() && getComputedStyle(html);

	  return {
	    height: getSize('Height', body, html, computedStyle),
	    width: getSize('Width', body, html, computedStyle)
	  };
	}

	var classCallCheck = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

	var createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }

	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	}();





	var defineProperty = function (obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }

	  return obj;
	};

	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];

	    for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }

	  return target;
	};

	/**
	 * Given element offsets, generate an output similar to getBoundingClientRect
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Object} offsets
	 * @returns {Object} ClientRect like output
	 */
	function getClientRect(offsets) {
	  return _extends({}, offsets, {
	    right: offsets.left + offsets.width,
	    bottom: offsets.top + offsets.height
	  });
	}

	/**
	 * Get bounding client rect of given element
	 * @method
	 * @memberof Popper.Utils
	 * @param {HTMLElement} element
	 * @return {Object} client rect
	 */
	function getBoundingClientRect(element) {
	  var rect = {};

	  // IE10 10 FIX: Please, don't ask, the element isn't
	  // considered in DOM in some circumstances...
	  // This isn't reproducible in IE10 compatibility mode of IE11
	  if (isIE10$1()) {
	    try {
	      rect = element.getBoundingClientRect();
	      var scrollTop = getScroll(element, 'top');
	      var scrollLeft = getScroll(element, 'left');
	      rect.top += scrollTop;
	      rect.left += scrollLeft;
	      rect.bottom += scrollTop;
	      rect.right += scrollLeft;
	    } catch (err) {}
	  } else {
	    rect = element.getBoundingClientRect();
	  }

	  var result = {
	    left: rect.left,
	    top: rect.top,
	    width: rect.right - rect.left,
	    height: rect.bottom - rect.top
	  };

	  // subtract scrollbar size from sizes
	  var sizes = element.nodeName === 'HTML' ? getWindowSizes() : {};
	  var width = sizes.width || element.clientWidth || result.right - result.left;
	  var height = sizes.height || element.clientHeight || result.bottom - result.top;

	  var horizScrollbar = element.offsetWidth - width;
	  var vertScrollbar = element.offsetHeight - height;

	  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
	  // we make this check conditional for performance reasons
	  if (horizScrollbar || vertScrollbar) {
	    var styles = getStyleComputedProperty(element);
	    horizScrollbar -= getBordersSize(styles, 'x');
	    vertScrollbar -= getBordersSize(styles, 'y');

	    result.width -= horizScrollbar;
	    result.height -= vertScrollbar;
	  }

	  return getClientRect(result);
	}

	function getOffsetRectRelativeToArbitraryNode(children, parent) {
	  var isIE10 = isIE10$1();
	  var isHTML = parent.nodeName === 'HTML';
	  var childrenRect = getBoundingClientRect(children);
	  var parentRect = getBoundingClientRect(parent);
	  var scrollParent = getScrollParent(children);

	  var styles = getStyleComputedProperty(parent);
	  var borderTopWidth = parseFloat(styles.borderTopWidth, 10);
	  var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);

	  var offsets = getClientRect({
	    top: childrenRect.top - parentRect.top - borderTopWidth,
	    left: childrenRect.left - parentRect.left - borderLeftWidth,
	    width: childrenRect.width,
	    height: childrenRect.height
	  });
	  offsets.marginTop = 0;
	  offsets.marginLeft = 0;

	  // Subtract margins of documentElement in case it's being used as parent
	  // we do this only on HTML because it's the only element that behaves
	  // differently when margins are applied to it. The margins are included in
	  // the box of the documentElement, in the other cases not.
	  if (!isIE10 && isHTML) {
	    var marginTop = parseFloat(styles.marginTop, 10);
	    var marginLeft = parseFloat(styles.marginLeft, 10);

	    offsets.top -= borderTopWidth - marginTop;
	    offsets.bottom -= borderTopWidth - marginTop;
	    offsets.left -= borderLeftWidth - marginLeft;
	    offsets.right -= borderLeftWidth - marginLeft;

	    // Attach marginTop and marginLeft because in some circumstances we may need them
	    offsets.marginTop = marginTop;
	    offsets.marginLeft = marginLeft;
	  }

	  if (isIE10 ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
	    offsets = includeScroll(offsets, parent);
	  }

	  return offsets;
	}

	function getViewportOffsetRectRelativeToArtbitraryNode(element) {
	  var html = element.ownerDocument.documentElement;
	  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
	  var width = Math.max(html.clientWidth, window.innerWidth || 0);
	  var height = Math.max(html.clientHeight, window.innerHeight || 0);

	  var scrollTop = getScroll(html);
	  var scrollLeft = getScroll(html, 'left');

	  var offset = {
	    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
	    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
	    width: width,
	    height: height
	  };

	  return getClientRect(offset);
	}

	/**
	 * Check if the given element is fixed or is inside a fixed parent
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element
	 * @argument {Element} customContainer
	 * @returns {Boolean} answer to "isFixed?"
	 */
	function isFixed(element) {
	  var nodeName = element.nodeName;
	  if (nodeName === 'BODY' || nodeName === 'HTML') {
	    return false;
	  }
	  if (getStyleComputedProperty(element, 'position') === 'fixed') {
	    return true;
	  }
	  return isFixed(getParentNode(element));
	}

	/**
	 * Computed the boundaries limits and return them
	 * @method
	 * @memberof Popper.Utils
	 * @param {HTMLElement} popper
	 * @param {HTMLElement} reference
	 * @param {number} padding
	 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
	 * @returns {Object} Coordinates of the boundaries
	 */
	function getBoundaries(popper, reference, padding, boundariesElement) {
	  // NOTE: 1 DOM access here
	  var boundaries = { top: 0, left: 0 };
	  var offsetParent = findCommonOffsetParent(popper, reference);

	  // Handle viewport case
	  if (boundariesElement === 'viewport') {
	    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent);
	  } else {
	    // Handle other cases based on DOM element used as boundaries
	    var boundariesNode = void 0;
	    if (boundariesElement === 'scrollParent') {
	      boundariesNode = getScrollParent(getParentNode(reference));
	      if (boundariesNode.nodeName === 'BODY') {
	        boundariesNode = popper.ownerDocument.documentElement;
	      }
	    } else if (boundariesElement === 'window') {
	      boundariesNode = popper.ownerDocument.documentElement;
	    } else {
	      boundariesNode = boundariesElement;
	    }

	    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent);

	    // In case of HTML, we need a different computation
	    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
	      var _getWindowSizes = getWindowSizes(),
	          height = _getWindowSizes.height,
	          width = _getWindowSizes.width;

	      boundaries.top += offsets.top - offsets.marginTop;
	      boundaries.bottom = height + offsets.top;
	      boundaries.left += offsets.left - offsets.marginLeft;
	      boundaries.right = width + offsets.left;
	    } else {
	      // for all the other DOM elements, this one is good
	      boundaries = offsets;
	    }
	  }

	  // Add paddings
	  boundaries.left += padding;
	  boundaries.top += padding;
	  boundaries.right -= padding;
	  boundaries.bottom -= padding;

	  return boundaries;
	}

	function getArea(_ref) {
	  var width = _ref.width,
	      height = _ref.height;

	  return width * height;
	}

	/**
	 * Utility used to transform the `auto` placement to the placement with more
	 * available space.
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Object} data - The data object generated by update method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
	  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

	  if (placement.indexOf('auto') === -1) {
	    return placement;
	  }

	  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

	  var rects = {
	    top: {
	      width: boundaries.width,
	      height: refRect.top - boundaries.top
	    },
	    right: {
	      width: boundaries.right - refRect.right,
	      height: boundaries.height
	    },
	    bottom: {
	      width: boundaries.width,
	      height: boundaries.bottom - refRect.bottom
	    },
	    left: {
	      width: refRect.left - boundaries.left,
	      height: boundaries.height
	    }
	  };

	  var sortedAreas = Object.keys(rects).map(function (key) {
	    return _extends({
	      key: key
	    }, rects[key], {
	      area: getArea(rects[key])
	    });
	  }).sort(function (a, b) {
	    return b.area - a.area;
	  });

	  var filteredAreas = sortedAreas.filter(function (_ref2) {
	    var width = _ref2.width,
	        height = _ref2.height;
	    return width >= popper.clientWidth && height >= popper.clientHeight;
	  });

	  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

	  var variation = placement.split('-')[1];

	  return computedPlacement + (variation ? '-' + variation : '');
	}

	/**
	 * Get offsets to the reference element
	 * @method
	 * @memberof Popper.Utils
	 * @param {Object} state
	 * @param {Element} popper - the popper element
	 * @param {Element} reference - the reference element (the popper will be relative to this)
	 * @returns {Object} An object containing the offsets which will be applied to the popper
	 */
	function getReferenceOffsets(state, popper, reference) {
	  var commonOffsetParent = findCommonOffsetParent(popper, reference);
	  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent);
	}

	/**
	 * Get the outer sizes of the given element (offset size + margins)
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element
	 * @returns {Object} object containing width and height properties
	 */
	function getOuterSizes(element) {
	  var styles = getComputedStyle(element);
	  var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);
	  var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);
	  var result = {
	    width: element.offsetWidth + y,
	    height: element.offsetHeight + x
	  };
	  return result;
	}

	/**
	 * Get the opposite placement of the given one
	 * @method
	 * @memberof Popper.Utils
	 * @argument {String} placement
	 * @returns {String} flipped placement
	 */
	function getOppositePlacement(placement) {
	  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
	  return placement.replace(/left|right|bottom|top/g, function (matched) {
	    return hash[matched];
	  });
	}

	/**
	 * Get offsets to the popper
	 * @method
	 * @memberof Popper.Utils
	 * @param {Object} position - CSS position the Popper will get applied
	 * @param {HTMLElement} popper - the popper element
	 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
	 * @param {String} placement - one of the valid placement options
	 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
	 */
	function getPopperOffsets(popper, referenceOffsets, placement) {
	  placement = placement.split('-')[0];

	  // Get popper node sizes
	  var popperRect = getOuterSizes(popper);

	  // Add position, width and height to our offsets object
	  var popperOffsets = {
	    width: popperRect.width,
	    height: popperRect.height
	  };

	  // depending by the popper placement we have to compute its offsets slightly differently
	  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
	  var mainSide = isHoriz ? 'top' : 'left';
	  var secondarySide = isHoriz ? 'left' : 'top';
	  var measurement = isHoriz ? 'height' : 'width';
	  var secondaryMeasurement = !isHoriz ? 'height' : 'width';

	  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
	  if (placement === secondarySide) {
	    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
	  } else {
	    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
	  }

	  return popperOffsets;
	}

	/**
	 * Mimics the `find` method of Array
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Array} arr
	 * @argument prop
	 * @argument value
	 * @returns index or -1
	 */
	function find(arr, check) {
	  // use native find if supported
	  if (Array.prototype.find) {
	    return arr.find(check);
	  }

	  // use `filter` to obtain the same behavior of `find`
	  return arr.filter(check)[0];
	}

	/**
	 * Return the index of the matching object
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Array} arr
	 * @argument prop
	 * @argument value
	 * @returns index or -1
	 */
	function findIndex(arr, prop, value) {
	  // use native findIndex if supported
	  if (Array.prototype.findIndex) {
	    return arr.findIndex(function (cur) {
	      return cur[prop] === value;
	    });
	  }

	  // use `find` + `indexOf` if `findIndex` isn't supported
	  var match = find(arr, function (obj) {
	    return obj[prop] === value;
	  });
	  return arr.indexOf(match);
	}

	/**
	 * Loop trough the list of modifiers and run them in order,
	 * each of them will then edit the data object.
	 * @method
	 * @memberof Popper.Utils
	 * @param {dataObject} data
	 * @param {Array} modifiers
	 * @param {String} ends - Optional modifier name used as stopper
	 * @returns {dataObject}
	 */
	function runModifiers(modifiers, data, ends) {
	  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));

	  modifiersToRun.forEach(function (modifier) {
	    if (modifier['function']) {
	      // eslint-disable-line dot-notation
	      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
	    }
	    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
	    if (modifier.enabled && isFunction(fn)) {
	      // Add properties to offsets to make them a complete clientRect object
	      // we do this before each modifier to make sure the previous one doesn't
	      // mess with these values
	      data.offsets.popper = getClientRect(data.offsets.popper);
	      data.offsets.reference = getClientRect(data.offsets.reference);

	      data = fn(data, modifier);
	    }
	  });

	  return data;
	}

	/**
	 * Updates the position of the popper, computing the new offsets and applying
	 * the new style.<br />
	 * Prefer `scheduleUpdate` over `update` because of performance reasons.
	 * @method
	 * @memberof Popper
	 */
	function update() {
	  // if popper is destroyed, don't perform any further update
	  if (this.state.isDestroyed) {
	    return;
	  }

	  var data = {
	    instance: this,
	    styles: {},
	    arrowStyles: {},
	    attributes: {},
	    flipped: false,
	    offsets: {}
	  };

	  // compute reference element offsets
	  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference);

	  // compute auto placement, store placement inside the data object,
	  // modifiers will be able to edit `placement` if needed
	  // and refer to originalPlacement to know the original value
	  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

	  // store the computed placement inside `originalPlacement`
	  data.originalPlacement = data.placement;

	  // compute the popper offsets
	  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
	  data.offsets.popper.position = 'absolute';

	  // run the modifiers
	  data = runModifiers(this.modifiers, data);

	  // the first `update` will call `onCreate` callback
	  // the other ones will call `onUpdate` callback
	  if (!this.state.isCreated) {
	    this.state.isCreated = true;
	    this.options.onCreate(data);
	  } else {
	    this.options.onUpdate(data);
	  }
	}

	/**
	 * Helper used to know if the given modifier is enabled.
	 * @method
	 * @memberof Popper.Utils
	 * @returns {Boolean}
	 */
	function isModifierEnabled(modifiers, modifierName) {
	  return modifiers.some(function (_ref) {
	    var name = _ref.name,
	        enabled = _ref.enabled;
	    return enabled && name === modifierName;
	  });
	}

	/**
	 * Get the prefixed supported property name
	 * @method
	 * @memberof Popper.Utils
	 * @argument {String} property (camelCase)
	 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
	 */
	function getSupportedPropertyName(property) {
	  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
	  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

	  for (var i = 0; i < prefixes.length - 1; i++) {
	    var prefix = prefixes[i];
	    var toCheck = prefix ? '' + prefix + upperProp : property;
	    if (typeof document.body.style[toCheck] !== 'undefined') {
	      return toCheck;
	    }
	  }
	  return null;
	}

	/**
	 * Destroy the popper
	 * @method
	 * @memberof Popper
	 */
	function destroy() {
	  this.state.isDestroyed = true;

	  // touch DOM only if `applyStyle` modifier is enabled
	  if (isModifierEnabled(this.modifiers, 'applyStyle')) {
	    this.popper.removeAttribute('x-placement');
	    this.popper.style.left = '';
	    this.popper.style.position = '';
	    this.popper.style.top = '';
	    this.popper.style[getSupportedPropertyName('transform')] = '';
	  }

	  this.disableEventListeners();

	  // remove the popper if user explicity asked for the deletion on destroy
	  // do not use `remove` because IE11 doesn't support it
	  if (this.options.removeOnDestroy) {
	    this.popper.parentNode.removeChild(this.popper);
	  }
	  return this;
	}

	/**
	 * Get the window associated with the element
	 * @argument {Element} element
	 * @returns {Window}
	 */
	function getWindow(element) {
	  var ownerDocument = element.ownerDocument;
	  return ownerDocument ? ownerDocument.defaultView : window;
	}

	function attachToScrollParents(scrollParent, event, callback, scrollParents) {
	  var isBody = scrollParent.nodeName === 'BODY';
	  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
	  target.addEventListener(event, callback, { passive: true });

	  if (!isBody) {
	    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
	  }
	  scrollParents.push(target);
	}

	/**
	 * Setup needed event listeners used to update the popper position
	 * @method
	 * @memberof Popper.Utils
	 * @private
	 */
	function setupEventListeners(reference, options, state, updateBound) {
	  // Resize event listener on window
	  state.updateBound = updateBound;
	  getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });

	  // Scroll event listener on scroll parents
	  var scrollElement = getScrollParent(reference);
	  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
	  state.scrollElement = scrollElement;
	  state.eventsEnabled = true;

	  return state;
	}

	/**
	 * It will add resize/scroll events and start recalculating
	 * position of the popper element when they are triggered.
	 * @method
	 * @memberof Popper
	 */
	function enableEventListeners() {
	  if (!this.state.eventsEnabled) {
	    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
	  }
	}

	/**
	 * Remove event listeners used to update the popper position
	 * @method
	 * @memberof Popper.Utils
	 * @private
	 */
	function removeEventListeners(reference, state) {
	  // Remove resize event listener on window
	  getWindow(reference).removeEventListener('resize', state.updateBound);

	  // Remove scroll event listener on scroll parents
	  state.scrollParents.forEach(function (target) {
	    target.removeEventListener('scroll', state.updateBound);
	  });

	  // Reset state
	  state.updateBound = null;
	  state.scrollParents = [];
	  state.scrollElement = null;
	  state.eventsEnabled = false;
	  return state;
	}

	/**
	 * It will remove resize/scroll events and won't recalculate popper position
	 * when they are triggered. It also won't trigger onUpdate callback anymore,
	 * unless you call `update` method manually.
	 * @method
	 * @memberof Popper
	 */
	function disableEventListeners() {
	  if (this.state.eventsEnabled) {
	    cancelAnimationFrame(this.scheduleUpdate);
	    this.state = removeEventListeners(this.reference, this.state);
	  }
	}

	/**
	 * Tells if a given input is a number
	 * @method
	 * @memberof Popper.Utils
	 * @param {*} input to check
	 * @return {Boolean}
	 */
	function isNumeric(n) {
	  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
	}

	/**
	 * Set the style to the given popper
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element - Element to apply the style to
	 * @argument {Object} styles
	 * Object with a list of properties and values which will be applied to the element
	 */
	function setStyles(element, styles) {
	  Object.keys(styles).forEach(function (prop) {
	    var unit = '';
	    // add unit if the value is numeric and is one of the following
	    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
	      unit = 'px';
	    }
	    element.style[prop] = styles[prop] + unit;
	  });
	}

	/**
	 * Set the attributes to the given popper
	 * @method
	 * @memberof Popper.Utils
	 * @argument {Element} element - Element to apply the attributes to
	 * @argument {Object} styles
	 * Object with a list of properties and values which will be applied to the element
	 */
	function setAttributes(element, attributes) {
	  Object.keys(attributes).forEach(function (prop) {
	    var value = attributes[prop];
	    if (value !== false) {
	      element.setAttribute(prop, attributes[prop]);
	    } else {
	      element.removeAttribute(prop);
	    }
	  });
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by `update` method
	 * @argument {Object} data.styles - List of style properties - values to apply to popper element
	 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The same data object
	 */
	function applyStyle(data) {
	  // any property present in `data.styles` will be applied to the popper,
	  // in this way we can make the 3rd party modifiers add custom styles to it
	  // Be aware, modifiers could override the properties defined in the previous
	  // lines of this modifier!
	  setStyles(data.instance.popper, data.styles);

	  // any property present in `data.attributes` will be applied to the popper,
	  // they will be set as HTML attributes of the element
	  setAttributes(data.instance.popper, data.attributes);

	  // if arrowElement is defined and arrowStyles has some properties
	  if (data.arrowElement && Object.keys(data.arrowStyles).length) {
	    setStyles(data.arrowElement, data.arrowStyles);
	  }

	  return data;
	}

	/**
	 * Set the x-placement attribute before everything else because it could be used
	 * to add margins to the popper margins needs to be calculated to get the
	 * correct popper offsets.
	 * @method
	 * @memberof Popper.modifiers
	 * @param {HTMLElement} reference - The reference element used to position the popper
	 * @param {HTMLElement} popper - The HTML element used as popper.
	 * @param {Object} options - Popper.js options
	 */
	function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
	  // compute reference element offsets
	  var referenceOffsets = getReferenceOffsets(state, popper, reference);

	  // compute auto placement, store placement inside the data object,
	  // modifiers will be able to edit `placement` if needed
	  // and refer to originalPlacement to know the original value
	  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

	  popper.setAttribute('x-placement', placement);

	  // Apply `position` to popper before anything else because
	  // without the position applied we can't guarantee correct computations
	  setStyles(popper, { position: 'absolute' });

	  return options;
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by `update` method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function computeStyle(data, options) {
	  var x = options.x,
	      y = options.y;
	  var popper = data.offsets.popper;

	  // Remove this legacy support in Popper.js v2

	  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
	    return modifier.name === 'applyStyle';
	  }).gpuAcceleration;
	  if (legacyGpuAccelerationOption !== undefined) {
	    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
	  }
	  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

	  var offsetParent = getOffsetParent(data.instance.popper);
	  var offsetParentRect = getBoundingClientRect(offsetParent);

	  // Styles
	  var styles = {
	    position: popper.position
	  };

	  // floor sides to avoid blurry text
	  var offsets = {
	    left: Math.floor(popper.left),
	    top: Math.floor(popper.top),
	    bottom: Math.floor(popper.bottom),
	    right: Math.floor(popper.right)
	  };

	  var sideA = x === 'bottom' ? 'top' : 'bottom';
	  var sideB = y === 'right' ? 'left' : 'right';

	  // if gpuAcceleration is set to `true` and transform is supported,
	  //  we use `translate3d` to apply the position to the popper we
	  // automatically use the supported prefixed version if needed
	  var prefixedProperty = getSupportedPropertyName('transform');

	  // now, let's make a step back and look at this code closely (wtf?)
	  // If the content of the popper grows once it's been positioned, it
	  // may happen that the popper gets misplaced because of the new content
	  // overflowing its reference element
	  // To avoid this problem, we provide two options (x and y), which allow
	  // the consumer to define the offset origin.
	  // If we position a popper on top of a reference element, we can set
	  // `x` to `top` to make the popper grow towards its top instead of
	  // its bottom.
	  var left = void 0,
	      top = void 0;
	  if (sideA === 'bottom') {
	    top = -offsetParentRect.height + offsets.bottom;
	  } else {
	    top = offsets.top;
	  }
	  if (sideB === 'right') {
	    left = -offsetParentRect.width + offsets.right;
	  } else {
	    left = offsets.left;
	  }
	  if (gpuAcceleration && prefixedProperty) {
	    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
	    styles[sideA] = 0;
	    styles[sideB] = 0;
	    styles.willChange = 'transform';
	  } else {
	    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
	    var invertTop = sideA === 'bottom' ? -1 : 1;
	    var invertLeft = sideB === 'right' ? -1 : 1;
	    styles[sideA] = top * invertTop;
	    styles[sideB] = left * invertLeft;
	    styles.willChange = sideA + ', ' + sideB;
	  }

	  // Attributes
	  var attributes = {
	    'x-placement': data.placement
	  };

	  // Update `data` attributes, styles and arrowStyles
	  data.attributes = _extends({}, attributes, data.attributes);
	  data.styles = _extends({}, styles, data.styles);
	  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);

	  return data;
	}

	/**
	 * Helper used to know if the given modifier depends from another one.<br />
	 * It checks if the needed modifier is listed and enabled.
	 * @method
	 * @memberof Popper.Utils
	 * @param {Array} modifiers - list of modifiers
	 * @param {String} requestingName - name of requesting modifier
	 * @param {String} requestedName - name of requested modifier
	 * @returns {Boolean}
	 */
	function isModifierRequired(modifiers, requestingName, requestedName) {
	  var requesting = find(modifiers, function (_ref) {
	    var name = _ref.name;
	    return name === requestingName;
	  });

	  var isRequired = !!requesting && modifiers.some(function (modifier) {
	    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
	  });

	  if (!isRequired) {
	    var _requesting = '`' + requestingName + '`';
	    var requested = '`' + requestedName + '`';
	    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
	  }
	  return isRequired;
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by update method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function arrow(data, options) {
	  var _data$offsets$arrow;

	  // arrow depends on keepTogether in order to work
	  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
	    return data;
	  }

	  var arrowElement = options.element;

	  // if arrowElement is a string, suppose it's a CSS selector
	  if (typeof arrowElement === 'string') {
	    arrowElement = data.instance.popper.querySelector(arrowElement);

	    // if arrowElement is not found, don't run the modifier
	    if (!arrowElement) {
	      return data;
	    }
	  } else {
	    // if the arrowElement isn't a query selector we must check that the
	    // provided DOM node is child of its popper node
	    if (!data.instance.popper.contains(arrowElement)) {
	      console.warn('WARNING: `arrow.element` must be child of its popper element!');
	      return data;
	    }
	  }

	  var placement = data.placement.split('-')[0];
	  var _data$offsets = data.offsets,
	      popper = _data$offsets.popper,
	      reference = _data$offsets.reference;

	  var isVertical = ['left', 'right'].indexOf(placement) !== -1;

	  var len = isVertical ? 'height' : 'width';
	  var sideCapitalized = isVertical ? 'Top' : 'Left';
	  var side = sideCapitalized.toLowerCase();
	  var altSide = isVertical ? 'left' : 'top';
	  var opSide = isVertical ? 'bottom' : 'right';
	  var arrowElementSize = getOuterSizes(arrowElement)[len];

	  //
	  // extends keepTogether behavior making sure the popper and its
	  // reference have enough pixels in conjuction
	  //

	  // top/left side
	  if (reference[opSide] - arrowElementSize < popper[side]) {
	    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
	  }
	  // bottom/right side
	  if (reference[side] + arrowElementSize > popper[opSide]) {
	    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
	  }
	  data.offsets.popper = getClientRect(data.offsets.popper);

	  // compute center of the popper
	  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

	  // Compute the sideValue using the updated popper offsets
	  // take popper margin in account because we don't have this info available
	  var css = getStyleComputedProperty(data.instance.popper);
	  var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);
	  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);
	  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;

	  // prevent arrowElement from being placed not contiguously to its popper
	  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

	  data.arrowElement = arrowElement;
	  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);

	  return data;
	}

	/**
	 * Get the opposite placement variation of the given one
	 * @method
	 * @memberof Popper.Utils
	 * @argument {String} placement variation
	 * @returns {String} flipped placement variation
	 */
	function getOppositeVariation(variation) {
	  if (variation === 'end') {
	    return 'start';
	  } else if (variation === 'start') {
	    return 'end';
	  }
	  return variation;
	}

	/**
	 * List of accepted placements to use as values of the `placement` option.<br />
	 * Valid placements are:
	 * - `auto`
	 * - `top`
	 * - `right`
	 * - `bottom`
	 * - `left`
	 *
	 * Each placement can have a variation from this list:
	 * - `-start`
	 * - `-end`
	 *
	 * Variations are interpreted easily if you think of them as the left to right
	 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
	 * is right.<br />
	 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
	 *
	 * Some valid examples are:
	 * - `top-end` (on top of reference, right aligned)
	 * - `right-start` (on right of reference, top aligned)
	 * - `bottom` (on bottom, centered)
	 * - `auto-right` (on the side with more space available, alignment depends by placement)
	 *
	 * @static
	 * @type {Array}
	 * @enum {String}
	 * @readonly
	 * @method placements
	 * @memberof Popper
	 */
	var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

	// Get rid of `auto` `auto-start` and `auto-end`
	var validPlacements = placements.slice(3);

	/**
	 * Given an initial placement, returns all the subsequent placements
	 * clockwise (or counter-clockwise).
	 *
	 * @method
	 * @memberof Popper.Utils
	 * @argument {String} placement - A valid placement (it accepts variations)
	 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
	 * @returns {Array} placements including their variations
	 */
	function clockwise(placement) {
	  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	  var index = validPlacements.indexOf(placement);
	  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
	  return counter ? arr.reverse() : arr;
	}

	var BEHAVIORS = {
	  FLIP: 'flip',
	  CLOCKWISE: 'clockwise',
	  COUNTERCLOCKWISE: 'counterclockwise'
	};

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by update method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function flip(data, options) {
	  // if `inner` modifier is enabled, we can't use the `flip` modifier
	  if (isModifierEnabled(data.instance.modifiers, 'inner')) {
	    return data;
	  }

	  if (data.flipped && data.placement === data.originalPlacement) {
	    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
	    return data;
	  }

	  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement);

	  var placement = data.placement.split('-')[0];
	  var placementOpposite = getOppositePlacement(placement);
	  var variation = data.placement.split('-')[1] || '';

	  var flipOrder = [];

	  switch (options.behavior) {
	    case BEHAVIORS.FLIP:
	      flipOrder = [placement, placementOpposite];
	      break;
	    case BEHAVIORS.CLOCKWISE:
	      flipOrder = clockwise(placement);
	      break;
	    case BEHAVIORS.COUNTERCLOCKWISE:
	      flipOrder = clockwise(placement, true);
	      break;
	    default:
	      flipOrder = options.behavior;
	  }

	  flipOrder.forEach(function (step, index) {
	    if (placement !== step || flipOrder.length === index + 1) {
	      return data;
	    }

	    placement = data.placement.split('-')[0];
	    placementOpposite = getOppositePlacement(placement);

	    var popperOffsets = data.offsets.popper;
	    var refOffsets = data.offsets.reference;

	    // using floor because the reference offsets may contain decimals we are not going to consider here
	    var floor = Math.floor;
	    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

	    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
	    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
	    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
	    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

	    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

	    // flip the variation if required
	    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
	    var flippedVariation = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

	    if (overlapsRef || overflowsBoundaries || flippedVariation) {
	      // this boolean to detect any flip loop
	      data.flipped = true;

	      if (overlapsRef || overflowsBoundaries) {
	        placement = flipOrder[index + 1];
	      }

	      if (flippedVariation) {
	        variation = getOppositeVariation(variation);
	      }

	      data.placement = placement + (variation ? '-' + variation : '');

	      // this object contains `position`, we want to preserve it along with
	      // any additional property we may add in the future
	      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

	      data = runModifiers(data.instance.modifiers, data, 'flip');
	    }
	  });
	  return data;
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by update method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function keepTogether(data) {
	  var _data$offsets = data.offsets,
	      popper = _data$offsets.popper,
	      reference = _data$offsets.reference;

	  var placement = data.placement.split('-')[0];
	  var floor = Math.floor;
	  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
	  var side = isVertical ? 'right' : 'bottom';
	  var opSide = isVertical ? 'left' : 'top';
	  var measurement = isVertical ? 'width' : 'height';

	  if (popper[side] < floor(reference[opSide])) {
	    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
	  }
	  if (popper[opSide] > floor(reference[side])) {
	    data.offsets.popper[opSide] = floor(reference[side]);
	  }

	  return data;
	}

	/**
	 * Converts a string containing value + unit into a px value number
	 * @function
	 * @memberof {modifiers~offset}
	 * @private
	 * @argument {String} str - Value + unit string
	 * @argument {String} measurement - `height` or `width`
	 * @argument {Object} popperOffsets
	 * @argument {Object} referenceOffsets
	 * @returns {Number|String}
	 * Value in pixels, or original string if no values were extracted
	 */
	function toValue(str, measurement, popperOffsets, referenceOffsets) {
	  // separate value from unit
	  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
	  var value = +split[1];
	  var unit = split[2];

	  // If it's not a number it's an operator, I guess
	  if (!value) {
	    return str;
	  }

	  if (unit.indexOf('%') === 0) {
	    var element = void 0;
	    switch (unit) {
	      case '%p':
	        element = popperOffsets;
	        break;
	      case '%':
	      case '%r':
	      default:
	        element = referenceOffsets;
	    }

	    var rect = getClientRect(element);
	    return rect[measurement] / 100 * value;
	  } else if (unit === 'vh' || unit === 'vw') {
	    // if is a vh or vw, we calculate the size based on the viewport
	    var size = void 0;
	    if (unit === 'vh') {
	      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
	    } else {
	      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
	    }
	    return size / 100 * value;
	  } else {
	    // if is an explicit pixel unit, we get rid of the unit and keep the value
	    // if is an implicit unit, it's px, and we return just the value
	    return value;
	  }
	}

	/**
	 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
	 * @function
	 * @memberof {modifiers~offset}
	 * @private
	 * @argument {String} offset
	 * @argument {Object} popperOffsets
	 * @argument {Object} referenceOffsets
	 * @argument {String} basePlacement
	 * @returns {Array} a two cells array with x and y offsets in numbers
	 */
	function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
	  var offsets = [0, 0];

	  // Use height if placement is left or right and index is 0 otherwise use width
	  // in this way the first offset will use an axis and the second one
	  // will use the other one
	  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

	  // Split the offset string to obtain a list of values and operands
	  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
	  var fragments = offset.split(/(\+|\-)/).map(function (frag) {
	    return frag.trim();
	  });

	  // Detect if the offset string contains a pair of values or a single one
	  // they could be separated by comma or space
	  var divider = fragments.indexOf(find(fragments, function (frag) {
	    return frag.search(/,|\s/) !== -1;
	  }));

	  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
	    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
	  }

	  // If divider is found, we divide the list of values and operands to divide
	  // them by ofset X and Y.
	  var splitRegex = /\s*,\s*|\s+/;
	  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

	  // Convert the values with units to absolute pixels to allow our computations
	  ops = ops.map(function (op, index) {
	    // Most of the units rely on the orientation of the popper
	    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
	    var mergeWithPrevious = false;
	    return op
	    // This aggregates any `+` or `-` sign that aren't considered operators
	    // e.g.: 10 + +5 => [10, +, +5]
	    .reduce(function (a, b) {
	      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
	        a[a.length - 1] = b;
	        mergeWithPrevious = true;
	        return a;
	      } else if (mergeWithPrevious) {
	        a[a.length - 1] += b;
	        mergeWithPrevious = false;
	        return a;
	      } else {
	        return a.concat(b);
	      }
	    }, [])
	    // Here we convert the string values into number values (in px)
	    .map(function (str) {
	      return toValue(str, measurement, popperOffsets, referenceOffsets);
	    });
	  });

	  // Loop trough the offsets arrays and execute the operations
	  ops.forEach(function (op, index) {
	    op.forEach(function (frag, index2) {
	      if (isNumeric(frag)) {
	        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
	      }
	    });
	  });
	  return offsets;
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by update method
	 * @argument {Object} options - Modifiers configuration and options
	 * @argument {Number|String} options.offset=0
	 * The offset value as described in the modifier description
	 * @returns {Object} The data object, properly modified
	 */
	function offset(data, _ref) {
	  var offset = _ref.offset;
	  var placement = data.placement,
	      _data$offsets = data.offsets,
	      popper = _data$offsets.popper,
	      reference = _data$offsets.reference;

	  var basePlacement = placement.split('-')[0];

	  var offsets = void 0;
	  if (isNumeric(+offset)) {
	    offsets = [+offset, 0];
	  } else {
	    offsets = parseOffset(offset, popper, reference, basePlacement);
	  }

	  if (basePlacement === 'left') {
	    popper.top += offsets[0];
	    popper.left -= offsets[1];
	  } else if (basePlacement === 'right') {
	    popper.top += offsets[0];
	    popper.left += offsets[1];
	  } else if (basePlacement === 'top') {
	    popper.left += offsets[0];
	    popper.top -= offsets[1];
	  } else if (basePlacement === 'bottom') {
	    popper.left += offsets[0];
	    popper.top += offsets[1];
	  }

	  data.popper = popper;
	  return data;
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by `update` method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function preventOverflow(data, options) {
	  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);

	  // If offsetParent is the reference element, we really want to
	  // go one step up and use the next offsetParent as reference to
	  // avoid to make this modifier completely useless and look like broken
	  if (data.instance.reference === boundariesElement) {
	    boundariesElement = getOffsetParent(boundariesElement);
	  }

	  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement);
	  options.boundaries = boundaries;

	  var order = options.priority;
	  var popper = data.offsets.popper;

	  var check = {
	    primary: function primary(placement) {
	      var value = popper[placement];
	      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
	        value = Math.max(popper[placement], boundaries[placement]);
	      }
	      return defineProperty({}, placement, value);
	    },
	    secondary: function secondary(placement) {
	      var mainSide = placement === 'right' ? 'left' : 'top';
	      var value = popper[mainSide];
	      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
	        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
	      }
	      return defineProperty({}, mainSide, value);
	    }
	  };

	  order.forEach(function (placement) {
	    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
	    popper = _extends({}, popper, check[side](placement));
	  });

	  data.offsets.popper = popper;

	  return data;
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by `update` method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function shift(data) {
	  var placement = data.placement;
	  var basePlacement = placement.split('-')[0];
	  var shiftvariation = placement.split('-')[1];

	  // if shift shiftvariation is specified, run the modifier
	  if (shiftvariation) {
	    var _data$offsets = data.offsets,
	        reference = _data$offsets.reference,
	        popper = _data$offsets.popper;

	    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
	    var side = isVertical ? 'left' : 'top';
	    var measurement = isVertical ? 'width' : 'height';

	    var shiftOffsets = {
	      start: defineProperty({}, side, reference[side]),
	      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
	    };

	    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
	  }

	  return data;
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by update method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function hide(data) {
	  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
	    return data;
	  }

	  var refRect = data.offsets.reference;
	  var bound = find(data.instance.modifiers, function (modifier) {
	    return modifier.name === 'preventOverflow';
	  }).boundaries;

	  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
	    // Avoid unnecessary DOM access if visibility hasn't changed
	    if (data.hide === true) {
	      return data;
	    }

	    data.hide = true;
	    data.attributes['x-out-of-boundaries'] = '';
	  } else {
	    // Avoid unnecessary DOM access if visibility hasn't changed
	    if (data.hide === false) {
	      return data;
	    }

	    data.hide = false;
	    data.attributes['x-out-of-boundaries'] = false;
	  }

	  return data;
	}

	/**
	 * @function
	 * @memberof Modifiers
	 * @argument {Object} data - The data object generated by `update` method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {Object} The data object, properly modified
	 */
	function inner(data) {
	  var placement = data.placement;
	  var basePlacement = placement.split('-')[0];
	  var _data$offsets = data.offsets,
	      popper = _data$offsets.popper,
	      reference = _data$offsets.reference;

	  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;

	  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;

	  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);

	  data.placement = getOppositePlacement(placement);
	  data.offsets.popper = getClientRect(popper);

	  return data;
	}

	/**
	 * Modifier function, each modifier can have a function of this type assigned
	 * to its `fn` property.<br />
	 * These functions will be called on each update, this means that you must
	 * make sure they are performant enough to avoid performance bottlenecks.
	 *
	 * @function ModifierFn
	 * @argument {dataObject} data - The data object generated by `update` method
	 * @argument {Object} options - Modifiers configuration and options
	 * @returns {dataObject} The data object, properly modified
	 */

	/**
	 * Modifiers are plugins used to alter the behavior of your poppers.<br />
	 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
	 * needed by the library.
	 *
	 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
	 * All the other properties are configurations that could be tweaked.
	 * @namespace modifiers
	 */
	var modifiers = {
	  /**
	   * Modifier used to shift the popper on the start or end of its reference
	   * element.<br />
	   * It will read the variation of the `placement` property.<br />
	   * It can be one either `-end` or `-start`.
	   * @memberof modifiers
	   * @inner
	   */
	  shift: {
	    /** @prop {number} order=100 - Index used to define the order of execution */
	    order: 100,
	    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
	    enabled: true,
	    /** @prop {ModifierFn} */
	    fn: shift
	  },

	  /**
	   * The `offset` modifier can shift your popper on both its axis.
	   *
	   * It accepts the following units:
	   * - `px` or unitless, interpreted as pixels
	   * - `%` or `%r`, percentage relative to the length of the reference element
	   * - `%p`, percentage relative to the length of the popper element
	   * - `vw`, CSS viewport width unit
	   * - `vh`, CSS viewport height unit
	   *
	   * For length is intended the main axis relative to the placement of the popper.<br />
	   * This means that if the placement is `top` or `bottom`, the length will be the
	   * `width`. In case of `left` or `right`, it will be the height.
	   *
	   * You can provide a single value (as `Number` or `String`), or a pair of values
	   * as `String` divided by a comma or one (or more) white spaces.<br />
	   * The latter is a deprecated method because it leads to confusion and will be
	   * removed in v2.<br />
	   * Additionally, it accepts additions and subtractions between different units.
	   * Note that multiplications and divisions aren't supported.
	   *
	   * Valid examples are:
	   * ```
	   * 10
	   * '10%'
	   * '10, 10'
	   * '10%, 10'
	   * '10 + 10%'
	   * '10 - 5vh + 3%'
	   * '-10px + 5vh, 5px - 6%'
	   * ```
	   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
	   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
	   * > More on this [reading this issue](https://github.com/FezVrasta/popper.js/issues/373)
	   *
	   * @memberof modifiers
	   * @inner
	   */
	  offset: {
	    /** @prop {number} order=200 - Index used to define the order of execution */
	    order: 200,
	    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
	    enabled: true,
	    /** @prop {ModifierFn} */
	    fn: offset,
	    /** @prop {Number|String} offset=0
	     * The offset value as described in the modifier description
	     */
	    offset: 0
	  },

	  /**
	   * Modifier used to prevent the popper from being positioned outside the boundary.
	   *
	   * An scenario exists where the reference itself is not within the boundaries.<br />
	   * We can say it has "escaped the boundaries" — or just "escaped".<br />
	   * In this case we need to decide whether the popper should either:
	   *
	   * - detach from the reference and remain "trapped" in the boundaries, or
	   * - if it should ignore the boundary and "escape with its reference"
	   *
	   * When `escapeWithReference` is set to`true` and reference is completely
	   * outside its boundaries, the popper will overflow (or completely leave)
	   * the boundaries in order to remain attached to the edge of the reference.
	   *
	   * @memberof modifiers
	   * @inner
	   */
	  preventOverflow: {
	    /** @prop {number} order=300 - Index used to define the order of execution */
	    order: 300,
	    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
	    enabled: true,
	    /** @prop {ModifierFn} */
	    fn: preventOverflow,
	    /**
	     * @prop {Array} [priority=['left','right','top','bottom']]
	     * Popper will try to prevent overflow following these priorities by default,
	     * then, it could overflow on the left and on top of the `boundariesElement`
	     */
	    priority: ['left', 'right', 'top', 'bottom'],
	    /**
	     * @prop {number} padding=5
	     * Amount of pixel used to define a minimum distance between the boundaries
	     * and the popper this makes sure the popper has always a little padding
	     * between the edges of its container
	     */
	    padding: 5,
	    /**
	     * @prop {String|HTMLElement} boundariesElement='scrollParent'
	     * Boundaries used by the modifier, can be `scrollParent`, `window`,
	     * `viewport` or any DOM element.
	     */
	    boundariesElement: 'scrollParent'
	  },

	  /**
	   * Modifier used to make sure the reference and its popper stay near eachothers
	   * without leaving any gap between the two. Expecially useful when the arrow is
	   * enabled and you want to assure it to point to its reference element.
	   * It cares only about the first axis, you can still have poppers with margin
	   * between the popper and its reference element.
	   * @memberof modifiers
	   * @inner
	   */
	  keepTogether: {
	    /** @prop {number} order=400 - Index used to define the order of execution */
	    order: 400,
	    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
	    enabled: true,
	    /** @prop {ModifierFn} */
	    fn: keepTogether
	  },

	  /**
	   * This modifier is used to move the `arrowElement` of the popper to make
	   * sure it is positioned between the reference element and its popper element.
	   * It will read the outer size of the `arrowElement` node to detect how many
	   * pixels of conjuction are needed.
	   *
	   * It has no effect if no `arrowElement` is provided.
	   * @memberof modifiers
	   * @inner
	   */
	  arrow: {
	    /** @prop {number} order=500 - Index used to define the order of execution */
	    order: 500,
	    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
	    enabled: true,
	    /** @prop {ModifierFn} */
	    fn: arrow,
	    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
	    element: '[x-arrow]'
	  },

	  /**
	   * Modifier used to flip the popper's placement when it starts to overlap its
	   * reference element.
	   *
	   * Requires the `preventOverflow` modifier before it in order to work.
	   *
	   * **NOTE:** this modifier will interrupt the current update cycle and will
	   * restart it if it detects the need to flip the placement.
	   * @memberof modifiers
	   * @inner
	   */
	  flip: {
	    /** @prop {number} order=600 - Index used to define the order of execution */
	    order: 600,
	    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
	    enabled: true,
	    /** @prop {ModifierFn} */
	    fn: flip,
	    /**
	     * @prop {String|Array} behavior='flip'
	     * The behavior used to change the popper's placement. It can be one of
	     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
	     * placements (with optional variations).
	     */
	    behavior: 'flip',
	    /**
	     * @prop {number} padding=5
	     * The popper will flip if it hits the edges of the `boundariesElement`
	     */
	    padding: 5,
	    /**
	     * @prop {String|HTMLElement} boundariesElement='viewport'
	     * The element which will define the boundaries of the popper position,
	     * the popper will never be placed outside of the defined boundaries
	     * (except if keepTogether is enabled)
	     */
	    boundariesElement: 'viewport'
	  },

	  /**
	   * Modifier used to make the popper flow toward the inner of the reference element.
	   * By default, when this modifier is disabled, the popper will be placed outside
	   * the reference element.
	   * @memberof modifiers
	   * @inner
	   */
	  inner: {
	    /** @prop {number} order=700 - Index used to define the order of execution */
	    order: 700,
	    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
	    enabled: false,
	    /** @prop {ModifierFn} */
	    fn: inner
	  },

	  /**
	   * Modifier used to hide the popper when its reference element is outside of the
	   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
	   * be used to hide with a CSS selector the popper when its reference is
	   * out of boundaries.
	   *
	   * Requires the `preventOverflow` modifier before it in order to work.
	   * @memberof modifiers
	   * @inner
	   */
	  hide: {
	    /** @prop {number} order=800 - Index used to define the order of execution */
	    order: 800,
	    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
	    enabled: true,
	    /** @prop {ModifierFn} */
	    fn: hide
	  },

	  /**
	   * Computes the style that will be applied to the popper element to gets
	   * properly positioned.
	   *
	   * Note that this modifier will not touch the DOM, it just prepares the styles
	   * so that `applyStyle` modifier can apply it. This separation is useful
	   * in case you need to replace `applyStyle` with a custom implementation.
	   *
	   * This modifier has `850` as `order` value to maintain backward compatibility
	   * with previous versions of Popper.js. Expect the modifiers ordering method
	   * to change in future major versions of the library.
	   *
	   * @memberof modifiers
	   * @inner
	   */
	  computeStyle: {
	    /** @prop {number} order=850 - Index used to define the order of execution */
	    order: 850,
	    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
	    enabled: true,
	    /** @prop {ModifierFn} */
	    fn: computeStyle,
	    /**
	     * @prop {Boolean} gpuAcceleration=true
	     * If true, it uses the CSS 3d transformation to position the popper.
	     * Otherwise, it will use the `top` and `left` properties.
	     */
	    gpuAcceleration: true,
	    /**
	     * @prop {string} [x='bottom']
	     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
	     * Change this if your popper should grow in a direction different from `bottom`
	     */
	    x: 'bottom',
	    /**
	     * @prop {string} [x='left']
	     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
	     * Change this if your popper should grow in a direction different from `right`
	     */
	    y: 'right'
	  },

	  /**
	   * Applies the computed styles to the popper element.
	   *
	   * All the DOM manipulations are limited to this modifier. This is useful in case
	   * you want to integrate Popper.js inside a framework or view library and you
	   * want to delegate all the DOM manipulations to it.
	   *
	   * Note that if you disable this modifier, you must make sure the popper element
	   * has its position set to `absolute` before Popper.js can do its work!
	   *
	   * Just disable this modifier and define you own to achieve the desired effect.
	   *
	   * @memberof modifiers
	   * @inner
	   */
	  applyStyle: {
	    /** @prop {number} order=900 - Index used to define the order of execution */
	    order: 900,
	    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
	    enabled: true,
	    /** @prop {ModifierFn} */
	    fn: applyStyle,
	    /** @prop {Function} */
	    onLoad: applyStyleOnLoad,
	    /**
	     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
	     * @prop {Boolean} gpuAcceleration=true
	     * If true, it uses the CSS 3d transformation to position the popper.
	     * Otherwise, it will use the `top` and `left` properties.
	     */
	    gpuAcceleration: undefined
	  }
	};

	/**
	 * The `dataObject` is an object containing all the informations used by Popper.js
	 * this object get passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
	 * @name dataObject
	 * @property {Object} data.instance The Popper.js instance
	 * @property {String} data.placement Placement applied to popper
	 * @property {String} data.originalPlacement Placement originally defined on init
	 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
	 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper.
	 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
	 * @property {Object} data.styles Any CSS property defined here will be applied to the popper, it expects the JavaScript nomenclature (eg. `marginBottom`)
	 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow, it expects the JavaScript nomenclature (eg. `marginBottom`)
	 * @property {Object} data.boundaries Offsets of the popper boundaries
	 * @property {Object} data.offsets The measurements of popper, reference and arrow elements.
	 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
	 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
	 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
	 */

	/**
	 * Default options provided to Popper.js constructor.<br />
	 * These can be overriden using the `options` argument of Popper.js.<br />
	 * To override an option, simply pass as 3rd argument an object with the same
	 * structure of this object, example:
	 * ```
	 * new Popper(ref, pop, {
	 *   modifiers: {
	 *     preventOverflow: { enabled: false }
	 *   }
	 * })
	 * ```
	 * @type {Object}
	 * @static
	 * @memberof Popper
	 */
	var Defaults = {
	  /**
	   * Popper's placement
	   * @prop {Popper.placements} placement='bottom'
	   */
	  placement: 'bottom',

	  /**
	   * Whether events (resize, scroll) are initially enabled
	   * @prop {Boolean} eventsEnabled=true
	   */
	  eventsEnabled: true,

	  /**
	   * Set to true if you want to automatically remove the popper when
	   * you call the `destroy` method.
	   * @prop {Boolean} removeOnDestroy=false
	   */
	  removeOnDestroy: false,

	  /**
	   * Callback called when the popper is created.<br />
	   * By default, is set to no-op.<br />
	   * Access Popper.js instance with `data.instance`.
	   * @prop {onCreate}
	   */
	  onCreate: function onCreate() {},

	  /**
	   * Callback called when the popper is updated, this callback is not called
	   * on the initialization/creation of the popper, but only on subsequent
	   * updates.<br />
	   * By default, is set to no-op.<br />
	   * Access Popper.js instance with `data.instance`.
	   * @prop {onUpdate}
	   */
	  onUpdate: function onUpdate() {},

	  /**
	   * List of modifiers used to modify the offsets before they are applied to the popper.
	   * They provide most of the functionalities of Popper.js
	   * @prop {modifiers}
	   */
	  modifiers: modifiers
	};

	/**
	 * @callback onCreate
	 * @param {dataObject} data
	 */

	/**
	 * @callback onUpdate
	 * @param {dataObject} data
	 */

	// Utils
	// Methods
	var Popper = function () {
	  /**
	   * Create a new Popper.js instance
	   * @class Popper
	   * @param {HTMLElement|referenceObject} reference - The reference element used to position the popper
	   * @param {HTMLElement} popper - The HTML element used as popper.
	   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
	   * @return {Object} instance - The generated Popper.js instance
	   */
	  function Popper(reference, popper) {
	    var _this = this;

	    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	    classCallCheck(this, Popper);

	    this.scheduleUpdate = function () {
	      return requestAnimationFrame(_this.update);
	    };

	    // make update() debounced, so that it only runs at most once-per-tick
	    this.update = debounce(this.update.bind(this));

	    // with {} we create a new object with the options inside it
	    this.options = _extends({}, Popper.Defaults, options);

	    // init state
	    this.state = {
	      isDestroyed: false,
	      isCreated: false,
	      scrollParents: []
	    };

	    // get reference and popper elements (allow jQuery wrappers)
	    this.reference = reference && reference.jquery ? reference[0] : reference;
	    this.popper = popper && popper.jquery ? popper[0] : popper;

	    // Deep merge modifiers options
	    this.options.modifiers = {};
	    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
	      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
	    });

	    // Refactoring modifiers' list (Object => Array)
	    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
	      return _extends({
	        name: name
	      }, _this.options.modifiers[name]);
	    })
	    // sort the modifiers by order
	    .sort(function (a, b) {
	      return a.order - b.order;
	    });

	    // modifiers have the ability to execute arbitrary code when Popper.js get inited
	    // such code is executed in the same order of its modifier
	    // they could add new properties to their options configuration
	    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
	    this.modifiers.forEach(function (modifierOptions) {
	      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
	        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
	      }
	    });

	    // fire the first update to position the popper in the right place
	    this.update();

	    var eventsEnabled = this.options.eventsEnabled;
	    if (eventsEnabled) {
	      // setup event listeners, they will take care of update the position in specific situations
	      this.enableEventListeners();
	    }

	    this.state.eventsEnabled = eventsEnabled;
	  }

	  // We can't use class properties because they don't get listed in the
	  // class prototype and break stuff like Sinon stubs


	  createClass(Popper, [{
	    key: 'update',
	    value: function update$$1() {
	      return update.call(this);
	    }
	  }, {
	    key: 'destroy',
	    value: function destroy$$1() {
	      return destroy.call(this);
	    }
	  }, {
	    key: 'enableEventListeners',
	    value: function enableEventListeners$$1() {
	      return enableEventListeners.call(this);
	    }
	  }, {
	    key: 'disableEventListeners',
	    value: function disableEventListeners$$1() {
	      return disableEventListeners.call(this);
	    }

	    /**
	     * Schedule an update, it will run on the next UI update available
	     * @method scheduleUpdate
	     * @memberof Popper
	     */


	    /**
	     * Collection of utilities useful when writing custom modifiers.
	     * Starting from version 1.7, this method is available only if you
	     * include `popper-utils.js` before `popper.js`.
	     *
	     * **DEPRECATION**: This way to access PopperUtils is deprecated
	     * and will be removed in v2! Use the PopperUtils module directly instead.
	     * Due to the high instability of the methods contained in Utils, we can't
	     * guarantee them to follow semver. Use them at your own risk!
	     * @static
	     * @private
	     * @type {Object}
	     * @deprecated since version 1.8
	     * @member Utils
	     * @memberof Popper
	     */

	  }]);
	  return Popper;
	}();

	/**
	 * The `referenceObject` is an object that provides an interface compatible with Popper.js
	 * and lets you use it as replacement of a real DOM node.<br />
	 * You can use this method to position a popper relatively to a set of coordinates
	 * in case you don't have a DOM node to use as reference.
	 *
	 * ```
	 * new Popper(referenceObject, popperNode);
	 * ```
	 *
	 * NB: This feature isn't supported in Internet Explorer 10
	 * @name referenceObject
	 * @property {Function} data.getBoundingClientRect
	 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
	 * @property {number} data.clientWidth
	 * An ES6 getter that will return the width of the virtual reference element.
	 * @property {number} data.clientHeight
	 * An ES6 getter that will return the height of the virtual reference element.
	 */


	Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
	Popper.placements = placements;
	Popper.Defaults = Defaults;

	return Popper;

	})));
	//# sourceMappingURL=popper.js.map

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 7 */
/***/ (function(module, exports) {

	/*!
	  * Bootstrap v4.0.0-beta.2 (https://getbootstrap.com)
	  * Copyright 2011-2017 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
	  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	  */
	var bootstrap = (function (exports,$,Popper) {
	'use strict';

	$ = $ && $.hasOwnProperty('default') ? $['default'] : $;
	Popper = Popper && Popper.hasOwnProperty('default') ? Popper['default'] : Popper;

	/**
	 * --------------------------------------------------------------------------
	 * Bootstrap (v4.0.0-beta.2): util.js
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * --------------------------------------------------------------------------
	 */

	var Util = function () {
	  /**
	   * ------------------------------------------------------------------------
	   * Private TransitionEnd Helpers
	   * ------------------------------------------------------------------------
	   */
	  var transition = false;
	  var MAX_UID = 1000000;
	  var TransitionEndEvent = {
	    WebkitTransition: 'webkitTransitionEnd',
	    MozTransition: 'transitionend',
	    OTransition: 'oTransitionEnd otransitionend',
	    transition: 'transitionend' // shoutout AngusCroll (https://goo.gl/pxwQGp)

	  };

	  function toType(obj) {
	    return {}.toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
	  }

	  function getSpecialTransitionEndEvent() {
	    return {
	      bindType: transition.end,
	      delegateType: transition.end,
	      handle: function handle(event) {
	        if ($(event.target).is(this)) {
	          return event.handleObj.handler.apply(this, arguments); // eslint-disable-line prefer-rest-params
	        }

	        return undefined; // eslint-disable-line no-undefined
	      }
	    };
	  }

	  function transitionEndTest() {
	    if (window.QUnit) {
	      return false;
	    }

	    var el = document.createElement('bootstrap');

	    for (var name in TransitionEndEvent) {
	      if (typeof el.style[name] !== 'undefined') {
	        return {
	          end: TransitionEndEvent[name]
	        };
	      }
	    }

	    return false;
	  }

	  function transitionEndEmulator(duration) {
	    var _this = this;

	    var called = false;
	    $(this).one(Util.TRANSITION_END, function () {
	      called = true;
	    });
	    setTimeout(function () {
	      if (!called) {
	        Util.triggerTransitionEnd(_this);
	      }
	    }, duration);
	    return this;
	  }

	  function setTransitionEndSupport() {
	    transition = transitionEndTest();
	    $.fn.emulateTransitionEnd = transitionEndEmulator;

	    if (Util.supportsTransitionEnd()) {
	      $.event.special[Util.TRANSITION_END] = getSpecialTransitionEndEvent();
	    }
	  }
	  /**
	   * --------------------------------------------------------------------------
	   * Public Util Api
	   * --------------------------------------------------------------------------
	   */


	  var Util = {
	    TRANSITION_END: 'bsTransitionEnd',
	    getUID: function getUID(prefix) {
	      do {
	        // eslint-disable-next-line no-bitwise
	        prefix += ~~(Math.random() * MAX_UID); // "~~" acts like a faster Math.floor() here
	      } while (document.getElementById(prefix));

	      return prefix;
	    },
	    getSelectorFromElement: function getSelectorFromElement(element) {
	      var selector = element.getAttribute('data-target');

	      if (!selector || selector === '#') {
	        selector = element.getAttribute('href') || '';
	      }

	      try {
	        var $selector = $(document).find(selector);
	        return $selector.length > 0 ? selector : null;
	      } catch (error) {
	        return null;
	      }
	    },
	    reflow: function reflow(element) {
	      return element.offsetHeight;
	    },
	    triggerTransitionEnd: function triggerTransitionEnd(element) {
	      $(element).trigger(transition.end);
	    },
	    supportsTransitionEnd: function supportsTransitionEnd() {
	      return Boolean(transition);
	    },
	    isElement: function isElement(obj) {
	      return (obj[0] || obj).nodeType;
	    },
	    typeCheckConfig: function typeCheckConfig(componentName, config, configTypes) {
	      for (var property in configTypes) {
	        if (Object.prototype.hasOwnProperty.call(configTypes, property)) {
	          var expectedTypes = configTypes[property];
	          var value = config[property];
	          var valueType = value && Util.isElement(value) ? 'element' : toType(value);

	          if (!new RegExp(expectedTypes).test(valueType)) {
	            throw new Error(componentName.toUpperCase() + ": " + ("Option \"" + property + "\" provided type \"" + valueType + "\" ") + ("but expected type \"" + expectedTypes + "\"."));
	          }
	        }
	      }
	    }
	  };
	  setTransitionEndSupport();
	  return Util;
	}($);

	function _defineProperties(target, props) {
	  for (var i = 0; i < props.length; i++) {
	    var descriptor = props[i];
	    descriptor.enumerable = descriptor.enumerable || false;
	    descriptor.configurable = true;
	    if ("value" in descriptor) descriptor.writable = true;
	    Object.defineProperty(target, descriptor.key, descriptor);
	  }
	}

	function _createClass(Constructor, protoProps, staticProps) {
	  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	  if (staticProps) _defineProperties(Constructor, staticProps);
	  return Constructor;
	}

	var createClass = _createClass;

	function _inheritsLoose(subClass, superClass) {
	  subClass.prototype = Object.create(superClass.prototype);
	  subClass.prototype.constructor = subClass;
	  subClass.__proto__ = superClass;
	}

	var inheritsLoose = _inheritsLoose;

	/**
	 * --------------------------------------------------------------------------
	 * Bootstrap (v4.0.0-beta.2): alert.js
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * --------------------------------------------------------------------------
	 */

	var Alert = function () {
	  /**
	   * ------------------------------------------------------------------------
	   * Constants
	   * ------------------------------------------------------------------------
	   */
	  var NAME = 'alert';
	  var VERSION = '4.0.0-beta.2';
	  var DATA_KEY = 'bs.alert';
	  var EVENT_KEY = "." + DATA_KEY;
	  var DATA_API_KEY = '.data-api';
	  var JQUERY_NO_CONFLICT = $.fn[NAME];
	  var TRANSITION_DURATION = 150;
	  var Selector = {
	    DISMISS: '[data-dismiss="alert"]'
	  };
	  var Event = {
	    CLOSE: "close" + EVENT_KEY,
	    CLOSED: "closed" + EVENT_KEY,
	    CLICK_DATA_API: "click" + EVENT_KEY + DATA_API_KEY
	  };
	  var ClassName = {
	    ALERT: 'alert',
	    FADE: 'fade',
	    SHOW: 'show'
	    /**
	     * ------------------------------------------------------------------------
	     * Class Definition
	     * ------------------------------------------------------------------------
	     */

	  };

	  var Alert =
	  /*#__PURE__*/
	  function () {
	    function Alert(element) {
	      this._element = element;
	    } // getters


	    var _proto = Alert.prototype;

	    // public
	    _proto.close = function close(element) {
	      element = element || this._element;

	      var rootElement = this._getRootElement(element);

	      var customEvent = this._triggerCloseEvent(rootElement);

	      if (customEvent.isDefaultPrevented()) {
	        return;
	      }

	      this._removeElement(rootElement);
	    };

	    _proto.dispose = function dispose() {
	      $.removeData(this._element, DATA_KEY);
	      this._element = null;
	    }; // private


	    _proto._getRootElement = function _getRootElement(element) {
	      var selector = Util.getSelectorFromElement(element);
	      var parent = false;

	      if (selector) {
	        parent = $(selector)[0];
	      }

	      if (!parent) {
	        parent = $(element).closest("." + ClassName.ALERT)[0];
	      }

	      return parent;
	    };

	    _proto._triggerCloseEvent = function _triggerCloseEvent(element) {
	      var closeEvent = $.Event(Event.CLOSE);
	      $(element).trigger(closeEvent);
	      return closeEvent;
	    };

	    _proto._removeElement = function _removeElement(element) {
	      var _this = this;

	      $(element).removeClass(ClassName.SHOW);

	      if (!Util.supportsTransitionEnd() || !$(element).hasClass(ClassName.FADE)) {
	        this._destroyElement(element);

	        return;
	      }

	      $(element).one(Util.TRANSITION_END, function (event) {
	        return _this._destroyElement(element, event);
	      }).emulateTransitionEnd(TRANSITION_DURATION);
	    };

	    _proto._destroyElement = function _destroyElement(element) {
	      $(element).detach().trigger(Event.CLOSED).remove();
	    }; // static


	    Alert._jQueryInterface = function _jQueryInterface(config) {
	      return this.each(function () {
	        var $element = $(this);
	        var data = $element.data(DATA_KEY);

	        if (!data) {
	          data = new Alert(this);
	          $element.data(DATA_KEY, data);
	        }

	        if (config === 'close') {
	          data[config](this);
	        }
	      });
	    };

	    Alert._handleDismiss = function _handleDismiss(alertInstance) {
	      return function (event) {
	        if (event) {
	          event.preventDefault();
	        }

	        alertInstance.close(this);
	      };
	    };

	    createClass(Alert, null, [{
	      key: "VERSION",
	      get: function get() {
	        return VERSION;
	      }
	    }]);
	    return Alert;
	  }();
	  /**
	   * ------------------------------------------------------------------------
	   * Data Api implementation
	   * ------------------------------------------------------------------------
	   */


	  $(document).on(Event.CLICK_DATA_API, Selector.DISMISS, Alert._handleDismiss(new Alert()));
	  /**
	   * ------------------------------------------------------------------------
	   * jQuery
	   * ------------------------------------------------------------------------
	   */

	  $.fn[NAME] = Alert._jQueryInterface;
	  $.fn[NAME].Constructor = Alert;

	  $.fn[NAME].noConflict = function () {
	    $.fn[NAME] = JQUERY_NO_CONFLICT;
	    return Alert._jQueryInterface;
	  };

	  return Alert;
	}($);

	/**
	 * --------------------------------------------------------------------------
	 * Bootstrap (v4.0.0-beta.2): button.js
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * --------------------------------------------------------------------------
	 */

	var Button = function () {
	  /**
	   * ------------------------------------------------------------------------
	   * Constants
	   * ------------------------------------------------------------------------
	   */
	  var NAME = 'button';
	  var VERSION = '4.0.0-beta.2';
	  var DATA_KEY = 'bs.button';
	  var EVENT_KEY = "." + DATA_KEY;
	  var DATA_API_KEY = '.data-api';
	  var JQUERY_NO_CONFLICT = $.fn[NAME];
	  var ClassName = {
	    ACTIVE: 'active',
	    BUTTON: 'btn',
	    FOCUS: 'focus'
	  };
	  var Selector = {
	    DATA_TOGGLE_CARROT: '[data-toggle^="button"]',
	    DATA_TOGGLE: '[data-toggle="buttons"]',
	    INPUT: 'input',
	    ACTIVE: '.active',
	    BUTTON: '.btn'
	  };
	  var Event = {
	    CLICK_DATA_API: "click" + EVENT_KEY + DATA_API_KEY,
	    FOCUS_BLUR_DATA_API: "focus" + EVENT_KEY + DATA_API_KEY + " " + ("blur" + EVENT_KEY + DATA_API_KEY)
	    /**
	     * ------------------------------------------------------------------------
	     * Class Definition
	     * ------------------------------------------------------------------------
	     */

	  };

	  var Button =
	  /*#__PURE__*/
	  function () {
	    function Button(element) {
	      this._element = element;
	    } // getters


	    var _proto = Button.prototype;

	    // public
	    _proto.toggle = function toggle() {
	      var triggerChangeEvent = true;
	      var addAriaPressed = true;
	      var rootElement = $(this._element).closest(Selector.DATA_TOGGLE)[0];

	      if (rootElement) {
	        var input = $(this._element).find(Selector.INPUT)[0];

	        if (input) {
	          if (input.type === 'radio') {
	            if (input.checked && $(this._element).hasClass(ClassName.ACTIVE)) {
	              triggerChangeEvent = false;
	            } else {
	              var activeElement = $(rootElement).find(Selector.ACTIVE)[0];

	              if (activeElement) {
	                $(activeElement).removeClass(ClassName.ACTIVE);
	              }
	            }
	          }

	          if (triggerChangeEvent) {
	            if (input.hasAttribute('disabled') || rootElement.hasAttribute('disabled') || input.classList.contains('disabled') || rootElement.classList.contains('disabled')) {
	              return;
	            }

	            input.checked = !$(this._element).hasClass(ClassName.ACTIVE);
	            $(input).trigger('change');
	          }

	          input.focus();
	          addAriaPressed = false;
	        }
	      }

	      if (addAriaPressed) {
	        this._element.setAttribute('aria-pressed', !$(this._element).hasClass(ClassName.ACTIVE));
	      }

	      if (triggerChangeEvent) {
	        $(this._element).toggleClass(ClassName.ACTIVE);
	      }
	    };

	    _proto.dispose = function dispose() {
	      $.removeData(this._element, DATA_KEY);
	      this._element = null;
	    }; // static


	    Button._jQueryInterface = function _jQueryInterface(config) {
	      return this.each(function () {
	        var data = $(this).data(DATA_KEY);

	        if (!data) {
	          data = new Button(this);
	          $(this).data(DATA_KEY, data);
	        }

	        if (config === 'toggle') {
	          data[config]();
	        }
	      });
	    };

	    createClass(Button, null, [{
	      key: "VERSION",
	      get: function get() {
	        return VERSION;
	      }
	    }]);
	    return Button;
	  }();
	  /**
	   * ------------------------------------------------------------------------
	   * Data Api implementation
	   * ------------------------------------------------------------------------
	   */


	  $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE_CARROT, function (event) {
	    event.preventDefault();
	    var button = event.target;

	    if (!$(button).hasClass(ClassName.BUTTON)) {
	      button = $(button).closest(Selector.BUTTON);
	    }

	    Button._jQueryInterface.call($(button), 'toggle');
	  }).on(Event.FOCUS_BLUR_DATA_API, Selector.DATA_TOGGLE_CARROT, function (event) {
	    var button = $(event.target).closest(Selector.BUTTON)[0];
	    $(button).toggleClass(ClassName.FOCUS, /^focus(in)?$/.test(event.type));
	  });
	  /**
	   * ------------------------------------------------------------------------
	   * jQuery
	   * ------------------------------------------------------------------------
	   */

	  $.fn[NAME] = Button._jQueryInterface;
	  $.fn[NAME].Constructor = Button;

	  $.fn[NAME].noConflict = function () {
	    $.fn[NAME] = JQUERY_NO_CONFLICT;
	    return Button._jQueryInterface;
	  };

	  return Button;
	}($);

	/**
	 * --------------------------------------------------------------------------
	 * Bootstrap (v4.0.0-beta.2): carousel.js
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * --------------------------------------------------------------------------
	 */

	var Carousel = function () {
	  /**
	   * ------------------------------------------------------------------------
	   * Constants
	   * ------------------------------------------------------------------------
	   */
	  var NAME = 'carousel';
	  var VERSION = '4.0.0-beta.2';
	  var DATA_KEY = 'bs.carousel';
	  var EVENT_KEY = "." + DATA_KEY;
	  var DATA_API_KEY = '.data-api';
	  var JQUERY_NO_CONFLICT = $.fn[NAME];
	  var TRANSITION_DURATION = 600;
	  var ARROW_LEFT_KEYCODE = 37; // KeyboardEvent.which value for left arrow key

	  var ARROW_RIGHT_KEYCODE = 39; // KeyboardEvent.which value for right arrow key

	  var TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch

	  var Default = {
	    interval: 5000,
	    keyboard: true,
	    slide: false,
	    pause: 'hover',
	    wrap: true
	  };
	  var DefaultType = {
	    interval: '(number|boolean)',
	    keyboard: 'boolean',
	    slide: '(boolean|string)',
	    pause: '(string|boolean)',
	    wrap: 'boolean'
	  };
	  var Direction = {
	    NEXT: 'next',
	    PREV: 'prev',
	    LEFT: 'left',
	    RIGHT: 'right'
	  };
	  var Event = {
	    SLIDE: "slide" + EVENT_KEY,
	    SLID: "slid" + EVENT_KEY,
	    KEYDOWN: "keydown" + EVENT_KEY,
	    MOUSEENTER: "mouseenter" + EVENT_KEY,
	    MOUSELEAVE: "mouseleave" + EVENT_KEY,
	    TOUCHEND: "touchend" + EVENT_KEY,
	    LOAD_DATA_API: "load" + EVENT_KEY + DATA_API_KEY,
	    CLICK_DATA_API: "click" + EVENT_KEY + DATA_API_KEY
	  };
	  var ClassName = {
	    CAROUSEL: 'carousel',
	    ACTIVE: 'active',
	    SLIDE: 'slide',
	    RIGHT: 'carousel-item-right',
	    LEFT: 'carousel-item-left',
	    NEXT: 'carousel-item-next',
	    PREV: 'carousel-item-prev',
	    ITEM: 'carousel-item'
	  };
	  var Selector = {
	    ACTIVE: '.active',
	    ACTIVE_ITEM: '.active.carousel-item',
	    ITEM: '.carousel-item',
	    NEXT_PREV: '.carousel-item-next, .carousel-item-prev',
	    INDICATORS: '.carousel-indicators',
	    DATA_SLIDE: '[data-slide], [data-slide-to]',
	    DATA_RIDE: '[data-ride="carousel"]'
	    /**
	     * ------------------------------------------------------------------------
	     * Class Definition
	     * ------------------------------------------------------------------------
	     */

	  };

	  var Carousel =
	  /*#__PURE__*/
	  function () {
	    function Carousel(element, config) {
	      this._items = null;
	      this._interval = null;
	      this._activeElement = null;
	      this._isPaused = false;
	      this._isSliding = false;
	      this.touchTimeout = null;
	      this._config = this._getConfig(config);
	      this._element = $(element)[0];
	      this._indicatorsElement = $(this._element).find(Selector.INDICATORS)[0];

	      this._addEventListeners();
	    } // getters


	    var _proto = Carousel.prototype;

	    // public
	    _proto.next = function next() {
	      if (!this._isSliding) {
	        this._slide(Direction.NEXT);
	      }
	    };

	    _proto.nextWhenVisible = function nextWhenVisible() {
	      // Don't call next when the page isn't visible
	      // or the carousel or its parent isn't visible
	      if (!document.hidden && $(this._element).is(':visible') && $(this._element).css('visibility') !== 'hidden') {
	        this.next();
	      }
	    };

	    _proto.prev = function prev() {
	      if (!this._isSliding) {
	        this._slide(Direction.PREV);
	      }
	    };

	    _proto.pause = function pause(event) {
	      if (!event) {
	        this._isPaused = true;
	      }

	      if ($(this._element).find(Selector.NEXT_PREV)[0] && Util.supportsTransitionEnd()) {
	        Util.triggerTransitionEnd(this._element);
	        this.cycle(true);
	      }

	      clearInterval(this._interval);
	      this._interval = null;
	    };

	    _proto.cycle = function cycle(event) {
	      if (!event) {
	        this._isPaused = false;
	      }

	      if (this._interval) {
	        clearInterval(this._interval);
	        this._interval = null;
	      }

	      if (this._config.interval && !this._isPaused) {
	        this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);
	      }
	    };

	    _proto.to = function to(index) {
	      var _this = this;

	      this._activeElement = $(this._element).find(Selector.ACTIVE_ITEM)[0];

	      var activeIndex = this._getItemIndex(this._activeElement);

	      if (index > this._items.length - 1 || index < 0) {
	        return;
	      }

	      if (this._isSliding) {
	        $(this._element).one(Event.SLID, function () {
	          return _this.to(index);
	        });
	        return;
	      }

	      if (activeIndex === index) {
	        this.pause();
	        this.cycle();
	        return;
	      }

	      var direction = index > activeIndex ? Direction.NEXT : Direction.PREV;

	      this._slide(direction, this._items[index]);
	    };

	    _proto.dispose = function dispose() {
	      $(this._element).off(EVENT_KEY);
	      $.removeData(this._element, DATA_KEY);
	      this._items = null;
	      this._config = null;
	      this._element = null;
	      this._interval = null;
	      this._isPaused = null;
	      this._isSliding = null;
	      this._activeElement = null;
	      this._indicatorsElement = null;
	    }; // private


	    _proto._getConfig = function _getConfig(config) {
	      config = $.extend({}, Default, config);
	      Util.typeCheckConfig(NAME, config, DefaultType);
	      return config;
	    };

	    _proto._addEventListeners = function _addEventListeners() {
	      var _this2 = this;

	      if (this._config.keyboard) {
	        $(this._element).on(Event.KEYDOWN, function (event) {
	          return _this2._keydown(event);
	        });
	      }

	      if (this._config.pause === 'hover') {
	        $(this._element).on(Event.MOUSEENTER, function (event) {
	          return _this2.pause(event);
	        }).on(Event.MOUSELEAVE, function (event) {
	          return _this2.cycle(event);
	        });

	        if ('ontouchstart' in document.documentElement) {
	          // if it's a touch-enabled device, mouseenter/leave are fired as
	          // part of the mouse compatibility events on first tap - the carousel
	          // would stop cycling until user tapped out of it;
	          // here, we listen for touchend, explicitly pause the carousel
	          // (as if it's the second time we tap on it, mouseenter compat event
	          // is NOT fired) and after a timeout (to allow for mouse compatibility
	          // events to fire) we explicitly restart cycling
	          $(this._element).on(Event.TOUCHEND, function () {
	            _this2.pause();

	            if (_this2.touchTimeout) {
	              clearTimeout(_this2.touchTimeout);
	            }

	            _this2.touchTimeout = setTimeout(function (event) {
	              return _this2.cycle(event);
	            }, TOUCHEVENT_COMPAT_WAIT + _this2._config.interval);
	          });
	        }
	      }
	    };

	    _proto._keydown = function _keydown(event) {
	      if (/input|textarea/i.test(event.target.tagName)) {
	        return;
	      }

	      switch (event.which) {
	        case ARROW_LEFT_KEYCODE:
	          event.preventDefault();
	          this.prev();
	          break;

	        case ARROW_RIGHT_KEYCODE:
	          event.preventDefault();
	          this.next();
	          break;

	        default:
	          return;
	      }
	    };

	    _proto._getItemIndex = function _getItemIndex(element) {
	      this._items = $.makeArray($(element).parent().find(Selector.ITEM));
	      return this._items.indexOf(element);
	    };

	    _proto._getItemByDirection = function _getItemByDirection(direction, activeElement) {
	      var isNextDirection = direction === Direction.NEXT;
	      var isPrevDirection = direction === Direction.PREV;

	      var activeIndex = this._getItemIndex(activeElement);

	      var lastItemIndex = this._items.length - 1;
	      var isGoingToWrap = isPrevDirection && activeIndex === 0 || isNextDirection && activeIndex === lastItemIndex;

	      if (isGoingToWrap && !this._config.wrap) {
	        return activeElement;
	      }

	      var delta = direction === Direction.PREV ? -1 : 1;
	      var itemIndex = (activeIndex + delta) % this._items.length;
	      return itemIndex === -1 ? this._items[this._items.length - 1] : this._items[itemIndex];
	    };

	    _proto._triggerSlideEvent = function _triggerSlideEvent(relatedTarget, eventDirectionName) {
	      var targetIndex = this._getItemIndex(relatedTarget);

	      var fromIndex = this._getItemIndex($(this._element).find(Selector.ACTIVE_ITEM)[0]);

	      var slideEvent = $.Event(Event.SLIDE, {
	        relatedTarget: relatedTarget,
	        direction: eventDirectionName,
	        from: fromIndex,
	        to: targetIndex
	      });
	      $(this._element).trigger(slideEvent);
	      return slideEvent;
	    };

	    _proto._setActiveIndicatorElement = function _setActiveIndicatorElement(element) {
	      if (this._indicatorsElement) {
	        $(this._indicatorsElement).find(Selector.ACTIVE).removeClass(ClassName.ACTIVE);

	        var nextIndicator = this._indicatorsElement.children[this._getItemIndex(element)];

	        if (nextIndicator) {
	          $(nextIndicator).addClass(ClassName.ACTIVE);
	        }
	      }
	    };

	    _proto._slide = function _slide(direction, element) {
	      var _this3 = this;

	      var activeElement = $(this._element).find(Selector.ACTIVE_ITEM)[0];

	      var activeElementIndex = this._getItemIndex(activeElement);

	      var nextElement = element || activeElement && this._getItemByDirection(direction, activeElement);

	      var nextElementIndex = this._getItemIndex(nextElement);

	      var isCycling = Boolean(this._interval);
	      var directionalClassName;
	      var orderClassName;
	      var eventDirectionName;

	      if (direction === Direction.NEXT) {
	        directionalClassName = ClassName.LEFT;
	        orderClassName = ClassName.NEXT;
	        eventDirectionName = Direction.LEFT;
	      } else {
	        directionalClassName = ClassName.RIGHT;
	        orderClassName = ClassName.PREV;
	        eventDirectionName = Direction.RIGHT;
	      }

	      if (nextElement && $(nextElement).hasClass(ClassName.ACTIVE)) {
	        this._isSliding = false;
	        return;
	      }

	      var slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName);

	      if (slideEvent.isDefaultPrevented()) {
	        return;
	      }

	      if (!activeElement || !nextElement) {
	        // some weirdness is happening, so we bail
	        return;
	      }

	      this._isSliding = true;

	      if (isCycling) {
	        this.pause();
	      }

	      this._setActiveIndicatorElement(nextElement);

	      var slidEvent = $.Event(Event.SLID, {
	        relatedTarget: nextElement,
	        direction: eventDirectionName,
	        from: activeElementIndex,
	        to: nextElementIndex
	      });

	      if (Util.supportsTransitionEnd() && $(this._element).hasClass(ClassName.SLIDE)) {
	        $(nextElement).addClass(orderClassName);
	        Util.reflow(nextElement);
	        $(activeElement).addClass(directionalClassName);
	        $(nextElement).addClass(directionalClassName);
	        $(activeElement).one(Util.TRANSITION_END, function () {
	          $(nextElement).removeClass(directionalClassName + " " + orderClassName).addClass(ClassName.ACTIVE);
	          $(activeElement).removeClass(ClassName.ACTIVE + " " + orderClassName + " " + directionalClassName);
	          _this3._isSliding = false;
	          setTimeout(function () {
	            return $(_this3._element).trigger(slidEvent);
	          }, 0);
	        }).emulateTransitionEnd(TRANSITION_DURATION);
	      } else {
	        $(activeElement).removeClass(ClassName.ACTIVE);
	        $(nextElement).addClass(ClassName.ACTIVE);
	        this._isSliding = false;
	        $(this._element).trigger(slidEvent);
	      }

	      if (isCycling) {
	        this.cycle();
	      }
	    }; // static


	    Carousel._jQueryInterface = function _jQueryInterface(config) {
	      return this.each(function () {
	        var data = $(this).data(DATA_KEY);

	        var _config = $.extend({}, Default, $(this).data());

	        if (typeof config === 'object') {
	          $.extend(_config, config);
	        }

	        var action = typeof config === 'string' ? config : _config.slide;

	        if (!data) {
	          data = new Carousel(this, _config);
	          $(this).data(DATA_KEY, data);
	        }

	        if (typeof config === 'number') {
	          data.to(config);
	        } else if (typeof action === 'string') {
	          if (typeof data[action] === 'undefined') {
	            throw new Error("No method named \"" + action + "\"");
	          }

	          data[action]();
	        } else if (_config.interval) {
	          data.pause();
	          data.cycle();
	        }
	      });
	    };

	    Carousel._dataApiClickHandler = function _dataApiClickHandler(event) {
	      var selector = Util.getSelectorFromElement(this);

	      if (!selector) {
	        return;
	      }

	      var target = $(selector)[0];

	      if (!target || !$(target).hasClass(ClassName.CAROUSEL)) {
	        return;
	      }

	      var config = $.extend({}, $(target).data(), $(this).data());
	      var slideIndex = this.getAttribute('data-slide-to');

	      if (slideIndex) {
	        config.interval = false;
	      }

	      Carousel._jQueryInterface.call($(target), config);

	      if (slideIndex) {
	        $(target).data(DATA_KEY).to(slideIndex);
	      }

	      event.preventDefault();
	    };

	    createClass(Carousel, null, [{
	      key: "VERSION",
	      get: function get() {
	        return VERSION;
	      }
	    }, {
	      key: "Default",
	      get: function get() {
	        return Default;
	      }
	    }]);
	    return Carousel;
	  }();
	  /**
	   * ------------------------------------------------------------------------
	   * Data Api implementation
	   * ------------------------------------------------------------------------
	   */


	  $(document).on(Event.CLICK_DATA_API, Selector.DATA_SLIDE, Carousel._dataApiClickHandler);
	  $(window).on(Event.LOAD_DATA_API, function () {
	    $(Selector.DATA_RIDE).each(function () {
	      var $carousel = $(this);

	      Carousel._jQueryInterface.call($carousel, $carousel.data());
	    });
	  });
	  /**
	   * ------------------------------------------------------------------------
	   * jQuery
	   * ------------------------------------------------------------------------
	   */

	  $.fn[NAME] = Carousel._jQueryInterface;
	  $.fn[NAME].Constructor = Carousel;

	  $.fn[NAME].noConflict = function () {
	    $.fn[NAME] = JQUERY_NO_CONFLICT;
	    return Carousel._jQueryInterface;
	  };

	  return Carousel;
	}($);

	/**
	 * --------------------------------------------------------------------------
	 * Bootstrap (v4.0.0-beta.2): collapse.js
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * --------------------------------------------------------------------------
	 */

	var Collapse = function () {
	  /**
	   * ------------------------------------------------------------------------
	   * Constants
	   * ------------------------------------------------------------------------
	   */
	  var NAME = 'collapse';
	  var VERSION = '4.0.0-beta.2';
	  var DATA_KEY = 'bs.collapse';
	  var EVENT_KEY = "." + DATA_KEY;
	  var DATA_API_KEY = '.data-api';
	  var JQUERY_NO_CONFLICT = $.fn[NAME];
	  var TRANSITION_DURATION = 600;
	  var Default = {
	    toggle: true,
	    parent: ''
	  };
	  var DefaultType = {
	    toggle: 'boolean',
	    parent: '(string|element)'
	  };
	  var Event = {
	    SHOW: "show" + EVENT_KEY,
	    SHOWN: "shown" + EVENT_KEY,
	    HIDE: "hide" + EVENT_KEY,
	    HIDDEN: "hidden" + EVENT_KEY,
	    CLICK_DATA_API: "click" + EVENT_KEY + DATA_API_KEY
	  };
	  var ClassName = {
	    SHOW: 'show',
	    COLLAPSE: 'collapse',
	    COLLAPSING: 'collapsing',
	    COLLAPSED: 'collapsed'
	  };
	  var Dimension = {
	    WIDTH: 'width',
	    HEIGHT: 'height'
	  };
	  var Selector = {
	    ACTIVES: '.show, .collapsing',
	    DATA_TOGGLE: '[data-toggle="collapse"]'
	    /**
	     * ------------------------------------------------------------------------
	     * Class Definition
	     * ------------------------------------------------------------------------
	     */

	  };

	  var Collapse =
	  /*#__PURE__*/
	  function () {
	    function Collapse(element, config) {
	      this._isTransitioning = false;
	      this._element = element;
	      this._config = this._getConfig(config);
	      this._triggerArray = $.makeArray($("[data-toggle=\"collapse\"][href=\"#" + element.id + "\"]," + ("[data-toggle=\"collapse\"][data-target=\"#" + element.id + "\"]")));
	      var tabToggles = $(Selector.DATA_TOGGLE);

	      for (var i = 0; i < tabToggles.length; i++) {
	        var elem = tabToggles[i];
	        var selector = Util.getSelectorFromElement(elem);

	        if (selector !== null && $(selector).filter(element).length > 0) {
	          this._triggerArray.push(elem);
	        }
	      }

	      this._parent = this._config.parent ? this._getParent() : null;

	      if (!this._config.parent) {
	        this._addAriaAndCollapsedClass(this._element, this._triggerArray);
	      }

	      if (this._config.toggle) {
	        this.toggle();
	      }
	    } // getters


	    var _proto = Collapse.prototype;

	    // public
	    _proto.toggle = function toggle() {
	      if ($(this._element).hasClass(ClassName.SHOW)) {
	        this.hide();
	      } else {
	        this.show();
	      }
	    };

	    _proto.show = function show() {
	      var _this = this;

	      if (this._isTransitioning || $(this._element).hasClass(ClassName.SHOW)) {
	        return;
	      }

	      var actives;
	      var activesData;

	      if (this._parent) {
	        actives = $.makeArray($(this._parent).children().children(Selector.ACTIVES));

	        if (!actives.length) {
	          actives = null;
	        }
	      }

	      if (actives) {
	        activesData = $(actives).data(DATA_KEY);

	        if (activesData && activesData._isTransitioning) {
	          return;
	        }
	      }

	      var startEvent = $.Event(Event.SHOW);
	      $(this._element).trigger(startEvent);

	      if (startEvent.isDefaultPrevented()) {
	        return;
	      }

	      if (actives) {
	        Collapse._jQueryInterface.call($(actives), 'hide');

	        if (!activesData) {
	          $(actives).data(DATA_KEY, null);
	        }
	      }

	      var dimension = this._getDimension();

	      $(this._element).removeClass(ClassName.COLLAPSE).addClass(ClassName.COLLAPSING);
	      this._element.style[dimension] = 0;

	      if (this._triggerArray.length) {
	        $(this._triggerArray).removeClass(ClassName.COLLAPSED).attr('aria-expanded', true);
	      }

	      this.setTransitioning(true);

	      var complete = function complete() {
	        $(_this._element).removeClass(ClassName.COLLAPSING).addClass(ClassName.COLLAPSE).addClass(ClassName.SHOW);
	        _this._element.style[dimension] = '';

	        _this.setTransitioning(false);

	        $(_this._element).trigger(Event.SHOWN);
	      };

	      if (!Util.supportsTransitionEnd()) {
	        complete();
	        return;
	      }

	      var capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
	      var scrollSize = "scroll" + capitalizedDimension;
	      $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(TRANSITION_DURATION);
	      this._element.style[dimension] = this._element[scrollSize] + "px";
	    };

	    _proto.hide = function hide() {
	      var _this2 = this;

	      if (this._isTransitioning || !$(this._element).hasClass(ClassName.SHOW)) {
	        return;
	      }

	      var startEvent = $.Event(Event.HIDE);
	      $(this._element).trigger(startEvent);

	      if (startEvent.isDefaultPrevented()) {
	        return;
	      }

	      var dimension = this._getDimension();

	      this._element.style[dimension] = this._element.getBoundingClientRect()[dimension] + "px";
	      Util.reflow(this._element);
	      $(this._element).addClass(ClassName.COLLAPSING).removeClass(ClassName.COLLAPSE).removeClass(ClassName.SHOW);

	      if (this._triggerArray.length) {
	        for (var i = 0; i < this._triggerArray.length; i++) {
	          var trigger = this._triggerArray[i];
	          var selector = Util.getSelectorFromElement(trigger);

	          if (selector !== null) {
	            var $elem = $(selector);

	            if (!$elem.hasClass(ClassName.SHOW)) {
	              $(trigger).addClass(ClassName.COLLAPSED).attr('aria-expanded', false);
	            }
	          }
	        }
	      }

	      this.setTransitioning(true);

	      var complete = function complete() {
	        _this2.setTransitioning(false);

	        $(_this2._element).removeClass(ClassName.COLLAPSING).addClass(ClassName.COLLAPSE).trigger(Event.HIDDEN);
	      };

	      this._element.style[dimension] = '';

	      if (!Util.supportsTransitionEnd()) {
	        complete();
	        return;
	      }

	      $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(TRANSITION_DURATION);
	    };

	    _proto.setTransitioning = function setTransitioning(isTransitioning) {
	      this._isTransitioning = isTransitioning;
	    };

	    _proto.dispose = function dispose() {
	      $.removeData(this._element, DATA_KEY);
	      this._config = null;
	      this._parent = null;
	      this._element = null;
	      this._triggerArray = null;
	      this._isTransitioning = null;
	    }; // private


	    _proto._getConfig = function _getConfig(config) {
	      config = $.extend({}, Default, config);
	      config.toggle = Boolean(config.toggle); // coerce string values

	      Util.typeCheckConfig(NAME, config, DefaultType);
	      return config;
	    };

	    _proto._getDimension = function _getDimension() {
	      var hasWidth = $(this._element).hasClass(Dimension.WIDTH);
	      return hasWidth ? Dimension.WIDTH : Dimension.HEIGHT;
	    };

	    _proto._getParent = function _getParent() {
	      var _this3 = this;

	      var parent = null;

	      if (Util.isElement(this._config.parent)) {
	        parent = this._config.parent; // it's a jQuery object

	        if (typeof this._config.parent.jquery !== 'undefined') {
	          parent = this._config.parent[0];
	        }
	      } else {
	        parent = $(this._config.parent)[0];
	      }

	      var selector = "[data-toggle=\"collapse\"][data-parent=\"" + this._config.parent + "\"]";
	      $(parent).find(selector).each(function (i, element) {
	        _this3._addAriaAndCollapsedClass(Collapse._getTargetFromElement(element), [element]);
	      });
	      return parent;
	    };

	    _proto._addAriaAndCollapsedClass = function _addAriaAndCollapsedClass(element, triggerArray) {
	      if (element) {
	        var isOpen = $(element).hasClass(ClassName.SHOW);

	        if (triggerArray.length) {
	          $(triggerArray).toggleClass(ClassName.COLLAPSED, !isOpen).attr('aria-expanded', isOpen);
	        }
	      }
	    }; // static


	    Collapse._getTargetFromElement = function _getTargetFromElement(element) {
	      var selector = Util.getSelectorFromElement(element);
	      return selector ? $(selector)[0] : null;
	    };

	    Collapse._jQueryInterface = function _jQueryInterface(config) {
	      return this.each(function () {
	        var $this = $(this);
	        var data = $this.data(DATA_KEY);

	        var _config = $.extend({}, Default, $this.data(), typeof config === 'object' && config);

	        if (!data && _config.toggle && /show|hide/.test(config)) {
	          _config.toggle = false;
	        }

	        if (!data) {
	          data = new Collapse(this, _config);
	          $this.data(DATA_KEY, data);
	        }

	        if (typeof config === 'string') {
	          if (typeof data[config] === 'undefined') {
	            throw new Error("No method named \"" + config + "\"");
	          }

	          data[config]();
	        }
	      });
	    };

	    createClass(Collapse, null, [{
	      key: "VERSION",
	      get: function get() {
	        return VERSION;
	      }
	    }, {
	      key: "Default",
	      get: function get() {
	        return Default;
	      }
	    }]);
	    return Collapse;
	  }();
	  /**
	   * ------------------------------------------------------------------------
	   * Data Api implementation
	   * ------------------------------------------------------------------------
	   */


	  $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {
	    // preventDefault only for <a> elements (which change the URL) not inside the collapsible element
	    if (event.currentTarget.tagName === 'A') {
	      event.preventDefault();
	    }

	    var $trigger = $(this);
	    var selector = Util.getSelectorFromElement(this);
	    $(selector).each(function () {
	      var $target = $(this);
	      var data = $target.data(DATA_KEY);
	      var config = data ? 'toggle' : $trigger.data();

	      Collapse._jQueryInterface.call($target, config);
	    });
	  });
	  /**
	   * ------------------------------------------------------------------------
	   * jQuery
	   * ------------------------------------------------------------------------
	   */

	  $.fn[NAME] = Collapse._jQueryInterface;
	  $.fn[NAME].Constructor = Collapse;

	  $.fn[NAME].noConflict = function () {
	    $.fn[NAME] = JQUERY_NO_CONFLICT;
	    return Collapse._jQueryInterface;
	  };

	  return Collapse;
	}($);

	/**
	 * --------------------------------------------------------------------------
	 * Bootstrap (v4.0.0-beta.2): dropdown.js
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * --------------------------------------------------------------------------
	 */

	var Dropdown = function () {
	  /**
	   * Check for Popper dependency
	   * Popper - https://popper.js.org
	   */
	  if (typeof Popper === 'undefined') {
	    throw new Error('Bootstrap dropdown require Popper.js (https://popper.js.org)');
	  }
	  /**
	   * ------------------------------------------------------------------------
	   * Constants
	   * ------------------------------------------------------------------------
	   */


	  var NAME = 'dropdown';
	  var VERSION = '4.0.0-beta.2';
	  var DATA_KEY = 'bs.dropdown';
	  var EVENT_KEY = "." + DATA_KEY;
	  var DATA_API_KEY = '.data-api';
	  var JQUERY_NO_CONFLICT = $.fn[NAME];
	  var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key

	  var SPACE_KEYCODE = 32; // KeyboardEvent.which value for space key

	  var TAB_KEYCODE = 9; // KeyboardEvent.which value for tab key

	  var ARROW_UP_KEYCODE = 38; // KeyboardEvent.which value for up arrow key

	  var ARROW_DOWN_KEYCODE = 40; // KeyboardEvent.which value for down arrow key

	  var RIGHT_MOUSE_BUTTON_WHICH = 3; // MouseEvent.which value for the right button (assuming a right-handed mouse)

	  var REGEXP_KEYDOWN = new RegExp(ARROW_UP_KEYCODE + "|" + ARROW_DOWN_KEYCODE + "|" + ESCAPE_KEYCODE);
	  var Event = {
	    HIDE: "hide" + EVENT_KEY,
	    HIDDEN: "hidden" + EVENT_KEY,
	    SHOW: "show" + EVENT_KEY,
	    SHOWN: "shown" + EVENT_KEY,
	    CLICK: "click" + EVENT_KEY,
	    CLICK_DATA_API: "click" + EVENT_KEY + DATA_API_KEY,
	    KEYDOWN_DATA_API: "keydown" + EVENT_KEY + DATA_API_KEY,
	    KEYUP_DATA_API: "keyup" + EVENT_KEY + DATA_API_KEY
	  };
	  var ClassName = {
	    DISABLED: 'disabled',
	    SHOW: 'show',
	    DROPUP: 'dropup',
	    MENURIGHT: 'dropdown-menu-right',
	    MENULEFT: 'dropdown-menu-left'
	  };
	  var Selector = {
	    DATA_TOGGLE: '[data-toggle="dropdown"]',
	    FORM_CHILD: '.dropdown form',
	    MENU: '.dropdown-menu',
	    NAVBAR_NAV: '.navbar-nav',
	    VISIBLE_ITEMS: '.dropdown-menu .dropdown-item:not(.disabled)'
	  };
	  var AttachmentMap = {
	    TOP: 'top-start',
	    TOPEND: 'top-end',
	    BOTTOM: 'bottom-start',
	    BOTTOMEND: 'bottom-end'
	  };
	  var Default = {
	    offset: 0,
	    flip: true
	  };
	  var DefaultType = {
	    offset: '(number|string|function)',
	    flip: 'boolean'
	    /**
	     * ------------------------------------------------------------------------
	     * Class Definition
	     * ------------------------------------------------------------------------
	     */

	  };

	  var Dropdown =
	  /*#__PURE__*/
	  function () {
	    function Dropdown(element, config) {
	      this._element = element;
	      this._popper = null;
	      this._config = this._getConfig(config);
	      this._menu = this._getMenuElement();
	      this._inNavbar = this._detectNavbar();

	      this._addEventListeners();
	    } // getters


	    var _proto = Dropdown.prototype;

	    // public
	    _proto.toggle = function toggle() {
	      if (this._element.disabled || $(this._element).hasClass(ClassName.DISABLED)) {
	        return;
	      }

	      var parent = Dropdown._getParentFromElement(this._element);

	      var isActive = $(this._menu).hasClass(ClassName.SHOW);

	      Dropdown._clearMenus();

	      if (isActive) {
	        return;
	      }

	      var relatedTarget = {
	        relatedTarget: this._element
	      };
	      var showEvent = $.Event(Event.SHOW, relatedTarget);
	      $(parent).trigger(showEvent);

	      if (showEvent.isDefaultPrevented()) {
	        return;
	      }

	      var element = this._element; // for dropup with alignment we use the parent as popper container

	      if ($(parent).hasClass(ClassName.DROPUP)) {
	        if ($(this._menu).hasClass(ClassName.MENULEFT) || $(this._menu).hasClass(ClassName.MENURIGHT)) {
	          element = parent;
	        }
	      }

	      this._popper = new Popper(element, this._menu, this._getPopperConfig()); // if this is a touch-enabled device we add extra
	      // empty mouseover listeners to the body's immediate children;
	      // only needed because of broken event delegation on iOS
	      // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html

	      if ('ontouchstart' in document.documentElement && !$(parent).closest(Selector.NAVBAR_NAV).length) {
	        $('body').children().on('mouseover', null, $.noop);
	      }

	      this._element.focus();

	      this._element.setAttribute('aria-expanded', true);

	      $(this._menu).toggleClass(ClassName.SHOW);
	      $(parent).toggleClass(ClassName.SHOW).trigger($.Event(Event.SHOWN, relatedTarget));
	    };

	    _proto.dispose = function dispose() {
	      $.removeData(this._element, DATA_KEY);
	      $(this._element).off(EVENT_KEY);
	      this._element = null;
	      this._menu = null;

	      if (this._popper !== null) {
	        this._popper.destroy();
	      }

	      this._popper = null;
	    };

	    _proto.update = function update() {
	      this._inNavbar = this._detectNavbar();

	      if (this._popper !== null) {
	        this._popper.scheduleUpdate();
	      }
	    }; // private


	    _proto._addEventListeners = function _addEventListeners() {
	      var _this = this;

	      $(this._element).on(Event.CLICK, function (event) {
	        event.preventDefault();
	        event.stopPropagation();

	        _this.toggle();
	      });
	    };

	    _proto._getConfig = function _getConfig(config) {
	      config = $.extend({}, this.constructor.Default, $(this._element).data(), config);
	      Util.typeCheckConfig(NAME, config, this.constructor.DefaultType);
	      return config;
	    };

	    _proto._getMenuElement = function _getMenuElement() {
	      if (!this._menu) {
	        var parent = Dropdown._getParentFromElement(this._element);

	        this._menu = $(parent).find(Selector.MENU)[0];
	      }

	      return this._menu;
	    };

	    _proto._getPlacement = function _getPlacement() {
	      var $parentDropdown = $(this._element).parent();
	      var placement = AttachmentMap.BOTTOM; // Handle dropup

	      if ($parentDropdown.hasClass(ClassName.DROPUP)) {
	        placement = AttachmentMap.TOP;

	        if ($(this._menu).hasClass(ClassName.MENURIGHT)) {
	          placement = AttachmentMap.TOPEND;
	        }
	      } else if ($(this._menu).hasClass(ClassName.MENURIGHT)) {
	        placement = AttachmentMap.BOTTOMEND;
	      }

	      return placement;
	    };

	    _proto._detectNavbar = function _detectNavbar() {
	      return $(this._element).closest('.navbar').length > 0;
	    };

	    _proto._getPopperConfig = function _getPopperConfig() {
	      var _this2 = this;

	      var offsetConf = {};

	      if (typeof this._config.offset === 'function') {
	        offsetConf.fn = function (data) {
	          data.offsets = $.extend({}, data.offsets, _this2._config.offset(data.offsets) || {});
	          return data;
	        };
	      } else {
	        offsetConf.offset = this._config.offset;
	      }

	      var popperConfig = {
	        placement: this._getPlacement(),
	        modifiers: {
	          offset: offsetConf,
	          flip: {
	            enabled: this._config.flip
	          }
	        } // Disable Popper.js for Dropdown in Navbar

	      };

	      if (this._inNavbar) {
	        popperConfig.modifiers.applyStyle = {
	          enabled: !this._inNavbar
	        };
	      }

	      return popperConfig;
	    }; // static


	    Dropdown._jQueryInterface = function _jQueryInterface(config) {
	      return this.each(function () {
	        var data = $(this).data(DATA_KEY);

	        var _config = typeof config === 'object' ? config : null;

	        if (!data) {
	          data = new Dropdown(this, _config);
	          $(this).data(DATA_KEY, data);
	        }

	        if (typeof config === 'string') {
	          if (typeof data[config] === 'undefined') {
	            throw new Error("No method named \"" + config + "\"");
	          }

	          data[config]();
	        }
	      });
	    };

	    Dropdown._clearMenus = function _clearMenus(event) {
	      if (event && (event.which === RIGHT_MOUSE_BUTTON_WHICH || event.type === 'keyup' && event.which !== TAB_KEYCODE)) {
	        return;
	      }

	      var toggles = $.makeArray($(Selector.DATA_TOGGLE));

	      for (var i = 0; i < toggles.length; i++) {
	        var parent = Dropdown._getParentFromElement(toggles[i]);

	        var context = $(toggles[i]).data(DATA_KEY);
	        var relatedTarget = {
	          relatedTarget: toggles[i]
	        };

	        if (!context) {
	          continue;
	        }

	        var dropdownMenu = context._menu;

	        if (!$(parent).hasClass(ClassName.SHOW)) {
	          continue;
	        }

	        if (event && (event.type === 'click' && /input|textarea/i.test(event.target.tagName) || event.type === 'keyup' && event.which === TAB_KEYCODE) && $.contains(parent, event.target)) {
	          continue;
	        }

	        var hideEvent = $.Event(Event.HIDE, relatedTarget);
	        $(parent).trigger(hideEvent);

	        if (hideEvent.isDefaultPrevented()) {
	          continue;
	        } // if this is a touch-enabled device we remove the extra
	        // empty mouseover listeners we added for iOS support


	        if ('ontouchstart' in document.documentElement) {
	          $('body').children().off('mouseover', null, $.noop);
	        }

	        toggles[i].setAttribute('aria-expanded', 'false');
	        $(dropdownMenu).removeClass(ClassName.SHOW);
	        $(parent).removeClass(ClassName.SHOW).trigger($.Event(Event.HIDDEN, relatedTarget));
	      }
	    };

	    Dropdown._getParentFromElement = function _getParentFromElement(element) {
	      var parent;
	      var selector = Util.getSelectorFromElement(element);

	      if (selector) {
	        parent = $(selector)[0];
	      }

	      return parent || element.parentNode;
	    };

	    Dropdown._dataApiKeydownHandler = function _dataApiKeydownHandler(event) {
	      if (!REGEXP_KEYDOWN.test(event.which) || /button/i.test(event.target.tagName) && event.which === SPACE_KEYCODE || /input|textarea/i.test(event.target.tagName)) {
	        return;
	      }

	      event.preventDefault();
	      event.stopPropagation();

	      if (this.disabled || $(this).hasClass(ClassName.DISABLED)) {
	        return;
	      }

	      var parent = Dropdown._getParentFromElement(this);

	      var isActive = $(parent).hasClass(ClassName.SHOW);

	      if (!isActive && (event.which !== ESCAPE_KEYCODE || event.which !== SPACE_KEYCODE) || isActive && (event.which === ESCAPE_KEYCODE || event.which === SPACE_KEYCODE)) {
	        if (event.which === ESCAPE_KEYCODE) {
	          var toggle = $(parent).find(Selector.DATA_TOGGLE)[0];
	          $(toggle).trigger('focus');
	        }

	        $(this).trigger('click');
	        return;
	      }

	      var items = $(parent).find(Selector.VISIBLE_ITEMS).get();

	      if (!items.length) {
	        return;
	      }

	      var index = items.indexOf(event.target);

	      if (event.which === ARROW_UP_KEYCODE && index > 0) {
	        // up
	        index--;
	      }

	      if (event.which === ARROW_DOWN_KEYCODE && index < items.length - 1) {
	        // down
	        index++;
	      }

	      if (index < 0) {
	        index = 0;
	      }

	      items[index].focus();
	    };

	    createClass(Dropdown, null, [{
	      key: "VERSION",
	      get: function get() {
	        return VERSION;
	      }
	    }, {
	      key: "Default",
	      get: function get() {
	        return Default;
	      }
	    }, {
	      key: "DefaultType",
	      get: function get() {
	        return DefaultType;
	      }
	    }]);
	    return Dropdown;
	  }();
	  /**
	   * ------------------------------------------------------------------------
	   * Data Api implementation
	   * ------------------------------------------------------------------------
	   */


	  $(document).on(Event.KEYDOWN_DATA_API, Selector.DATA_TOGGLE, Dropdown._dataApiKeydownHandler).on(Event.KEYDOWN_DATA_API, Selector.MENU, Dropdown._dataApiKeydownHandler).on(Event.CLICK_DATA_API + " " + Event.KEYUP_DATA_API, Dropdown._clearMenus).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {
	    event.preventDefault();
	    event.stopPropagation();

	    Dropdown._jQueryInterface.call($(this), 'toggle');
	  }).on(Event.CLICK_DATA_API, Selector.FORM_CHILD, function (e) {
	    e.stopPropagation();
	  });
	  /**
	   * ------------------------------------------------------------------------
	   * jQuery
	   * ------------------------------------------------------------------------
	   */

	  $.fn[NAME] = Dropdown._jQueryInterface;
	  $.fn[NAME].Constructor = Dropdown;

	  $.fn[NAME].noConflict = function () {
	    $.fn[NAME] = JQUERY_NO_CONFLICT;
	    return Dropdown._jQueryInterface;
	  };

	  return Dropdown;
	}($, Popper);

	/**
	 * --------------------------------------------------------------------------
	 * Bootstrap (v4.0.0-beta.2): modal.js
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * --------------------------------------------------------------------------
	 */

	var Modal = function () {
	  /**
	   * ------------------------------------------------------------------------
	   * Constants
	   * ------------------------------------------------------------------------
	   */
	  var NAME = 'modal';
	  var VERSION = '4.0.0-beta.2';
	  var DATA_KEY = 'bs.modal';
	  var EVENT_KEY = "." + DATA_KEY;
	  var DATA_API_KEY = '.data-api';
	  var JQUERY_NO_CONFLICT = $.fn[NAME];
	  var TRANSITION_DURATION = 300;
	  var BACKDROP_TRANSITION_DURATION = 150;
	  var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key

	  var Default = {
	    backdrop: true,
	    keyboard: true,
	    focus: true,
	    show: true
	  };
	  var DefaultType = {
	    backdrop: '(boolean|string)',
	    keyboard: 'boolean',
	    focus: 'boolean',
	    show: 'boolean'
	  };
	  var Event = {
	    HIDE: "hide" + EVENT_KEY,
	    HIDDEN: "hidden" + EVENT_KEY,
	    SHOW: "show" + EVENT_KEY,
	    SHOWN: "shown" + EVENT_KEY,
	    FOCUSIN: "focusin" + EVENT_KEY,
	    RESIZE: "resize" + EVENT_KEY,
	    CLICK_DISMISS: "click.dismiss" + EVENT_KEY,
	    KEYDOWN_DISMISS: "keydown.dismiss" + EVENT_KEY,
	    MOUSEUP_DISMISS: "mouseup.dismiss" + EVENT_KEY,
	    MOUSEDOWN_DISMISS: "mousedown.dismiss" + EVENT_KEY,
	    CLICK_DATA_API: "click" + EVENT_KEY + DATA_API_KEY
	  };
	  var ClassName = {
	    SCROLLBAR_MEASURER: 'modal-scrollbar-measure',
	    BACKDROP: 'modal-backdrop',
	    OPEN: 'modal-open',
	    FADE: 'fade',
	    SHOW: 'show'
	  };
	  var Selector = {
	    DIALOG: '.modal-dialog',
	    DATA_TOGGLE: '[data-toggle="modal"]',
	    DATA_DISMISS: '[data-dismiss="modal"]',
	    FIXED_CONTENT: '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top',
	    STICKY_CONTENT: '.sticky-top',
	    NAVBAR_TOGGLER: '.navbar-toggler'
	    /**
	     * ------------------------------------------------------------------------
	     * Class Definition
	     * ------------------------------------------------------------------------
	     */

	  };

	  var Modal =
	  /*#__PURE__*/
	  function () {
	    function Modal(element, config) {
	      this._config = this._getConfig(config);
	      this._element = element;
	      this._dialog = $(element).find(Selector.DIALOG)[0];
	      this._backdrop = null;
	      this._isShown = false;
	      this._isBodyOverflowing = false;
	      this._ignoreBackdropClick = false;
	      this._originalBodyPadding = 0;
	      this._scrollbarWidth = 0;
	    } // getters


	    var _proto = Modal.prototype;

	    // public
	    _proto.toggle = function toggle(relatedTarget) {
	      return this._isShown ? this.hide() : this.show(relatedTarget);
	    };

	    _proto.show = function show(relatedTarget) {
	      var _this = this;

	      if (this._isTransitioning || this._isShown) {
	        return;
	      }

	      if (Util.supportsTransitionEnd() && $(this._element).hasClass(ClassName.FADE)) {
	        this._isTransitioning = true;
	      }

	      var showEvent = $.Event(Event.SHOW, {
	        relatedTarget: relatedTarget
	      });
	      $(this._element).trigger(showEvent);

	      if (this._isShown || showEvent.isDefaultPrevented()) {
	        return;
	      }

	      this._isShown = true;

	      this._checkScrollbar();

	      this._setScrollbar();

	      this._adjustDialog();

	      $(document.body).addClass(ClassName.OPEN);

	      this._setEscapeEvent();

	      this._setResizeEvent();

	      $(this._element).on(Event.CLICK_DISMISS, Selector.DATA_DISMISS, function (event) {
	        return _this.hide(event);
	      });
	      $(this._dialog).on(Event.MOUSEDOWN_DISMISS, function () {
	        $(_this._element).one(Event.MOUSEUP_DISMISS, function (event) {
	          if ($(event.target).is(_this._element)) {
	            _this._ignoreBackdropClick = true;
	          }
	        });
	      });

	      this._showBackdrop(function () {
	        return _this._showElement(relatedTarget);
	      });
	    };

	    _proto.hide = function hide(event) {
	      var _this2 = this;

	      if (event) {
	        event.preventDefault();
	      }

	      if (this._isTransitioning || !this._isShown) {
	        return;
	      }

	      var hideEvent = $.Event(Event.HIDE);
	      $(this._element).trigger(hideEvent);

	      if (!this._isShown || hideEvent.isDefaultPrevented()) {
	        return;
	      }

	      this._isShown = false;
	      var transition = Util.supportsTransitionEnd() && $(this._element).hasClass(ClassName.FADE);

	      if (transition) {
	        this._isTransitioning = true;
	      }

	      this._setEscapeEvent();

	      this._setResizeEvent();

	      $(document).off(Event.FOCUSIN);
	      $(this._element).removeClass(ClassName.SHOW);
	      $(this._element).off(Event.CLICK_DISMISS);
	      $(this._dialog).off(Event.MOUSEDOWN_DISMISS);

	      if (transition) {
	        $(this._element).one(Util.TRANSITION_END, function (event) {
	          return _this2._hideModal(event);
	        }).emulateTransitionEnd(TRANSITION_DURATION);
	      } else {
	        this._hideModal();
	      }
	    };

	    _proto.dispose = function dispose() {
	      $.removeData(this._element, DATA_KEY);
	      $(window, document, this._element, this._backdrop).off(EVENT_KEY);
	      this._config = null;
	      this._element = null;
	      this._dialog = null;
	      this._backdrop = null;
	      this._isShown = null;
	      this._isBodyOverflowing = null;
	      this._ignoreBackdropClick = null;
	      this._scrollbarWidth = null;
	    };

	    _proto.handleUpdate = function handleUpdate() {
	      this._adjustDialog();
	    }; // private


	    _proto._getConfig = function _getConfig(config) {
	      config = $.extend({}, Default, config);
	      Util.typeCheckConfig(NAME, config, DefaultType);
	      return config;
	    };

	    _proto._showElement = function _showElement(relatedTarget) {
	      var _this3 = this;

	      var transition = Util.supportsTransitionEnd() && $(this._element).hasClass(ClassName.FADE);

	      if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {
	        // don't move modals dom position
	        document.body.appendChild(this._element);
	      }

	      this._element.style.display = 'block';

	      this._element.removeAttribute('aria-hidden');

	      this._element.scrollTop = 0;

	      if (transition) {
	        Util.reflow(this._element);
	      }

	      $(this._element).addClass(ClassName.SHOW);

	      if (this._config.focus) {
	        this._enforceFocus();
	      }

	      var shownEvent = $.Event(Event.SHOWN, {
	        relatedTarget: relatedTarget
	      });

	      var transitionComplete = function transitionComplete() {
	        if (_this3._config.focus) {
	          _this3._element.focus();
	        }

	        _this3._isTransitioning = false;
	        $(_this3._element).trigger(shownEvent);
	      };

	      if (transition) {
	        $(this._dialog).one(Util.TRANSITION_END, transitionComplete).emulateTransitionEnd(TRANSITION_DURATION);
	      } else {
	        transitionComplete();
	      }
	    };

	    _proto._enforceFocus = function _enforceFocus() {
	      var _this4 = this;

	      $(document).off(Event.FOCUSIN) // guard against infinite focus loop
	      .on(Event.FOCUSIN, function (event) {
	        if (document !== event.target && _this4._element !== event.target && !$(_this4._element).has(event.target).length) {
	          _this4._element.focus();
	        }
	      });
	    };

	    _proto._setEscapeEvent = function _setEscapeEvent() {
	      var _this5 = this;

	      if (this._isShown && this._config.keyboard) {
	        $(this._element).on(Event.KEYDOWN_DISMISS, function (event) {
	          if (event.which === ESCAPE_KEYCODE) {
	            event.preventDefault();

	            _this5.hide();
	          }
	        });
	      } else if (!this._isShown) {
	        $(this._element).off(Event.KEYDOWN_DISMISS);
	      }
	    };

	    _proto._setResizeEvent = function _setResizeEvent() {
	      var _this6 = this;

	      if (this._isShown) {
	        $(window).on(Event.RESIZE, function (event) {
	          return _this6.handleUpdate(event);
	        });
	      } else {
	        $(window).off(Event.RESIZE);
	      }
	    };

	    _proto._hideModal = function _hideModal() {
	      var _this7 = this;

	      this._element.style.display = 'none';

	      this._element.setAttribute('aria-hidden', true);

	      this._isTransitioning = false;

	      this._showBackdrop(function () {
	        $(document.body).removeClass(ClassName.OPEN);

	        _this7._resetAdjustments();

	        _this7._resetScrollbar();

	        $(_this7._element).trigger(Event.HIDDEN);
	      });
	    };

	    _proto._removeBackdrop = function _removeBackdrop() {
	      if (this._backdrop) {
	        $(this._backdrop).remove();
	        this._backdrop = null;
	      }
	    };

	    _proto._showBackdrop = function _showBackdrop(callback) {
	      var _this8 = this;

	      var animate = $(this._element).hasClass(ClassName.FADE) ? ClassName.FADE : '';

	      if (this._isShown && this._config.backdrop) {
	        var doAnimate = Util.supportsTransitionEnd() && animate;
	        this._backdrop = document.createElement('div');
	        this._backdrop.className = ClassName.BACKDROP;

	        if (animate) {
	          $(this._backdrop).addClass(animate);
	        }

	        $(this._backdrop).appendTo(document.body);
	        $(this._element).on(Event.CLICK_DISMISS, function (event) {
	          if (_this8._ignoreBackdropClick) {
	            _this8._ignoreBackdropClick = false;
	            return;
	          }

	          if (event.target !== event.currentTarget) {
	            return;
	          }

	          if (_this8._config.backdrop === 'static') {
	            _this8._element.focus();
	          } else {
	            _this8.hide();
	          }
	        });

	        if (doAnimate) {
	          Util.reflow(this._backdrop);
	        }

	        $(this._backdrop).addClass(ClassName.SHOW);

	        if (!callback) {
	          return;
	        }

	        if (!doAnimate) {
	          callback();
	          return;
	        }

	        $(this._backdrop).one(Util.TRANSITION_END, callback).emulateTransitionEnd(BACKDROP_TRANSITION_DURATION);
	      } else if (!this._isShown && this._backdrop) {
	        $(this._backdrop).removeClass(ClassName.SHOW);

	        var callbackRemove = function callbackRemove() {
	          _this8._removeBackdrop();

	          if (callback) {
	            callback();
	          }
	        };

	        if (Util.supportsTransitionEnd() && $(this._element).hasClass(ClassName.FADE)) {
	          $(this._backdrop).one(Util.TRANSITION_END, callbackRemove).emulateTransitionEnd(BACKDROP_TRANSITION_DURATION);
	        } else {
	          callbackRemove();
	        }
	      } else if (callback) {
	        callback();
	      }
	    }; // ----------------------------------------------------------------------
	    // the following methods are used to handle overflowing modals
	    // todo (fat): these should probably be refactored out of modal.js
	    // ----------------------------------------------------------------------


	    _proto._adjustDialog = function _adjustDialog() {
	      var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;

	      if (!this._isBodyOverflowing && isModalOverflowing) {
	        this._element.style.paddingLeft = this._scrollbarWidth + "px";
	      }

	      if (this._isBodyOverflowing && !isModalOverflowing) {
	        this._element.style.paddingRight = this._scrollbarWidth + "px";
	      }
	    };

	    _proto._resetAdjustments = function _resetAdjustments() {
	      this._element.style.paddingLeft = '';
	      this._element.style.paddingRight = '';
	    };

	    _proto._checkScrollbar = function _checkScrollbar() {
	      var rect = document.body.getBoundingClientRect();
	      this._isBodyOverflowing = rect.left + rect.right < window.innerWidth;
	      this._scrollbarWidth = this._getScrollbarWidth();
	    };

	    _proto._setScrollbar = function _setScrollbar() {
	      var _this9 = this;

	      if (this._isBodyOverflowing) {
	        // Note: DOMNode.style.paddingRight returns the actual value or '' if not set
	        //   while $(DOMNode).css('padding-right') returns the calculated value or 0 if not set
	        // Adjust fixed content padding
	        $(Selector.FIXED_CONTENT).each(function (index, element) {
	          var actualPadding = $(element)[0].style.paddingRight;
	          var calculatedPadding = $(element).css('padding-right');
	          $(element).data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + _this9._scrollbarWidth + "px");
	        }); // Adjust sticky content margin

	        $(Selector.STICKY_CONTENT).each(function (index, element) {
	          var actualMargin = $(element)[0].style.marginRight;
	          var calculatedMargin = $(element).css('margin-right');
	          $(element).data('margin-right', actualMargin).css('margin-right', parseFloat(calculatedMargin) - _this9._scrollbarWidth + "px");
	        }); // Adjust navbar-toggler margin

	        $(Selector.NAVBAR_TOGGLER).each(function (index, element) {
	          var actualMargin = $(element)[0].style.marginRight;
	          var calculatedMargin = $(element).css('margin-right');
	          $(element).data('margin-right', actualMargin).css('margin-right', parseFloat(calculatedMargin) + _this9._scrollbarWidth + "px");
	        }); // Adjust body padding

	        var actualPadding = document.body.style.paddingRight;
	        var calculatedPadding = $('body').css('padding-right');
	        $('body').data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + this._scrollbarWidth + "px");
	      }
	    };

	    _proto._resetScrollbar = function _resetScrollbar() {
	      // Restore fixed content padding
	      $(Selector.FIXED_CONTENT).each(function (index, element) {
	        var padding = $(element).data('padding-right');

	        if (typeof padding !== 'undefined') {
	          $(element).css('padding-right', padding).removeData('padding-right');
	        }
	      }); // Restore sticky content and navbar-toggler margin

	      $(Selector.STICKY_CONTENT + ", " + Selector.NAVBAR_TOGGLER).each(function (index, element) {
	        var margin = $(element).data('margin-right');

	        if (typeof margin !== 'undefined') {
	          $(element).css('margin-right', margin).removeData('margin-right');
	        }
	      }); // Restore body padding

	      var padding = $('body').data('padding-right');

	      if (typeof padding !== 'undefined') {
	        $('body').css('padding-right', padding).removeData('padding-right');
	      }
	    };

	    _proto._getScrollbarWidth = function _getScrollbarWidth() {
	      // thx d.walsh
	      var scrollDiv = document.createElement('div');
	      scrollDiv.className = ClassName.SCROLLBAR_MEASURER;
	      document.body.appendChild(scrollDiv);
	      var scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
	      document.body.removeChild(scrollDiv);
	      return scrollbarWidth;
	    }; // static


	    Modal._jQueryInterface = function _jQueryInterface(config, relatedTarget) {
	      return this.each(function () {
	        var data = $(this).data(DATA_KEY);

	        var _config = $.extend({}, Modal.Default, $(this).data(), typeof config === 'object' && config);

	        if (!data) {
	          data = new Modal(this, _config);
	          $(this).data(DATA_KEY, data);
	        }

	        if (typeof config === 'string') {
	          if (typeof data[config] === 'undefined') {
	            throw new Error("No method named \"" + config + "\"");
	          }

	          data[config](relatedTarget);
	        } else if (_config.show) {
	          data.show(relatedTarget);
	        }
	      });
	    };

	    createClass(Modal, null, [{
	      key: "VERSION",
	      get: function get() {
	        return VERSION;
	      }
	    }, {
	      key: "Default",
	      get: function get() {
	        return Default;
	      }
	    }]);
	    return Modal;
	  }();
	  /**
	   * ------------------------------------------------------------------------
	   * Data Api implementation
	   * ------------------------------------------------------------------------
	   */


	  $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {
	    var _this10 = this;

	    var target;
	    var selector = Util.getSelectorFromElement(this);

	    if (selector) {
	      target = $(selector)[0];
	    }

	    var config = $(target).data(DATA_KEY) ? 'toggle' : $.extend({}, $(target).data(), $(this).data());

	    if (this.tagName === 'A' || this.tagName === 'AREA') {
	      event.preventDefault();
	    }

	    var $target = $(target).one(Event.SHOW, function (showEvent) {
	      if (showEvent.isDefaultPrevented()) {
	        // only register focus restorer if modal will actually get shown
	        return;
	      }

	      $target.one(Event.HIDDEN, function () {
	        if ($(_this10).is(':visible')) {
	          _this10.focus();
	        }
	      });
	    });

	    Modal._jQueryInterface.call($(target), config, this);
	  });
	  /**
	   * ------------------------------------------------------------------------
	   * jQuery
	   * ------------------------------------------------------------------------
	   */

	  $.fn[NAME] = Modal._jQueryInterface;
	  $.fn[NAME].Constructor = Modal;

	  $.fn[NAME].noConflict = function () {
	    $.fn[NAME] = JQUERY_NO_CONFLICT;
	    return Modal._jQueryInterface;
	  };

	  return Modal;
	}($);

	/**
	 * --------------------------------------------------------------------------
	 * Bootstrap (v4.0.0-beta.2): tooltip.js
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * --------------------------------------------------------------------------
	 */

	var Tooltip = function () {
	  /**
	   * Check for Popper dependency
	   * Popper - https://popper.js.org
	   */
	  if (typeof Popper === 'undefined') {
	    throw new Error('Bootstrap tooltips require Popper.js (https://popper.js.org)');
	  }
	  /**
	   * ------------------------------------------------------------------------
	   * Constants
	   * ------------------------------------------------------------------------
	   */


	  var NAME = 'tooltip';
	  var VERSION = '4.0.0-beta.2';
	  var DATA_KEY = 'bs.tooltip';
	  var EVENT_KEY = "." + DATA_KEY;
	  var JQUERY_NO_CONFLICT = $.fn[NAME];
	  var TRANSITION_DURATION = 150;
	  var CLASS_PREFIX = 'bs-tooltip';
	  var BSCLS_PREFIX_REGEX = new RegExp("(^|\\s)" + CLASS_PREFIX + "\\S+", 'g');
	  var DefaultType = {
	    animation: 'boolean',
	    template: 'string',
	    title: '(string|element|function)',
	    trigger: 'string',
	    delay: '(number|object)',
	    html: 'boolean',
	    selector: '(string|boolean)',
	    placement: '(string|function)',
	    offset: '(number|string)',
	    container: '(string|element|boolean)',
	    fallbackPlacement: '(string|array)'
	  };
	  var AttachmentMap = {
	    AUTO: 'auto',
	    TOP: 'top',
	    RIGHT: 'right',
	    BOTTOM: 'bottom',
	    LEFT: 'left'
	  };
	  var Default = {
	    animation: true,
	    template: '<div class="tooltip" role="tooltip">' + '<div class="arrow"></div>' + '<div class="tooltip-inner"></div></div>',
	    trigger: 'hover focus',
	    title: '',
	    delay: 0,
	    html: false,
	    selector: false,
	    placement: 'top',
	    offset: 0,
	    container: false,
	    fallbackPlacement: 'flip'
	  };
	  var HoverState = {
	    SHOW: 'show',
	    OUT: 'out'
	  };
	  var Event = {
	    HIDE: "hide" + EVENT_KEY,
	    HIDDEN: "hidden" + EVENT_KEY,
	    SHOW: "show" + EVENT_KEY,
	    SHOWN: "shown" + EVENT_KEY,
	    INSERTED: "inserted" + EVENT_KEY,
	    CLICK: "click" + EVENT_KEY,
	    FOCUSIN: "focusin" + EVENT_KEY,
	    FOCUSOUT: "focusout" + EVENT_KEY,
	    MOUSEENTER: "mouseenter" + EVENT_KEY,
	    MOUSELEAVE: "mouseleave" + EVENT_KEY
	  };
	  var ClassName = {
	    FADE: 'fade',
	    SHOW: 'show'
	  };
	  var Selector = {
	    TOOLTIP: '.tooltip',
	    TOOLTIP_INNER: '.tooltip-inner',
	    ARROW: '.arrow'
	  };
	  var Trigger = {
	    HOVER: 'hover',
	    FOCUS: 'focus',
	    CLICK: 'click',
	    MANUAL: 'manual'
	    /**
	     * ------------------------------------------------------------------------
	     * Class Definition
	     * ------------------------------------------------------------------------
	     */

	  };

	  var Tooltip =
	  /*#__PURE__*/
	  function () {
	    function Tooltip(element, config) {
	      // private
	      this._isEnabled = true;
	      this._timeout = 0;
	      this._hoverState = '';
	      this._activeTrigger = {};
	      this._popper = null; // protected

	      this.element = element;
	      this.config = this._getConfig(config);
	      this.tip = null;

	      this._setListeners();
	    } // getters


	    var _proto = Tooltip.prototype;

	    // public
	    _proto.enable = function enable() {
	      this._isEnabled = true;
	    };

	    _proto.disable = function disable() {
	      this._isEnabled = false;
	    };

	    _proto.toggleEnabled = function toggleEnabled() {
	      this._isEnabled = !this._isEnabled;
	    };

	    _proto.toggle = function toggle(event) {
	      if (!this._isEnabled) {
	        return;
	      }

	      if (event) {
	        var dataKey = this.constructor.DATA_KEY;
	        var context = $(event.currentTarget).data(dataKey);

	        if (!context) {
	          context = new this.constructor(event.currentTarget, this._getDelegateConfig());
	          $(event.currentTarget).data(dataKey, context);
	        }

	        context._activeTrigger.click = !context._activeTrigger.click;

	        if (context._isWithActiveTrigger()) {
	          context._enter(null, context);
	        } else {
	          context._leave(null, context);
	        }
	      } else {
	        if ($(this.getTipElement()).hasClass(ClassName.SHOW)) {
	          this._leave(null, this);

	          return;
	        }

	        this._enter(null, this);
	      }
	    };

	    _proto.dispose = function dispose() {
	      clearTimeout(this._timeout);
	      $.removeData(this.element, this.constructor.DATA_KEY);
	      $(this.element).off(this.constructor.EVENT_KEY);
	      $(this.element).closest('.modal').off('hide.bs.modal');

	      if (this.tip) {
	        $(this.tip).remove();
	      }

	      this._isEnabled = null;
	      this._timeout = null;
	      this._hoverState = null;
	      this._activeTrigger = null;

	      if (this._popper !== null) {
	        this._popper.destroy();
	      }

	      this._popper = null;
	      this.element = null;
	      this.config = null;
	      this.tip = null;
	    };

	    _proto.show = function show() {
	      var _this = this;

	      if ($(this.element).css('display') === 'none') {
	        throw new Error('Please use show on visible elements');
	      }

	      var showEvent = $.Event(this.constructor.Event.SHOW);

	      if (this.isWithContent() && this._isEnabled) {
	        $(this.element).trigger(showEvent);
	        var isInTheDom = $.contains(this.element.ownerDocument.documentElement, this.element);

	        if (showEvent.isDefaultPrevented() || !isInTheDom) {
	          return;
	        }

	        var tip = this.getTipElement();
	        var tipId = Util.getUID(this.constructor.NAME);
	        tip.setAttribute('id', tipId);
	        this.element.setAttribute('aria-describedby', tipId);
	        this.setContent();

	        if (this.config.animation) {
	          $(tip).addClass(ClassName.FADE);
	        }

	        var placement = typeof this.config.placement === 'function' ? this.config.placement.call(this, tip, this.element) : this.config.placement;

	        var attachment = this._getAttachment(placement);

	        this.addAttachmentClass(attachment);
	        var container = this.config.container === false ? document.body : $(this.config.container);
	        $(tip).data(this.constructor.DATA_KEY, this);

	        if (!$.contains(this.element.ownerDocument.documentElement, this.tip)) {
	          $(tip).appendTo(container);
	        }

	        $(this.element).trigger(this.constructor.Event.INSERTED);
	        this._popper = new Popper(this.element, tip, {
	          placement: attachment,
	          modifiers: {
	            offset: {
	              offset: this.config.offset
	            },
	            flip: {
	              behavior: this.config.fallbackPlacement
	            },
	            arrow: {
	              element: Selector.ARROW
	            }
	          },
	          onCreate: function onCreate(data) {
	            if (data.originalPlacement !== data.placement) {
	              _this._handlePopperPlacementChange(data);
	            }
	          },
	          onUpdate: function onUpdate(data) {
	            _this._handlePopperPlacementChange(data);
	          }
	        });
	        $(tip).addClass(ClassName.SHOW); // if this is a touch-enabled device we add extra
	        // empty mouseover listeners to the body's immediate children;
	        // only needed because of broken event delegation on iOS
	        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html

	        if ('ontouchstart' in document.documentElement) {
	          $('body').children().on('mouseover', null, $.noop);
	        }

	        var complete = function complete() {
	          if (_this.config.animation) {
	            _this._fixTransition();
	          }

	          var prevHoverState = _this._hoverState;
	          _this._hoverState = null;
	          $(_this.element).trigger(_this.constructor.Event.SHOWN);

	          if (prevHoverState === HoverState.OUT) {
	            _this._leave(null, _this);
	          }
	        };

	        if (Util.supportsTransitionEnd() && $(this.tip).hasClass(ClassName.FADE)) {
	          $(this.tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(Tooltip._TRANSITION_DURATION);
	        } else {
	          complete();
	        }
	      }
	    };

	    _proto.hide = function hide(callback) {
	      var _this2 = this;

	      var tip = this.getTipElement();
	      var hideEvent = $.Event(this.constructor.Event.HIDE);

	      var complete = function complete() {
	        if (_this2._hoverState !== HoverState.SHOW && tip.parentNode) {
	          tip.parentNode.removeChild(tip);
	        }

	        _this2._cleanTipClass();

	        _this2.element.removeAttribute('aria-describedby');

	        $(_this2.element).trigger(_this2.constructor.Event.HIDDEN);

	        if (_this2._popper !== null) {
	          _this2._popper.destroy();
	        }

	        if (callback) {
	          callback();
	        }
	      };

	      $(this.element).trigger(hideEvent);

	      if (hideEvent.isDefaultPrevented()) {
	        return;
	      }

	      $(tip).removeClass(ClassName.SHOW); // if this is a touch-enabled device we remove the extra
	      // empty mouseover listeners we added for iOS support

	      if ('ontouchstart' in document.documentElement) {
	        $('body').children().off('mouseover', null, $.noop);
	      }

	      this._activeTrigger[Trigger.CLICK] = false;
	      this._activeTrigger[Trigger.FOCUS] = false;
	      this._activeTrigger[Trigger.HOVER] = false;

	      if (Util.supportsTransitionEnd() && $(this.tip).hasClass(ClassName.FADE)) {
	        $(tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(TRANSITION_DURATION);
	      } else {
	        complete();
	      }

	      this._hoverState = '';
	    };

	    _proto.update = function update() {
	      if (this._popper !== null) {
	        this._popper.scheduleUpdate();
	      }
	    }; // protected


	    _proto.isWithContent = function isWithContent() {
	      return Boolean(this.getTitle());
	    };

	    _proto.addAttachmentClass = function addAttachmentClass(attachment) {
	      $(this.getTipElement()).addClass(CLASS_PREFIX + "-" + attachment);
	    };

	    _proto.getTipElement = function getTipElement() {
	      this.tip = this.tip || $(this.config.template)[0];
	      return this.tip;
	    };

	    _proto.setContent = function setContent() {
	      var $tip = $(this.getTipElement());
	      this.setElementContent($tip.find(Selector.TOOLTIP_INNER), this.getTitle());
	      $tip.removeClass(ClassName.FADE + " " + ClassName.SHOW);
	    };

	    _proto.setElementContent = function setElementContent($element, content) {
	      var html = this.config.html;

	      if (typeof content === 'object' && (content.nodeType || content.jquery)) {
	        // content is a DOM node or a jQuery
	        if (html) {
	          if (!$(content).parent().is($element)) {
	            $element.empty().append(content);
	          }
	        } else {
	          $element.text($(content).text());
	        }
	      } else {
	        $element[html ? 'html' : 'text'](content);
	      }
	    };

	    _proto.getTitle = function getTitle() {
	      var title = this.element.getAttribute('data-original-title');

	      if (!title) {
	        title = typeof this.config.title === 'function' ? this.config.title.call(this.element) : this.config.title;
	      }

	      return title;
	    }; // private


	    _proto._getAttachment = function _getAttachment(placement) {
	      return AttachmentMap[placement.toUpperCase()];
	    };

	    _proto._setListeners = function _setListeners() {
	      var _this3 = this;

	      var triggers = this.config.trigger.split(' ');
	      triggers.forEach(function (trigger) {
	        if (trigger === 'click') {
	          $(_this3.element).on(_this3.constructor.Event.CLICK, _this3.config.selector, function (event) {
	            return _this3.toggle(event);
	          });
	        } else if (trigger !== Trigger.MANUAL) {
	          var eventIn = trigger === Trigger.HOVER ? _this3.constructor.Event.MOUSEENTER : _this3.constructor.Event.FOCUSIN;
	          var eventOut = trigger === Trigger.HOVER ? _this3.constructor.Event.MOUSELEAVE : _this3.constructor.Event.FOCUSOUT;
	          $(_this3.element).on(eventIn, _this3.config.selector, function (event) {
	            return _this3._enter(event);
	          }).on(eventOut, _this3.config.selector, function (event) {
	            return _this3._leave(event);
	          });
	        }

	        $(_this3.element).closest('.modal').on('hide.bs.modal', function () {
	          return _this3.hide();
	        });
	      });

	      if (this.config.selector) {
	        this.config = $.extend({}, this.config, {
	          trigger: 'manual',
	          selector: ''
	        });
	      } else {
	        this._fixTitle();
	      }
	    };

	    _proto._fixTitle = function _fixTitle() {
	      var titleType = typeof this.element.getAttribute('data-original-title');

	      if (this.element.getAttribute('title') || titleType !== 'string') {
	        this.element.setAttribute('data-original-title', this.element.getAttribute('title') || '');
	        this.element.setAttribute('title', '');
	      }
	    };

	    _proto._enter = function _enter(event, context) {
	      var dataKey = this.constructor.DATA_KEY;
	      context = context || $(event.currentTarget).data(dataKey);

	      if (!context) {
	        context = new this.constructor(event.currentTarget, this._getDelegateConfig());
	        $(event.currentTarget).data(dataKey, context);
	      }

	      if (event) {
	        context._activeTrigger[event.type === 'focusin' ? Trigger.FOCUS : Trigger.HOVER] = true;
	      }

	      if ($(context.getTipElement()).hasClass(ClassName.SHOW) || context._hoverState === HoverState.SHOW) {
	        context._hoverState = HoverState.SHOW;
	        return;
	      }

	      clearTimeout(context._timeout);
	      context._hoverState = HoverState.SHOW;

	      if (!context.config.delay || !context.config.delay.show) {
	        context.show();
	        return;
	      }

	      context._timeout = setTimeout(function () {
	        if (context._hoverState === HoverState.SHOW) {
	          context.show();
	        }
	      }, context.config.delay.show);
	    };

	    _proto._leave = function _leave(event, context) {
	      var dataKey = this.constructor.DATA_KEY;
	      context = context || $(event.currentTarget).data(dataKey);

	      if (!context) {
	        context = new this.constructor(event.currentTarget, this._getDelegateConfig());
	        $(event.currentTarget).data(dataKey, context);
	      }

	      if (event) {
	        context._activeTrigger[event.type === 'focusout' ? Trigger.FOCUS : Trigger.HOVER] = false;
	      }

	      if (context._isWithActiveTrigger()) {
	        return;
	      }

	      clearTimeout(context._timeout);
	      context._hoverState = HoverState.OUT;

	      if (!context.config.delay || !context.config.delay.hide) {
	        context.hide();
	        return;
	      }

	      context._timeout = setTimeout(function () {
	        if (context._hoverState === HoverState.OUT) {
	          context.hide();
	        }
	      }, context.config.delay.hide);
	    };

	    _proto._isWithActiveTrigger = function _isWithActiveTrigger() {
	      for (var trigger in this._activeTrigger) {
	        if (this._activeTrigger[trigger]) {
	          return true;
	        }
	      }

	      return false;
	    };

	    _proto._getConfig = function _getConfig(config) {
	      config = $.extend({}, this.constructor.Default, $(this.element).data(), config);

	      if (typeof config.delay === 'number') {
	        config.delay = {
	          show: config.delay,
	          hide: config.delay
	        };
	      }

	      if (typeof config.title === 'number') {
	        config.title = config.title.toString();
	      }

	      if (typeof config.content === 'number') {
	        config.content = config.content.toString();
	      }

	      Util.typeCheckConfig(NAME, config, this.constructor.DefaultType);
	      return config;
	    };

	    _proto._getDelegateConfig = function _getDelegateConfig() {
	      var config = {};

	      if (this.config) {
	        for (var key in this.config) {
	          if (this.constructor.Default[key] !== this.config[key]) {
	            config[key] = this.config[key];
	          }
	        }
	      }

	      return config;
	    };

	    _proto._cleanTipClass = function _cleanTipClass() {
	      var $tip = $(this.getTipElement());
	      var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX);

	      if (tabClass !== null && tabClass.length > 0) {
	        $tip.removeClass(tabClass.join(''));
	      }
	    };

	    _proto._handlePopperPlacementChange = function _handlePopperPlacementChange(data) {
	      this._cleanTipClass();

	      this.addAttachmentClass(this._getAttachment(data.placement));
	    };

	    _proto._fixTransition = function _fixTransition() {
	      var tip = this.getTipElement();
	      var initConfigAnimation = this.config.animation;

	      if (tip.getAttribute('x-placement') !== null) {
	        return;
	      }

	      $(tip).removeClass(ClassName.FADE);
	      this.config.animation = false;
	      this.hide();
	      this.show();
	      this.config.animation = initConfigAnimation;
	    }; // static


	    Tooltip._jQueryInterface = function _jQueryInterface(config) {
	      return this.each(function () {
	        var data = $(this).data(DATA_KEY);

	        var _config = typeof config === 'object' && config;

	        if (!data && /dispose|hide/.test(config)) {
	          return;
	        }

	        if (!data) {
	          data = new Tooltip(this, _config);
	          $(this).data(DATA_KEY, data);
	        }

	        if (typeof config === 'string') {
	          if (typeof data[config] === 'undefined') {
	            throw new Error("No method named \"" + config + "\"");
	          }

	          data[config]();
	        }
	      });
	    };

	    createClass(Tooltip, null, [{
	      key: "VERSION",
	      get: function get() {
	        return VERSION;
	      }
	    }, {
	      key: "Default",
	      get: function get() {
	        return Default;
	      }
	    }, {
	      key: "NAME",
	      get: function get() {
	        return NAME;
	      }
	    }, {
	      key: "DATA_KEY",
	      get: function get() {
	        return DATA_KEY;
	      }
	    }, {
	      key: "Event",
	      get: function get() {
	        return Event;
	      }
	    }, {
	      key: "EVENT_KEY",
	      get: function get() {
	        return EVENT_KEY;
	      }
	    }, {
	      key: "DefaultType",
	      get: function get() {
	        return DefaultType;
	      }
	    }]);
	    return Tooltip;
	  }();
	  /**
	   * ------------------------------------------------------------------------
	   * jQuery
	   * ------------------------------------------------------------------------
	   */


	  $.fn[NAME] = Tooltip._jQueryInterface;
	  $.fn[NAME].Constructor = Tooltip;

	  $.fn[NAME].noConflict = function () {
	    $.fn[NAME] = JQUERY_NO_CONFLICT;
	    return Tooltip._jQueryInterface;
	  };

	  return Tooltip;
	}($, Popper);

	/**
	 * --------------------------------------------------------------------------
	 * Bootstrap (v4.0.0-beta.2): popover.js
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * --------------------------------------------------------------------------
	 */

	var Popover = function () {
	  /**
	   * ------------------------------------------------------------------------
	   * Constants
	   * ------------------------------------------------------------------------
	   */
	  var NAME = 'popover';
	  var VERSION = '4.0.0-beta.2';
	  var DATA_KEY = 'bs.popover';
	  var EVENT_KEY = "." + DATA_KEY;
	  var JQUERY_NO_CONFLICT = $.fn[NAME];
	  var CLASS_PREFIX = 'bs-popover';
	  var BSCLS_PREFIX_REGEX = new RegExp("(^|\\s)" + CLASS_PREFIX + "\\S+", 'g');
	  var Default = $.extend({}, Tooltip.Default, {
	    placement: 'right',
	    trigger: 'click',
	    content: '',
	    template: '<div class="popover" role="tooltip">' + '<div class="arrow"></div>' + '<h3 class="popover-header"></h3>' + '<div class="popover-body"></div></div>'
	  });
	  var DefaultType = $.extend({}, Tooltip.DefaultType, {
	    content: '(string|element|function)'
	  });
	  var ClassName = {
	    FADE: 'fade',
	    SHOW: 'show'
	  };
	  var Selector = {
	    TITLE: '.popover-header',
	    CONTENT: '.popover-body'
	  };
	  var Event = {
	    HIDE: "hide" + EVENT_KEY,
	    HIDDEN: "hidden" + EVENT_KEY,
	    SHOW: "show" + EVENT_KEY,
	    SHOWN: "shown" + EVENT_KEY,
	    INSERTED: "inserted" + EVENT_KEY,
	    CLICK: "click" + EVENT_KEY,
	    FOCUSIN: "focusin" + EVENT_KEY,
	    FOCUSOUT: "focusout" + EVENT_KEY,
	    MOUSEENTER: "mouseenter" + EVENT_KEY,
	    MOUSELEAVE: "mouseleave" + EVENT_KEY
	    /**
	     * ------------------------------------------------------------------------
	     * Class Definition
	     * ------------------------------------------------------------------------
	     */

	  };

	  var Popover =
	  /*#__PURE__*/
	  function (_Tooltip) {
	    inheritsLoose(Popover, _Tooltip);

	    function Popover() {
	      return _Tooltip.apply(this, arguments) || this;
	    }

	    var _proto = Popover.prototype;

	    // overrides
	    _proto.isWithContent = function isWithContent() {
	      return this.getTitle() || this._getContent();
	    };

	    _proto.addAttachmentClass = function addAttachmentClass(attachment) {
	      $(this.getTipElement()).addClass(CLASS_PREFIX + "-" + attachment);
	    };

	    _proto.getTipElement = function getTipElement() {
	      this.tip = this.tip || $(this.config.template)[0];
	      return this.tip;
	    };

	    _proto.setContent = function setContent() {
	      var $tip = $(this.getTipElement()); // we use append for html objects to maintain js events

	      this.setElementContent($tip.find(Selector.TITLE), this.getTitle());
	      this.setElementContent($tip.find(Selector.CONTENT), this._getContent());
	      $tip.removeClass(ClassName.FADE + " " + ClassName.SHOW);
	    }; // private


	    _proto._getContent = function _getContent() {
	      return this.element.getAttribute('data-content') || (typeof this.config.content === 'function' ? this.config.content.call(this.element) : this.config.content);
	    };

	    _proto._cleanTipClass = function _cleanTipClass() {
	      var $tip = $(this.getTipElement());
	      var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX);

	      if (tabClass !== null && tabClass.length > 0) {
	        $tip.removeClass(tabClass.join(''));
	      }
	    }; // static


	    Popover._jQueryInterface = function _jQueryInterface(config) {
	      return this.each(function () {
	        var data = $(this).data(DATA_KEY);

	        var _config = typeof config === 'object' ? config : null;

	        if (!data && /destroy|hide/.test(config)) {
	          return;
	        }

	        if (!data) {
	          data = new Popover(this, _config);
	          $(this).data(DATA_KEY, data);
	        }

	        if (typeof config === 'string') {
	          if (typeof data[config] === 'undefined') {
	            throw new Error("No method named \"" + config + "\"");
	          }

	          data[config]();
	        }
	      });
	    };

	    createClass(Popover, null, [{
	      key: "VERSION",
	      // getters
	      get: function get() {
	        return VERSION;
	      }
	    }, {
	      key: "Default",
	      get: function get() {
	        return Default;
	      }
	    }, {
	      key: "NAME",
	      get: function get() {
	        return NAME;
	      }
	    }, {
	      key: "DATA_KEY",
	      get: function get() {
	        return DATA_KEY;
	      }
	    }, {
	      key: "Event",
	      get: function get() {
	        return Event;
	      }
	    }, {
	      key: "EVENT_KEY",
	      get: function get() {
	        return EVENT_KEY;
	      }
	    }, {
	      key: "DefaultType",
	      get: function get() {
	        return DefaultType;
	      }
	    }]);
	    return Popover;
	  }(Tooltip);
	  /**
	   * ------------------------------------------------------------------------
	   * jQuery
	   * ------------------------------------------------------------------------
	   */


	  $.fn[NAME] = Popover._jQueryInterface;
	  $.fn[NAME].Constructor = Popover;

	  $.fn[NAME].noConflict = function () {
	    $.fn[NAME] = JQUERY_NO_CONFLICT;
	    return Popover._jQueryInterface;
	  };

	  return Popover;
	}($);

	/**
	 * --------------------------------------------------------------------------
	 * Bootstrap (v4.0.0-beta.2): scrollspy.js
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * --------------------------------------------------------------------------
	 */

	var ScrollSpy = function () {
	  /**
	   * ------------------------------------------------------------------------
	   * Constants
	   * ------------------------------------------------------------------------
	   */
	  var NAME = 'scrollspy';
	  var VERSION = '4.0.0-beta.2';
	  var DATA_KEY = 'bs.scrollspy';
	  var EVENT_KEY = "." + DATA_KEY;
	  var DATA_API_KEY = '.data-api';
	  var JQUERY_NO_CONFLICT = $.fn[NAME];
	  var Default = {
	    offset: 10,
	    method: 'auto',
	    target: ''
	  };
	  var DefaultType = {
	    offset: 'number',
	    method: 'string',
	    target: '(string|element)'
	  };
	  var Event = {
	    ACTIVATE: "activate" + EVENT_KEY,
	    SCROLL: "scroll" + EVENT_KEY,
	    LOAD_DATA_API: "load" + EVENT_KEY + DATA_API_KEY
	  };
	  var ClassName = {
	    DROPDOWN_ITEM: 'dropdown-item',
	    DROPDOWN_MENU: 'dropdown-menu',
	    ACTIVE: 'active'
	  };
	  var Selector = {
	    DATA_SPY: '[data-spy="scroll"]',
	    ACTIVE: '.active',
	    NAV_LIST_GROUP: '.nav, .list-group',
	    NAV_LINKS: '.nav-link',
	    NAV_ITEMS: '.nav-item',
	    LIST_ITEMS: '.list-group-item',
	    DROPDOWN: '.dropdown',
	    DROPDOWN_ITEMS: '.dropdown-item',
	    DROPDOWN_TOGGLE: '.dropdown-toggle'
	  };
	  var OffsetMethod = {
	    OFFSET: 'offset',
	    POSITION: 'position'
	    /**
	     * ------------------------------------------------------------------------
	     * Class Definition
	     * ------------------------------------------------------------------------
	     */

	  };

	  var ScrollSpy =
	  /*#__PURE__*/
	  function () {
	    function ScrollSpy(element, config) {
	      var _this = this;

	      this._element = element;
	      this._scrollElement = element.tagName === 'BODY' ? window : element;
	      this._config = this._getConfig(config);
	      this._selector = this._config.target + " " + Selector.NAV_LINKS + "," + (this._config.target + " " + Selector.LIST_ITEMS + ",") + (this._config.target + " " + Selector.DROPDOWN_ITEMS);
	      this._offsets = [];
	      this._targets = [];
	      this._activeTarget = null;
	      this._scrollHeight = 0;
	      $(this._scrollElement).on(Event.SCROLL, function (event) {
	        return _this._process(event);
	      });
	      this.refresh();

	      this._process();
	    } // getters


	    var _proto = ScrollSpy.prototype;

	    // public
	    _proto.refresh = function refresh() {
	      var _this2 = this;

	      var autoMethod = this._scrollElement !== this._scrollElement.window ? OffsetMethod.POSITION : OffsetMethod.OFFSET;
	      var offsetMethod = this._config.method === 'auto' ? autoMethod : this._config.method;
	      var offsetBase = offsetMethod === OffsetMethod.POSITION ? this._getScrollTop() : 0;
	      this._offsets = [];
	      this._targets = [];
	      this._scrollHeight = this._getScrollHeight();
	      var targets = $.makeArray($(this._selector));
	      targets.map(function (element) {
	        var target;
	        var targetSelector = Util.getSelectorFromElement(element);

	        if (targetSelector) {
	          target = $(targetSelector)[0];
	        }

	        if (target) {
	          var targetBCR = target.getBoundingClientRect();

	          if (targetBCR.width || targetBCR.height) {
	            // todo (fat): remove sketch reliance on jQuery position/offset
	            return [$(target)[offsetMethod]().top + offsetBase, targetSelector];
	          }
	        }

	        return null;
	      }).filter(function (item) {
	        return item;
	      }).sort(function (a, b) {
	        return a[0] - b[0];
	      }).forEach(function (item) {
	        _this2._offsets.push(item[0]);

	        _this2._targets.push(item[1]);
	      });
	    };

	    _proto.dispose = function dispose() {
	      $.removeData(this._element, DATA_KEY);
	      $(this._scrollElement).off(EVENT_KEY);
	      this._element = null;
	      this._scrollElement = null;
	      this._config = null;
	      this._selector = null;
	      this._offsets = null;
	      this._targets = null;
	      this._activeTarget = null;
	      this._scrollHeight = null;
	    }; // private


	    _proto._getConfig = function _getConfig(config) {
	      config = $.extend({}, Default, config);

	      if (typeof config.target !== 'string') {
	        var id = $(config.target).attr('id');

	        if (!id) {
	          id = Util.getUID(NAME);
	          $(config.target).attr('id', id);
	        }

	        config.target = "#" + id;
	      }

	      Util.typeCheckConfig(NAME, config, DefaultType);
	      return config;
	    };

	    _proto._getScrollTop = function _getScrollTop() {
	      return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
	    };

	    _proto._getScrollHeight = function _getScrollHeight() {
	      return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
	    };

	    _proto._getOffsetHeight = function _getOffsetHeight() {
	      return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
	    };

	    _proto._process = function _process() {
	      var scrollTop = this._getScrollTop() + this._config.offset;

	      var scrollHeight = this._getScrollHeight();

	      var maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();

	      if (this._scrollHeight !== scrollHeight) {
	        this.refresh();
	      }

	      if (scrollTop >= maxScroll) {
	        var target = this._targets[this._targets.length - 1];

	        if (this._activeTarget !== target) {
	          this._activate(target);
	        }

	        return;
	      }

	      if (this._activeTarget && scrollTop < this._offsets[0] && this._offsets[0] > 0) {
	        this._activeTarget = null;

	        this._clear();

	        return;
	      }

	      for (var i = this._offsets.length; i--;) {
	        var isActiveTarget = this._activeTarget !== this._targets[i] && scrollTop >= this._offsets[i] && (typeof this._offsets[i + 1] === 'undefined' || scrollTop < this._offsets[i + 1]);

	        if (isActiveTarget) {
	          this._activate(this._targets[i]);
	        }
	      }
	    };

	    _proto._activate = function _activate(target) {
	      this._activeTarget = target;

	      this._clear();

	      var queries = this._selector.split(','); // eslint-disable-next-line arrow-body-style


	      queries = queries.map(function (selector) {
	        return selector + "[data-target=\"" + target + "\"]," + (selector + "[href=\"" + target + "\"]");
	      });
	      var $link = $(queries.join(','));

	      if ($link.hasClass(ClassName.DROPDOWN_ITEM)) {
	        $link.closest(Selector.DROPDOWN).find(Selector.DROPDOWN_TOGGLE).addClass(ClassName.ACTIVE);
	        $link.addClass(ClassName.ACTIVE);
	      } else {
	        // Set triggered link as active
	        $link.addClass(ClassName.ACTIVE); // Set triggered links parents as active
	        // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor

	        $link.parents(Selector.NAV_LIST_GROUP).prev(Selector.NAV_LINKS + ", " + Selector.LIST_ITEMS).addClass(ClassName.ACTIVE); // Handle special case when .nav-link is inside .nav-item

	        $link.parents(Selector.NAV_LIST_GROUP).prev(Selector.NAV_ITEMS).children(Selector.NAV_LINKS).addClass(ClassName.ACTIVE);
	      }

	      $(this._scrollElement).trigger(Event.ACTIVATE, {
	        relatedTarget: target
	      });
	    };

	    _proto._clear = function _clear() {
	      $(this._selector).filter(Selector.ACTIVE).removeClass(ClassName.ACTIVE);
	    }; // static


	    ScrollSpy._jQueryInterface = function _jQueryInterface(config) {
	      return this.each(function () {
	        var data = $(this).data(DATA_KEY);

	        var _config = typeof config === 'object' && config;

	        if (!data) {
	          data = new ScrollSpy(this, _config);
	          $(this).data(DATA_KEY, data);
	        }

	        if (typeof config === 'string') {
	          if (typeof data[config] === 'undefined') {
	            throw new Error("No method named \"" + config + "\"");
	          }

	          data[config]();
	        }
	      });
	    };

	    createClass(ScrollSpy, null, [{
	      key: "VERSION",
	      get: function get() {
	        return VERSION;
	      }
	    }, {
	      key: "Default",
	      get: function get() {
	        return Default;
	      }
	    }]);
	    return ScrollSpy;
	  }();
	  /**
	   * ------------------------------------------------------------------------
	   * Data Api implementation
	   * ------------------------------------------------------------------------
	   */


	  $(window).on(Event.LOAD_DATA_API, function () {
	    var scrollSpys = $.makeArray($(Selector.DATA_SPY));

	    for (var i = scrollSpys.length; i--;) {
	      var $spy = $(scrollSpys[i]);

	      ScrollSpy._jQueryInterface.call($spy, $spy.data());
	    }
	  });
	  /**
	   * ------------------------------------------------------------------------
	   * jQuery
	   * ------------------------------------------------------------------------
	   */

	  $.fn[NAME] = ScrollSpy._jQueryInterface;
	  $.fn[NAME].Constructor = ScrollSpy;

	  $.fn[NAME].noConflict = function () {
	    $.fn[NAME] = JQUERY_NO_CONFLICT;
	    return ScrollSpy._jQueryInterface;
	  };

	  return ScrollSpy;
	}($);

	/**
	 * --------------------------------------------------------------------------
	 * Bootstrap (v4.0.0-beta.2): tab.js
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * --------------------------------------------------------------------------
	 */

	var Tab = function () {
	  /**
	   * ------------------------------------------------------------------------
	   * Constants
	   * ------------------------------------------------------------------------
	   */
	  var NAME = 'tab';
	  var VERSION = '4.0.0-beta.2';
	  var DATA_KEY = 'bs.tab';
	  var EVENT_KEY = "." + DATA_KEY;
	  var DATA_API_KEY = '.data-api';
	  var JQUERY_NO_CONFLICT = $.fn[NAME];
	  var TRANSITION_DURATION = 150;
	  var Event = {
	    HIDE: "hide" + EVENT_KEY,
	    HIDDEN: "hidden" + EVENT_KEY,
	    SHOW: "show" + EVENT_KEY,
	    SHOWN: "shown" + EVENT_KEY,
	    CLICK_DATA_API: "click" + EVENT_KEY + DATA_API_KEY
	  };
	  var ClassName = {
	    DROPDOWN_MENU: 'dropdown-menu',
	    ACTIVE: 'active',
	    DISABLED: 'disabled',
	    FADE: 'fade',
	    SHOW: 'show'
	  };
	  var Selector = {
	    DROPDOWN: '.dropdown',
	    NAV_LIST_GROUP: '.nav, .list-group',
	    ACTIVE: '.active',
	    ACTIVE_UL: '> li > .active',
	    DATA_TOGGLE: '[data-toggle="tab"], [data-toggle="pill"], [data-toggle="list"]',
	    DROPDOWN_TOGGLE: '.dropdown-toggle',
	    DROPDOWN_ACTIVE_CHILD: '> .dropdown-menu .active'
	    /**
	     * ------------------------------------------------------------------------
	     * Class Definition
	     * ------------------------------------------------------------------------
	     */

	  };

	  var Tab =
	  /*#__PURE__*/
	  function () {
	    function Tab(element) {
	      this._element = element;
	    } // getters


	    var _proto = Tab.prototype;

	    // public
	    _proto.show = function show() {
	      var _this = this;

	      if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && $(this._element).hasClass(ClassName.ACTIVE) || $(this._element).hasClass(ClassName.DISABLED)) {
	        return;
	      }

	      var target;
	      var previous;
	      var listElement = $(this._element).closest(Selector.NAV_LIST_GROUP)[0];
	      var selector = Util.getSelectorFromElement(this._element);

	      if (listElement) {
	        var itemSelector = listElement.nodeName === 'UL' ? Selector.ACTIVE_UL : Selector.ACTIVE;
	        previous = $.makeArray($(listElement).find(itemSelector));
	        previous = previous[previous.length - 1];
	      }

	      var hideEvent = $.Event(Event.HIDE, {
	        relatedTarget: this._element
	      });
	      var showEvent = $.Event(Event.SHOW, {
	        relatedTarget: previous
	      });

	      if (previous) {
	        $(previous).trigger(hideEvent);
	      }

	      $(this._element).trigger(showEvent);

	      if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) {
	        return;
	      }

	      if (selector) {
	        target = $(selector)[0];
	      }

	      this._activate(this._element, listElement);

	      var complete = function complete() {
	        var hiddenEvent = $.Event(Event.HIDDEN, {
	          relatedTarget: _this._element
	        });
	        var shownEvent = $.Event(Event.SHOWN, {
	          relatedTarget: previous
	        });
	        $(previous).trigger(hiddenEvent);
	        $(_this._element).trigger(shownEvent);
	      };

	      if (target) {
	        this._activate(target, target.parentNode, complete);
	      } else {
	        complete();
	      }
	    };

	    _proto.dispose = function dispose() {
	      $.removeData(this._element, DATA_KEY);
	      this._element = null;
	    }; // private


	    _proto._activate = function _activate(element, container, callback) {
	      var _this2 = this;

	      var activeElements;

	      if (container.nodeName === 'UL') {
	        activeElements = $(container).find(Selector.ACTIVE_UL);
	      } else {
	        activeElements = $(container).children(Selector.ACTIVE);
	      }

	      var active = activeElements[0];
	      var isTransitioning = callback && Util.supportsTransitionEnd() && active && $(active).hasClass(ClassName.FADE);

	      var complete = function complete() {
	        return _this2._transitionComplete(element, active, isTransitioning, callback);
	      };

	      if (active && isTransitioning) {
	        $(active).one(Util.TRANSITION_END, complete).emulateTransitionEnd(TRANSITION_DURATION);
	      } else {
	        complete();
	      }

	      if (active) {
	        $(active).removeClass(ClassName.SHOW);
	      }
	    };

	    _proto._transitionComplete = function _transitionComplete(element, active, isTransitioning, callback) {
	      if (active) {
	        $(active).removeClass(ClassName.ACTIVE);
	        var dropdownChild = $(active.parentNode).find(Selector.DROPDOWN_ACTIVE_CHILD)[0];

	        if (dropdownChild) {
	          $(dropdownChild).removeClass(ClassName.ACTIVE);
	        }

	        if (active.getAttribute('role') === 'tab') {
	          active.setAttribute('aria-selected', false);
	        }
	      }

	      $(element).addClass(ClassName.ACTIVE);

	      if (element.getAttribute('role') === 'tab') {
	        element.setAttribute('aria-selected', true);
	      }

	      if (isTransitioning) {
	        Util.reflow(element);
	        $(element).addClass(ClassName.SHOW);
	      } else {
	        $(element).removeClass(ClassName.FADE);
	      }

	      if (element.parentNode && $(element.parentNode).hasClass(ClassName.DROPDOWN_MENU)) {
	        var dropdownElement = $(element).closest(Selector.DROPDOWN)[0];

	        if (dropdownElement) {
	          $(dropdownElement).find(Selector.DROPDOWN_TOGGLE).addClass(ClassName.ACTIVE);
	        }

	        element.setAttribute('aria-expanded', true);
	      }

	      if (callback) {
	        callback();
	      }
	    }; // static


	    Tab._jQueryInterface = function _jQueryInterface(config) {
	      return this.each(function () {
	        var $this = $(this);
	        var data = $this.data(DATA_KEY);

	        if (!data) {
	          data = new Tab(this);
	          $this.data(DATA_KEY, data);
	        }

	        if (typeof config === 'string') {
	          if (typeof data[config] === 'undefined') {
	            throw new Error("No method named \"" + config + "\"");
	          }

	          data[config]();
	        }
	      });
	    };

	    createClass(Tab, null, [{
	      key: "VERSION",
	      get: function get() {
	        return VERSION;
	      }
	    }]);
	    return Tab;
	  }();
	  /**
	   * ------------------------------------------------------------------------
	   * Data Api implementation
	   * ------------------------------------------------------------------------
	   */


	  $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {
	    event.preventDefault();

	    Tab._jQueryInterface.call($(this), 'show');
	  });
	  /**
	   * ------------------------------------------------------------------------
	   * jQuery
	   * ------------------------------------------------------------------------
	   */

	  $.fn[NAME] = Tab._jQueryInterface;
	  $.fn[NAME].Constructor = Tab;

	  $.fn[NAME].noConflict = function () {
	    $.fn[NAME] = JQUERY_NO_CONFLICT;
	    return Tab._jQueryInterface;
	  };

	  return Tab;
	}($);

	/**
	 * --------------------------------------------------------------------------
	 * Bootstrap (v4.0.0-alpha.6): index.js
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * --------------------------------------------------------------------------
	 */

	(function () {
	  if (typeof $ === 'undefined') {
	    throw new Error('Bootstrap\'s JavaScript requires jQuery. jQuery must be included before Bootstrap\'s JavaScript.');
	  }

	  var version = $.fn.jquery.split(' ')[0].split('.');
	  var minMajor = 1;
	  var ltMajor = 2;
	  var minMinor = 9;
	  var minPatch = 1;
	  var maxMajor = 4;

	  if (version[0] < ltMajor && version[1] < minMinor || version[0] === minMajor && version[1] === minMinor && version[2] < minPatch || version[0] >= maxMajor) {
	    throw new Error('Bootstrap\'s JavaScript requires at least jQuery v1.9.1 but less than v4.0.0');
	  }
	})($);

	exports.Util = Util;
	exports.Alert = Alert;
	exports.Button = Button;
	exports.Carousel = Carousel;
	exports.Collapse = Collapse;
	exports.Dropdown = Dropdown;
	exports.Modal = Modal;
	exports.Popover = Popover;
	exports.Scrollspy = ScrollSpy;
	exports.Tab = Tab;
	exports.Tooltip = Tooltip;

	return exports;

	}({},$,Popper));
	//# sourceMappingURL=bootstrap.js.map


/***/ }),
/* 8 */
/***/ (function(module, exports) {

	/*! waitForImages jQuery Plugin 2013-07-20 */
	!function(a){var b="waitForImages";a.waitForImages={hasImageProperties:["backgroundImage","listStyleImage","borderImage","borderCornerImage","cursor"]},a.expr[":"].uncached=function(b){if(!a(b).is('img[src!=""]'))return!1;var c=new Image;return c.src=b.src,!c.complete},a.fn.waitForImages=function(c,d,e){var f=0,g=0;if(a.isPlainObject(arguments[0])&&(e=arguments[0].waitForAll,d=arguments[0].each,c=arguments[0].finished),c=c||a.noop,d=d||a.noop,e=!!e,!a.isFunction(c)||!a.isFunction(d))throw new TypeError("An invalid callback was supplied.");return this.each(function(){var h=a(this),i=[],j=a.waitForImages.hasImageProperties||[],k=/url\(\s*(['"]?)(.*?)\1\s*\)/g;e?h.find("*").addBack().each(function(){var b=a(this);b.is("img:uncached")&&i.push({src:b.attr("src"),element:b[0]}),a.each(j,function(a,c){var d,e=b.css(c);if(!e)return!0;for(;d=k.exec(e);)i.push({src:d[2],element:b[0]})})}):h.find("img:uncached").each(function(){i.push({src:this.src,element:this})}),f=i.length,g=0,0===f&&c.call(h[0]),a.each(i,function(e,i){var j=new Image;a(j).on("load."+b+" error."+b,function(a){return g++,d.call(i.element,g,f,"load"==a.type),g==f?(c.call(h[0]),!1):void 0}),j.src=i.src})})}}(jQuery);

/***/ }),
/* 9 */
/***/ (function(module, exports) {

	/*
	 * CSS3 Animate it
	 * Copyright (c) 2014 Jack McCourt
	 * https://github.com/kriegar/css3-animate-it
	 * Version: 0.1.0
	 * 
	 * I utilise the jQuery.appear plugin within this javascript file so here is a link to that too
	 * https://github.com/morr/jquery.appear
	 *
	 * I also utilise the jQuery.doTimeout plugin for the data-sequence functionality so here is a link back to them.
	 * http://benalman.com/projects/jquery-dotimeout-plugin/
	 */
	(function ($) {
	    var selectors = [];

	    var check_binded = false;
	    var check_lock = false;
	    var defaults = {
	        interval: 250,
	        force_process: false
	    };
	    var $window = $(window);

	    var $prior_appeared;

	    function process() {
	        check_lock = false;
	        for (var index = 0; index < selectors.length; index++) {
	            var $appeared = $(selectors[index]).filter(function () {
	                return $(this).is(':appeared');
	            });

	            $appeared.trigger('appear', [$appeared]);

	            if ($prior_appeared) {

	                var $disappeared = $prior_appeared.not($appeared);
	                $disappeared.trigger('disappear', [$disappeared]);
	            }
	            $prior_appeared = $appeared;
	        }
	    }

	    // "appeared" custom filter
	    $.expr[':']['appeared'] = function (element) {
	        var $element = $(element);
	        if (!$element.is(':visible')) {
	            return false;
	        }

	        var window_left = $window.scrollLeft();
	        var window_top = $window.scrollTop();
	        var offset = $element.offset();
	        var left = offset.left;
	        var top = offset.top;

	        if (top + $element.height() >= window_top &&
	            top - ($element.data('appear-top-offset') || 0) <= window_top + $window.height() &&
	            left + $element.width() >= window_left &&
	            left - ($element.data('appear-left-offset') || 0) <= window_left + $window.width()) {
	            return true;
	        } else {
	            return false;
	        }
	    };

	    $.fn.extend({
	        // watching for element's appearance in browser viewport
	        appear: function (options) {
	            var opts = $.extend({}, defaults, options || {});
	            var selector = this.selector || this;
	            if (!check_binded) {
	                var on_check = function () {
	                    if (check_lock) {
	                        return;
	                    }
	                    check_lock = true;

	                    setTimeout(process, opts.interval);
	                };

	                $(window).scroll(on_check).resize(on_check);
	                check_binded = true;
	            }

	            if (opts.force_process) {
	                setTimeout(process, opts.interval);
	            }
	            selectors.push(selector);
	            return $(selector);
	        }
	    });

	    $.extend({
	        // force elements's appearance check
	        force_appear: function () {
	            if (check_binded) {
	                process();
	                return true;
	            }
	            return false;
	        }
	    });
	})(jQuery);


	/*!
	 * jQuery doTimeout: Like setTimeout, but better! - v1.0 - 3/3/2010
	 * http://benalman.com/projects/jquery-dotimeout-plugin/
	 * 
	 * Copyright (c) 2010 "Cowboy" Ben Alman
	 * Dual licensed under the MIT and GPL licenses.
	 * http://benalman.com/about/license/
	 */

	// Script: jQuery doTimeout: Like setTimeout, but better!
	//
	// *Version: 1.0, Last updated: 3/3/2010*
	// 
	// Project Home - http://benalman.com/projects/jquery-dotimeout-plugin/
	// GitHub       - http://github.com/cowboy/jquery-dotimeout/
	// Source       - http://github.com/cowboy/jquery-dotimeout/raw/master/jquery.ba-dotimeout.js
	// (Minified)   - http://github.com/cowboy/jquery-dotimeout/raw/master/jquery.ba-dotimeout.min.js (1.0kb)
	// 
	// About: License
	// 
	// Copyright (c) 2010 "Cowboy" Ben Alman,
	// Dual licensed under the MIT and GPL licenses.
	// http://benalman.com/about/license/
	// 
	// About: Examples
	// 
	// These working examples, complete with fully commented code, illustrate a few
	// ways in which this plugin can be used.
	// 
	// Debouncing      - http://benalman.com/code/projects/jquery-dotimeout/examples/debouncing/
	// Delays, Polling - http://benalman.com/code/projects/jquery-dotimeout/examples/delay-poll/
	// Hover Intent    - http://benalman.com/code/projects/jquery-dotimeout/examples/hoverintent/
	// 
	// About: Support and Testing
	// 
	// Information about what version or versions of jQuery this plugin has been
	// tested with, what browsers it has been tested in, and where the unit tests
	// reside (so you can test it yourself).
	// 
	// jQuery Versions - 1.3.2, 1.4.2
	// Browsers Tested - Internet Explorer 6-8, Firefox 2-3.6, Safari 3-4, Chrome 4-5, Opera 9.6-10.1.
	// Unit Tests      - http://benalman.com/code/projects/jquery-dotimeout/unit/
	// 
	// About: Release History
	// 
	// 1.0 - (3/3/2010) Callback can now be a string, in which case it will call
	//       the appropriate $.method or $.fn.method, depending on where .doTimeout
	//       was called. Callback must now return `true` (not just a truthy value)
	//       to poll.
	// 0.4 - (7/15/2009) Made the "id" argument optional, some other minor tweaks
	// 0.3 - (6/25/2009) Initial release

	(function ($) {
	    '$:nomunge'; // Used by YUI compressor.

	    var cache = {},

	        // Reused internal string.
	        doTimeout = 'doTimeout',

	        // A convenient shortcut.
	        aps = Array.prototype.slice;

	    // Method: jQuery.doTimeout
	    // 
	    // Initialize, cancel, or force execution of a callback after a delay.
	    // 
	    // If delay and callback are specified, a doTimeout is initialized. The
	    // callback will execute, asynchronously, after the delay. If an id is
	    // specified, this doTimeout will override and cancel any existing doTimeout
	    // with the same id. Any additional arguments will be passed into callback
	    // when it is executed.
	    // 
	    // If the callback returns true, the doTimeout loop will execute again, after
	    // the delay, creating a polling loop until the callback returns a non-true
	    // value.
	    // 
	    // Note that if an id is not passed as the first argument, this doTimeout will
	    // NOT be able to be manually canceled or forced. (for debouncing, be sure to
	    // specify an id).
	    // 
	    // If id is specified, but delay and callback are not, the doTimeout will be
	    // canceled without executing the callback. If force_mode is specified, the
	    // callback will be executed, synchronously, but will only be allowed to
	    // continue a polling loop if force_mode is true (provided the callback
	    // returns true, of course). If force_mode is false, no polling loop will
	    // continue, even if the callback returns true.
	    // 
	    // Usage:
	    // 
	    // > jQuery.doTimeout( [ id, ] delay, callback [, arg ... ] );
	    // > jQuery.doTimeout( id [, force_mode ] );
	    // 
	    // Arguments:
	    // 
	    //  id - (String) An optional unique identifier for this doTimeout. If id is
	    //    not specified, the doTimeout will NOT be able to be manually canceled or
	    //    forced.
	    //  delay - (Number) A zero-or-greater delay in milliseconds after which
	    //    callback will be executed. 
	    //  callback - (Function) A function to be executed after delay milliseconds.
	    //  callback - (String) A jQuery method to be executed after delay
	    //    milliseconds. This method will only poll if it explicitly returns
	    //    true.
	    //  force_mode - (Boolean) If true, execute that id's doTimeout callback
	    //    immediately and synchronously, continuing any callback return-true
	    //    polling loop. If false, execute the callback immediately and
	    //    synchronously but do NOT continue a callback return-true polling loop.
	    //    If omitted, cancel that id's doTimeout.
	    // 
	    // Returns:
	    // 
	    //  If force_mode is true, false or undefined and there is a
	    //  yet-to-be-executed callback to cancel, true is returned, but if no
	    //  callback remains to be executed, undefined is returned.

	    $[doTimeout] = function () {
	        return p_doTimeout.apply(window, [0].concat(aps.call(arguments)));
	    };

	    // Method: jQuery.fn.doTimeout
	    // 
	    // Initialize, cancel, or force execution of a callback after a delay.
	    // Operates like <jQuery.doTimeout>, but the passed callback executes in the
	    // context of the jQuery collection of elements, and the id is stored as data
	    // on the first element in that collection.
	    // 
	    // If delay and callback are specified, a doTimeout is initialized. The
	    // callback will execute, asynchronously, after the delay. If an id is
	    // specified, this doTimeout will override and cancel any existing doTimeout
	    // with the same id. Any additional arguments will be passed into callback
	    // when it is executed.
	    // 
	    // If the callback returns true, the doTimeout loop will execute again, after
	    // the delay, creating a polling loop until the callback returns a non-true
	    // value.
	    // 
	    // Note that if an id is not passed as the first argument, this doTimeout will
	    // NOT be able to be manually canceled or forced (for debouncing, be sure to
	    // specify an id).
	    // 
	    // If id is specified, but delay and callback are not, the doTimeout will be
	    // canceled without executing the callback. If force_mode is specified, the
	    // callback will be executed, synchronously, but will only be allowed to
	    // continue a polling loop if force_mode is true (provided the callback
	    // returns true, of course). If force_mode is false, no polling loop will
	    // continue, even if the callback returns true.
	    // 
	    // Usage:
	    // 
	    // > jQuery('selector').doTimeout( [ id, ] delay, callback [, arg ... ] );
	    // > jQuery('selector').doTimeout( id [, force_mode ] );
	    // 
	    // Arguments:
	    // 
	    //  id - (String) An optional unique identifier for this doTimeout, stored as
	    //    jQuery data on the element. If id is not specified, the doTimeout will
	    //    NOT be able to be manually canceled or forced.
	    //  delay - (Number) A zero-or-greater delay in milliseconds after which
	    //    callback will be executed. 
	    //  callback - (Function) A function to be executed after delay milliseconds.
	    //  callback - (String) A jQuery.fn method to be executed after delay
	    //    milliseconds. This method will only poll if it explicitly returns
	    //    true (most jQuery.fn methods return a jQuery object, and not `true`,
	    //    which allows them to be chained and prevents polling).
	    //  force_mode - (Boolean) If true, execute that id's doTimeout callback
	    //    immediately and synchronously, continuing any callback return-true
	    //    polling loop. If false, execute the callback immediately and
	    //    synchronously but do NOT continue a callback return-true polling loop.
	    //    If omitted, cancel that id's doTimeout.
	    // 
	    // Returns:
	    // 
	    //  When creating a <jQuery.fn.doTimeout>, the initial jQuery collection of
	    //  elements is returned. Otherwise, if force_mode is true, false or undefined
	    //  and there is a yet-to-be-executed callback to cancel, true is returned,
	    //  but if no callback remains to be executed, undefined is returned.

	    $.fn[doTimeout] = function () {
	        var args = aps.call(arguments),
	            result = p_doTimeout.apply(this, [doTimeout + args[0]].concat(args));

	        return typeof args[0] === 'number' || typeof args[1] === 'number' ?
	            this :
	            result;
	    };

	    function p_doTimeout(jquery_data_key) {
	        var that = this,
	            elem,
	            data = {},

	            // Allows the plugin to call a string callback method.
	            method_base = jquery_data_key ? $.fn : $,

	            // Any additional arguments will be passed to the callback.
	            args = arguments,
	            slice_args = 4,

	            id = args[1],
	            delay = args[2],
	            callback = args[3];

	        if (typeof id !== 'string') {
	            slice_args--;

	            id = jquery_data_key = 0;
	            delay = args[1];
	            callback = args[2];
	        }

	        // If id is passed, store a data reference either as .data on the first
	        // element in a jQuery collection, or in the internal cache.
	        if (jquery_data_key) { // Note: key is 'doTimeout' + id

	            // Get id-object from the first element's data, otherwise initialize it to {}.
	            elem = that.eq(0);
	            elem.data(jquery_data_key, data = elem.data(jquery_data_key) || {});

	        } else if (id) {
	            // Get id-object from the cache, otherwise initialize it to {}.
	            data = cache[id] || (cache[id] = {});
	        }

	        // Clear any existing timeout for this id.
	        data.id && clearTimeout(data.id);
	        delete data.id;

	        // Clean up when necessary.
	        function cleanup() {
	            if (jquery_data_key) {
	                elem.removeData(jquery_data_key);
	            } else if (id) {
	                delete cache[id];
	            }
	        }
	        // Yes, there actually is a setTimeout call in here!
	        function actually_setTimeout() {
	            data.id = setTimeout(function () {
	                data.fn();
	            }, delay);
	        }
	        if (callback) {
	            // A callback (and delay) were specified. Store the callback reference for
	            // possible later use, and then setTimeout.
	            data.fn = function (no_polling_loop) {

	                // If the callback value is a string, it is assumed to be the name of a
	                // method on $ or $.fn depending on where doTimeout was executed.
	                if (typeof callback === 'string') {
	                    callback = method_base[callback];
	                }

	                callback.apply(that, aps.call(args, slice_args)) === true && !no_polling_loop

	                    // Since the callback returned true, and we're not specifically
	                    // canceling a polling loop, do it again!
	                    ?
	                    actually_setTimeout()

	                    // Otherwise, clean up and quit.
	                    : cleanup();
	            };

	            // Set that timeout!
	            actually_setTimeout();

	        } else if (data.fn) {
	            // No callback passed. If force_mode (delay) is true, execute the data.fn
	            // callback immediately, continuing any callback return-true polling loop.
	            // If force_mode is false, execute the data.fn callback immediately but do
	            // NOT continue a callback return-true polling loop. If force_mode is
	            // undefined, simply clean up. Since data.fn was still defined, whatever
	            // was supposed to happen hadn't yet, so return true.
	            delay === undefined ? cleanup() : data.fn(delay === false);
	            return true;

	        } else {
	            // Since no callback was passed, and data.fn isn't defined, it looks like
	            // whatever was supposed to happen already did. Clean up and quit!
	            cleanup();
	        }

	    }
	})(jQuery);


	//CSS3 Animate-it
	$('.animatedParent').appear();
	$('.animatedClick').click(function () {
	    var target = $(this).attr('data-target');


	    if ($(this).attr('data-sequence') != undefined) {
	        var firstId = $("." + target + ":first").attr('data-id');
	        var lastId = $("." + target + ":last").attr('data-id');
	        var number = firstId;

	        //Add or remove the class
	        if ($("." + target + "[data-id=" + number + "]").hasClass('go')) {
	            $("." + target + "[data-id=" + number + "]").addClass('goAway');
	            $("." + target + "[data-id=" + number + "]").removeClass('go');
	        } else {
	            $("." + target + "[data-id=" + number + "]").addClass('go');
	            $("." + target + "[data-id=" + number + "]").removeClass('goAway');
	        }
	        number++;
	        delay = Number($(this).attr('data-sequence'));
	        $.doTimeout(delay, function () {
	            console.log(lastId);

	            //Add or remove the class
	            if ($("." + target + "[data-id=" + number + "]").hasClass('go')) {
	                $("." + target + "[data-id=" + number + "]").addClass('goAway');
	                $("." + target + "[data-id=" + number + "]").removeClass('go');
	            } else {
	                $("." + target + "[data-id=" + number + "]").addClass('go');
	                $("." + target + "[data-id=" + number + "]").removeClass('goAway');
	            }

	            //increment
	            ++number;

	            //continute looping till reached last ID
	            if (number <= lastId) {
	                return true;
	            }
	        });
	    } else {
	        if ($('.' + target).hasClass('go')) {
	            $('.' + target).addClass('goAway');
	            $('.' + target).removeClass('go');
	        } else {
	            $('.' + target).addClass('go');
	            $('.' + target).removeClass('goAway');
	        }
	    }
	});

	$(document.body).on('appear', '.animatedParent', function (e, $affected) {
	    var ele = $(this).find('.animated');
	    var parent = $(this);


	    if (parent.attr('data-sequence') != undefined) {

	        var firstId = $(this).find('.animated:first').attr('data-id');
	        var number = firstId;
	        var lastId = $(this).find('.animated:last').attr('data-id');

	        $(parent).find(".animated[data-id=" + number + "]").addClass('go');
	        number++;
	        delay = Number(parent.attr('data-sequence'));

	        $.doTimeout(delay, function () {
	            $(parent).find(".animated[data-id=" + number + "]").addClass('go');
	            ++number;
	            if (number <= lastId) {
	                return true;
	            }
	        });
	    } else {
	        ele.addClass('go');
	    }

	});

	$(document.body).on('disappear', '.animatedParent', function (e, $affected) {
	    if (!$(this).hasClass('animateOnce')) {
	        $(this).find('.animated').removeClass('go');
	    }
	});

	$(window).on('load', function () {
	    $.force_appear();
	});

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(11);

	jQuery(function ($) {
	    "use strict";
	    if ($('.sticky').length) {
	        $('.sticky').Stickyfill();
	    }
	});



/***/ }),
/* 11 */
/***/ (function(module, exports) {

	/*!
	 * Stickyfill -- `position: sticky` polyfill
	 * v. 1.1.4 | https://github.com/wilddeer/stickyfill
	 * Copyright Oleg Korsunsky | http://wd.dizaina.net/
	 *
	 * MIT License
	 */
	!function(a,b){function c(){y=D=z=A=B=C=K}function d(a,b){for(var c in b)b.hasOwnProperty(c)&&(a[c]=b[c])}function e(a){return parseFloat(a)||0}function f(){F={top:b.pageYOffset,left:b.pageXOffset}}function g(){return b.pageXOffset!=F.left?(f(),void z()):void(b.pageYOffset!=F.top&&(f(),i()))}function h(a){setTimeout(function(){b.pageYOffset!=F.top&&(F.top=b.pageYOffset,i())},0)}function i(){for(var a=H.length-1;a>=0;a--)j(H[a])}function j(a){if(a.inited){var b=F.top<=a.limit.start?0:F.top>=a.limit.end?2:1;a.mode!=b&&p(a,b)}}function k(){for(var a=H.length-1;a>=0;a--)if(H[a].inited){var b=Math.abs(t(H[a].clone)-H[a].docOffsetTop),c=Math.abs(H[a].parent.node.offsetHeight-H[a].parent.height);if(b>=2||c>=2)return!1}return!0}function l(a){isNaN(parseFloat(a.computed.top))||a.isCell||"none"==a.computed.display||(a.inited=!0,a.clone||q(a),"absolute"!=a.parent.computed.position&&"relative"!=a.parent.computed.position&&(a.parent.node.style.position="relative"),j(a),a.parent.height=a.parent.node.offsetHeight,a.docOffsetTop=t(a.clone))}function m(a){var b=!0;a.clone&&r(a),d(a.node.style,a.css);for(var c=H.length-1;c>=0;c--)if(H[c].node!==a.node&&H[c].parent.node===a.parent.node){b=!1;break}b&&(a.parent.node.style.position=a.parent.css.position),a.mode=-1}function n(){for(var a=H.length-1;a>=0;a--)l(H[a])}function o(){for(var a=H.length-1;a>=0;a--)m(H[a])}function p(a,b){var c=a.node.style;switch(b){case 0:c.position="absolute",c.left=a.offset.left+"px",c.right=a.offset.right+"px",c.top=a.offset.top+"px",c.bottom="auto",c.width="auto",c.marginLeft=0,c.marginRight=0,c.marginTop=0;break;case 1:c.position="fixed",c.left=a.box.left+"px",c.right=a.box.right+"px",c.top=a.css.top,c.bottom="auto",c.width="auto",c.marginLeft=0,c.marginRight=0,c.marginTop=0;break;case 2:c.position="absolute",c.left=a.offset.left+"px",c.right=a.offset.right+"px",c.top="auto",c.bottom=0,c.width="auto",c.marginLeft=0,c.marginRight=0}a.mode=b}function q(a){a.clone=document.createElement("div");var b=a.node.nextSibling||a.node,c=a.clone.style;c.height=a.height+"px",c.width=a.width+"px",c.marginTop=a.computed.marginTop,c.marginBottom=a.computed.marginBottom,c.marginLeft=a.computed.marginLeft,c.marginRight=a.computed.marginRight,c.padding=c.border=c.borderSpacing=0,c.fontSize="1em",c.position="static",c.cssFloat=a.computed.cssFloat,a.node.parentNode.insertBefore(a.clone,b)}function r(a){a.clone.parentNode.removeChild(a.clone),a.clone=void 0}function s(a){var b=getComputedStyle(a),c=a.parentNode,d=getComputedStyle(c),f=a.style.position;a.style.position="relative";var g={top:b.top,marginTop:b.marginTop,marginBottom:b.marginBottom,marginLeft:b.marginLeft,marginRight:b.marginRight,cssFloat:b.cssFloat,display:b.display},h={top:e(b.top),marginBottom:e(b.marginBottom),paddingLeft:e(b.paddingLeft),paddingRight:e(b.paddingRight),borderLeftWidth:e(b.borderLeftWidth),borderRightWidth:e(b.borderRightWidth)};a.style.position=f;var i={position:a.style.position,top:a.style.top,bottom:a.style.bottom,left:a.style.left,right:a.style.right,width:a.style.width,marginTop:a.style.marginTop,marginLeft:a.style.marginLeft,marginRight:a.style.marginRight},j=u(a),k=u(c),l={node:c,css:{position:c.style.position},computed:{position:d.position},numeric:{borderLeftWidth:e(d.borderLeftWidth),borderRightWidth:e(d.borderRightWidth),borderTopWidth:e(d.borderTopWidth),borderBottomWidth:e(d.borderBottomWidth)}},m={node:a,box:{left:j.win.left,right:J.clientWidth-j.win.right},offset:{top:j.win.top-k.win.top-l.numeric.borderTopWidth,left:j.win.left-k.win.left-l.numeric.borderLeftWidth,right:-j.win.right+k.win.right-l.numeric.borderRightWidth},css:i,isCell:"table-cell"==b.display,computed:g,numeric:h,width:j.win.right-j.win.left,height:j.win.bottom-j.win.top,mode:-1,inited:!1,parent:l,limit:{start:j.doc.top-h.top,end:k.doc.top+c.offsetHeight-l.numeric.borderBottomWidth-a.offsetHeight-h.top-h.marginBottom}};return m}function t(a){for(var b=0;a;)b+=a.offsetTop,a=a.offsetParent;return b}function u(a){var c=a.getBoundingClientRect();return{doc:{top:c.top+b.pageYOffset,left:c.left+b.pageXOffset},win:c}}function v(){G=setInterval(function(){!k()&&z()},500)}function w(){clearInterval(G)}function x(){I&&(document[L]?w():v())}function y(){I||(f(),n(),b.addEventListener("scroll",g),b.addEventListener("wheel",h),b.addEventListener("resize",z),b.addEventListener("orientationchange",z),a.addEventListener(M,x),v(),I=!0)}function z(){if(I){o();for(var a=H.length-1;a>=0;a--)H[a]=s(H[a].node);n()}}function A(){b.removeEventListener("scroll",g),b.removeEventListener("wheel",h),b.removeEventListener("resize",z),b.removeEventListener("orientationchange",z),a.removeEventListener(M,x),w(),I=!1}function B(){A(),o()}function C(){for(B();H.length;)H.pop()}function D(a){for(var b=H.length-1;b>=0;b--)if(H[b].node===a)return;var c=s(a);H.push(c),I?l(c):y()}function E(a){for(var b=H.length-1;b>=0;b--)H[b].node===a&&(m(H[b]),H.splice(b,1))}var F,G,H=[],I=!1,J=a.documentElement,K=function(){},L="hidden",M="visibilitychange";void 0!==a.webkitHidden&&(L="webkitHidden",M="webkitvisibilitychange"),b.getComputedStyle||c();for(var N=["","-webkit-","-moz-","-ms-"],O=document.createElement("div"),P=N.length-1;P>=0;P--){try{O.style.position=N[P]+"sticky"}catch(Q){}""!=O.style.position&&c()}f(),b.Stickyfill={stickies:H,add:D,remove:E,init:y,rebuild:z,pause:A,stop:B,kill:C}}(document,window),window.jQuery&&!function($){$.fn.Stickyfill=function(a){return this.each(function(){Stickyfill.add(this)}),this}}(window.jQuery);

/***/ }),
/* 12 */
/***/ (function(module, exports) {

	// Format Number With Commas
	getNumberWithCommas = function (x) {
	    return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
	};

	isElementInViewport = function isElementInViewport(el) {

	    //special bonus for those using jQuery
	    if (typeof jQuery === "function" && el instanceof jQuery) {
	        el = el[0];
	    }

	    var rect = el.getBoundingClientRect();

	    return (
	        rect.top >= 0 &&
	        rect.left >= 0 &&
	        rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && /*or $(window).height() */
	        rect.right <= (window.innerWidth || document.documentElement.clientWidth) /*or $(window).width() */
	    );
	};


	goToTop = function () {
	    if($('.js-gotop').length) {
	        $('.js-gotop').on('click', function (event) {
	            event.preventDefault();
	            $('html, body').animate({
	                scrollTop: $('html').offset().top
	            }, 500, 'easeInOutExpo');
	            return false;
	        });

	        $(window).scroll(function () {
	            var $win = $(window);
	            if ($win.scrollTop() > 200) {
	                $('.js-top').addClass('active');
	            } else {
	                $('.js-top').removeClass('active');
	            }
	        });
	    }
	};


/***/ }),
/* 13 */
/***/ (function(module, exports) {

	(function () {

	    'use strict';

	    /*-------------------------------------
	     window...
	     --------------------------------------*/

	    var window_w = $(window).width(); // Window Width
	    var window_h = $(window).height(); // Window Height
	    var window_s = $(window).scrollTop(); // Window Scroll Top

	    var $html = $('html'); // HTML
	    var $body = $('body'); // Body


	    if ($("#docs").length) {
	        $('#docs').popover('show');
	    }

	    /*-------------------------------------
	     Smooth Scroll
	     --------------------------------------*/

	    if ($(".scroll").length > 0 || $(".scroll a[href^='#']").length > 0) {
	        $('.scroll, .scroll a[href^="#"]').on('click', function () {
	            $('html, body').animate({
	                scrollTop: $($.attr(this, 'href')).offset().top - 30
	            }, 1500, function () {
	            });
	            return false;
	        });
	    }

	    /*-------------------------------------
	     Woo-Quantity
	     --------------------------------------*/

	    $("body").on("click", ".xv-qyt", function (e) {
	        e.preventDefault();
	        var $add = parseInt($(this).attr("data-value")),
	            $input = $(this).siblings("input.qty"),
	            cVal = parseInt($input.val());
	        if (cVal >= 1) {
	            if ($add === -1 && cVal === 1)
	                return false;
	            $input.val(cVal + $add);
	        }
	    });

	    /*-------------------------------------
	     Custom Select
	     --------------------------------------*/
	    $('.custome-select select').on('change', function () {
	        var p = $(this).parent(".custome-select");
	        p.find('span').html($(this).val());
	    });


	    goToTop();

	}());

/***/ }),
/* 14 */
/***/ (function(module, exports) {

	var $root = $('html, body');

	$('a[href^="#"]').click(function () {
	    $root.animate({
	        scrollTop: $( $.attr(this, 'href') ).offset().top
	    }, 500);

	    return false;
	});

	window.onload = function () {

		var donutChart1 = new CanvasJS.Chart("2017_chartContainer1", {
			theme: "light1",
			exportFileName: "Doughnut Chart",
			backgroundColor: "#e0e0e0",
			exportEnabled: false,
			animationEnabled: true,
			title:{
				text: "本次Veritas Academy所设置课程的丰富程度是否让你感到满意？",
				fontSize: 20
			},
			legend:{
				cursor: "pointer",
				itemclick: explodePie
			},
			data: [{
				type: "doughnut",
				innerRadius: 90,
				showInLegend: true,
				toolTipContent: "<b>{name}</b>: #percent%的学员",
				indexLabel: "{name} - #percent%",
				dataPoints: [
					{ y: 0, name: "非常不满意" },
					{ y: 0, name: "不满意" },
					{ y: 1034, name: "略不满意" },
					{ y: 1724, name: "满意" },
					{ y: 7241, name: "非常满意", color: "#4f9eff"},
				]
			}]
		});
		donutChart1.render();

		var donutChart2 = new CanvasJS.Chart("2017_chartContainer2", {
			theme: "light1",
			exportFileName: "Doughnut Chart",
			backgroundColor: "#e0e0e0",
			exportEnabled: false,
			animationEnabled: true,
			title:{
				text: "2017年书院的整体体验如何？",
				fontSize: 20
			},
			legend:{
				cursor: "pointer",
				itemclick: explodePie
			},
			data: [{
				type: "doughnut",
				innerRadius: 90,
				showInLegend: true,
				toolTipContent: "<b>{name}</b>: #percent%的学员",
				indexLabel: "{name} - #percent%",
				dataPoints: [
					{ y: 0, name: "非常不满意" },
					{ y: 189, name: "不满意" },
					{ y: 0, name: "略不满意" },
					{ y: 189, name: "略满意"},
					{ y: 2642, name: "满意" },
					{ y: 6980, name: "非常满意", color: "#4f9eff"},
				]
			}]
		});
		donutChart2.render();



		var donutChart3 = new CanvasJS.Chart("2017_chartContainer3", {
			theme: "light1",
			exportFileName: "Doughnut Chart",
			backgroundColor: "#e0e0e0",
			exportEnabled: false,
			animationEnabled: true,
			title:{
				text: "如何评价2017年书院学生讲师课程？",
				fontSize: 20
			},
			legend:{
				cursor: "pointer",
				itemclick: explodePie
			},
			data: [{
				type: "doughnut",
				innerRadius: 90,
				showInLegend: true,
				toolTipContent: "<b>{name}</b>: #percent%的学员",
				indexLabel: "{name} - #percent%",
				dataPoints: [
					{ y: 0, name: "非常不满意" },
					{ y: 189, name: "不满意" },
					{ y: 0, name: "略不满意" },
					{ y: 377, name: "略满意"},
					{ y: 3396, name: "满意" },
					{ y: 6038, name: "非常满意", color: "#4f9eff"},
				]
			}]
		});
		donutChart3.render();

		var donutChart4 = new CanvasJS.Chart("2017_chartContainer4", {
			theme: "light1",
			exportFileName: "Doughnut Chart",
			backgroundColor: "#e0e0e0",
			exportEnabled: false,
			animationEnabled: true,
			title:{
				text: "如何评价2017年书院教授课程？",
				fontSize: 20
			},
			legend:{
				cursor: "pointer",
				itemclick: explodePie
			},
			data: [{
				type: "doughnut",
				innerRadius: 90,
				showInLegend: true,
				toolTipContent: "<b>{name}</b>: #percent%的学员",
				indexLabel: "{name} - #percent%",
				dataPoints: [
					{ y: 0, name: "非常不满意" },
					{ y: 189, name: "不满意" },
					{ y: 0, name: "略不满意" },
					{ y: 566, name: "略满意"},
					{ y: 2641, name: "满意" },
					{ y: 6604, name: "非常满意", color: "#4f9eff"},
				]
			}]
		});
		donutChart4.render();

		

		var donutChart6 = new CanvasJS.Chart("2017_chartContainer6", {
			theme: "light1",
			exportFileName: "Doughnut Chart",
			backgroundColor: "#e0e0e0",
			exportEnabled: false,
			animationEnabled: true,
			title:{
				text: "如何评价2017年书院学生讲师Office Hour？",
				fontSize: 20
			},
			legend:{
				cursor: "pointer",
				itemclick: explodePie
			},
			data: [{
				type: "doughnut",
				innerRadius: 90,
				showInLegend: true,
				toolTipContent: "<b>{name}</b>: #percent%的学员",
				indexLabel: "{name} - #percent%",
				dataPoints: [
					{ y: 0, name: "非常不满意" },
					{ y: 189, name: "不满意" },
					{ y: 0, name: "略不满意" },
					{ y: 189, name: "略满意"},
					{ y: 2642, name: "满意" },
					{ y: 6980, name: "非常满意", color: "#4f9eff"},
				]
			}]
		});
		donutChart6.render();

	var donutChart5 = new CanvasJS.Chart("2017_chartContainer5", {
			theme: "light1",
			exportFileName: "Doughnut Chart",
			backgroundColor: "#e0e0e0",
			exportEnabled: false,
			animationEnabled: true,
			title:{
				text: "如何评价2017年书院的收费？",
				fontSize: 20
			},
			legend:{
				cursor: "pointer",
				itemclick: explodePie
			},
			data: [{
				type: "doughnut",
				innerRadius: 90,
				showInLegend: true,
				toolTipContent: "<b>{name}</b>: #percent%的学员",
				indexLabel: "{name} - #percent%",
				dataPoints: [
					{ y: 189, name: "非常不满意" },
					{ y: 0, name: "不满意" },
					{ y: 189, name: "略不满意" },
					{ y: 755, name: "略满意"},
					{ y: 2075, name: "满意" },
					{ y: 6792, name: "非常满意", color: "#4f9eff"},
				]
			}]
		});
		donutChart5.render();

		function explodePie (e) {
			if(typeof (e.dataSeries.dataPoints[e.dataPointIndex].exploded) === "undefined" || !e.dataSeries.dataPoints[e.dataPointIndex].exploded) {
				e.dataSeries.dataPoints[e.dataPointIndex].exploded = true;
			} else {
				e.dataSeries.dataPoints[e.dataPointIndex].exploded = false;
			}
			e.chart.render();
		}

		var stackedBarChart1 = new CanvasJS.Chart("2017_chartContainer7", {
		animationEnabled: true,
		theme: "light2", //"light1", "dark1", "dark2"
		title:{
			text: "对比参加书院前，你有了哪些改变？",
			fontSize: 20             
		},
		axisY:{
			interval: 10,
			suffix: "%"
		},
		toolTip:{
			shared: true
		},
		data:[{
				type: "stackedBar100",
				toolTipContent: "<b>{name}:</b> #percent%的学员",
				showInLegend: true, 
				name: "改变很大",
				color: "#4f9eff",
				dataPoints: [
					{ y: 4906, label: "对学科的了解" },
					{ y: 2453, label: "专业选择" },
					{ y: 1509, label: "升学计划" },
					{ y: 2830, label: "人生理想" },
					{ y: 4151, label: "自我认知" },
					{ y: 5094, label: "对博雅教育的认识" },
					{ y: 1321, label: "政治立场" }
				]
			}, 
			{
				type: "stackedBar100",
				toolTipContent: "<b>{name}:</b> #percent%的学员",
				showInLegend: true, 
				name: "有改变",
				dataPoints: [
					{ y: 3774, label: "对学科的了解" },
					{ y: 2453, label: "专业选择" },
					{ y: 3019, label: "升学计划" },
					{ y: 3019, label: "人生理想" },
					{ y: 3774, label: "自我认知" },
					{ y: 2830, label: "对博雅教育的认识" },
					{ y: 1698, label: "政治立场" }
				]
			}, 
			{
				type: "stackedBar100",
				toolTipContent: "<b>{name}:</b> #percent%的学员",
				showInLegend: true, 
				name: "略有改变",
				dataPoints: [
					{ y: 943, label: "对学科的了解" },
					{ y: 2830, label: "专业选择" },
					{ y: 3019, label: "升学计划" },
					{ y: 3019, label: "人生理想" },
					{ y: 1132, label: "自我认知" },
					{ y: 943, label: "对博雅教育的认识" },
					{ y: 4340, label: "政治立场" }
				]
			}, 
			{
				type: "stackedBar100",
				toolTipContent: "<b>{name}:</b> #percent%的学员",
				showInLegend: true, 
				name: "完全没有改变",
				dataPoints: [
					{ y: 377, label: "对学科的了解" },
					{ y: 2264, label: "专业选择" },
					{ y: 2453, label: "升学计划" },
					{ y: 1132, label: "人生理想" },
					{ y: 943, label: "自我认知" },
					{ y: 1132, label: "对博雅教育的认识" },
					{ y: 2642, label: "政治立场" }
				]
			}]
		});
		stackedBarChart1.render();

	}


/***/ }),
/* 15 */
/***/ (function(module, exports) {

	/*
	 CanvasJS HTML5 & JavaScript Charts - v2.0 GA - https://canvasjs.com/ 
	 Copyright 2017 fenopix

	  --------------------- License Information --------------------
	 CanvasJS is a commercial product which requires purchase of license. Without a commercial license you can use it for evaluation purposes for upto 30 days. Please refer to the following link for further details.
	     https://canvasjs.com/license-canvasjs/

	*/
	(function() {
	    function pa(m, s) {
	        m.prototype = $a(s.prototype);
	        m.prototype.constructor = m;
	        m.base = s.prototype
	    }

	    function $a(m) {
	        function s() {}
	        s.prototype = m;
	        return new s
	    }

	    function Ta(m, s, q) {
	        "millisecond" === q ? m.setMilliseconds(m.getMilliseconds() + 1 * s) : "second" === q ? m.setSeconds(m.getSeconds() + 1 * s) : "minute" === q ? m.setMinutes(m.getMinutes() + 1 * s) : "hour" === q ? m.setHours(m.getHours() + 1 * s) : "day" === q ? m.setDate(m.getDate() + 1 * s) : "week" === q ? m.setDate(m.getDate() + 7 * s) : "month" === q ? m.setMonth(m.getMonth() + 1 * s) : "year" === q && m.setFullYear(m.getFullYear() +
	            1 * s);
	        return m
	    }

	    function ia(m, s) {
	        var q = !1;
	        0 > m && (q = !0, m *= -1);
	        m = "" + m;
	        for (s = s ? s : 1; m.length < s;) m = "0" + m;
	        return q ? "-" + m : m
	    }

	    function Ga(m) {
	        if (!m) return m;
	        m = m.replace(/^\s\s*/, "");
	        for (var s = /\s/, q = m.length; s.test(m.charAt(--q)););
	        return m.slice(0, q + 1)
	    }

	    function Ca(m) {
	        m.roundRect = function(m, q, v, y, x, z, Q, C) {
	            Q && (this.fillStyle = Q);
	            C && (this.strokeStyle = C);
	            "undefined" === typeof x && (x = 5);
	            this.lineWidth = z;
	            this.beginPath();
	            this.moveTo(m + x, q);
	            this.lineTo(m + v - x, q);
	            this.quadraticCurveTo(m + v, q, m + v, q + x);
	            this.lineTo(m + v, q + y -
	                x);
	            this.quadraticCurveTo(m + v, q + y, m + v - x, q + y);
	            this.lineTo(m + x, q + y);
	            this.quadraticCurveTo(m, q + y, m, q + y - x);
	            this.lineTo(m, q + x);
	            this.quadraticCurveTo(m, q, m + x, q);
	            this.closePath();
	            Q && this.fill();
	            C && 0 < z && this.stroke()
	        }
	    }

	    function Pa(m, s) {
	        return m - s
	    }

	    function R(m) {
	        var s = ((m & 16711680) >> 16).toString(16),
	            q = ((m & 65280) >> 8).toString(16);
	        m = ((m & 255) >> 0).toString(16);
	        s = 2 > s.length ? "0" + s : s;
	        q = 2 > q.length ? "0" + q : q;
	        m = 2 > m.length ? "0" + m : m;
	        return "#" + s + q + m
	    }

	    function ab(m, s) {
	        var q = this.length >>> 0,
	            v = Number(s) || 0,
	            v = 0 > v ? Math.ceil(v) : Math.floor(v);
	        for (0 > v && (v += q); v < q; v++)
	            if (v in this && this[v] === m) return v;
	        return -1
	    }

	    function y(m) {
	        return null === m || "undefined" === typeof m
	    }

	    function Da(m) {
	        m.indexOf || (m.indexOf = ab);
	        return m
	    }

	    function bb(m) {
	        if (Z.fSDec) m[ka("`eeDwdouMhrudods")](ka("e`u`@ohl`uhnoHuds`uhnoDoe"), function() {
	            Z._fTWm && Z._fTWm(m)
	        })
	    }

	    function Ua(m, s, q) {
	        q = q || "normal";
	        var v = m + "_" + s + "_" + q,
	            y = Va[v];
	        if (isNaN(y)) {
	            try {
	                m = "position:absolute; left:0px; top:-20000px; padding:0px;margin:0px;border:none;white-space:pre;line-height:normal;font-family:" + m + "; font-size:" +
	                    s + "px; font-weight:" + q + ";";
	                if (!ra) {
	                    var x = document.body;
	                    ra = document.createElement("span");
	                    ra.innerHTML = "";
	                    var z = document.createTextNode("Mpgyi");
	                    ra.appendChild(z);
	                    x.appendChild(ra)
	                }
	                ra.style.display = "";
	                ra.setAttribute("style", m);
	                y = Math.round(ra.offsetHeight);
	                ra.style.display = "none"
	            } catch (Q) {
	                y = Math.ceil(1.1 * s)
	            }
	            y = Math.max(y, s);
	            Va[v] = y
	        }
	        return y
	    }

	    function G(m, s) {
	        var q = [];
	        if (q = {
	                solid: [],
	                shortDash: [3, 1],
	                shortDot: [1, 1],
	                shortDashDot: [3, 1, 1, 1],
	                shortDashDotDot: [3, 1, 1, 1, 1, 1],
	                dot: [1, 2],
	                dash: [4, 2],
	                dashDot: [4, 2, 1,
	                    2
	                ],
	                longDash: [8, 2],
	                longDashDot: [8, 2, 1, 2],
	                longDashDotDot: [8, 2, 1, 2, 1, 2]
	            }[m || "solid"])
	            for (var v = 0; v < q.length; v++) q[v] *= s;
	        else q = [];
	        return q
	    }

	    function N(m, s, q, v) {
	        return m.addEventListener ? (m.addEventListener(s, q, v || !1), q) : m.attachEvent ? (v = function(s) {
	            s = s || window.event;
	            s.preventDefault = s.preventDefault || function() {
	                s.returnValue = !1
	            };
	            s.stopPropagation = s.stopPropagation || function() {
	                s.cancelBubble = !0
	            };
	            q.call(m, s)
	        }, m.attachEvent("on" + s, v), v) : !1
	    }

	    function Wa(m, s, q) {
	        m *= ha;
	        s *= ha;
	        m = q.getImageData(m, s, 2, 2).data;
	        s = !0;
	        for (q = 0; 4 > q; q++)
	            if (m[q] !== m[q + 4] | m[q] !== m[q + 8] | m[q] !== m[q + 12]) {
	                s = !1;
	                break
	            }
	        return s ? m[0] << 16 | m[1] << 8 | m[2] : 0
	    }

	    function na(m, s, q) {
	        return m in s ? s[m] : q[m]
	    }

	    function Ha(m, s, q) {
	        if (v && Xa) {
	            var y = m.getContext("2d");
	            La = y.webkitBackingStorePixelRatio || y.mozBackingStorePixelRatio || y.msBackingStorePixelRatio || y.oBackingStorePixelRatio || y.backingStorePixelRatio || 1;
	            ha = Qa / La;
	            m.width = s * ha;
	            m.height = q * ha;
	            Qa !== La && (m.style.width = s + "px", m.style.height = q + "px", y.scale(ha, ha))
	        } else m.width = s, m.height = q
	    }

	    function cb(m) {
	        if (!Ya) {
	            var s = !1,
	                q = !1;
	            "undefined" === typeof sa.Chart.creditHref ? (m.creditHref = ka("iuuqr;..b`ow`rkr/bnl."), m.creditText = ka("B`ow`rKR/bnl")) : (s = m.updateOption("creditText"), q = m.updateOption("creditHref"));
	            if (m.creditHref && m.creditText) {
	                m._creditLink || (m._creditLink = document.createElement("a"), m._creditLink.setAttribute("class", "canvasjs-chart-credit"), m._creditLink.setAttribute("style", "outline:none;margin:0px;position:absolute;right:2px;top:" + (m.height - 14) + "px;color:dimgrey;text-decoration:none;font-size:11px;font-family: Calibri, Lucida Grande, Lucida Sans Unicode, Arial, sans-serif"),
	                    m._creditLink.setAttribute("tabIndex", -1), m._creditLink.setAttribute("target", "_blank"));
	                if (0 === m.renderCount || s || q) m._creditLink.setAttribute("href", m.creditHref), m._creditLink.innerHTML = m.creditText;
	                m._creditLink && m.creditHref && m.creditText ? (m._creditLink.parentElement || m._canvasJSContainer.appendChild(m._creditLink), m._creditLink.style.top = m.height - 14 + "px") : m._creditLink.parentElement && m._canvasJSContainer.removeChild(m._creditLink)
	            }
	        }
	    }

	    function ua(m, s) {
	        var q = document.createElement("canvas");
	        q.setAttribute("class",
	            "canvasjs-chart-canvas");
	        Ha(q, m, s);
	        v || "undefined" === typeof G_vmlCanvasManager || G_vmlCanvasManager.initElement(q);
	        return q
	    }

	    function qa(m, s, q) {
	        for (var v in q) s.style[v] = q[v]
	    }

	    function va(m, s, q) {
	        s.getAttribute("state") || (s.style.backgroundColor = m.toolbar.backgroundColor, s.style.color = m.toolbar.fontColor, s.style.border = "none", qa(m, s, {
	            WebkitUserSelect: "none",
	            MozUserSelect: "none",
	            msUserSelect: "none",
	            userSelect: "none"
	        }));
	        s.getAttribute("state") !== q && (s.setAttribute("state", q), s.setAttribute("type", "button"),
	            qa(m, s, {
	                padding: "5px 12px",
	                cursor: "pointer",
	                "float": "left",
	                width: "40px",
	                height: "25px",
	                outline: "0px",
	                verticalAlign: "baseline",
	                lineHeight: "0"
	            }), s.setAttribute("title", m._cultureInfo[q + "Text"]), s.innerHTML = "<img style='height:95%;' src='" + db[q].image + "' alt='" + m._cultureInfo[q + "Text"] + "' />")
	    }

	    function Ma() {
	        for (var m = null, s = 0; s < arguments.length; s++) m = arguments[s], m.style && (m.style.display = "inline")
	    }

	    function wa() {
	        for (var m = null, s = 0; s < arguments.length; s++)(m = arguments[s]) && m.style && (m.style.display = "none")
	    }

	    function X(m, s, q, v, x) {
	        this._defaultsKey = m;
	        this._themeOptionsKey = s;
	        this._index = v;
	        this.parent = x;
	        this._eventListeners = [];
	        m = {};
	        this.theme && y(s) && y(v) ? m = y(ya[this.theme]) ? ya.light1 : ya[this.theme] : this.parent && (this.parent.themeOptions && this.parent.themeOptions[s]) && (null === v ? m = this.parent.themeOptions[s] : 0 < this.parent.themeOptions[s].length && (v = Math.min(this.parent.themeOptions[s].length - 1, v), m = this.parent.themeOptions[s][v]));
	        this.themeOptions = m;
	        this.options = q ? q : {
	            _isPlaceholder: !0
	        };
	        this.setOptions(this.options,
	            m)
	    }

	    function Ea(m, s, q, v, y) {
	        "undefined" === typeof y && (y = 0);
	        this._padding = y;
	        this._x1 = m;
	        this._y1 = s;
	        this._x2 = q;
	        this._y2 = v;
	        this._rightOccupied = this._leftOccupied = this._bottomOccupied = this._topOccupied = this._padding
	    }

	    function la(m, s) {
	        la.base.constructor.call(this, "TextBlock", null, s, null, null);
	        this.ctx = m;
	        this._isDirty = !0;
	        this._wrappedText = null;
	        this._initialize()
	    }

	    function Ra(m, s) {
	        Ra.base.constructor.call(this, "Toolbar", "toolbar", s, null, m);
	        this.chart = m;
	        this.canvas = m.canvas;
	        this.ctx = this.chart.ctx;
	        this.optionsName =
	            "toolbar"
	    }

	    function Ia(m, s) {
	        Ia.base.constructor.call(this, "Title", "title", s, null, m);
	        this.chart = m;
	        this.canvas = m.canvas;
	        this.ctx = this.chart.ctx;
	        this.optionsName = "title";
	        if (y(this.options.margin) && m.options.subtitles)
	            for (var q = m.options.subtitles, v = 0; v < q.length; v++)
	                if ((y(q[v].horizontalAlign) && "center" === this.horizontalAlign || q[v].horizontalAlign === this.horizontalAlign) && (y(q[v].verticalAlign) && "top" === this.verticalAlign || q[v].verticalAlign === this.verticalAlign) && !q[v].dockInsidePlotArea === !this.dockInsidePlotArea) {
	                    this.margin =
	                        0;
	                    break
	                }
	        "undefined" === typeof this.options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize));
	        this.height = this.width = null;
	        this.bounds = {
	            x1: null,
	            y1: null,
	            x2: null,
	            y2: null
	        }
	    }

	    function Na(m, s, q) {
	        Na.base.constructor.call(this, "Subtitle", "subtitles", s, q, m);
	        this.chart = m;
	        this.canvas = m.canvas;
	        this.ctx = this.chart.ctx;
	        this.optionsName = "subtitles";
	        this.isOptionsInArray = !0;
	        "undefined" === typeof this.options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize));
	        this.height = this.width = null;
	        this.bounds = {
	            x1: null,
	            y1: null,
	            x2: null,
	            y2: null
	        }
	    }

	    function Ja(m) {
	        var s;
	        m && Ka[m] && (s = Ka[m]);
	        Ja.base.constructor.call(this, "CultureInfo", null, s, null, null)
	    }
	    var Z = {},
	        v = !!document.createElement("canvas").getContext,
	        sa = {
	            Chart: {
	                width: 500,
	                height: 400,
	                zoomEnabled: !1,
	                zoomType: "x",
	                backgroundColor: "white",
	                theme: "light1",
	                animationEnabled: !1,
	                animationDuration: 1200,
	                dataPointWidth: null,
	                dataPointMinWidth: null,
	                dataPointMaxWidth: null,
	                colorSet: "colorSet1",
	                culture: "en",
	                creditHref: "",
	                creditText: "CanvasJS",
	                interactivityEnabled: !0,
	                exportEnabled: !1,
	                exportFileName: "Chart",
	                rangeChanging: null,
	                rangeChanged: null,
	                publicProperties: {
	                    title: "readWrite",
	                    subtitles: "readWrite",
	                    toolbar: "readWrite",
	                    toolTip: "readWrite",
	                    legend: "readWrite",
	                    axisX: "readWrite",
	                    axisY: "readWrite",
	                    axisX2: "readWrite",
	                    axisY2: "readWrite",
	                    data: "readWrite",
	                    options: "readWrite",
	                    bounds: "readOnly",
	                    container: "readOnly"
	                }
	            },
	            Title: {
	                padding: 0,
	                text: null,
	                verticalAlign: "top",
	                horizontalAlign: "center",
	                fontSize: 20,
	                fontFamily: "Calibri",
	                fontWeight: "normal",
	                fontColor: "black",
	                fontStyle: "normal",
	                borderThickness: 0,
	                borderColor: "black",
	                cornerRadius: 0,
	                backgroundColor: v ? "transparent" : null,
	                margin: 5,
	                wrap: !0,
	                maxWidth: null,
	                dockInsidePlotArea: !1,
	                publicProperties: {
	                    options: "readWrite",
	                    bounds: "readOnly",
	                    chart: "readOnly"
	                }
	            },
	            Subtitle: {
	                padding: 0,
	                text: null,
	                verticalAlign: "top",
	                horizontalAlign: "center",
	                fontSize: 14,
	                fontFamily: "Calibri",
	                fontWeight: "normal",
	                fontColor: "black",
	                fontStyle: "normal",
	                borderThickness: 0,
	                borderColor: "black",
	                cornerRadius: 0,
	                backgroundColor: null,
	                margin: 2,
	                wrap: !0,
	                maxWidth: null,
	                dockInsidePlotArea: !1,
	                publicProperties: {
	                    options: "readWrite",
	                    bounds: "readOnly",
	                    chart: "readOnly"
	                }
	            },
	            Toolbar: {
	                backgroundColor: "white",
	                backgroundColorOnHover: "#2196f3",
	                borderColor: "#2196f3",
	                borderThickness: 1,
	                fontColor: "black",
	                fontColorOnHover: "white",
	                publicProperties: {
	                    options: "readWrite",
	                    chart: "readOnly"
	                }
	            },
	            Legend: {
	                name: null,
	                verticalAlign: "center",
	                horizontalAlign: "right",
	                fontSize: 14,
	                fontFamily: "calibri",
	                fontWeight: "normal",
	                fontColor: "black",
	                fontStyle: "normal",
	                cursor: null,
	                itemmouseover: null,
	                itemmouseout: null,
	                itemmousemove: null,
	                itemclick: null,
	                dockInsidePlotArea: !1,
	                reversed: !1,
	                backgroundColor: v ? "transparent" : null,
	                borderColor: v ? "transparent" : null,
	                borderThickness: 0,
	                cornerRadius: 0,
	                maxWidth: null,
	                maxHeight: null,
	                markerMargin: null,
	                itemMaxWidth: null,
	                itemWidth: null,
	                itemWrap: !0,
	                itemTextFormatter: null,
	                publicProperties: {
	                    options: "readWrite",
	                    bounds: "readOnly",
	                    chart: "readOnly"
	                }
	            },
	            ToolTip: {
	                enabled: !0,
	                shared: !1,
	                animationEnabled: !0,
	                content: null,
	                contentFormatter: null,
	                reversed: !1,
	                backgroundColor: v ? "rgba(255,255,255,.9)" : "rgb(255,255,255)",
	                borderColor: null,
	                borderThickness: 2,
	                cornerRadius: 5,
	                fontSize: 14,
	                fontColor: "black",
	                fontFamily: "Calibri, Arial, Georgia, serif;",
	                fontWeight: "normal",
	                fontStyle: "italic",
	                publicProperties: {
	                    options: "readWrite",
	                    chart: "readOnly"
	                }
	            },
	            Axis: {
	                minimum: null,
	                maximum: null,
	                viewportMinimum: null,
	                viewportMaximum: null,
	                interval: null,
	                intervalType: null,
	                reversed: !1,
	                logarithmic: !1,
	                logarithmBase: 10,
	                title: null,
	                titleFontColor: "black",
	                titleFontSize: 20,
	                titleFontFamily: "arial",
	                titleFontWeight: "normal",
	                titleFontStyle: "normal",
	                titleWrap: !0,
	                titleMaxWidth: null,
	                titleBackgroundColor: v ? "transparent" : null,
	                titleBorderColor: v ? "transparent" : null,
	                titleBorderThickness: 0,
	                titleCornerRadius: 0,
	                labelAngle: 0,
	                labelFontFamily: "arial",
	                labelFontColor: "black",
	                labelFontSize: 12,
	                labelFontWeight: "normal",
	                labelFontStyle: "normal",
	                labelAutoFit: !0,
	                labelWrap: !0,
	                labelMaxWidth: null,
	                labelFormatter: null,
	                labelBackgroundColor: v ? "transparent" : null,
	                labelBorderColor: v ? "transparent" : null,
	                labelBorderThickness: 0,
	                labelCornerRadius: 0,
	                labelPlacement: "outside",
	                prefix: "",
	                suffix: "",
	                includeZero: !0,
	                tickLength: 5,
	                tickColor: "black",
	                tickThickness: 1,
	                lineColor: "black",
	                lineThickness: 1,
	                lineDashType: "solid",
	                gridColor: "A0A0A0",
	                gridThickness: 0,
	                gridDashType: "solid",
	                interlacedColor: v ? "transparent" : null,
	                valueFormatString: null,
	                margin: 2,
	                publicProperties: {
	                    options: "readWrite",
	                    stripLines: "readWrite",
	                    scaleBreaks: "readWrite",
	                    crosshair: "readWrite",
	                    bounds: "readOnly",
	                    chart: "readOnly"
	                }
	            },
	            StripLine: {
	                value: null,
	                startValue: null,
	                endValue: null,
	                color: "orange",
	                opacity: null,
	                thickness: 2,
	                lineDashType: "solid",
	                label: "",
	                labelPlacement: "inside",
	                labelAlign: "far",
	                labelWrap: !0,
	                labelMaxWidth: null,
	                labelBackgroundColor: null,
	                labelBorderColor: v ? "transparent" : null,
	                labelBorderThickness: 0,
	                labelCornerRadius: 0,
	                labelFontFamily: "arial",
	                labelFontColor: "orange",
	                labelFontSize: 12,
	                labelFontWeight: "normal",
	                labelFontStyle: "normal",
	                labelFormatter: null,
	                showOnTop: !1,
	                publicProperties: {
	                    options: "readWrite",
	                    axis: "readOnly",
	                    bounds: "readOnly",
	                    chart: "readOnly"
	                }
	            },
	            ScaleBreaks: {
	                autoCalculate: !1,
	                collapsibleThreshold: "25%",
	                maxNumberOfAutoBreaks: 2,
	                spacing: 8,
	                type: "straight",
	                color: "#FFFFFF",
	                fillOpacity: 0.9,
	                lineThickness: 2,
	                lineColor: "#E16E6E",
	                lineDashType: "solid",
	                publicProperties: {
	                    options: "readWrite",
	                    customBreaks: "readWrite",
	                    axis: "readOnly",
	                    autoBreaks: "readOnly",
	                    bounds: "readOnly",
	                    chart: "readOnly"
	                }
	            },
	            Break: {
	                startValue: null,
	                endValue: null,
	                spacing: 8,
	                type: "straight",
	                color: "#FFFFFF",
	                fillOpacity: 0.9,
	                lineThickness: 2,
	                lineColor: "#E16E6E",
	                lineDashType: "solid",
	                publicProperties: {
	                    options: "readWrite",
	                    scaleBreaks: "readOnly",
	                    bounds: "readOnly",
	                    chart: "readOnly"
	                }
	            },
	            Crosshair: {
	                enabled: !1,
	                snapToDataPoint: !1,
	                color: "grey",
	                opacity: null,
	                thickness: 2,
	                lineDashType: "solid",
	                label: "",
	                labelWrap: !0,
	                labelMaxWidth: null,
	                labelBackgroundColor: v ? "grey" : null,
	                labelBorderColor: v ? "grey" : null,
	                labelBorderThickness: 0,
	                labelCornerRadius: 0,
	                labelFontFamily: v ? "Calibri, Optima, Candara, Verdana, Geneva, sans-serif" : "calibri",
	                labelFontSize: 12,
	                labelFontColor: "#fff",
	                labelFontWeight: "normal",
	                labelFontStyle: "normal",
	                labelFormatter: null,
	                valueFormatString: null,
	                publicProperties: {
	                    options: "readWrite",
	                    axis: "readOnly",
	                    bounds: "readOnly",
	                    chart: "readOnly"
	                }
	            },
	            DataSeries: {
	                name: null,
	                dataPoints: null,
	                label: "",
	                bevelEnabled: !1,
	                highlightEnabled: !0,
	                cursor: "default",
	                indexLabel: "",
	                indexLabelPlacement: "auto",
	                indexLabelOrientation: "horizontal",
	                indexLabelFontColor: "black",
	                indexLabelFontSize: 12,
	                indexLabelFontStyle: "normal",
	                indexLabelFontFamily: "Arial",
	                indexLabelFontWeight: "normal",
	                indexLabelBackgroundColor: null,
	                indexLabelLineColor: "gray",
	                indexLabelLineThickness: 1,
	                indexLabelLineDashType: "solid",
	                indexLabelMaxWidth: null,
	                indexLabelWrap: !0,
	                indexLabelFormatter: null,
	                lineThickness: 2,
	                lineDashType: "solid",
	                connectNullData: !1,
	                nullDataLineDashType: "dash",
	                color: null,
	                lineColor: null,
	                risingColor: "white",
	                fallingColor: "red",
	                fillOpacity: null,
	                startAngle: 0,
	                radius: null,
	                innerRadius: null,
	                neckHeight: null,
	                neckWidth: null,
	                reversed: !1,
	                valueRepresents: null,
	                linkedDataSeriesIndex: null,
	                whiskerThickness: 2,
	                whiskerDashType: "solid",
	                whiskerColor: null,
	                whiskerLength: null,
	                stemThickness: 2,
	                stemColor: null,
	                stemDashType: "solid",
	                upperBoxColor: "white",
	                lowerBoxColor: "white",
	                type: "column",
	                xValueType: "number",
	                axisXType: "primary",
	                axisYType: "primary",
	                axisXIndex: 0,
	                axisYIndex: 0,
	                xValueFormatString: null,
	                yValueFormatString: null,
	                zValueFormatString: null,
	                percentFormatString: null,
	                showInLegend: null,
	                legendMarkerType: null,
	                legendMarkerColor: null,
	                legendText: null,
	                legendMarkerBorderColor: v ? "transparent" : null,
	                legendMarkerBorderThickness: 0,
	                markerType: "circle",
	                markerColor: null,
	                markerSize: null,
	                markerBorderColor: v ? "transparent" : null,
	                markerBorderThickness: 0,
	                mouseover: null,
	                mouseout: null,
	                mousemove: null,
	                click: null,
	                toolTipContent: null,
	                visible: !0,
	                publicProperties: {
	                    options: "readWrite",
	                    axisX: "readWrite",
	                    axisY: "readWrite",
	                    chart: "readOnly"
	                }
	            },
	            TextBlock: {
	                x: 0,
	                y: 0,
	                width: null,
	                height: null,
	                maxWidth: null,
	                maxHeight: null,
	                padding: 0,
	                angle: 0,
	                text: "",
	                horizontalAlign: "center",
	                fontSize: 12,
	                fontFamily: "calibri",
	                fontWeight: "normal",
	                fontColor: "black",
	                fontStyle: "normal",
	                borderThickness: 0,
	                borderColor: "black",
	                cornerRadius: 0,
	                backgroundColor: null,
	                textBaseline: "top"
	            },
	            CultureInfo: {
	                decimalSeparator: ".",
	                digitGroupSeparator: ",",
	                zoomText: "Zoom",
	                panText: "Pan",
	                resetText: "Reset",
	                menuText: "More Options",
	                saveJPGText: "Save as JPEG",
	                savePNGText: "Save as PNG",
	                printText: "Print",
	                days: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
	                shortDays: "Sun Mon Tue Wed Thu Fri Sat".split(" "),
	                months: "January February March April May June July August September October November December".split(" "),
	                shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" ")
	            }
	        },
	        Ka = {
	            en: {}
	        },
	        x = v ? "Trebuchet MS, Helvetica, sans-serif" : "Arial",
	        Fa = v ? "Impact, Charcoal, sans-serif" : "Arial",
	        Aa = {
	            colorSet1: "#4F81BC #C0504E #9BBB58 #23BFAA #8064A1 #4AACC5 #F79647 #7F6084 #77A033 #33558B #E59566".split(" "),
	            colorSet2: "#6D78AD #51CDA0 #DF7970 #4C9CA0 #AE7D99 #C9D45C #5592AD #DF874D #52BCA8 #8E7AA3 #E3CB64 #C77B85 #C39762 #8DD17E #B57952 #FCC26C".split(" "),
	            colorSet3: "#8CA1BC #36845C #017E82 #8CB9D0 #708C98 #94838D #F08891 #0366A7 #008276 #EE7757 #E5BA3A #F2990B #03557B #782970".split(" ")
	        },
	        O, ga, T, Y, fa;
	    ga = "#333333";
	    T = "#000000";
	    O = "#666666";
	    fa = Y = "#000000";
	    var aa = 20,
	        z = 14,
	        Sa = {
	            colorSet: "colorSet1",
	            backgroundColor: "#FFFFFF",
	            title: {
	                fontFamily: Fa,
	                fontSize: 32,
	                fontColor: ga,
	                fontWeight: "normal",
	                verticalAlign: "top",
	                margin: 5
	            },
	            subtitles: [{
	                fontFamily: Fa,
	                fontSize: z,
	                fontColor: ga,
	                fontWeight: "normal",
	                verticalAlign: "top",
	                margin: 5
	            }],
	            data: [{
	                indexLabelFontFamily: x,
	                indexLabelFontSize: z,
	                indexLabelFontColor: ga,
	                indexLabelFontWeight: "normal",
	                indexLabelLineThickness: 1
	            }],
	            axisX: [{
	                titleFontFamily: x,
	                titleFontSize: aa,
	                titleFontColor: ga,
	                titleFontWeight: "normal",
	                labelFontFamily: x,
	                labelFontSize: z,
	                labelFontColor: T,
	                labelFontWeight: "normal",
	                lineThickness: 1,
	                lineColor: O,
	                tickThickness: 1,
	                tickColor: O,
	                gridThickness: 0,
	                gridColor: O,
	                stripLines: [{
	                    labelFontFamily: x,
	                    labelFontSize: z,
	                    labelFontColor: "#FF7300",
	                    labelFontWeight: "normal",
	                    labelBackgroundColor: null,
	                    color: "#FF7300",
	                    thickness: 1
	                }],
	                crosshair: {
	                    labelFontFamily: x,
	                    labelFontSize: z,
	                    labelFontColor: "#EEEEEE",
	                    labelFontWeight: "normal",
	                    labelBackgroundColor: fa,
	                    color: Y,
	                    thickness: 1,
	                    lineDashType: "dash"
	                },
	                scaleBreaks: {
	                    type: "zigzag",
	                    spacing: "2%",
	                    lineColor: "#BBBBBB",
	                    lineThickness: 1,
	                    lineDashType: "solid"
	                }
	            }],
	            axisX2: [{
	                titleFontFamily: x,
	                titleFontSize: aa,
	                titleFontColor: ga,
	                titleFontWeight: "normal",
	                labelFontFamily: x,
	                labelFontSize: z,
	                labelFontColor: T,
	                labelFontWeight: "normal",
	                lineThickness: 1,
	                lineColor: O,
	                tickThickness: 1,
	                tickColor: O,
	                gridThickness: 0,
	                gridColor: O,
	                stripLines: [{
	                    labelFontFamily: x,
	                    labelFontSize: z,
	                    labelFontColor: "#FF7300",
	                    labelFontWeight: "normal",
	                    labelBackgroundColor: null,
	                    color: "#FF7300",
	                    thickness: 1
	                }],
	                crosshair: {
	                    labelFontFamily: x,
	                    labelFontSize: z,
	                    labelFontColor: "#EEEEEE",
	                    labelFontWeight: "normal",
	                    labelBackgroundColor: fa,
	                    color: Y,
	                    thickness: 1,
	                    lineDashType: "dash"
	                },
	                scaleBreaks: {
	                    type: "zigzag",
	                    spacing: "2%",
	                    lineColor: "#BBBBBB",
	                    lineThickness: 1,
	                    lineDashType: "solid"
	                }
	            }],
	            axisY: [{
	                titleFontFamily: x,
	                titleFontSize: aa,
	                titleFontColor: ga,
	                titleFontWeight: "normal",
	                labelFontFamily: x,
	                labelFontSize: z,
	                labelFontColor: T,
	                labelFontWeight: "normal",
	                lineThickness: 1,
	                lineColor: O,
	                tickThickness: 1,
	                tickColor: O,
	                gridThickness: 1,
	                gridColor: O,
	                stripLines: [{
	                    labelFontFamily: x,
	                    labelFontSize: z,
	                    labelFontColor: "#FF7300",
	                    labelFontWeight: "normal",
	                    labelBackgroundColor: null,
	                    color: "#FF7300",
	                    thickness: 1
	                }],
	                crosshair: {
	                    labelFontFamily: x,
	                    labelFontSize: z,
	                    labelFontColor: "#EEEEEE",
	                    labelFontWeight: "normal",
	                    labelBackgroundColor: fa,
	                    color: Y,
	                    thickness: 1,
	                    lineDashType: "dash"
	                },
	                scaleBreaks: {
	                    type: "zigzag",
	                    spacing: "2%",
	                    lineColor: "#BBBBBB",
	                    lineThickness: 1,
	                    lineDashType: "solid"
	                }
	            }],
	            axisY2: [{
	                titleFontFamily: x,
	                titleFontSize: aa,
	                titleFontColor: ga,
	                titleFontWeight: "normal",
	                labelFontFamily: x,
	                labelFontSize: z,
	                labelFontColor: T,
	                labelFontWeight: "normal",
	                lineThickness: 1,
	                lineColor: O,
	                tickThickness: 1,
	                tickColor: O,
	                gridThickness: 1,
	                gridColor: O,
	                stripLines: [{
	                    labelFontFamily: x,
	                    labelFontSize: z,
	                    labelFontColor: "#FF7300",
	                    labelFontWeight: "normal",
	                    labelBackgroundColor: null,
	                    color: "#FF7300",
	                    thickness: 1
	                }],
	                crosshair: {
	                    labelFontFamily: x,
	                    labelFontSize: z,
	                    labelFontColor: "#EEEEEE",
	                    labelFontWeight: "normal",
	                    labelBackgroundColor: fa,
	                    color: Y,
	                    thickness: 1,
	                    lineDashType: "dash"
	                },
	                scaleBreaks: {
	                    type: "zigzag",
	                    spacing: "2%",
	                    lineColor: "#BBBBBB",
	                    lineThickness: 1,
	                    lineDashType: "solid"
	                }
	            }],
	            legend: {
	                fontFamily: x,
	                fontSize: 14,
	                fontColor: ga,
	                fontWeight: "bold",
	                verticalAlign: "bottom",
	                horizontalAlign: "center"
	            },
	            toolTip: {
	                fontFamily: x,
	                fontSize: 14,
	                fontStyle: "normal",
	                cornerRadius: 0,
	                borderThickness: 1
	            }
	        };
	    T = ga = "#F5F5F5";
	    O = "#FFFFFF";
	    Y = "#40BAF1";
	    fa = "#F5F5F5";
	    var aa = 20,
	        z = 14,
	        Za = {
	            colorSet: "colorSet2",
	            title: {
	                fontFamily: x,
	                fontSize: 33,
	                fontColor: "#3A3A3A",
	                fontWeight: "bold",
	                verticalAlign: "top",
	                margin: 5
	            },
	            subtitles: [{
	                fontFamily: x,
	                fontSize: z,
	                fontColor: "#3A3A3A",
	                fontWeight: "normal",
	                verticalAlign: "top",
	                margin: 5
	            }],
	            data: [{
	                indexLabelFontFamily: x,
	                indexLabelFontSize: z,
	                indexLabelFontColor: "#666666",
	                indexLabelFontWeight: "normal",
	                indexLabelLineThickness: 1
	            }],
	            axisX: [{
	                titleFontFamily: x,
	                titleFontSize: aa,
	                titleFontColor: "#666666",
	                titleFontWeight: "normal",
	                labelFontFamily: x,
	                labelFontSize: z,
	                labelFontColor: "#666666",
	                labelFontWeight: "normal",
	                lineThickness: 1,
	                lineColor: "#BBBBBB",
	                tickThickness: 1,
	                tickColor: "#BBBBBB",
	                gridThickness: 1,
	                gridColor: "#BBBBBB",
	                stripLines: [{
	                    labelFontFamily: x,
	                    labelFontSize: z,
	                    labelFontColor: "#FFA500",
	                    labelFontWeight: "normal",
	                    labelBackgroundColor: null,
	                    color: "#FFA500",
	                    thickness: 1
	                }],
	                crosshair: {
	                    labelFontFamily: x,
	                    labelFontSize: z,
	                    labelFontColor: "#EEEEEE",
	                    labelFontWeight: "normal",
	                    labelBackgroundColor: "black",
	                    color: "black",
	                    thickness: 1,
	                    lineDashType: "dot"
	                },
	                scaleBreaks: {
	                    type: "zigzag",
	                    spacing: "2%",
	                    lineColor: "#BBBBBB",
	                    lineThickness: 1,
	                    lineDashType: "solid"
	                }
	            }],
	            axisX2: [{
	                titleFontFamily: x,
	                titleFontSize: aa,
	                titleFontColor: "#666666",
	                titleFontWeight: "normal",
	                labelFontFamily: x,
	                labelFontSize: z,
	                labelFontColor: "#666666",
	                labelFontWeight: "normal",
	                lineThickness: 1,
	                lineColor: "#BBBBBB",
	                tickColor: "#BBBBBB",
	                tickThickness: 1,
	                gridThickness: 1,
	                gridColor: "#BBBBBB",
	                stripLines: [{
	                    labelFontFamily: x,
	                    labelFontSize: z,
	                    labelFontColor: "#FFA500",
	                    labelFontWeight: "normal",
	                    labelBackgroundColor: null,
	                    color: "#FFA500",
	                    thickness: 1
	                }],
	                crosshair: {
	                    labelFontFamily: x,
	                    labelFontSize: z,
	                    labelFontColor: "#EEEEEE",
	                    labelFontWeight: "normal",
	                    labelBackgroundColor: "black",
	                    color: "black",
	                    thickness: 1,
	                    lineDashType: "dot"
	                },
	                scaleBreaks: {
	                    type: "zigzag",
	                    spacing: "2%",
	                    lineColor: "#BBBBBB",
	                    lineThickness: 1,
	                    lineDashType: "solid"
	                }
	            }],
	            axisY: [{
	                titleFontFamily: x,
	                titleFontSize: aa,
	                titleFontColor: "#666666",
	                titleFontWeight: "normal",
	                labelFontFamily: x,
	                labelFontSize: z,
	                labelFontColor: "#666666",
	                labelFontWeight: "normal",
	                lineThickness: 0,
	                lineColor: "#BBBBBB",
	                tickColor: "#BBBBBB",
	                tickThickness: 1,
	                gridThickness: 1,
	                gridColor: "#BBBBBB",
	                stripLines: [{
	                    labelFontFamily: x,
	                    labelFontSize: z,
	                    labelFontColor: "#FFA500",
	                    labelFontWeight: "normal",
	                    labelBackgroundColor: null,
	                    color: "#FFA500",
	                    thickness: 1
	                }],
	                crosshair: {
	                    labelFontFamily: x,
	                    labelFontSize: z,
	                    labelFontColor: "#EEEEEE",
	                    labelFontWeight: "normal",
	                    labelBackgroundColor: "black",
	                    color: "black",
	                    thickness: 1,
	                    lineDashType: "dot"
	                },
	                scaleBreaks: {
	                    type: "zigzag",
	                    spacing: "2%",
	                    lineColor: "#BBBBBB",
	                    lineThickness: 1,
	                    lineDashType: "solid"
	                }
	            }],
	            axisY2: [{
	                titleFontFamily: x,
	                titleFontSize: aa,
	                titleFontColor: "#666666",
	                titleFontWeight: "normal",
	                labelFontFamily: x,
	                labelFontSize: z,
	                labelFontColor: "#666666",
	                labelFontWeight: "normal",
	                lineThickness: 0,
	                lineColor: "#BBBBBB",
	                tickColor: "#BBBBBB",
	                tickThickness: 1,
	                gridThickness: 1,
	                gridColor: "#BBBBBB",
	                stripLines: [{
	                    labelFontFamily: x,
	                    labelFontSize: z,
	                    labelFontColor: "#FFA500",
	                    labelFontWeight: "normal",
	                    labelBackgroundColor: null,
	                    color: "#FFA500",
	                    thickness: 1
	                }],
	                crosshair: {
	                    labelFontFamily: x,
	                    labelFontSize: z,
	                    labelFontColor: "#EEEEEE",
	                    labelFontWeight: "normal",
	                    labelBackgroundColor: "black",
	                    color: "black",
	                    thickness: 1,
	                    lineDashType: "dot"
	                },
	                scaleBreaks: {
	                    type: "zigzag",
	                    spacing: "2%",
	                    lineColor: "#BBBBBB",
	                    lineThickness: 1,
	                    lineDashType: "solid"
	                }
	            }],
	            legend: {
	                fontFamily: x,
	                fontSize: 14,
	                fontColor: "#3A3A3A",
	                fontWeight: "bold",
	                verticalAlign: "bottom",
	                horizontalAlign: "center"
	            },
	            toolTip: {
	                fontFamily: x,
	                fontSize: 14,
	                fontStyle: "normal",
	                cornerRadius: 0,
	                borderThickness: 1
	            }
	        };
	    T = ga = "#F5F5F5";
	    O = "#FFFFFF";
	    Y = "#40BAF1";
	    fa = "#F5F5F5";
	    aa = 20;
	    z = 14;
	    Fa = {
	        colorSet: "colorSet12",
	        backgroundColor: "#2A2A2A",
	        title: {
	            fontFamily: Fa,
	            fontSize: 32,
	            fontColor: ga,
	            fontWeight: "normal",
	            verticalAlign: "top",
	            margin: 5
	        },
	        subtitles: [{
	            fontFamily: Fa,
	            fontSize: z,
	            fontColor: ga,
	            fontWeight: "normal",
	            verticalAlign: "top",
	            margin: 5
	        }],
	        toolbar: {
	            backgroundColor: "#666666",
	            backgroundColorOnHover: "#FF7372",
	            borderColor: "#FF7372",
	            borderThickness: 1,
	            fontColor: "#F5F5F5",
	            fontColorOnHover: "#F5F5F5"
	        },
	        data: [{
	            indexLabelFontFamily: x,
	            indexLabelFontSize: z,
	            indexLabelFontColor: T,
	            indexLabelFontWeight: "normal",
	            indexLabelLineThickness: 1
	        }],
	        axisX: [{
	            titleFontFamily: x,
	            titleFontSize: aa,
	            titleFontColor: T,
	            titleFontWeight: "normal",
	            labelFontFamily: x,
	            labelFontSize: z,
	            labelFontColor: T,
	            labelFontWeight: "normal",
	            lineThickness: 1,
	            lineColor: O,
	            tickThickness: 1,
	            tickColor: O,
	            gridThickness: 0,
	            gridColor: O,
	            stripLines: [{
	                labelFontFamily: x,
	                labelFontSize: z,
	                labelFontColor: "#FF7300",
	                labelFontWeight: "normal",
	                labelBackgroundColor: null,
	                color: "#FF7300",
	                thickness: 1
	            }],
	            crosshair: {
	                labelFontFamily: x,
	                labelFontSize: z,
	                labelFontColor: "#000000",
	                labelFontWeight: "normal",
	                labelBackgroundColor: fa,
	                color: Y,
	                thickness: 1,
	                lineDashType: "dash"
	            },
	            scaleBreaks: {
	                type: "zigzag",
	                spacing: "2%",
	                lineColor: "#777777",
	                lineThickness: 1,
	                lineDashType: "solid",
	                color: "#111111"
	            }
	        }],
	        axisX2: [{
	            titleFontFamily: x,
	            titleFontSize: aa,
	            titleFontColor: T,
	            titleFontWeight: "normal",
	            labelFontFamily: x,
	            labelFontSize: z,
	            labelFontColor: T,
	            labelFontWeight: "normal",
	            lineThickness: 1,
	            lineColor: O,
	            tickThickness: 1,
	            tickColor: O,
	            gridThickness: 0,
	            gridColor: O,
	            stripLines: [{
	                labelFontFamily: x,
	                labelFontSize: z,
	                labelFontColor: "#FF7300",
	                labelFontWeight: "normal",
	                labelBackgroundColor: null,
	                color: "#FF7300",
	                thickness: 1
	            }],
	            crosshair: {
	                labelFontFamily: x,
	                labelFontSize: z,
	                labelFontColor: "#000000",
	                labelFontWeight: "normal",
	                labelBackgroundColor: fa,
	                color: Y,
	                thickness: 1,
	                lineDashType: "dash"
	            },
	            scaleBreaks: {
	                type: "zigzag",
	                spacing: "2%",
	                lineColor: "#777777",
	                lineThickness: 1,
	                lineDashType: "solid",
	                color: "#111111"
	            }
	        }],
	        axisY: [{
	            titleFontFamily: x,
	            titleFontSize: aa,
	            titleFontColor: T,
	            titleFontWeight: "normal",
	            labelFontFamily: x,
	            labelFontSize: z,
	            labelFontColor: T,
	            labelFontWeight: "normal",
	            lineThickness: 1,
	            lineColor: O,
	            tickThickness: 1,
	            tickColor: O,
	            gridThickness: 1,
	            gridColor: O,
	            stripLines: [{
	                labelFontFamily: x,
	                labelFontSize: z,
	                labelFontColor: "#FF7300",
	                labelFontWeight: "normal",
	                labelBackgroundColor: null,
	                color: "#FF7300",
	                thickness: 1
	            }],
	            crosshair: {
	                labelFontFamily: x,
	                labelFontSize: z,
	                labelFontColor: "#000000",
	                labelFontWeight: "normal",
	                labelBackgroundColor: fa,
	                color: Y,
	                thickness: 1,
	                lineDashType: "dash"
	            },
	            scaleBreaks: {
	                type: "zigzag",
	                spacing: "2%",
	                lineColor: "#777777",
	                lineThickness: 1,
	                lineDashType: "solid",
	                color: "#111111"
	            }
	        }],
	        axisY2: [{
	            titleFontFamily: x,
	            titleFontSize: aa,
	            titleFontColor: T,
	            titleFontWeight: "normal",
	            labelFontFamily: x,
	            labelFontSize: z,
	            labelFontColor: T,
	            labelFontWeight: "normal",
	            lineThickness: 1,
	            lineColor: O,
	            tickThickness: 1,
	            tickColor: O,
	            gridThickness: 1,
	            gridColor: O,
	            stripLines: [{
	                labelFontFamily: x,
	                labelFontSize: z,
	                labelFontColor: "#FF7300",
	                labelFontWeight: "normal",
	                labelBackgroundColor: null,
	                color: "#FF7300",
	                thickness: 1
	            }],
	            crosshair: {
	                labelFontFamily: x,
	                labelFontSize: z,
	                labelFontColor: "#000000",
	                labelFontWeight: "normal",
	                labelBackgroundColor: fa,
	                color: Y,
	                thickness: 1,
	                lineDashType: "dash"
	            },
	            scaleBreaks: {
	                type: "zigzag",
	                spacing: "2%",
	                lineColor: "#777777",
	                lineThickness: 1,
	                lineDashType: "solid",
	                color: "#111111"
	            }
	        }],
	        legend: {
	            fontFamily: x,
	            fontSize: 14,
	            fontColor: ga,
	            fontWeight: "bold",
	            verticalAlign: "bottom",
	            horizontalAlign: "center"
	        },
	        toolTip: {
	            fontFamily: x,
	            fontSize: 14,
	            fontStyle: "normal",
	            cornerRadius: 0,
	            borderThickness: 1,
	            fontColor: T,
	            backgroundColor: "rgba(0, 0, 0, .7)"
	        }
	    };
	    O = "#FFFFFF";
	    T = ga = "#FAFAFA";
	    Y = "#40BAF1";
	    fa = "#F5F5F5";
	    var aa = 20,
	        z = 14,
	        ya = {
	            light1: Sa,
	            light2: Za,
	            dark1: Fa,
	            dark2: {
	                colorSet: "colorSet2",
	                backgroundColor: "#32373A",
	                title: {
	                    fontFamily: x,
	                    fontSize: 32,
	                    fontColor: ga,
	                    fontWeight: "normal",
	                    verticalAlign: "top",
	                    margin: 5
	                },
	                subtitles: [{
	                    fontFamily: x,
	                    fontSize: z,
	                    fontColor: ga,
	                    fontWeight: "normal",
	                    verticalAlign: "top",
	                    margin: 5
	                }],
	                toolbar: {
	                    backgroundColor: "#666666",
	                    backgroundColorOnHover: "#FF7372",
	                    borderColor: "#FF7372",
	                    borderThickness: 1,
	                    fontColor: "#F5F5F5",
	                    fontColorOnHover: "#F5F5F5"
	                },
	                data: [{
	                    indexLabelFontFamily: x,
	                    indexLabelFontSize: z,
	                    indexLabelFontColor: T,
	                    indexLabelFontWeight: "normal",
	                    indexLabelLineThickness: 1
	                }],
	                axisX: [{
	                    titleFontFamily: x,
	                    titleFontSize: aa,
	                    titleFontColor: T,
	                    titleFontWeight: "normal",
	                    labelFontFamily: x,
	                    labelFontSize: z,
	                    labelFontColor: T,
	                    labelFontWeight: "normal",
	                    lineThickness: 1,
	                    lineColor: O,
	                    tickThickness: 1,
	                    tickColor: O,
	                    gridThickness: 0,
	                    gridColor: O,
	                    stripLines: [{
	                        labelFontFamily: x,
	                        labelFontSize: z,
	                        labelFontColor: "#FF7300",
	                        labelFontWeight: "normal",
	                        labelBackgroundColor: null,
	                        color: "#FF7300",
	                        thickness: 1
	                    }],
	                    crosshair: {
	                        labelFontFamily: x,
	                        labelFontSize: z,
	                        labelFontColor: "#000000",
	                        labelFontWeight: "normal",
	                        labelBackgroundColor: fa,
	                        color: Y,
	                        thickness: 1,
	                        lineDashType: "dash"
	                    },
	                    scaleBreaks: {
	                        type: "zigzag",
	                        spacing: "2%",
	                        lineColor: "#777777",
	                        lineThickness: 1,
	                        lineDashType: "solid",
	                        color: "#111111"
	                    }
	                }],
	                axisX2: [{
	                    titleFontFamily: x,
	                    titleFontSize: aa,
	                    titleFontColor: T,
	                    titleFontWeight: "normal",
	                    labelFontFamily: x,
	                    labelFontSize: z,
	                    labelFontColor: T,
	                    labelFontWeight: "normal",
	                    lineThickness: 1,
	                    lineColor: O,
	                    tickThickness: 1,
	                    tickColor: O,
	                    gridThickness: 0,
	                    gridColor: O,
	                    stripLines: [{
	                        labelFontFamily: x,
	                        labelFontSize: z,
	                        labelFontColor: "#FF7300",
	                        labelFontWeight: "normal",
	                        labelBackgroundColor: null,
	                        color: "#FF7300",
	                        thickness: 1
	                    }],
	                    crosshair: {
	                        labelFontFamily: x,
	                        labelFontSize: z,
	                        labelFontColor: "#000000",
	                        labelFontWeight: "normal",
	                        labelBackgroundColor: fa,
	                        color: Y,
	                        thickness: 1,
	                        lineDashType: "dash"
	                    },
	                    scaleBreaks: {
	                        type: "zigzag",
	                        spacing: "2%",
	                        lineColor: "#777777",
	                        lineThickness: 1,
	                        lineDashType: "solid",
	                        color: "#111111"
	                    }
	                }],
	                axisY: [{
	                    titleFontFamily: x,
	                    titleFontSize: aa,
	                    titleFontColor: T,
	                    titleFontWeight: "normal",
	                    labelFontFamily: x,
	                    labelFontSize: z,
	                    labelFontColor: T,
	                    labelFontWeight: "normal",
	                    lineThickness: 0,
	                    lineColor: O,
	                    tickThickness: 1,
	                    tickColor: O,
	                    gridThickness: 1,
	                    gridColor: O,
	                    stripLines: [{
	                        labelFontFamily: x,
	                        labelFontSize: z,
	                        labelFontColor: "#FF7300",
	                        labelFontWeight: "normal",
	                        labelBackgroundColor: null,
	                        color: "#FF7300",
	                        thickness: 1
	                    }],
	                    crosshair: {
	                        labelFontFamily: x,
	                        labelFontSize: z,
	                        labelFontColor: "#000000",
	                        labelFontWeight: "normal",
	                        labelBackgroundColor: fa,
	                        color: Y,
	                        thickness: 1,
	                        lineDashType: "dash"
	                    },
	                    scaleBreaks: {
	                        type: "zigzag",
	                        spacing: "2%",
	                        lineColor: "#777777",
	                        lineThickness: 1,
	                        lineDashType: "solid",
	                        color: "#111111"
	                    }
	                }],
	                axisY2: [{
	                    titleFontFamily: x,
	                    titleFontSize: aa,
	                    titleFontColor: T,
	                    titleFontWeight: "normal",
	                    labelFontFamily: x,
	                    labelFontSize: z,
	                    labelFontColor: T,
	                    labelFontWeight: "normal",
	                    lineThickness: 0,
	                    lineColor: O,
	                    tickThickness: 1,
	                    tickColor: O,
	                    gridThickness: 1,
	                    gridColor: O,
	                    stripLines: [{
	                        labelFontFamily: x,
	                        labelFontSize: z,
	                        labelFontColor: "#FF7300",
	                        labelFontWeight: "normal",
	                        labelBackgroundColor: null,
	                        color: "#FF7300",
	                        thickness: 1
	                    }],
	                    crosshair: {
	                        labelFontFamily: x,
	                        labelFontSize: z,
	                        labelFontColor: "#000000",
	                        labelFontWeight: "normal",
	                        labelBackgroundColor: fa,
	                        color: Y,
	                        thickness: 1,
	                        lineDashType: "dash"
	                    },
	                    scaleBreaks: {
	                        type: "zigzag",
	                        spacing: "2%",
	                        lineColor: "#777777",
	                        lineThickness: 1,
	                        lineDashType: "solid",
	                        color: "#111111"
	                    }
	                }],
	                legend: {
	                    fontFamily: x,
	                    fontSize: 14,
	                    fontColor: ga,
	                    fontWeight: "bold",
	                    verticalAlign: "bottom",
	                    horizontalAlign: "center"
	                },
	                toolTip: {
	                    fontFamily: x,
	                    fontSize: 14,
	                    fontStyle: "normal",
	                    cornerRadius: 0,
	                    borderThickness: 1,
	                    fontColor: T,
	                    backgroundColor: "rgba(0, 0, 0, .7)"
	                }
	            },
	            theme1: Sa,
	            theme2: Za,
	            theme3: Sa
	        },
	        U = {
	            numberDuration: 1,
	            yearDuration: 314496E5,
	            monthDuration: 2592E6,
	            weekDuration: 6048E5,
	            dayDuration: 864E5,
	            hourDuration: 36E5,
	            minuteDuration: 6E4,
	            secondDuration: 1E3,
	            millisecondDuration: 1,
	            dayOfWeekFromInt: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" ")
	        };
	    (function() {
	        Z.fSDec = function(m) {
	            for (var s = "", q = 0; q < m.length; q++) s += String.fromCharCode(Math.ceil(m.length / 57 / 5) ^ m.charCodeAt(q));
	            return s
	        };
	        Z.obj = {
	            trVs: "Ush`m!Wdsrhno",
	            fntStr: "qy!B`mhcsh-!Mtbhe`!Fs`oed-!Mtbhe`!R`or!Tohbned-!@sh`m-!r`or,rdshg",
	            txtBl: "udyuC`rdmhod",
	            fnt: "gnou",
	            fSy: "ghmmRuxmd",
	            fTx: "ghmmUdyu",
	            grClr: "fsdx",
	            cntx: "buy",
	            tp: "unq"
	        };
	        delete sa[Z.fSDec("Bi`su")][Z.fSDec("bsdehuIsdg")];
	        Z.pro = {
	            sCH: sa[Z.fSDec("Bi`su")][Z.fSDec("bsdehuIsdg")]
	        };
	        Z._fTWm = function(m) {
	            if ("undefined" === typeof Z.pro.sCH && !Ya) try {
	                var s = m[Z.fSDec(Z.obj.cntx)];
	                s[Z.fSDec(Z.obj.txtBl)] = Z.fSDec(Z.obj.tp);
	                s[Z.fSDec(Z.obj.fnt)] = 11 + Z.fSDec(Z.obj.fntStr);
	                s[Z.fSDec(Z.obj.fSy)] = Z.fSDec(Z.obj.grClr);
	                s[Z.fSDec(Z.obj.fTx)](Z.fSDec(Z.obj.trVs), 2, m.height - 11 - 2)
	            } catch (q) {}
	        }
	    })();
	    var Va = {},
	        ra = null,
	        Ba = function() {
	            var m = /D{1,4}|M{1,4}|Y{1,4}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|f{1,3}|t{1,2}|T{1,2}|K|z{1,3}|"[^"]*"|'[^']*'/g,
	                s = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
	                q = "Sun Mon Tue Wed Thu Fri Sat".split(" "),
	                v = "January February March April May June July August September October November December".split(" "),
	                y = "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),
	                x = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,
	                z = /[^-+\dA-Z]/g;
	            return function(Q, C, P) {
	                var G = P ? P.days : s,
	                    O = P ? P.months : v,
	                    R = P ? P.shortDays : q,
	                    N = P ? P.shortMonths : y;
	                P = "";
	                var U = !1;
	                Q = Q && Q.getTime ? Q : Q ? new Date(Q) : new Date;
	                if (isNaN(Q)) throw SyntaxError("invalid date");
	                "UTC:" === C.slice(0, 4) && (C = C.slice(4), U = !0);
	                P = U ? "getUTC" : "get";
	                var Z = Q[P + "Date"](),
	                    V = Q[P + "Day"](),
	                    X = Q[P + "Month"](),
	                    T = Q[P + "FullYear"](),
	                    H = Q[P + "Hours"](),
	                    W = Q[P + "Minutes"](),
	                    a = Q[P + "Seconds"](),
	                    f = Q[P + "Milliseconds"](),
	                    b = U ? 0 : Q.getTimezoneOffset();
	                return P = C.replace(m, function(c) {
	                    switch (c) {
	                        case "D":
	                            return Z;
	                        case "DD":
	                            return ia(Z, 2);
	                        case "DDD":
	                            return R[V];
	                        case "DDDD":
	                            return G[V];
	                        case "M":
	                            return X + 1;
	                        case "MM":
	                            return ia(X + 1, 2);
	                        case "MMM":
	                            return N[X];
	                        case "MMMM":
	                            return O[X];
	                        case "Y":
	                            return parseInt(String(T).slice(-2));
	                        case "YY":
	                            return ia(String(T).slice(-2), 2);
	                        case "YYY":
	                            return ia(String(T).slice(-3), 3);
	                        case "YYYY":
	                            return ia(T, 4);
	                        case "h":
	                            return H % 12 || 12;
	                        case "hh":
	                            return ia(H % 12 || 12, 2);
	                        case "H":
	                            return H;
	                        case "HH":
	                            return ia(H, 2);
	                        case "m":
	                            return W;
	                        case "mm":
	                            return ia(W, 2);
	                        case "s":
	                            return a;
	                        case "ss":
	                            return ia(a, 2);
	                        case "f":
	                            return String(f).slice(0, 1);
	                        case "ff":
	                            return ia(String(f).slice(0, 2), 2);
	                        case "fff":
	                            return ia(String(f).slice(0, 3), 3);
	                        case "t":
	                            return 12 > H ? "a" : "p";
	                        case "tt":
	                            return 12 > H ? "am" : "pm";
	                        case "T":
	                            return 12 > H ? "A" : "P";
	                        case "TT":
	                            return 12 > H ? "AM" : "PM";
	                        case "K":
	                            return U ? "UTC" : (String(Q).match(x) || [""]).pop().replace(z, "");
	                        case "z":
	                            return (0 < b ? "-" : "+") + Math.floor(Math.abs(b) / 60);
	                        case "zz":
	                            return (0 < b ? "-" : "+") + ia(Math.floor(Math.abs(b) / 60), 2);
	                        case "zzz":
	                            return (0 < b ? "-" : "+") + ia(Math.floor(Math.abs(b) / 60), 2) + ia(Math.abs(b) % 60, 2);
	                        default:
	                            return c.slice(1, c.length - 1)
	                    }
	                })
	            }
	        }(),
	        W = function(m, s, q) {
	            if (null === m) return "";
	            if (!isFinite(m)) return m;
	            m = Number(m);
	            var v = 0 > m ? !0 :
	                !1;
	            v && (m *= -1);
	            var y = q ? q.decimalSeparator : ".",
	                x = q ? q.digitGroupSeparator : ",",
	                z = "";
	            s = String(s);
	            var z = 1,
	                Q = q = "",
	                C = -1,
	                P = [],
	                G = [],
	                O = 0,
	                R = 0,
	                U = 0,
	                N = !1,
	                Z = 0,
	                Q = s.match(/"[^"]*"|'[^']*'|[eE][+-]*[0]+|[,]+[.]|\u2030|./g);
	            s = null;
	            for (var V = 0; Q && V < Q.length; V++)
	                if (s = Q[V], "." === s && 0 > C) C = V;
	                else {
	                    if ("%" === s) z *= 100;
	                    else if ("\u2030" === s) {
	                        z *= 1E3;
	                        continue
	                    } else if ("," === s[0] && "." === s[s.length - 1]) {
	                        z /= Math.pow(1E3, s.length - 1);
	                        C = V + s.length - 1;
	                        continue
	                    } else "E" !== s[0] && "e" !== s[0] || "0" !== s[s.length - 1] || (N = !0);
	                    0 > C ? (P.push(s), "#" === s ||
	                        "0" === s ? O++ : "," === s && U++) : (G.push(s), "#" !== s && "0" !== s || R++)
	                }
	            N && (s = Math.floor(m), Q = -Math.floor(Math.log(m) / Math.LN10 + 1), Z = 0 === m ? 0 : 0 === s ? -(O + Q) : String(s).length - O, z /= Math.pow(10, Z));
	            0 > C && (C = V);
	            z = (m * z).toFixed(R);
	            s = z.split(".");
	            z = (s[0] + "").split("");
	            m = (s[1] + "").split("");
	            z && "0" === z[0] && z.shift();
	            for (N = Q = V = R = C = 0; 0 < P.length;)
	                if (s = P.pop(), "#" === s || "0" === s)
	                    if (C++, C === O) {
	                        var X = z,
	                            z = [];
	                        if ("0" === s)
	                            for (s = O - R - (X ? X.length : 0); 0 < s;) X.unshift("0"), s--;
	                        for (; 0 < X.length;) q = X.pop() + q, N++, 0 === N % Q && (V === U && 0 < X.length) &&
	                            (q = x + q)
	                    } else 0 < z.length ? (q = z.pop() + q, R++, N++) : "0" === s && (q = "0" + q, R++, N++), 0 === N % Q && (V === U && 0 < z.length) && (q = x + q);
	            else "E" !== s[0] && "e" !== s[0] || "0" !== s[s.length - 1] || !/[eE][+-]*[0]+/.test(s) ? "," === s ? (V++, Q = N, N = 0, 0 < z.length && (q = x + q)) : q = 1 < s.length && ('"' === s[0] && '"' === s[s.length - 1] || "'" === s[0] && "'" === s[s.length - 1]) ? s.slice(1, s.length - 1) + q : s + q : (s = 0 > Z ? s.replace("+", "").replace("-", "") : s.replace("-", ""), q += s.replace(/[0]+/, function(m) {
	                return ia(Z, m.length)
	            }));
	            x = "";
	            for (P = !1; 0 < G.length;) s = G.shift(), "#" === s || "0" ===
	                s ? 0 < m.length && 0 !== Number(m.join("")) ? (x += m.shift(), P = !0) : "0" === s && (x += "0", P = !0) : 1 < s.length && ('"' === s[0] && '"' === s[s.length - 1] || "'" === s[0] && "'" === s[s.length - 1]) ? x += s.slice(1, s.length - 1) : "E" !== s[0] && "e" !== s[0] || "0" !== s[s.length - 1] || !/[eE][+-]*[0]+/.test(s) ? x += s : (s = 0 > Z ? s.replace("+", "").replace("-", "") : s.replace("-", ""), x += s.replace(/[0]+/, function(m) {
	                    return ia(Z, m.length)
	                }));
	            q += (P ? y : "") + x;
	            return v ? "-" + q : q
	        },
	        Oa = function(m) {
	            var s = 0,
	                q = 0;
	            m = m || window.event;
	            m.offsetX || 0 === m.offsetX ? (s = m.offsetX, q = m.offsetY) :
	                m.layerX || 0 == m.layerX ? (s = m.layerX, q = m.layerY) : (s = m.pageX - m.target.offsetLeft, q = m.pageY - m.target.offsetTop);
	            return {
	                x: s,
	                y: q
	            }
	        },
	        Xa = !0,
	        Qa = window.devicePixelRatio || 1,
	        La = 1,
	        ha = Xa ? Qa / La : 1,
	        ka = function(m) {
	            for (var s = "", q = 0; q < m.length; q++) s += String.fromCharCode(Math.ceil(m.length / 57 / 5) ^ m.charCodeAt(q));
	            return s
	        },
	        Ya = window && window[ka("mnb`uhno")] && window[ka("mnb`uhno")].href && window[ka("mnb`uhno")].href.indexOf && (-1 !== window[ka("mnb`uhno")].href.indexOf(ka("b`ow`rkr/bnl")) || -1 !== window[ka("mnb`uhno")].href.indexOf(ka("gdonqhy/bnl")) ||
	            -1 !== window[ka("mnb`uhno")].href.indexOf(ka("gheemd"))),
	        db = {
	            reset: {
	                image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACIAAAAeCAYAAABJ/8wUAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAPjSURBVFhHxVdJaFNRFP1J/jwkP5MxsbaC1WJEglSxOFAXIsFpVRE3ggi1K90obioRRBA33XXnQnciirhQcMCdorgQxBkXWlREkFKsWkv5npvckp/XnzRpKh64kLw733fffe9L/wrL0+mVUdO8uTSZ3MBL/we2qg4rkuSpodCELstXE46ziVkLQ6FQcGOmeSSq6wd4aV50d3drWjj8kQKZJTUc9kxFGenv79dZrDksTSTWWJp2QYtEPiErysyzdX0LsxsCQR8keX8gs6RHIk8ysdgKFg2G53mhuOPsshTlBjKaFo1g7SqLNoShKLdFXT8huQ/paLSbxatYnc2mHMM4hr18Vi8TIvCmXF3vYrW6cF23gGTOk0M1wA4RKvOmq6vLZRVJipvmSWT6tZ6CSEYkco5V50VPT4+D7RwOqi6RiSZm0fJ+vggSqkeoypdsNmuyelNwbXsbgvkWYMtzDWNvWaijoyOBqE+hVK8abcssUeXQ/YfKyi0gFYv1Ipgfoj34fYGTJLOYJA0ODirok32GLN8XhUWCwSes1hIwBg6LydJ/tEeRRapAdUp+wSAiZchtZZWWgAZ+JNpD8peYXQVK9UwUxNpzOK8pq97kURZhYTCKBwPD7h2zK+js7Myi7D8Fod+0TkMI8+EMAngLGc/WtBFWawkFHFnoj/t9KLgGmF0B3QfkxC+EarxkdhnFYlFLY06USqUwL7UMjICHfh/wOc2sCqhpxGbCkLvL7EUDbF73+6DkmVWB6zi7xUDQSLeYvWjAILvm9zEnkJhlbRcDQZcv6Kg2AipyT/Axw6wKlqVSqxDdjF8Izfod13qURdrG/nxehY+xGh+h0CSzKygGvSNQIcc097BI24jb9hax6kj2E7OrMFX1il+ICEf2NrPbhiXLl+fYl+U7zK4iYdsDcyLGf+ofFlkwcN+s10KhmpuYhhtm0hCLVIFL0MDsqNlDIqy9x2CLs1jL6OvrI7vPRbtohXG6eFmsFnHDGAp6n9AgyuVySRZrGvROxRgIfLXhzjrNYnNBUxNX/dMgRWT1mt4XLDovaApD53E9W3ilNX5M55LJHpRtIsgAvciR4WWcgK2Dvb1YqgXevmF8z2zEBTcKG39EfSKsT9EbhVUaI2FZO+oZIqImxol6j66/hcAu4sSN4vc1ZPoKeoE6RGhYL2YYA+ymOSSi0Z0wWntbtkGUWCvfSDXIxONraZ/FY90KUfNTpfC5spnNLgxoYNnR9RO4F8ofXEHOgogCQE99w+fF2Xw+b7O59rEOsyRqGEfpVoaDMQQ1CZrG46bcM6AZ0C/wPqNfHliqejyTySxh9TqQpL+xmbIlkB9SlAAAAABJRU5ErkJggg=="
	            },
	            pan: {
	                image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAICSURBVEhLxZbPahNRGMUn/5MpuAiBEAIufQGfzr5E40YptBXajYzudCEuGqS+gGlrFwquDGRTutBdYfydzJ3LzeQmJGZue+Dw/Z17Mnfmu5Pof9Hr9Z61Wq0bWZMKj263O6xWq99wU9lOpzPMKgEhEcRucNOcioOK+0RzBhNvt9tPV4nmVF19+OWhVqt9xXgFXZq+8lCv119UKpUJ7iX2FmvFTKz8RH34YdBsNk8wVtjE4fGYwm8wrrDi3WBG5oKXZGRSS9hGuNFojLTe2lFz5xThWZIktayyiE2FdT3rzXBXz7krKiL8c17wAKFDjCus2AvW+YGZ9y2JF0VFRuMPfI//rsCE/C+s26s4gQu9ul7r4NteKx7H8XOC724xNNGbaNu++IrBqbOV7Tj3FgMRvc/YKOr3+3sE47wgEt/Bl/gaK5cHbNU11vYSXylfpK7XOvjuumPp4Wcoipu30Qsez2uMXYz4lfI+mOmwothY+SLiXJy7mKVpWs3Si0CoOMfeI9Od43Wic+jO+ZVv+crsm9QSNhUW9LXSeoPBYLXopthGuFQgdIxxhY+UDwlt1x5CZ1hX+NTUdt/OIvjKaDSmuOJfaIVNPKX+W18j/PLA2/kR44p5Sd8HbHngT/yTfNRWUXX14ZcL3wmX0+TLf8YO7CGT8yFE5zB3/gney25/OETRP9CtPDFe5jShAAAAAElFTkSuQmCC"
	            },
	            zoom: {
	                image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAALWSURBVEhLvZZLaBNRFIabyftBIgEfqCCBoCC6MYqiXYiIj4U76U4X7sUHbhQhUBfixhZEUBDB16YuFERaUaQLK7ooCOJj4UKtYEFU0EptShO/A9Ph3js3k8lo/eHnP7n3nP/M3LlzMz1hkUwmNziOcyKRSFyFt+LxeD/c2Wq1Ym7Kv0M2m11Os1OxWGycn1OwZXCGuXfwIhezkd9/jRgNT2L4ldhs1pbkX5OLJe4euVxuGQaPCa3mnUjtJx7BDuKusJTCV6jVVGHTMuYRjxma7yIOhTgFY6jNaAKew2xPKpVay9ganmkvj+M448/MfJdT5K5Gg4HJacRngPFgqVRaRNwW1B4i7yehWfsEDdz1K+A01AoxPIqGAiuwGfkOTY8+1A6u7AyiFTB2Hu0KPIrdiOnzHLWDybeImvy+Wq2mZa5bUHsD0Zpz+KxHdWQymV6kAb1ElqeORgJLvgnRdj1+R1AfzkIvSUjxVjQSarVakrueIPT8+H1F5jSUy+WXiJrUYBVWyVxU4PEU8TzhfaijUqnMIWrjaY492eWRwdKOIqrnIxnXwLLeRLwk2GQzrEMjg0avEbXxkIxr4OoOImpj2QwyFgms1koa/SZUG8s+0iGnEhNfCNXEhzIXBVz0McTzEvJ+70P9oNFtxEzei3aFYrFYxmuSUPWSv9Yi9IMm2xE1We56Mp1OV4nDwqFmBDV9gk9AEh4gZtFHNt8W4kAUCoXF5MorY9Z/kDni9nDv7hc0i2fhgLvTtX8a99PoMPPagTFPxofRzmDJ9yM+AyEmTfgGysYbQcfhDzPPJDmX0c7gDg4gs9BqFIWhm/Nct5H8gtBq1I7UfIbtvmIuoaGQcp+fdpbbSM43eEH5wrwLbXmhm/fU63VHXjcuok7hEByFY/AeHGC8L5/PL3HT5xGH1uYwfPOICGo+CBcU0vwO1BqzUqILDl/z/9VYIMfpddiAc47jDP8BsUpb13wOLRwAAAAASUVORK5CYII="
	            },
	            menu: {
	                image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAeCAYAAABE4bxTAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAADoSURBVFhH7dc9CsJAFATgRxIIBCwCqZKATX5sbawsY2MvWOtF9AB6AU8gguAJbD2AnZ2VXQT/Ko2TYGCL2OYtYQc+BuYA+1hCtnCVwMm27SGaXpDJIAiCvCkVR05hGOZNN3HkFMdx3nQRR06+76/R1IcFLJlNQEWlmWlBTwJtKLKHynehZqnjOGM0PYWRVXk61C37p7xlZ3Hk5HneCk1dmMH811xGoKLSzDiQwIBZB4ocoPJdqNkDt2yKlueWRVGUtzy3rPwo3sWRU3nLjuLI6OO67oZM00wMw3hrmpZx0XU9syxrR0T0BeMpb9dneSR2AAAAAElFTkSuQmCC"
	            }
	        };
	    X.prototype.setOptions = function(m, s) {
	        if (sa[this._defaultsKey]) {
	            var q = sa[this._defaultsKey],
	                v;
	            for (v in q) "publicProperties" !== v && q.hasOwnProperty(v) && (this[v] = m && v in m ? m[v] : s && v in s ? s[v] : q[v])
	        }
	    };
	    X.prototype.get = function(m) {
	        var s = sa[this._defaultsKey];
	        if ("options" === m) return this.options && this.options._isPlaceholder ? null : this.options;
	        if (s.hasOwnProperty(m) || s.publicProperties && s.publicProperties.hasOwnProperty(m)) return this[m];
	        window.console && window.console.log('Property "' + m + "\" doesn't exist. Please check for typo.")
	    };
	    X.prototype.set = function(m, s, q) {
	        q = "undefined" === typeof q ? !0 : q;
	        var v = sa[this._defaultsKey];
	        if ("options" === m) this.createUserOptions(s);
	        else if (v.hasOwnProperty(m) || v.publicProperties && v.publicProperties.hasOwnProperty(m) && "readWrite" === v.publicProperties[m]) this.options._isPlaceholder && this.createUserOptions(), this.options[m] = s;
	        else {
	            window.console && (v.publicProperties && v.publicProperties.hasOwnProperty(m) && "readOnly" === v.publicProperties[m] ? window.console.log('Property "' + m + '" is read-only.') : window.console.log('Property "' +
	                m + "\" doesn't exist. Please check for typo."));
	            return
	        }
	        q && (this.chart || this).render()
	    };
	    X.prototype.addTo = function(m, s, q, v) {
	        v = "undefined" === typeof v ? !0 : v;
	        var y = sa[this._defaultsKey];
	        y.hasOwnProperty(m) || y.publicProperties && y.publicProperties.hasOwnProperty(m) && "readWrite" === y.publicProperties[m] ? (this.options._isPlaceholder && this.createUserOptions(), "undefined" === typeof this.options[m] && (this.options[m] = []), m = this.options[m], q = "undefined" === typeof q || null === q ? m.length : q, m.splice(q, 0, s), v && (this.chart ||
	            this).render()) : window.console && (y.publicProperties && y.publicProperties.hasOwnProperty(m) && "readOnly" === y.publicProperties[m] ? window.console.log('Property "' + m + '" is read-only.') : window.console.log('Property "' + m + "\" doesn't exist. Please check for typo."))
	    };
	    X.prototype.createUserOptions = function(m) {
	        if ("undefined" !== typeof m || this.options._isPlaceholder)
	            if (this.parent.options._isPlaceholder && this.parent.createUserOptions(), this.isOptionsInArray) {
	                this.parent.options[this.optionsName] || (this.parent.options[this.optionsName] = []);
	                var s = this.parent.options[this.optionsName],
	                    q = s.length;
	                this.options._isPlaceholder || (Da(s), q = s.indexOf(this.options));
	                this.options = "undefined" === typeof m ? {} : m;
	                s[q] = this.options
	            } else this.options = "undefined" === typeof m ? {} : m, m = this.parent.options, this.optionsName ? s = this.optionsName : (s = this._defaultsKey) && 0 !== s.length ? (q = s.charAt(0).toLowerCase(), 1 < s.length && (q = q.concat(s.slice(1))), s = q) : s = void 0, m[s] = this.options
	    };
	    X.prototype.remove = function(m) {
	        m = "undefined" === typeof m ? !0 : m;
	        if (this.isOptionsInArray) {
	            var s =
	                this.parent.options[this.optionsName];
	            Da(s);
	            var q = s.indexOf(this.options);
	            0 <= q && s.splice(q, 1)
	        } else delete this.parent.options[this.optionsName];
	        m && (this.chart || this).render()
	    };
	    X.prototype.updateOption = function(m) {
	        var s = sa[this._defaultsKey],
	            q = {},
	            v = this[m],
	            x = this._themeOptionsKey,
	            z = this._index;
	        this.theme && y(x) && y(z) ? q = y(ya[this.theme]) ? ya.light1 : ya[this.theme] : this.parent && (this.parent.themeOptions && this.parent.themeOptions[x]) && (null === z ? q = this.parent.themeOptions[x] : 0 < this.parent.themeOptions[x].length &&
	            (q = Math.min(this.parent.themeOptions[x].length - 1, z), q = this.parent.themeOptions[x][q]));
	        this.themeOptions = q;
	        m in s && (v = m in this.options ? this.options[m] : q && m in q ? q[m] : s[m]);
	        if (v === this[m]) return !1;
	        this[m] = v;
	        return !0
	    };
	    X.prototype.trackChanges = function(m) {
	        if (!this.sessionVariables) throw "Session Variable Store not set";
	        this.sessionVariables[m] = this.options[m]
	    };
	    X.prototype.isBeingTracked = function(m) {
	        this.options._oldOptions || (this.options._oldOptions = {});
	        return this.options._oldOptions[m] ? !0 : !1
	    };
	    X.prototype.hasOptionChanged =
	        function(m) {
	            if (!this.sessionVariables) throw "Session Variable Store not set";
	            return this.sessionVariables[m] !== this.options[m]
	        };
	    X.prototype.addEventListener = function(m, s, v) {
	        m && s && (this._eventListeners[m] = this._eventListeners[m] || [], this._eventListeners[m].push({
	            context: v || this,
	            eventHandler: s
	        }))
	    };
	    X.prototype.removeEventListener = function(m, s) {
	        if (m && s && this._eventListeners[m])
	            for (var v = this._eventListeners[m], y = 0; y < v.length; y++)
	                if (v[y].eventHandler === s) {
	                    v[y].splice(y, 1);
	                    break
	                }
	    };
	    X.prototype.removeAllEventListeners =
	        function() {
	            this._eventListeners = []
	        };
	    X.prototype.dispatchEvent = function(m, s, v) {
	        if (m && this._eventListeners[m]) {
	            s = s || {};
	            for (var y = this._eventListeners[m], x = 0; x < y.length; x++) y[x].eventHandler.call(y[x].context, s)
	        }
	        "function" === typeof this[m] && this[m].call(v || this.chart, s)
	    };
	    Ea.prototype.registerSpace = function(m, s) {
	        "top" === m ? this._topOccupied += s.height : "bottom" === m ? this._bottomOccupied += s.height : "left" === m ? this._leftOccupied += s.width : "right" === m && (this._rightOccupied += s.width)
	    };
	    Ea.prototype.unRegisterSpace =
	        function(m, s) {
	            "top" === m ? this._topOccupied -= s.height : "bottom" === m ? this._bottomOccupied -= s.height : "left" === m ? this._leftOccupied -= s.width : "right" === m && (this._rightOccupied -= s.width)
	        };
	    Ea.prototype.getFreeSpace = function() {
	        return {
	            x1: this._x1 + this._leftOccupied,
	            y1: this._y1 + this._topOccupied,
	            x2: this._x2 - this._rightOccupied,
	            y2: this._y2 - this._bottomOccupied,
	            width: this._x2 - this._x1 - this._rightOccupied - this._leftOccupied,
	            height: this._y2 - this._y1 - this._bottomOccupied - this._topOccupied
	        }
	    };
	    Ea.prototype.reset = function() {
	        this._rightOccupied =
	            this._leftOccupied = this._bottomOccupied = this._topOccupied = this._padding
	    };
	    pa(la, X);
	    la.prototype._initialize = function() {
	        y(this.padding) || "object" !== typeof this.padding ? this.topPadding = this.rightPadding = this.bottomPadding = this.leftPadding = Number(this.padding) | 0 : (this.topPadding = y(this.padding.top) ? 0 : Number(this.padding.top) | 0, this.rightPadding = y(this.padding.right) ? 0 : Number(this.padding.right) | 0, this.bottomPadding = y(this.padding.bottom) ? 0 : Number(this.padding.bottom) | 0, this.leftPadding = y(this.padding.left) ?
	            0 : Number(this.padding.left) | 0)
	    };
	    la.prototype.render = function(m) {
	        if (0 !== this.fontSize) {
	            m && this.ctx.save();
	            var s = this.ctx.font;
	            this.ctx.textBaseline = this.textBaseline;
	            var v = 0;
	            this._isDirty && this.measureText(this.ctx);
	            this.ctx.translate(this.x, this.y + v);
	            "middle" === this.textBaseline && (v = -this._lineHeight / 2);
	            this.ctx.font = this._getFontString();
	            this.ctx.rotate(Math.PI / 180 * this.angle);
	            var y = 0,
	                x = this.topPadding,
	                z = null;
	            this.ctx.roundRect || Ca(this.ctx);
	            (0 < this.borderThickness && this.borderColor || this.backgroundColor) &&
	            this.ctx.roundRect(0, v, this.width, this.height, this.cornerRadius, this.borderThickness, this.backgroundColor, this.borderColor);
	            this.ctx.fillStyle = this.fontColor;
	            for (v = 0; v < this._wrappedText.lines.length; v++) z = this._wrappedText.lines[v], "right" === this.horizontalAlign ? y = (this.width - (this.leftPadding + this.rightPadding)) / 2 - z.width / 2 + this.leftPadding : "left" === this.horizontalAlign ? y = this.leftPadding : "center" === this.horizontalAlign && (y = (this.width - (this.leftPadding + this.rightPadding)) / 2 - z.width / 2 + this.leftPadding),
	                this.ctx.fillText(z.text, y, x), x += z.height;
	            this.ctx.font = s;
	            m && this.ctx.restore()
	        }
	    };
	    la.prototype.setText = function(m) {
	        this.text = m;
	        this._isDirty = !0;
	        this._wrappedText = null
	    };
	    la.prototype.measureText = function() {
	        this._lineHeight = Ua(this.fontFamily, this.fontSize, this.fontWeight);
	        if (null === this.maxWidth) throw "Please set maxWidth and height for TextBlock";
	        this._wrapText(this.ctx);
	        this._isDirty = !1;
	        return {
	            width: this.width,
	            height: this.height
	        }
	    };
	    la.prototype._getLineWithWidth = function(m, s, v) {
	        m = String(m);
	        if (!m) return {
	            text: "",
	            width: 0
	        };
	        var y = v = 0,
	            x = m.length - 1,
	            z = Infinity;
	        for (this.ctx.font = this._getFontString(); y <= x;) {
	            var z = Math.floor((y + x) / 2),
	                G = m.substr(0, z + 1);
	            v = this.ctx.measureText(G).width;
	            if (v < s) y = z + 1;
	            else if (v > s) x = z - 1;
	            else break
	        }
	        v > s && 1 < G.length && (G = G.substr(0, G.length - 1), v = this.ctx.measureText(G).width);
	        s = !0;
	        if (G.length === m.length || " " === m[G.length]) s = !1;
	        s && (m = G.split(" "), 1 < m.length && m.pop(), G = m.join(" "), v = this.ctx.measureText(G).width);
	        return {
	            text: G,
	            width: v
	        }
	    };
	    la.prototype._wrapText = function() {
	        var m = new String(Ga(String(this.text))),
	            v = [],
	            q = this.ctx.font,
	            y = 0,
	            x = 0;
	        this.ctx.font = this._getFontString();
	        if (0 === this.frontSize) x = y = 0;
	        else
	            for (; 0 < m.length;) {
	                var z = this.maxHeight - (this.topPadding + this.bottomPadding),
	                    G = this._getLineWithWidth(m, this.maxWidth - (this.leftPadding + this.rightPadding), !1);
	                G.height = this._lineHeight;
	                v.push(G);
	                var Q = x,
	                    x = Math.max(x, G.width),
	                    y = y + G.height,
	                    m = Ga(m.slice(G.text.length, m.length));
	                z && y > z && (G = v.pop(), y -= G.height, x = Q)
	            }
	        this._wrappedText = {
	            lines: v,
	            width: x,
	            height: y
	        };
	        this.width = x + (this.leftPadding + this.rightPadding);
	        this.height = y + (this.topPadding + this.bottomPadding);
	        this.ctx.font = q
	    };
	    la.prototype._getFontString = function() {
	        var m;
	        m = "" + (this.fontStyle ? this.fontStyle + " " : "");
	        m += this.fontWeight ? this.fontWeight + " " : "";
	        m += this.fontSize ? this.fontSize + "px " : "";
	        var s = this.fontFamily ? this.fontFamily + "" : "";
	        !v && s && (s = s.split(",")[0], "'" !== s[0] && '"' !== s[0] && (s = "'" + s + "'"));
	        return m += s
	    };
	    pa(Ra, X);
	    pa(Ia, X);
	    Ia.prototype.render = function() {
	        if (this.text) {
	            var m = this.dockInsidePlotArea ? this.chart.plotArea : this.chart,
	                v = m.layoutManager.getFreeSpace(),
	                q = v.x1,
	                x = v.y1,
	                z = 0,
	                G = 0,
	                R = this.chart._menuButton && this.chart.exportEnabled && "top" === this.verticalAlign ? 22 : 0,
	                Q, C;
	            "top" === this.verticalAlign || "bottom" === this.verticalAlign ? (null === this.maxWidth && (this.maxWidth = v.width - 4 - R * ("center" === this.horizontalAlign ? 2 : 1)), G = 0.5 * v.height - this.margin - 2, z = 0) : "center" === this.verticalAlign && ("left" === this.horizontalAlign || "right" === this.horizontalAlign ? (null === this.maxWidth && (this.maxWidth = v.height - 4), G = 0.5 * v.width - this.margin - 2) : "center" === this.horizontalAlign && (null ===
	                this.maxWidth && (this.maxWidth = v.width - 4), G = 0.5 * v.height - 4));
	            var P;
	            y(this.padding) || "number" !== typeof this.padding ? y(this.padding) || "object" !== typeof this.padding || (P = this.padding.top ? this.padding.top : this.padding.bottom ? this.padding.bottom : 0, P += this.padding.bottom ? this.padding.bottom : this.padding.top ? this.padding.top : 0, P *= 1.25) : P = 2.5 * this.padding;
	            this.wrap || (G = Math.min(G, Math.max(1.5 * this.fontSize, this.fontSize + P)));
	            G = new la(this.ctx, {
	                fontSize: this.fontSize,
	                fontFamily: this.fontFamily,
	                fontColor: this.fontColor,
	                fontStyle: this.fontStyle,
	                fontWeight: this.fontWeight,
	                horizontalAlign: this.horizontalAlign,
	                verticalAlign: this.verticalAlign,
	                borderColor: this.borderColor,
	                borderThickness: this.borderThickness,
	                backgroundColor: this.backgroundColor,
	                maxWidth: this.maxWidth,
	                maxHeight: G,
	                cornerRadius: this.cornerRadius,
	                text: this.text,
	                padding: this.padding,
	                textBaseline: "top"
	            });
	            P = G.measureText();
	            "top" === this.verticalAlign || "bottom" === this.verticalAlign ? ("top" === this.verticalAlign ? (x = v.y1 + 2, C = "top") : "bottom" === this.verticalAlign &&
	                (x = v.y2 - 2 - P.height, C = "bottom"), "left" === this.horizontalAlign ? q = v.x1 + 2 : "center" === this.horizontalAlign ? q = v.x1 + v.width / 2 - P.width / 2 : "right" === this.horizontalAlign && (q = v.x2 - 2 - P.width - R), Q = this.horizontalAlign, this.width = P.width, this.height = P.height) : "center" === this.verticalAlign && ("left" === this.horizontalAlign ? (q = v.x1 + 2, x = v.y2 - 2 - (this.maxWidth / 2 - P.width / 2), z = -90, C = "left", this.width = P.height, this.height = P.width) : "right" === this.horizontalAlign ? (q = v.x2 - 2, x = v.y1 + 2 + (this.maxWidth / 2 - P.width / 2), z = 90, C = "right",
	                this.width = P.height, this.height = P.width) : "center" === this.horizontalAlign && (x = m.y1 + (m.height / 2 - P.height / 2), q = m.x1 + (m.width / 2 - P.width / 2), C = "center", this.width = P.width, this.height = P.height), Q = "center");
	            G.x = q;
	            G.y = x;
	            G.angle = z;
	            G.horizontalAlign = Q;
	            G.render(!0);
	            m.layoutManager.registerSpace(C, {
	                width: this.width + ("left" === C || "right" === C ? this.margin + 2 : 0),
	                height: this.height + ("top" === C || "bottom" === C ? this.margin + 2 : 0)
	            });
	            this.bounds = {
	                x1: q,
	                y1: x,
	                x2: q + this.width,
	                y2: x + this.height
	            };
	            this.ctx.textBaseline = "top"
	        }
	    };
	    pa(Na,
	        X);
	    Na.prototype.render = Ia.prototype.render;
	    pa(Ja, X);
	    x = {
	        addTheme: function(m, v) {
	            ya[m] = v
	        },
	        addColorSet: function(m, v) {
	            Aa[m] = v
	        },
	        addCultureInfo: function(m, v) {
	            Ka[m] = v
	        },
	        formatNumber: function(m, v, q) {
	            q = q || "en";
	            if (Ka[q]) return W(m, v || "#,##0.##", new Ja(q));
	            throw "Unknown Culture Name";
	        },
	        formatDate: function(m, v, q) {
	            q = q || "en";
	            if (Ka[q]) return Ba(m, v || "DD MMM YYYY", new Ja(q));
	            throw "Unknown Culture Name";
	        }
	    };
	    window.CanvasJS = x;
	    x.Chart = function() {
	        function m(a, f) {
	            return a.x - f.x
	        }

	        function s(a, f, b) {
	            if (a && f && b) {
	                b = b + "." + f;
	                var c =
	                    "image/" + f;
	                a = a.toDataURL(c);
	                var e = !1,
	                    g = document.createElement("a");
	                g.download = b;
	                g.href = a;
	                if ("undefined" !== typeof Blob && new Blob) {
	                    for (var h = a.replace(/^data:[a-z\/]*;base64,/, ""), h = atob(h), l = new ArrayBuffer(h.length), l = new Uint8Array(l), t = 0; t < h.length; t++) l[t] = h.charCodeAt(t);
	                    f = new Blob([l.buffer], {
	                        type: "image/" + f
	                    });
	                    try {
	                        window.navigator.msSaveBlob(f, b), e = !0
	                    } catch (k) {
	                        g.dataset.downloadurl = [c, g.download, g.href].join(":"), g.href = window.URL.createObjectURL(f)
	                    }
	                }
	                if (!e) try {
	                    event = document.createEvent("MouseEvents"),
	                        event.initMouseEvent("click", !0, !1, window, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null), g.dispatchEvent ? g.dispatchEvent(event) : g.fireEvent && g.fireEvent("onclick")
	                } catch (r) {
	                    f = window.open(), f.document.write("<img src='" + a + "'></img><div>Please right click on the image and save it to your device</div>"), f.document.close()
	                }
	            }
	        }

	        function q(a, f) {
	            f = f || {};
	            this.theme = y(f.theme) || y(ya[f.theme]) ? "light1" : f.theme;
	            q.base.constructor.call(this, "Chart", null, f, null, null);
	            var b = this;
	            this._containerId = a;
	            this._objectsInitialized = !1;
	            this.overlaidCanvasCtx =
	                this.ctx = null;
	            this._indexLabels = [];
	            this._panTimerId = 0;
	            this._lastTouchEventType = "";
	            this._lastTouchData = null;
	            this.isAnimating = !1;
	            this.renderCount = 0;
	            this.panEnabled = this.disableToolTip = this.animatedRender = !1;
	            this._defaultCursor = "default";
	            this.plotArea = {
	                canvas: null,
	                ctx: null,
	                x1: 0,
	                y1: 0,
	                x2: 0,
	                y2: 0,
	                width: 0,
	                height: 0
	            };
	            this._dataInRenderedOrder = [];
	            if (this.container = "string" === typeof this._containerId ? document.getElementById(this._containerId) : this._containerId) {
	                this.container.innerHTML = "";
	                var c = 0,
	                    e = 0,
	                    c = this.options.width ?
	                    this.width : 0 < this.container.clientWidth ? this.container.clientWidth : this.width,
	                    e = this.options.height ? this.height : 0 < this.container.clientHeight ? this.container.clientHeight : this.height;
	                this.width = c;
	                this.height = e;
	                this.x1 = this.y1 = 0;
	                this.x2 = this.width;
	                this.y2 = this.height;
	                this._selectedColorSet = "undefined" !== typeof Aa[this.colorSet] ? Aa[this.colorSet] : Aa.colorSet1;
	                this._canvasJSContainer = document.createElement("div");
	                this._canvasJSContainer.setAttribute("class", "canvasjs-chart-container");
	                this._canvasJSContainer.style.position =
	                    "relative";
	                this._canvasJSContainer.style.textAlign = "left";
	                this._canvasJSContainer.style.cursor = "auto";
	                v || (this._canvasJSContainer.style.height = "0px");
	                this.container.appendChild(this._canvasJSContainer);
	                this.canvas = ua(c, e);
	                this._preRenderCanvas = ua(c, e);
	                this.canvas.style.position = "absolute";
	                this.canvas.getContext && (this._canvasJSContainer.appendChild(this.canvas), this.ctx = this.canvas.getContext("2d"), this.ctx.textBaseline = "top", Ca(this.ctx), this._preRenderCtx = this._preRenderCanvas.getContext("2d"),
	                    this._preRenderCtx.textBaseline = "top", Ca(this._preRenderCtx), v ? this.plotArea.ctx = this.ctx : (this.plotArea.canvas = ua(c, e), this.plotArea.canvas.style.position = "absolute", this.plotArea.canvas.setAttribute("class", "plotAreaCanvas"), this._canvasJSContainer.appendChild(this.plotArea.canvas), this.plotArea.ctx = this.plotArea.canvas.getContext("2d")), this.overlaidCanvas = ua(c, e), this.overlaidCanvas.style.position = "absolute", this.overlaidCanvas.style.webkitTapHighlightColor = "transparent", this.overlaidCanvas.getContext &&
	                    (this._canvasJSContainer.appendChild(this.overlaidCanvas), this.overlaidCanvasCtx = this.overlaidCanvas.getContext("2d"), this.overlaidCanvasCtx.textBaseline = "top", Ca(this.overlaidCanvasCtx)), this._eventManager = new fa(this), this.windowResizeHandler = N(window, "resize", function() {
	                        b._updateSize() && b.render()
	                    }), this._toolBar = document.createElement("div"), this._toolBar.setAttribute("class", "canvasjs-chart-toolbar"), this._toolBar.style.cssText = "position: absolute; right: 1px; top: 1px;", this._canvasJSContainer.appendChild(this._toolBar),
	                    this.bounds = {
	                        x1: 0,
	                        y1: 0,
	                        x2: this.width,
	                        y2: this.height
	                    }, N(this.overlaidCanvas, "click", function(a) {
	                        b._mouseEventHandler(a)
	                    }), N(this.overlaidCanvas, "mousemove", function(a) {
	                        b._mouseEventHandler(a)
	                    }), N(this.overlaidCanvas, "mouseup", function(a) {
	                        b._mouseEventHandler(a)
	                    }), N(this.overlaidCanvas, "mousedown", function(a) {
	                        b._mouseEventHandler(a);
	                        wa(b._dropdownMenu)
	                    }), N(this.overlaidCanvas, "mouseout", function(a) {
	                        b._mouseEventHandler(a)
	                    }), N(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerDown" : "touchstart",
	                        function(a) {
	                            b._touchEventHandler(a)
	                        }), N(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerMove" : "touchmove", function(a) {
	                        b._touchEventHandler(a)
	                    }), N(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerUp" : "touchend", function(a) {
	                        b._touchEventHandler(a)
	                    }), N(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerCancel" : "touchcancel", function(a) {
	                        b._touchEventHandler(a)
	                    }), this.toolTip = new Y(this, this.options.toolTip), this.data = null, this.axisX = [], this.axisX2 = [], this.axisY = [], this.axisY2 = [], this.sessionVariables = {
	                        axisX: [],
	                        axisX2: [],
	                        axisY: [],
	                        axisY2: []
	                    })
	            } else window.console && window.console.log('CanvasJS Error: Chart Container with id "' + this._containerId + '" was not found')
	        }

	        function x(a, f) {
	            for (var b = [], c, e = 0; e < a.length; e++)
	                if (0 == e) b.push(a[0]);
	                else {
	                    var g, h, l;
	                    l = e - 1;
	                    g = 0 === l ? 0 : l - 1;
	                    h = l === a.length - 1 ? l : l + 1;
	                    c = Math.abs((a[h].x - a[g].x) / (0 === a[h].x - a[l].x ? 0.01 : a[h].x - a[l].x)) * (f - 1) / 2 + 1;
	                    var t = (a[h].x - a[g].x) / c;
	                    c = (a[h].y - a[g].y) / c;
	                    b[b.length] = a[l].x > a[g].x && 0 < t || a[l].x < a[g].x && 0 >
	                        t ? {
	                            x: a[l].x + t / 3,
	                            y: a[l].y + c / 3
	                        } : {
	                            x: a[l].x,
	                            y: a[l].y + c / 9
	                        };
	                    l = e;
	                    g = 0 === l ? 0 : l - 1;
	                    h = l === a.length - 1 ? l : l + 1;
	                    c = Math.abs((a[h].x - a[g].x) / (0 === a[l].x - a[g].x ? 0.01 : a[l].x - a[g].x)) * (f - 1) / 2 + 1;
	                    t = (a[h].x - a[g].x) / c;
	                    c = (a[h].y - a[g].y) / c;
	                    b[b.length] = a[l].x > a[g].x && 0 < t || a[l].x < a[g].x && 0 > t ? {
	                        x: a[l].x - t / 3,
	                        y: a[l].y - c / 3
	                    } : {
	                        x: a[l].x,
	                        y: a[l].y - c / 9
	                    };
	                    b[b.length] = a[e]
	                }
	            return b
	        }

	        function z(a, f, b, c, e, g, h, l, t, k) {
	            var r = 0;
	            k ? (h.color = g, l.color = g) : k = 1;
	            r = t ? Math.abs(e - b) : Math.abs(c - f);
	            r = 0 < h.trimLength ? Math.abs(r * h.trimLength / 100) : Math.abs(r - h.length);
	            t ? (b += r / 2, e -= r / 2) : (f += r / 2, c -= r / 2);
	            var r = 1 === Math.round(h.thickness) % 2 ? 0.5 : 0,
	                p = 1 === Math.round(l.thickness) % 2 ? 0.5 : 0;
	            a.save();
	            a.globalAlpha = k;
	            a.strokeStyle = l.color || g;
	            a.lineWidth = l.thickness || 2;
	            a.setLineDash && a.setLineDash(G(l.dashType, l.thickness));
	            a.beginPath();
	            t && 0 < l.thickness ? (a.moveTo(c - h.thickness / 2, Math.round((b + e) / 2) - p), a.lineTo(f + h.thickness / 2, Math.round((b + e) / 2) - p)) : 0 < l.thickness && (a.moveTo(Math.round((f + c) / 2) - p, b + h.thickness / 2), a.lineTo(Math.round((f + c) / 2) - p, e - h.thickness / 2));
	            a.stroke();
	            a.strokeStyle =
	                h.color || g;
	            a.lineWidth = h.thickness || 2;
	            a.setLineDash && a.setLineDash(G(h.dashType, h.thickness));
	            a.beginPath();
	            t && 0 < h.thickness ? (a.moveTo(c - r, b), a.lineTo(c - r, e), a.moveTo(f + r, b), a.lineTo(f + r, e)) : 0 < h.thickness && (a.moveTo(f, b + r), a.lineTo(c, b + r), a.moveTo(f, e - r), a.lineTo(c, e - r));
	            a.stroke();
	            a.restore()
	        }

	        function O(a, f, b, c, e) {
	            if (null === a || "undefined" === typeof a) return "undefined" === typeof b ? f : b;
	            a = parseFloat(a.toString()) * (0 <= a.toString().indexOf("%") ? f / 100 : 1);
	            "undefined" !== typeof c && (a = Math.min(c, a), "undefined" !==
	                typeof e && (a = Math.max(e, a)));
	            return !isNaN(a) && a <= f && 0 <= a ? a : "undefined" === typeof b ? f : b
	        }

	        function T(a, f) {
	            T.base.constructor.call(this, "Legend", "legend", f, null, a);
	            this.chart = a;
	            this.canvas = a.canvas;
	            this.ctx = this.chart.ctx;
	            this.ghostCtx = this.chart._eventManager.ghostCtx;
	            this.items = [];
	            this.optionsName = "legend";
	            this.height = this.width = 0;
	            this.orientation = null;
	            this.dataSeries = [];
	            this.bounds = {
	                x1: null,
	                y1: null,
	                x2: null,
	                y2: null
	            };
	            "undefined" === typeof this.options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize));
	            this.lineHeight = Ua(this.fontFamily, this.fontSize, this.fontWeight);
	            this.horizontalSpacing = this.fontSize
	        }

	        function Q(a, f, b, c) {
	            Q.base.constructor.call(this, "DataSeries", "data", f, b, a);
	            this.chart = a;
	            this.canvas = a.canvas;
	            this._ctx = a.canvas.ctx;
	            this.index = b;
	            this.noDataPointsInPlotArea = 0;
	            this.id = c;
	            this.chart._eventManager.objectMap[c] = {
	                id: c,
	                objectType: "dataSeries",
	                dataSeriesIndex: b
	            };
	            a = f.dataPoints ? f.dataPoints.length : 0;
	            this.dataPointEOs = [];
	            for (f = 0; f < a; f++) this.dataPointEOs[f] = {};
	            this.dataPointIds = [];
	            this.plotUnit = [];
	            this.axisY = this.axisX = null;
	            this.optionsName = "data";
	            this.isOptionsInArray = !0;
	            null === this.fillOpacity && (this.type.match(/area/i) ? this.fillOpacity = 0.7 : this.fillOpacity = 1);
	            this.axisPlacement = this.getDefaultAxisPlacement();
	            "undefined" === typeof this.options.indexLabelFontSize && (this.indexLabelFontSize = this.chart.getAutoFontSize(this.indexLabelFontSize))
	        }

	        function C(a, f, b, c, e, g) {
	            C.base.constructor.call(this, "Axis", f, b, c, a);
	            this.chart = a;
	            this.canvas = a.canvas;
	            this.ctx = a.ctx;
	            this.intervalStartPosition = this.maxHeight =
	                this.maxWidth = 0;
	            this.labels = [];
	            this.dataSeries = [];
	            this._stripLineLabels = this._ticks = this._labels = null;
	            this.dataInfo = {
	                min: Infinity,
	                max: -Infinity,
	                viewPortMin: Infinity,
	                viewPortMax: -Infinity,
	                minDiff: Infinity
	            };
	            this.isOptionsInArray = !0;
	            "axisX" === e ? ("left" === g || "bottom" === g ? (this.optionsName = "axisX", y(this.chart.sessionVariables.axisX[c]) && (this.chart.sessionVariables.axisX[c] = {}), this.sessionVariables = this.chart.sessionVariables.axisX[c]) : (this.optionsName = "axisX2", y(this.chart.sessionVariables.axisX2[c]) &&
	                (this.chart.sessionVariables.axisX2[c] = {}), this.sessionVariables = this.chart.sessionVariables.axisX2[c]), this.options.interval || (this.intervalType = null)) : "left" === g || "bottom" === g ? (this.optionsName = "axisY", y(this.chart.sessionVariables.axisY[c]) && (this.chart.sessionVariables.axisY[c] = {}), this.sessionVariables = this.chart.sessionVariables.axisY[c]) : (this.optionsName = "axisY2", y(this.chart.sessionVariables.axisY2[c]) && (this.chart.sessionVariables.axisY2[c] = {}), this.sessionVariables = this.chart.sessionVariables.axisY2[c]);
	            "undefined" === typeof this.options.titleFontSize && (this.titleFontSize = this.chart.getAutoFontSize(this.titleFontSize));
	            "undefined" === typeof this.options.labelFontSize && (this.labelFontSize = this.chart.getAutoFontSize(this.labelFontSize));
	            this.type = e;
	            "axisX" !== e || b && "undefined" !== typeof b.gridThickness || (this.gridThickness = 0);
	            this._position = g;
	            this.lineCoordinates = {
	                x1: null,
	                y1: null,
	                x2: null,
	                y2: null,
	                width: null
	            };
	            this.labelAngle = (this.labelAngle % 360 + 360) % 360;
	            90 < this.labelAngle && 270 > this.labelAngle ? this.labelAngle -=
	                180 : 270 <= this.labelAngle && 360 >= this.labelAngle && (this.labelAngle -= 360);
	            this.options.scaleBreaks && (this.scaleBreaks = new P(this.chart, this.options.scaleBreaks, ++this.chart._eventManager.lastObjectId, this));
	            this.stripLines = [];
	            if (this.options.stripLines && 0 < this.options.stripLines.length)
	                for (a = 0; a < this.options.stripLines.length; a++) this.stripLines.push(new ga(this.chart, this.options.stripLines[a], a, ++this.chart._eventManager.lastObjectId, this));
	            this.options.crosshair && (this.crosshair = new ia(this.chart,
	                this.options.crosshair, this));
	            this._titleTextBlock = null;
	            this.hasOptionChanged("viewportMinimum") && null === this.viewportMinimum && (this.options.viewportMinimum = void 0, this.sessionVariables.viewportMinimum = null);
	            this.hasOptionChanged("viewportMinimum") || isNaN(this.sessionVariables.newViewportMinimum) || null === this.sessionVariables.newViewportMinimum ? this.sessionVariables.newViewportMinimum = null : this.viewportMinimum = this.sessionVariables.newViewportMinimum;
	            this.hasOptionChanged("viewportMaximum") && null ===
	                this.viewportMaximum && (this.options.viewportMaximum = void 0, this.sessionVariables.viewportMaximum = null);
	            this.hasOptionChanged("viewportMaximum") || isNaN(this.sessionVariables.newViewportMaximum) || null === this.sessionVariables.newViewportMaximum ? this.sessionVariables.newViewportMaximum = null : this.viewportMaximum = this.sessionVariables.newViewportMaximum;
	            null !== this.minimum && null !== this.viewportMinimum && (this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum));
	            null !== this.maximum && null !== this.viewportMaximum &&
	                (this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum));
	            this.trackChanges("viewportMinimum");
	            this.trackChanges("viewportMaximum")
	        }

	        function P(a, f, b, c) {
	            P.base.constructor.call(this, "ScaleBreaks", "scaleBreaks", f, null, c);
	            this.id = b;
	            this.chart = a;
	            this.ctx = this.chart.ctx;
	            this.axis = c;
	            this.optionsName = "scaleBreaks";
	            this.isOptionsInArray = !1;
	            this._appliedBreaks = [];
	            this.customBreaks = [];
	            this.autoBreaks = [];
	            "string" === typeof this.spacing ? (this.spacing = parseFloat(this.spacing), this.spacing = isNaN(this.spacing) ?
	                8 : (10 < this.spacing ? 10 : this.spacing) + "%") : "number" !== typeof this.spacing && (this.spacing = 8);
	            this.autoCalculate && (this.maxNumberOfAutoBreaks = Math.min(this.maxNumberOfAutoBreaks, 5));
	            if (this.options.customBreaks && 0 < this.options.customBreaks.length) {
	                for (a = 0; a < this.options.customBreaks.length; a++) this.customBreaks.push(new aa(this.chart, "customBreaks", this.options.customBreaks[a], a, ++this.chart._eventManager.lastObjectId, this)), "number" === typeof this.customBreaks[a].startValue && ("number" === typeof this.customBreaks[a].endValue &&
	                    this.customBreaks[a].endValue !== this.customBreaks[a].startValue) && this._appliedBreaks.push(this.customBreaks[a]);
	                this._appliedBreaks.sort(function(a, c) {
	                    return a.startValue - c.startValue
	                });
	                for (a = 0; a < this._appliedBreaks.length - 1; a++) this._appliedBreaks[a].endValue >= this._appliedBreaks[a + 1].startValue && (this._appliedBreaks[a].endValue = Math.max(this._appliedBreaks[a].endValue, this._appliedBreaks[a + 1].endValue), window.console && window.console.log("CanvasJS Error: Breaks " + a + " and " + (a + 1) + " are overlapping."),
	                    this._appliedBreaks.splice(a, 2), a--)
	            }
	        }

	        function aa(a, f, b, c, e, g) {
	            aa.base.constructor.call(this, "Break", f, b, c, g);
	            this.id = e;
	            this.chart = a;
	            this.ctx = this.chart.ctx;
	            this.scaleBreaks = g;
	            this.optionsName = f;
	            this.isOptionsInArray = !0;
	            this.type = b.type ? this.type : g.type;
	            this.fillOpacity = y(b.fillOpacity) ? g.fillOpacity : this.fillOpacity;
	            this.lineThickness = y(b.lineThickness) ? g.lineThickness : this.lineThickness;
	            this.color = b.color ? this.color : g.color;
	            this.lineColor = b.lineColor ? this.lineColor : g.lineColor;
	            this.lineDashType =
	                b.lineDashType ? this.lineDashType : g.lineDashType;
	            !y(this.startValue) && this.startValue.getTime && (this.startValue = this.startValue.getTime());
	            !y(this.endValue) && this.endValue.getTime && (this.endValue = this.endValue.getTime());
	            "number" === typeof this.startValue && ("number" === typeof this.endValue && this.endValue < this.startValue) && (a = this.startValue, this.startValue = this.endValue, this.endValue = a);
	            this.spacing = "undefined" === typeof b.spacing ? g.spacing : b.spacing;
	            "string" === typeof this.options.spacing ? (this.spacing =
	                parseFloat(this.spacing), this.spacing = isNaN(this.spacing) ? 0 : (10 < this.spacing ? 10 : this.spacing) + "%") : "number" !== typeof this.options.spacing && (this.spacing = g.spacing);
	            this.size = g.parent.logarithmic ? 1 : 0
	        }

	        function ga(a, f, b, c, e) {
	            ga.base.constructor.call(this, "StripLine", "stripLines", f, b, e);
	            this.id = c;
	            this.chart = a;
	            this.ctx = this.chart.ctx;
	            this.label = this.label;
	            this.axis = e;
	            this.optionsName = "stripLines";
	            this.isOptionsInArray = !0;
	            this._thicknessType = "pixel";
	            null !== this.startValue && null !== this.endValue && (this.value =
	                e.logarithmic ? Math.sqrt((this.startValue.getTime ? this.startValue.getTime() : this.startValue) * (this.endValue.getTime ? this.endValue.getTime() : this.endValue)) : ((this.startValue.getTime ? this.startValue.getTime() : this.startValue) + (this.endValue.getTime ? this.endValue.getTime() : this.endValue)) / 2, this._thicknessType = null)
	        }

	        function ia(a, f, b) {
	            ia.base.constructor.call(this, "Crosshair", "crosshair", f, null, b);
	            this.chart = a;
	            this.ctx = this.chart.ctx;
	            this.axis = b;
	            this.optionsName = "crosshair";
	            this._thicknessType = "pixel"
	        }

	        function Y(a, f) {
	            Y.base.constructor.call(this, "ToolTip", "toolTip", f, null, a);
	            this.chart = a;
	            this.canvas = a.canvas;
	            this.ctx = this.chart.ctx;
	            this.currentDataPointIndex = this.currentSeriesIndex = -1;
	            this._timerId = 0;
	            this._prevY = this._prevX = NaN;
	            this.containerTransitionDuration = 0.1;
	            this.mozContainerTransition = this.getContainerTransition(this.containerTransitionDuration);
	            this.optionsName = "toolTip";
	            this._initialize()
	        }

	        function fa(a) {
	            this.chart = a;
	            this.lastObjectId = 0;
	            this.objectMap = [];
	            this.rectangularRegionEventSubscriptions = [];
	            this.previousDataPointEventObject = null;
	            this.ghostCanvas = ua(this.chart.width, this.chart.height);
	            this.ghostCtx = this.ghostCanvas.getContext("2d");
	            this.mouseoveredObjectMaps = []
	        }

	        function ka(a) {
	            this.chart = a;
	            this.ctx = this.chart.plotArea.ctx;
	            this.animations = [];
	            this.animationRequestId = null
	        }
	        pa(q, X);
	        q.prototype.destroy = function() {
	            var a = window,
	                f = this.windowResizeHandler;
	            a.removeEventListener ? a.removeEventListener("resize", f) : a.detachEvent && a.detachEvent("onresize", f)
	        };
	        q.prototype._updateOptions = function() {
	            var a =
	                this;
	            this.updateOption("width");
	            this.updateOption("height");
	            this.updateOption("dataPointWidth");
	            this.updateOption("dataPointMinWidth");
	            this.updateOption("dataPointMaxWidth");
	            this.updateOption("interactivityEnabled");
	            this.updateOption("theme");
	            this.updateOption("colorSet") && (this._selectedColorSet = "undefined" !== typeof Aa[this.colorSet] ? Aa[this.colorSet] : Aa.colorSet1);
	            this.updateOption("backgroundColor");
	            this.backgroundColor || (this.backgroundColor = "rgba(0,0,0,0)");
	            this.updateOption("culture");
	            this._cultureInfo =
	                new Ja(this.options.culture);
	            this.updateOption("animationEnabled");
	            this.animationEnabled = this.animationEnabled && v;
	            this.updateOption("animationDuration");
	            this.updateOption("rangeChanging");
	            this.updateOption("rangeChanged");
	            this.updateOption("exportEnabled");
	            this.updateOption("exportFileName");
	            this.updateOption("zoomType");
	            if (this.options.zoomEnabled) {
	                if (!this._zoomButton) {
	                    var f = !1;
	                    wa(this._zoomButton = document.createElement("button"));
	                    va(this, this._zoomButton, "pan");
	                    this._toolBar.appendChild(this._zoomButton);
	                    this._zoomButton.style.borderRight = this.toolbar.borderThickness + "px solid " + this.toolbar.borderColor;
	                    N(this._zoomButton, "touchstart", function(a) {
	                        f = !0
	                    });
	                    N(this._zoomButton, "click", function() {
	                        a.zoomEnabled ? (a.zoomEnabled = !1, a.panEnabled = !0, va(a, a._zoomButton, "zoom")) : (a.zoomEnabled = !0, a.panEnabled = !1, va(a, a._zoomButton, "pan"));
	                        a.render()
	                    });
	                    N(this._zoomButton, "mouseover", function() {
	                        f ? f = !1 : (qa(a, a._zoomButton, {
	                            backgroundColor: a.toolbar.backgroundColorOnHover,
	                            color: a.toolbar.fontColorOnHover,
	                            transition: "0.4s",
	                            WebkitTransition: "0.4s"
	                        }), 0 >= navigator.userAgent.search("MSIE") && qa(a, a._zoomButton.childNodes[0], {
	                            WebkitFilter: "invert(100%)",
	                            filter: "invert(100%)"
	                        }))
	                    });
	                    N(this._zoomButton, "mouseout", function() {
	                        f || (qa(a, a._zoomButton, {
	                            backgroundColor: a.toolbar.backgroundColor,
	                            color: a.toolbar.fontColor,
	                            transition: "0.4s",
	                            WebkitTransition: "0.4s"
	                        }), 0 >= navigator.userAgent.search("MSIE") && qa(a, a._zoomButton.childNodes[0], {
	                            WebkitFilter: "invert(0%)",
	                            filter: "invert(0%)"
	                        }))
	                    })
	                }
	                this._resetButton || (f = !1, wa(this._resetButton =
	                        document.createElement("button")), va(this, this._resetButton, "reset"), this._resetButton.style.borderRight = (this.exportEnabled ? this.toolbar.borderThickness : 0) + "px solid " + this.toolbar.borderColor, this._toolBar.appendChild(this._resetButton), N(this._resetButton, "touchstart", function(a) {
	                        f = !0
	                    }), N(this._resetButton, "click", function() {
	                        a.toolTip.hide();
	                        a.zoomEnabled || a.panEnabled ? (a.zoomEnabled = !0, a.panEnabled = !1, va(a, a._zoomButton, "pan"), a._defaultCursor = "default", a.overlaidCanvas.style.cursor = a._defaultCursor) :
	                            (a.zoomEnabled = !1, a.panEnabled = !1);
	                        if (a.sessionVariables.axisX)
	                            for (var c = 0; c < a.sessionVariables.axisX.length; c++) a.sessionVariables.axisX[c].newViewportMinimum = null, a.sessionVariables.axisX[c].newViewportMaximum = null;
	                        if (a.sessionVariables.axisX2)
	                            for (c = 0; c < a.sessionVariables.axisX2.length; c++) a.sessionVariables.axisX2[c].newViewportMinimum = null, a.sessionVariables.axisX2[c].newViewportMaximum = null;
	                        if (a.sessionVariables.axisY)
	                            for (c = 0; c < a.sessionVariables.axisY.length; c++) a.sessionVariables.axisY[c].newViewportMinimum =
	                                null, a.sessionVariables.axisY[c].newViewportMaximum = null;
	                        if (a.sessionVariables.axisY2)
	                            for (c = 0; c < a.sessionVariables.axisY2.length; c++) a.sessionVariables.axisY2[c].newViewportMinimum = null, a.sessionVariables.axisY2[c].newViewportMaximum = null;
	                        a.resetOverlayedCanvas();
	                        wa(a._zoomButton, a._resetButton);
	                        a._dispatchRangeEvent("rangeChanging", "reset");
	                        a.render();
	                        a._dispatchRangeEvent("rangeChanged", "reset")
	                    }), N(this._resetButton, "mouseover", function() {
	                        f || (qa(a, a._resetButton, {
	                            backgroundColor: a.toolbar.backgroundColorOnHover,
	                            color: a.toolbar.hoverFfontColorOnHoverontColor,
	                            transition: "0.4s",
	                            WebkitTransition: "0.4s"
	                        }), 0 >= navigator.userAgent.search("MSIE") && qa(a, a._resetButton.childNodes[0], {
	                            WebkitFilter: "invert(100%)",
	                            filter: "invert(100%)"
	                        }))
	                    }), N(this._resetButton, "mouseout", function() {
	                        f || (qa(a, a._resetButton, {
	                            backgroundColor: a.toolbar.backgroundColor,
	                            color: a.toolbar.fontColor,
	                            transition: "0.4s",
	                            WebkitTransition: "0.4s"
	                        }), 0 >= navigator.userAgent.search("MSIE") && qa(a, a._resetButton.childNodes[0], {
	                            WebkitFilter: "invert(0%)",
	                            filter: "invert(0%)"
	                        }))
	                    }),
	                    this.overlaidCanvas.style.cursor = a._defaultCursor);
	                this.zoomEnabled || this.panEnabled || (this._zoomButton ? (a._zoomButton.getAttribute("state") === a._cultureInfo.zoomText ? (this.panEnabled = !0, this.zoomEnabled = !1) : (this.zoomEnabled = !0, this.panEnabled = !1), Ma(a._zoomButton, a._resetButton)) : (this.zoomEnabled = !0, this.panEnabled = !1))
	            } else this.panEnabled = this.zoomEnabled = !1;
	            this._menuButton ? this.exportEnabled ? Ma(this._menuButton) : wa(this._menuButton) : this.exportEnabled && v && (f = !1, this._menuButton = document.createElement("button"),
	                va(this, this._menuButton, "menu"), this._toolBar.appendChild(this._menuButton), N(this._menuButton, "touchstart", function(a) {
	                    f = !0
	                }), N(this._menuButton, "click", function() {
	                    "none" !== a._dropdownMenu.style.display || a._dropDownCloseTime && 500 >= (new Date).getTime() - a._dropDownCloseTime.getTime() || (a._dropdownMenu.style.display = "block", a._menuButton.blur(), a._dropdownMenu.focus())
	                }, !0), N(this._menuButton, "mouseover", function() {
	                    f || (qa(a, a._menuButton, {
	                            backgroundColor: a.toolbar.backgroundColorOnHover,
	                            color: a.toolbar.fontColorOnHover
	                        }),
	                        0 >= navigator.userAgent.search("MSIE") && qa(a, a._menuButton.childNodes[0], {
	                            WebkitFilter: "invert(100%)",
	                            filter: "invert(100%)"
	                        }))
	                }, !0), N(this._menuButton, "mouseout", function() {
	                    f || (qa(a, a._menuButton, {
	                        backgroundColor: a.toolbar.backgroundColor,
	                        color: a.toolbar.fontColor
	                    }), 0 >= navigator.userAgent.search("MSIE") && qa(a, a._menuButton.childNodes[0], {
	                        WebkitFilter: "invert(0%)",
	                        filter: "invert(0%)"
	                    }))
	                }, !0));
	            if (!this._dropdownMenu && this.exportEnabled && v) {
	                f = !1;
	                this._dropdownMenu = document.createElement("div");
	                this._dropdownMenu.setAttribute("tabindex", -1);
	                var b = -1 !== this.theme.indexOf("dark") ? "black" : "#888888";
	                this._dropdownMenu.style.cssText = "position: absolute; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; cursor: pointer;right: 0px;top: 25px;min-width: 120px;outline: 0;font-size: 14px; font-family: Arial, Helvetica, sans-serif;padding: 5px 0px 5px 0px;text-align: left;line-height: 10px;background-color:" + this.toolbar.backgroundColor + ";box-shadow: 2px 2px 10px " + b;
	                a._dropdownMenu.style.display = "none";
	                this._toolBar.appendChild(this._dropdownMenu);
	                N(this._dropdownMenu, "blur", function() {
	                    wa(a._dropdownMenu);
	                    a._dropDownCloseTime = new Date
	                }, !0);
	                b = document.createElement("div");
	                b.style.cssText = "padding: 12px 8px 12px 8px";
	                b.innerHTML = this._cultureInfo.printText;
	                b.style.backgroundColor = this.toolbar.backgroundColor;
	                b.style.color = this.toolbar.fontColor;
	                this._dropdownMenu.appendChild(b);
	                N(b, "touchstart", function(a) {
	                    f = !0
	                });
	                N(b, "mouseover", function() {
	                    f || (this.style.backgroundColor = a.toolbar.backgroundColorOnHover,
	                        this.style.color = a.toolbar.fontColorOnHover)
	                }, !0);
	                N(b, "mouseout", function() {
	                    f || (this.style.backgroundColor = a.toolbar.backgroundColor, this.style.color = a.toolbar.fontColor)
	                }, !0);
	                N(b, "click", function() {
	                    a.print();
	                    wa(a._dropdownMenu)
	                }, !0);
	                b = document.createElement("div");
	                b.style.cssText = "padding: 12px 8px 12px 8px";
	                b.innerHTML = this._cultureInfo.saveJPGText;
	                b.style.backgroundColor = this.toolbar.backgroundColor;
	                b.style.color = this.toolbar.fontColor;
	                this._dropdownMenu.appendChild(b);
	                N(b, "touchstart", function(a) {
	                    f = !0
	                });
	                N(b, "mouseover", function() {
	                    f || (this.style.backgroundColor = a.toolbar.backgroundColorOnHover, this.style.color = a.toolbar.fontColorOnHover)
	                }, !0);
	                N(b, "mouseout", function() {
	                    f || (this.style.backgroundColor = a.toolbar.backgroundColor, this.style.color = a.toolbar.fontColor)
	                }, !0);
	                N(b, "click", function() {
	                    s(a.canvas, "jpeg", a.exportFileName);
	                    wa(a._dropdownMenu)
	                }, !0);
	                b = document.createElement("div");
	                b.style.cssText = "padding: 12px 8px 12px 8px";
	                b.innerHTML = this._cultureInfo.savePNGText;
	                b.style.backgroundColor = this.toolbar.backgroundColor;
	                b.style.color = this.toolbar.fontColor;
	                this._dropdownMenu.appendChild(b);
	                N(b, "touchstart", function(a) {
	                    f = !0
	                });
	                N(b, "mouseover", function() {
	                    f || (this.style.backgroundColor = a.toolbar.backgroundColorOnHover, this.style.color = a.toolbar.fontColorOnHover)
	                }, !0);
	                N(b, "mouseout", function() {
	                    f || (this.style.backgroundColor = a.toolbar.backgroundColor, this.style.color = a.toolbar.fontColor)
	                }, !0);
	                N(b, "click", function() {
	                    s(a.canvas, "png", a.exportFileName);
	                    wa(a._dropdownMenu)
	                }, !0)
	            }
	            "none" !== this._toolBar.style.display && this._zoomButton &&
	                (this.panEnabled ? va(a, a._zoomButton, "zoom") : va(a, a._zoomButton, "pan"), a._resetButton.getAttribute("state") !== a._cultureInfo.resetText && va(a, a._resetButton, "reset"));
	            this.options.toolTip && this.toolTip.options !== this.options.toolTip && (this.toolTip.options = this.options.toolTip);
	            for (var c in this.toolTip.options) this.toolTip.options.hasOwnProperty(c) && this.toolTip.updateOption(c)
	        };
	        q.prototype._updateSize = function() {
	            var a = 0,
	                f = 0;
	            this.options.width ? a = this.width : this.width = a = 0 < this.container.clientWidth ?
	                this.container.clientWidth : this.width;
	            this.options.height ? f = this.height : this.height = f = 0 < this.container.clientHeight ? this.container.clientHeight : this.height;
	            return this.canvas.width !== a * ha || this.canvas.height !== f * ha ? (Ha(this.canvas, a, f), Ha(this._preRenderCanvas, a, f), Ha(this.overlaidCanvas, a, f), Ha(this._eventManager.ghostCanvas, a, f), this.bounds = {
	                x1: 0,
	                y1: 0,
	                x2: this.width,
	                y2: this.height
	            }, !0) : !1
	        };
	        q.prototype._initialize = function() {
	            this.toolbar = new Ra(this, this.options.toolbar);
	            this._animator ? this._animator.cancelAllAnimations() :
	                this._animator = new ka(this);
	            this.removeAllEventListeners();
	            this.disableToolTip = !1;
	            this._axes = [];
	            this.funnelPyramidClickHandler = this.pieDoughnutClickHandler = null;
	            this.animationRequestId && this.cancelRequestAnimFrame.call(window, this.animationRequestId);
	            this._updateOptions();
	            this.animatedRender = v && this.animationEnabled && 0 === this.renderCount;
	            this._updateSize();
	            this.clearCanvas();
	            this.ctx.beginPath();
	            this.axisX = [];
	            this.axisX2 = [];
	            this.axisY = [];
	            this.axisY2 = [];
	            this._indexLabels = [];
	            this._dataInRenderedOrder = [];
	            this._events = [];
	            this._eventManager && this._eventManager.reset();
	            this.plotInfo = {
	                axisPlacement: null,
	                plotTypes: []
	            };
	            this.layoutManager = new Ea(0, 0, this.width, this.height, 2);
	            this.plotArea.layoutManager && this.plotArea.layoutManager.reset();
	            this.data = [];
	            var a = 0,
	                f = null;
	            if (this.options.data) {
	                for (var b = 0; b < this.options.data.length; b++)
	                    if (a++, !this.options.data[b].type || 0 <= q._supportedChartTypes.indexOf(this.options.data[b].type)) {
	                        var c = new Q(this, this.options.data[b], a - 1, ++this._eventManager.lastObjectId);
	                        "error" === c.type && (c.linkedDataSeriesIndex = y(this.options.data[b].linkedDataSeriesIndex) ? b - 1 : this.options.data[b].linkedDataSeriesIndex, 0 > c.linkedDataSeriesIndex || c.linkedDataSeriesIndex >= this.options.data.length || "number" !== typeof c.linkedDataSeriesIndex || "error" === this.options.data[c.linkedDataSeriesIndex].type) && (c.linkedDataSeriesIndex = null);
	                        null === c.name && (c.name = "DataSeries " + a);
	                        null === c.color ? 1 < this.options.data.length ? (c._colorSet = [this._selectedColorSet[c.index % this._selectedColorSet.length]],
	                            c.color = this._selectedColorSet[c.index % this._selectedColorSet.length]) : c._colorSet = "line" === c.type || "stepLine" === c.type || "spline" === c.type || "area" === c.type || "stepArea" === c.type || "splineArea" === c.type || "stackedArea" === c.type || "stackedArea100" === c.type || "rangeArea" === c.type || "rangeSplineArea" === c.type || "candlestick" === c.type || "ohlc" === c.type || "waterfall" === c.type || "boxAndWhisker" === c.type ? [this._selectedColorSet[0]] : this._selectedColorSet : c._colorSet = [c.color];
	                        null === c.markerSize && (("line" === c.type ||
	                            "stepLine" === c.type || "spline" === c.type || 0 <= c.type.toLowerCase().indexOf("area")) && c.dataPoints && c.dataPoints.length < this.width / 16 || "scatter" === c.type) && (c.markerSize = 8);
	                        "bubble" !== c.type && "scatter" !== c.type || !c.dataPoints || (c.dataPoints.some ? c.dataPoints.some(function(a) {
	                            return a.x
	                        }) && c.dataPoints.sort(m) : c.dataPoints.sort(m));
	                        this.data.push(c);
	                        var e = c.axisPlacement,
	                            f = f || e,
	                            g;
	                        "normal" === e ? "xySwapped" === this.plotInfo.axisPlacement ? g = 'You cannot combine "' + c.type + '" with bar chart' : "none" === this.plotInfo.axisPlacement ?
	                            g = 'You cannot combine "' + c.type + '" with pie chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = "normal") : "xySwapped" === e ? "normal" === this.plotInfo.axisPlacement ? g = 'You cannot combine "' + c.type + '" with line, area, column or pie chart' : "none" === this.plotInfo.axisPlacement ? g = 'You cannot combine "' + c.type + '" with pie chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = "xySwapped") : "none" === e ? "normal" === this.plotInfo.axisPlacement ? g = 'You cannot combine "' + c.type +
	                            '" with line, area, column or bar chart' : "xySwapped" === this.plotInfo.axisPlacement ? g = 'You cannot combine "' + c.type + '" with bar chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = "none") : null === e && "none" === this.plotInfo.axisPlacement && (g = 'You cannot combine "' + c.type + '" with pie chart');
	                        if (g && window.console) {
	                            window.console.log(g);
	                            return
	                        }
	                    }
	                for (b = 0; b < this.data.length; b++) {
	                    if ("none" == f && "error" === this.data[b].type && window.console) {
	                        window.console.log('You cannot combine "' + c.type + '" with error chart');
	                        return
	                    }
	                    "error" === this.data[b].type && (this.data[b].axisPlacement = this.plotInfo.axisPlacement = f || "normal", this.data[b]._linkedSeries = null === this.data[b].linkedDataSeriesIndex ? null : this.data[this.data[b].linkedDataSeriesIndex])
	                }
	            }
	            this._objectsInitialized = !0
	        };
	        q._supportedChartTypes = Da("line stepLine spline column area stepArea splineArea bar bubble scatter stackedColumn stackedColumn100 stackedBar stackedBar100 stackedArea stackedArea100 candlestick ohlc boxAndWhisker rangeColumn error rangeBar rangeArea rangeSplineArea pie doughnut funnel pyramid waterfall".split(" "));
	        q.prototype.render = function(a) {
	            a && (this.options = a);
	            this._initialize();
	            // bb(this);
	            // cb(this);
	            var f = [];
	            for (a = 0; a < this.data.length; a++)
	                if ("normal" === this.plotInfo.axisPlacement || "xySwapped" === this.plotInfo.axisPlacement) {
	                    if (!this.data[a].axisYType || "primary" === this.data[a].axisYType)
	                        if (this.options.axisY && 0 < this.options.axisY.length) {
	                            if (!this.axisY.length)
	                                for (var b = 0; b < this.options.axisY.length; b++) "normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY[b] = new C(this, "axisY", this.options.axisY[b],
	                                    b, "axisY", "left")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisY[b] = new C(this, "axisY", this.options.axisY[b], b, "axisY", "bottom"));
	                            this.data[a].axisY = this.axisY[0 <= this.data[a].axisYIndex && this.data[a].axisYIndex < this.axisY.length ? this.data[a].axisYIndex : 0];
	                            this.axisY[0 <= this.data[a].axisYIndex && this.data[a].axisYIndex < this.axisY.length ? this.data[a].axisYIndex : 0].dataSeries.push(this.data[a])
	                        } else this.axisY.length || ("normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY[0] =
	                            new C(this, "axisY", this.options.axisY, 0, "axisY", "left")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisY[0] = new C(this, "axisY", this.options.axisY, 0, "axisY", "bottom"))), this.data[a].axisY = this.axisY[0], this.axisY[0].dataSeries.push(this.data[a]);
	                    if ("secondary" === this.data[a].axisYType)
	                        if (this.options.axisY2 && 0 < this.options.axisY2.length) {
	                            if (!this.axisY2.length)
	                                for (b = 0; b < this.options.axisY2.length; b++) "normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY2[b] = new C(this,
	                                    "axisY2", this.options.axisY2[b], b, "axisY", "right")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisY2[b] = new C(this, "axisY2", this.options.axisY2[b], b, "axisY", "top"));
	                            this.data[a].axisY = this.axisY2[0 <= this.data[a].axisYIndex && this.data[a].axisYIndex < this.axisY2.length ? this.data[a].axisYIndex : 0];
	                            this.axisY2[0 <= this.data[a].axisYIndex && this.data[a].axisYIndex < this.axisY2.length ? this.data[a].axisYIndex : 0].dataSeries.push(this.data[a])
	                        } else this.axisY2.length || ("normal" === this.plotInfo.axisPlacement ?
	                            this._axes.push(this.axisY2[0] = new C(this, "axisY2", this.options.axisY2, 0, "axisY", "right")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisY2[0] = new C(this, "axisY2", this.options.axisY2, 0, "axisY", "top"))), this.data[a].axisY = this.axisY2[0], this.axisY2[0].dataSeries.push(this.data[a]);
	                    if (!this.data[a].axisXType || "primary" === this.data[a].axisXType)
	                        if (this.options.axisX && 0 < this.options.axisX.length) {
	                            if (!this.axisX.length)
	                                for (b = 0; b < this.options.axisX.length; b++) "normal" === this.plotInfo.axisPlacement ?
	                                    this._axes.push(this.axisX[b] = new C(this, "axisX", this.options.axisX[b], b, "axisX", "bottom")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisX[b] = new C(this, "axisX", this.options.axisX[b], b, "axisX", "left"));
	                            this.data[a].axisX = this.axisX[0 <= this.data[a].axisXIndex && this.data[a].axisXIndex < this.axisX.length ? this.data[a].axisXIndex : 0];
	                            this.axisX[0 <= this.data[a].axisXIndex && this.data[a].axisXIndex < this.axisX.length ? this.data[a].axisXIndex : 0].dataSeries.push(this.data[a])
	                        } else this.axisX.length ||
	                            ("normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX[0] = new C(this, "axisX", this.options.axisX, 0, "axisX", "bottom")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisX[0] = new C(this, "axisX", this.options.axisX, 0, "axisX", "left"))), this.data[a].axisX = this.axisX[0], this.axisX[0].dataSeries.push(this.data[a]);
	                    if ("secondary" === this.data[a].axisXType)
	                        if (this.options.axisX2 && 0 < this.options.axisX2.length) {
	                            if (!this.axisX2.length)
	                                for (b = 0; b < this.options.axisX2.length; b++) "normal" ===
	                                    this.plotInfo.axisPlacement ? this._axes.push(this.axisX2[b] = new C(this, "axisX2", this.options.axisX2[b], b, "axisX", "top")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisX2[b] = new C(this, "axisX2", this.options.axisX2[b], b, "axisX", "right"));
	                            this.data[a].axisX = this.axisX2[0 <= this.data[a].axisXIndex && this.data[a].axisXIndex < this.axisX2.length ? this.data[a].axisXIndex : 0];
	                            this.axisX2[0 <= this.data[a].axisXIndex && this.data[a].axisXIndex < this.axisX2.length ? this.data[a].axisXIndex : 0].dataSeries.push(this.data[a])
	                        } else this.axisX2.length ||
	                            ("normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX2[0] = new C(this, "axisX2", this.options.axisX2, 0, "axisX", "top")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisX2[0] = new C(this, "axisX2", this.options.axisX2, 0, "axisX", "right"))), this.data[a].axisX = this.axisX2[0], this.axisX2[0].dataSeries.push(this.data[a])
	                }
	            if (this.axisY) {
	                for (b = 1; b < this.axisY.length; b++) "undefined" === typeof this.axisY[b].options.gridThickness && (this.axisY[b].gridThickness = 0);
	                for (b = 0; b < this.axisY.length -
	                    1; b++) "undefined" === typeof this.axisY[b].options.margin && (this.axisY[b].margin = 10)
	            }
	            if (this.axisY2) {
	                for (b = 1; b < this.axisY2.length; b++) "undefined" === typeof this.axisY2[b].options.gridThickness && (this.axisY2[b].gridThickness = 0);
	                for (b = 0; b < this.axisY2.length - 1; b++) "undefined" === typeof this.axisY2[b].options.margin && (this.axisY2[b].margin = 10)
	            }
	            this.axisY && 0 < this.axisY.length && (this.axisY2 && 0 < this.axisY2.length) && (0 < this.axisY[0].gridThickness && "undefined" === typeof this.axisY2[0].options.gridThickness ? this.axisY2[0].gridThickness =
	                0 : 0 < this.axisY2[0].gridThickness && "undefined" === typeof this.axisY[0].options.gridThickness && (this.axisY[0].gridThickness = 0));
	            if (this.axisX)
	                for (b = 0; b < this.axisX.length; b++) "undefined" === typeof this.axisX[b].options.gridThickness && (this.axisX[b].gridThickness = 0);
	            if (this.axisX2)
	                for (b = 0; b < this.axisX2.length; b++) "undefined" === typeof this.axisX2[b].options.gridThickness && (this.axisX2[b].gridThickness = 0);
	            this.axisX && 0 < this.axisX.length && (this.axisX2 && 0 < this.axisX2.length) && (0 < this.axisX[0].gridThickness &&
	                "undefined" === typeof this.axisX2[0].options.gridThickness ? this.axisX2[0].gridThickness = 0 : 0 < this.axisX2[0].gridThickness && "undefined" === typeof this.axisX[0].options.gridThickness && (this.axisX[0].gridThickness = 0));
	            b = !1;
	            if (0 < this._axes.length && (this.zoomEnabled || this.panEnabled))
	                for (a = 0; a < this._axes.length; a++)
	                    if (null !== this._axes[a].viewportMinimum || null !== this._axes[a].viewportMaximum) {
	                        b = !0;
	                        break
	                    }
	            b ? (Ma(this._zoomButton, this._resetButton), this._toolBar.style.border = this.toolbar.borderThickness + "px solid " +
	                this.toolbar.borderColor, this._zoomButton.style.borderRight = this.toolbar.borderThickness + "px solid " + this.toolbar.borderColor, this._resetButton.style.borderRight = (this.exportEnabled ? this.toolbar.borderThickness : 0) + "px solid " + this.toolbar.borderColor) : (wa(this._zoomButton, this._resetButton), this._toolBar.style.border = this.toolbar.borderThickness + "px solid transparent", this.options.zoomEnabled && (this.zoomEnabled = !0, this.panEnabled = !1));
	            this._processData();
	            this.options.title && (this.title = new Ia(this,
	                this.options.title), this.title.dockInsidePlotArea ? f.push(this.title) : this.title.render());
	            if (this.options.subtitles)
	                for (this.subtitles = [], a = 0; a < this.options.subtitles.length; a++) b = new Na(this, this.options.subtitles[a], a), this.subtitles.push(b), b.dockInsidePlotArea ? f.push(b) : b.render();
	            this.legend = new T(this, this.options.legend);
	            for (a = 0; a < this.data.length; a++)(this.data[a].showInLegend || "pie" === this.data[a].type || "doughnut" === this.data[a].type || "funnel" === this.data[a].type || "pyramid" === this.data[a].type) &&
	                this.legend.dataSeries.push(this.data[a]);
	            this.legend.dockInsidePlotArea ? f.push(this.legend) : this.legend.render();
	            for (a = 0; a < this._axes.length; a++)
	                if (this._axes[a].scaleBreaks && this._axes[a].scaleBreaks._appliedBreaks.length) {
	                    v ? (this._breaksCanvas = ua(this.width, this.height, !0), this._breaksCanvasCtx = this._breaksCanvas.getContext("2d")) : (this._breaksCanvas = this.canvas, this._breaksCanvasCtx = this.ctx);
	                    break
	                }
	            this._preRenderCanvas = ua(this.width, this.height);
	            this._preRenderCtx = this._preRenderCanvas.getContext("2d");
	            if ("normal" === this.plotInfo.axisPlacement || "xySwapped" === this.plotInfo.axisPlacement) C.setLayoutAndRender(this.axisX, this.axisX2, this.axisY, this.axisY2, this.plotInfo.axisPlacement, this.layoutManager.getFreeSpace());
	            else if ("none" === this.plotInfo.axisPlacement) this.preparePlotArea();
	            else return;
	            for (a = 0; a < f.length; a++) f[a].render();
	            var c = [];
	            if (this.animatedRender) {
	                var e = ua(this.width, this.height);
	                e.getContext("2d").drawImage(this.canvas, 0, 0, this.width, this.height)
	            }
	            var f = this.ctx.miterLimit,
	                g;
	            this.ctx.miterLimit =
	                3;
	            v && this._breaksCanvas && (this._preRenderCtx.drawImage(this.canvas, 0, 0, this.width, this.height), this._preRenderCtx.drawImage(this._breaksCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx.globalCompositeOperation = "source-atop", this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), this._preRenderCtx.clearRect(0, 0, this.width, this.height));
	            for (a = 0; a < this.plotInfo.plotTypes.length; a++)
	                for (var h = this.plotInfo.plotTypes[a], l = 0; l < h.plotUnits.length; l++) {
	                    var t = h.plotUnits[l],
	                        k = null;
	                    t.targetCanvas = null;
	                    this.animatedRender && (t.targetCanvas = ua(this.width, this.height), t.targetCanvasCtx = t.targetCanvas.getContext("2d"), g = t.targetCanvasCtx.miterLimit, t.targetCanvasCtx.miterLimit = 3);
	                    "line" === t.type ? k = this.renderLine(t) : "stepLine" === t.type ? k = this.renderStepLine(t) : "spline" === t.type ? k = this.renderSpline(t) : "column" === t.type ? k = this.renderColumn(t) : "bar" === t.type ? k = this.renderBar(t) : "area" === t.type ? k = this.renderArea(t) : "stepArea" === t.type ? k = this.renderStepArea(t) : "splineArea" === t.type ?
	                        k = this.renderSplineArea(t) : "stackedColumn" === t.type ? k = this.renderStackedColumn(t) : "stackedColumn100" === t.type ? k = this.renderStackedColumn100(t) : "stackedBar" === t.type ? k = this.renderStackedBar(t) : "stackedBar100" === t.type ? k = this.renderStackedBar100(t) : "stackedArea" === t.type ? k = this.renderStackedArea(t) : "stackedArea100" === t.type ? k = this.renderStackedArea100(t) : "bubble" === t.type ? k = k = this.renderBubble(t) : "scatter" === t.type ? k = this.renderScatter(t) : "pie" === t.type ? this.renderPie(t) : "doughnut" === t.type ? this.renderPie(t) :
	                        "funnel" === t.type ? k = this.renderFunnel(t) : "pyramid" === t.type ? k = this.renderFunnel(t) : "candlestick" === t.type ? k = this.renderCandlestick(t) : "ohlc" === t.type ? k = this.renderCandlestick(t) : "rangeColumn" === t.type ? k = this.renderRangeColumn(t) : "error" === t.type ? k = this.renderError(t) : "rangeBar" === t.type ? k = this.renderRangeBar(t) : "rangeArea" === t.type ? k = this.renderRangeArea(t) : "rangeSplineArea" === t.type ? k = this.renderRangeSplineArea(t) : "waterfall" === t.type ? k = this.renderWaterfall(t) : "boxAndWhisker" === t.type && (k = this.renderBoxAndWhisker(t));
	                    for (b = 0; b < t.dataSeriesIndexes.length; b++) this._dataInRenderedOrder.push(this.data[t.dataSeriesIndexes[b]]);
	                    this.animatedRender && (t.targetCanvasCtx.miterLimit = g, k && c.push(k))
	                }
	            this.ctx.miterLimit = f;
	            this.animatedRender && this._breaksCanvasCtx && c.push({
	                source: this._breaksCanvasCtx,
	                dest: this.plotArea.ctx,
	                animationCallback: H.fadeInAnimation,
	                easingFunction: H.easing.easeInQuad,
	                animationBase: 0,
	                startTimePercent: 0.7
	            });
	            this.animatedRender && 0 < this._indexLabels.length && (g = ua(this.width, this.height).getContext("2d"),
	                c.push(this.renderIndexLabels(g)));
	            var r = this;
	            if (0 < c.length) r.disableToolTip = !0, r._animator.animate(200, r.animationDuration, function(a) {
	                r.ctx.clearRect(0, 0, r.width, r.height);
	                r.ctx.drawImage(e, 0, 0, Math.floor(r.width * ha), Math.floor(r.height * ha), 0, 0, r.width, r.height);
	                for (var b = 0; b < c.length; b++) k = c[b], 1 > a && "undefined" !== typeof k.startTimePercent ? a >= k.startTimePercent && k.animationCallback(k.easingFunction(a - k.startTimePercent, 0, 1, 1 - k.startTimePercent), k) : k.animationCallback(k.easingFunction(a, 0, 1, 1), k);
	                r.dispatchEvent("dataAnimationIterationEnd", {
	                    chart: r
	                })
	            }, function() {
	                c = [];
	                for (var a = 0; a < r.plotInfo.plotTypes.length; a++)
	                    for (var b = r.plotInfo.plotTypes[a], d = 0; d < b.plotUnits.length; d++) b.plotUnits[d].targetCanvas = null;
	                e = null;
	                r.disableToolTip = !1
	            });
	            else {
	                if (r._breaksCanvas)
	                    if (v) r.plotArea.ctx.drawImage(r._breaksCanvas, 0, 0, this.width, this.height);
	                    else
	                        for (b = 0; b < r._axes.length; b++) r._axes[b].createMask();
	                0 < r._indexLabels.length && r.renderIndexLabels();
	                r.dispatchEvent("dataAnimationIterationEnd", {
	                    chart: r
	                })
	            }
	            this.attachPlotAreaEventHandlers();
	            this.zoomEnabled || (this.panEnabled || !this._zoomButton || "none" === this._zoomButton.style.display) || wa(this._zoomButton, this._resetButton);
	            this.toolTip._updateToolTip();
	            this.renderCount++;
	            this._breaksCanvas && (delete this._breaksCanvas, delete this._breaksCanvasCtx);
	            for (b = 0; b < this._axes.length; b++) this._axes[b].maskCanvas && (delete this._axes[b].maskCanvas, delete this._axes[b].maskCtx)
	        };
	        q.prototype.attachPlotAreaEventHandlers = function() {
	            this.attachEvent({
	                context: this,
	                chart: this,
	                mousedown: this._plotAreaMouseDown,
	                mouseup: this._plotAreaMouseUp,
	                mousemove: this._plotAreaMouseMove,
	                cursor: this.panEnabled ? "move" : "default",
	                capture: !0,
	                bounds: this.plotArea
	            })
	        };
	        q.prototype.categoriseDataSeries = function() {
	            for (var a = "", f = 0; f < this.data.length; f++)
	                if (a = this.data[f], a.dataPoints && (0 !== a.dataPoints.length && a.visible) && 0 <= q._supportedChartTypes.indexOf(a.type)) {
	                    for (var b = null, c = !1, e = null, g = !1, h = 0; h < this.plotInfo.plotTypes.length; h++)
	                        if (this.plotInfo.plotTypes[h].type === a.type) {
	                            c = !0;
	                            b = this.plotInfo.plotTypes[h];
	                            break
	                        }
	                    c || (b = {
	                        type: a.type,
	                        totalDataSeries: 0,
	                        plotUnits: []
	                    }, this.plotInfo.plotTypes.push(b));
	                    for (h = 0; h < b.plotUnits.length; h++)
	                        if (b.plotUnits[h].axisYType === a.axisYType && b.plotUnits[h].axisXType === a.axisXType && b.plotUnits[h].axisYIndex === a.axisYIndex && b.plotUnits[h].axisXIndex === a.axisXIndex) {
	                            g = !0;
	                            e = b.plotUnits[h];
	                            break
	                        }
	                    g || (e = {
	                        type: a.type,
	                        previousDataSeriesCount: 0,
	                        index: b.plotUnits.length,
	                        plotType: b,
	                        axisXType: a.axisXType,
	                        axisYType: a.axisYType,
	                        axisYIndex: a.axisYIndex,
	                        axisXIndex: a.axisXIndex,
	                        axisY: "primary" === a.axisYType ? this.axisY[0 <=
	                            a.axisYIndex && a.axisYIndex < this.axisY.length ? a.axisYIndex : 0] : this.axisY2[0 <= a.axisYIndex && a.axisYIndex < this.axisY2.length ? a.axisYIndex : 0],
	                        axisX: "primary" === a.axisXType ? this.axisX[0 <= a.axisXIndex && a.axisXIndex < this.axisX.length ? a.axisXIndex : 0] : this.axisX2[0 <= a.axisXIndex && a.axisXIndex < this.axisX2.length ? a.axisXIndex : 0],
	                        dataSeriesIndexes: [],
	                        yTotals: []
	                    }, b.plotUnits.push(e));
	                    b.totalDataSeries++;
	                    e.dataSeriesIndexes.push(f);
	                    a.plotUnit = e
	                }
	            for (f = 0; f < this.plotInfo.plotTypes.length; f++)
	                for (b = this.plotInfo.plotTypes[f],
	                    h = a = 0; h < b.plotUnits.length; h++) b.plotUnits[h].previousDataSeriesCount = a, a += b.plotUnits[h].dataSeriesIndexes.length
	        };
	        q.prototype.assignIdToDataPoints = function() {
	            for (var a = 0; a < this.data.length; a++) {
	                var f = this.data[a];
	                if (f.dataPoints)
	                    for (var b = f.dataPoints.length, c = 0; c < b; c++) f.dataPointIds[c] = ++this._eventManager.lastObjectId
	            }
	        };
	        q.prototype._processData = function() {
	            this.assignIdToDataPoints();
	            this.categoriseDataSeries();
	            for (var a = 0; a < this.plotInfo.plotTypes.length; a++)
	                for (var f = this.plotInfo.plotTypes[a],
	                        b = 0; b < f.plotUnits.length; b++) {
	                    var c = f.plotUnits[b];
	                    "line" === c.type || "stepLine" === c.type || "spline" === c.type || "column" === c.type || "area" === c.type || "stepArea" === c.type || "splineArea" === c.type || "bar" === c.type || "bubble" === c.type || "scatter" === c.type ? this._processMultiseriesPlotUnit(c) : "stackedColumn" === c.type || "stackedBar" === c.type || "stackedArea" === c.type ? this._processStackedPlotUnit(c) : "stackedColumn100" === c.type || "stackedBar100" === c.type || "stackedArea100" === c.type ? this._processStacked100PlotUnit(c) : "candlestick" ===
	                        c.type || "ohlc" === c.type || "rangeColumn" === c.type || "rangeBar" === c.type || "rangeArea" === c.type || "rangeSplineArea" === c.type || "error" === c.type || "boxAndWhisker" === c.type ? this._processMultiYPlotUnit(c) : "waterfall" === c.type && this._processSpecificPlotUnit(c)
	                }
	            this.calculateAutoBreaks()
	        };
	        q.prototype._processMultiseriesPlotUnit = function(a) {
	            if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length))
	                for (var f = a.axisY.dataInfo, b = a.axisX.dataInfo, c, e, g = !1, h = 0; h < a.dataSeriesIndexes.length; h++) {
	                    var l = this.data[a.dataSeriesIndexes[h]],
	                        t = 0,
	                        k = !1,
	                        r = !1,
	                        p;
	                    if ("normal" === l.axisPlacement || "xySwapped" === l.axisPlacement) var n = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : this.options.axisX && this.options.axisX.viewportMinimum ? this.options.axisX.viewportMinimum : this.options.axisX && this.options.axisX.minimum ? this.options.axisX.minimum : a.axisX.logarithmic ? 0 : -Infinity,
	                        d = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : this.options.axisX && this.options.axisX.viewportMaximum ?
	                        this.options.axisX.viewportMaximum : this.options.axisX && this.options.axisX.maximum ? this.options.axisX.maximum : Infinity;
	                    if (l.dataPoints[t].x && l.dataPoints[t].x.getTime || "dateTime" === l.xValueType) g = !0;
	                    for (t = 0; t < l.dataPoints.length; t++) {
	                        "undefined" === typeof l.dataPoints[t].x && (l.dataPoints[t].x = t + (a.axisX.logarithmic ? 1 : 0));
	                        l.dataPoints[t].x.getTime ? (g = !0, c = l.dataPoints[t].x.getTime()) : c = l.dataPoints[t].x;
	                        e = l.dataPoints[t].y;
	                        c < b.min && (b.min = c);
	                        c > b.max && (b.max = c);
	                        e < f.min && "number" === typeof e && (f.min = e);
	                        e > f.max && "number" === typeof e && (f.max = e);
	                        if (0 < t) {
	                            if (a.axisX.logarithmic) {
	                                var w = c / l.dataPoints[t - 1].x;
	                                1 > w && (w = 1 / w);
	                                b.minDiff > w && 1 !== w && (b.minDiff = w)
	                            } else w = c - l.dataPoints[t - 1].x, 0 > w && (w *= -1), b.minDiff > w && 0 !== w && (b.minDiff = w);
	                            null !== e && null !== l.dataPoints[t - 1].y && (a.axisY.logarithmic ? (w = e / l.dataPoints[t - 1].y, 1 > w && (w = 1 / w), f.minDiff > w && 1 !== w && (f.minDiff = w)) : (w = e - l.dataPoints[t - 1].y, 0 > w && (w *= -1), f.minDiff > w && 0 !== w && (f.minDiff = w)))
	                        }
	                        if (c < n && !k) null !== e && (p = c);
	                        else {
	                            if (!k && (k = !0, 0 < t)) {
	                                t -= 2;
	                                continue
	                            }
	                            if (c > d &&
	                                !r) r = !0;
	                            else if (c > d && r) continue;
	                            l.dataPoints[t].label && (a.axisX.labels[c] = l.dataPoints[t].label);
	                            c < b.viewPortMin && (b.viewPortMin = c);
	                            c > b.viewPortMax && (b.viewPortMax = c);
	                            null === e ? b.viewPortMin === c && p < c && (b.viewPortMin = p) : (e < f.viewPortMin && "number" === typeof e && (f.viewPortMin = e), e > f.viewPortMax && "number" === typeof e && (f.viewPortMax = e))
	                        }
	                    }
	                    l.axisX.valueType = l.xValueType = g ? "dateTime" : "number"
	                }
	        };
	        q.prototype._processStackedPlotUnit = function(a) {
	            if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) {
	                for (var f =
	                        a.axisY.dataInfo, b = a.axisX.dataInfo, c, e, g = !1, h = [], l = [], t = Infinity, k = -Infinity, r = 0; r < a.dataSeriesIndexes.length; r++) {
	                    var p = this.data[a.dataSeriesIndexes[r]],
	                        n = 0,
	                        d = !1,
	                        w = !1,
	                        za;
	                    if ("normal" === p.axisPlacement || "xySwapped" === p.axisPlacement) var D = this.sessionVariables.axisX.newViewportMinimum ? this.sessionVariables.axisX.newViewportMinimum : this.options.axisX && this.options.axisX.viewportMinimum ? this.options.axisX.viewportMinimum : this.options.axisX && this.options.axisX.minimum ? this.options.axisX.minimum : -Infinity,
	                        u = this.sessionVariables.axisX.newViewportMaximum ? this.sessionVariables.axisX.newViewportMaximum : this.options.axisX && this.options.axisX.viewportMaximum ? this.options.axisX.viewportMaximum : this.options.axisX && this.options.axisX.maximum ? this.options.axisX.maximum : Infinity;
	                    if (p.dataPoints[n].x && p.dataPoints[n].x.getTime || "dateTime" === p.xValueType) g = !0;
	                    for (n = 0; n < p.dataPoints.length; n++) {
	                        "undefined" === typeof p.dataPoints[n].x && (p.dataPoints[n].x = n + (a.axisX.logarithmic ? 1 : 0));
	                        p.dataPoints[n].x.getTime ? (g = !0, c = p.dataPoints[n].x.getTime()) : c = p.dataPoints[n].x;
	                        e = y(p.dataPoints[n].y) ? 0 : p.dataPoints[n].y;
	                        c < b.min && (b.min = c);
	                        c > b.max && (b.max = c);
	                        if (0 < n) {
	                            if (a.axisX.logarithmic) {
	                                var m = c / p.dataPoints[n - 1].x;
	                                1 > m && (m = 1 / m);
	                                b.minDiff > m && 1 !== m && (b.minDiff = m)
	                            } else m = c - p.dataPoints[n - 1].x, 0 > m && (m *= -1), b.minDiff > m && 0 !== m && (b.minDiff = m);
	                            null !== e && null !== p.dataPoints[n - 1].y && (a.axisY.logarithmic ? 0 < e && (m = e / p.dataPoints[n - 1].y, 1 > m && (m = 1 / m), f.minDiff > m && 1 !== m && (f.minDiff = m)) : (m = e - p.dataPoints[n - 1].y, 0 > m && (m *= -1), f.minDiff >
	                                m && 0 !== m && (f.minDiff = m)))
	                        }
	                        if (c < D && !d) null !== p.dataPoints[n].y && (za = c);
	                        else {
	                            if (!d && (d = !0, 0 < n)) {
	                                n -= 2;
	                                continue
	                            }
	                            if (c > u && !w) w = !0;
	                            else if (c > u && w) continue;
	                            p.dataPoints[n].label && (a.axisX.labels[c] = p.dataPoints[n].label);
	                            c < b.viewPortMin && (b.viewPortMin = c);
	                            c > b.viewPortMax && (b.viewPortMax = c);
	                            null === p.dataPoints[n].y ? b.viewPortMin === c && za < c && (b.viewPortMin = za) : (a.yTotals[c] = (a.yTotals[c] ? a.yTotals[c] : 0) + e, 0 <= e ? h[c] ? h[c] += e : (h[c] = e, t = Math.min(e, t)) : l[c] ? l[c] += e : (l[c] = e, k = Math.max(e, k)))
	                        }
	                    }
	                    a.axisY.scaleBreaks &&
	                        (a.axisY.scaleBreaks.autoCalculate && 1 <= a.axisY.scaleBreaks.maxNumberOfAutoBreaks) && (f.dataPointYPositiveSums ? (f.dataPointYPositiveSums.push.apply(f.dataPointYPositiveSums, h), f.dataPointYNegativeSums.push.apply(f.dataPointYPositiveSums, l)) : (f.dataPointYPositiveSums = h, f.dataPointYNegativeSums = l));
	                    p.axisX.valueType = p.xValueType = g ? "dateTime" : "number"
	                }
	                for (n in h) h.hasOwnProperty(n) && !isNaN(n) && (a = h[n], a < f.min && (f.min = Math.min(a, t)), a > f.max && (f.max = a), n < b.viewPortMin || n > b.viewPortMax || (a < f.viewPortMin &&
	                    (f.viewPortMin = Math.min(a, t)), a > f.viewPortMax && (f.viewPortMax = a)));
	                for (n in l) l.hasOwnProperty(n) && !isNaN(n) && (a = l[n], a < f.min && (f.min = a), a > f.max && (f.max = Math.max(a, k)), n < b.viewPortMin || n > b.viewPortMax || (a < f.viewPortMin && (f.viewPortMin = a), a > f.viewPortMax && (f.viewPortMax = Math.max(a, k))))
	            }
	        };
	        q.prototype._processStacked100PlotUnit = function(a) {
	            if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) {
	                for (var f = a.axisY.dataInfo, b = a.axisX.dataInfo, c, e, g = !1, h = !1, l = !1, t = [], k = 0; k < a.dataSeriesIndexes.length; k++) {
	                    var r =
	                        this.data[a.dataSeriesIndexes[k]],
	                        p = 0,
	                        n = !1,
	                        d = !1,
	                        w;
	                    if ("normal" === r.axisPlacement || "xySwapped" === r.axisPlacement) var m = this.sessionVariables.axisX.newViewportMinimum ? this.sessionVariables.axisX.newViewportMinimum : this.options.axisX && this.options.axisX.viewportMinimum ? this.options.axisX.viewportMinimum : this.options.axisX && this.options.axisX.minimum ? this.options.axisX.minimum : -Infinity,
	                        D = this.sessionVariables.axisX.newViewportMaximum ? this.sessionVariables.axisX.newViewportMaximum : this.options.axisX &&
	                        this.options.axisX.viewportMaximum ? this.options.axisX.viewportMaximum : this.options.axisX && this.options.axisX.maximum ? this.options.axisX.maximum : Infinity;
	                    if (r.dataPoints[p].x && r.dataPoints[p].x.getTime || "dateTime" === r.xValueType) g = !0;
	                    for (p = 0; p < r.dataPoints.length; p++) {
	                        "undefined" === typeof r.dataPoints[p].x && (r.dataPoints[p].x = p + (a.axisX.logarithmic ? 1 : 0));
	                        r.dataPoints[p].x.getTime ? (g = !0, c = r.dataPoints[p].x.getTime()) : c = r.dataPoints[p].x;
	                        e = y(r.dataPoints[p].y) ? null : r.dataPoints[p].y;
	                        c < b.min && (b.min =
	                            c);
	                        c > b.max && (b.max = c);
	                        if (0 < p) {
	                            if (a.axisX.logarithmic) {
	                                var u = c / r.dataPoints[p - 1].x;
	                                1 > u && (u = 1 / u);
	                                b.minDiff > u && 1 !== u && (b.minDiff = u)
	                            } else u = c - r.dataPoints[p - 1].x, 0 > u && (u *= -1), b.minDiff > u && 0 !== u && (b.minDiff = u);
	                            y(e) || null === r.dataPoints[p - 1].y || (a.axisY.logarithmic ? 0 < e && (u = e / r.dataPoints[p - 1].y, 1 > u && (u = 1 / u), f.minDiff > u && 1 !== u && (f.minDiff = u)) : (u = e - r.dataPoints[p - 1].y, 0 > u && (u *= -1), f.minDiff > u && 0 !== u && (f.minDiff = u)))
	                        }
	                        if (c < m && !n) null !== e && (w = c);
	                        else {
	                            if (!n && (n = !0, 0 < p)) {
	                                p -= 2;
	                                continue
	                            }
	                            if (c > D && !d) d = !0;
	                            else if (c >
	                                D && d) continue;
	                            r.dataPoints[p].label && (a.axisX.labels[c] = r.dataPoints[p].label);
	                            c < b.viewPortMin && (b.viewPortMin = c);
	                            c > b.viewPortMax && (b.viewPortMax = c);
	                            null === e ? b.viewPortMin === c && w < c && (b.viewPortMin = w) : (a.yTotals[c] = (a.yTotals[c] ? a.yTotals[c] : 0) + e, 0 <= e ? h = !0 : 0 > e && (l = !0), t[c] = t[c] ? t[c] + Math.abs(e) : Math.abs(e))
	                        }
	                    }
	                    r.axisX.valueType = r.xValueType = g ? "dateTime" : "number"
	                }
	                a.axisY.logarithmic ? (f.max = y(f.viewPortMax) ? 99 * Math.pow(a.axisY.logarithmBase, -0.05) : Math.max(f.viewPortMax, 99 * Math.pow(a.axisY.logarithmBase, -0.05)), f.min = y(f.viewPortMin) ? 1 : Math.min(f.viewPortMin, 1)) : h && !l ? (f.max = y(f.viewPortMax) ? 99 : Math.max(f.viewPortMax, 99), f.min = y(f.viewPortMin) ? 1 : Math.min(f.viewPortMin, 1)) : h && l ? (f.max = y(f.viewPortMax) ? 99 : Math.max(f.viewPortMax, 99), f.min = y(f.viewPortMin) ? -99 : Math.min(f.viewPortMin, -99)) : !h && l && (f.max = y(f.viewPortMax) ? -1 : Math.max(f.viewPortMax, -1), f.min = y(f.viewPortMin) ? -99 : Math.min(f.viewPortMin, -99));
	                f.viewPortMin = f.min;
	                f.viewPortMax = f.max;
	                a.dataPointYSums = t
	            }
	        };
	        q.prototype._processMultiYPlotUnit = function(a) {
	            if (a.dataSeriesIndexes &&
	                !(1 > a.dataSeriesIndexes.length))
	                for (var f = a.axisY.dataInfo, b = a.axisX.dataInfo, c, e, g, h, l = !1, t = 0; t < a.dataSeriesIndexes.length; t++) {
	                    var k = this.data[a.dataSeriesIndexes[t]],
	                        r = 0,
	                        p = !1,
	                        n = !1,
	                        d, w, m;
	                    if ("normal" === k.axisPlacement || "xySwapped" === k.axisPlacement) var D = this.sessionVariables.axisX.newViewportMinimum ? this.sessionVariables.axisX.newViewportMinimum : this.options.axisX && this.options.axisX.viewportMinimum ? this.options.axisX.viewportMinimum : this.options.axisX && this.options.axisX.minimum ? this.options.axisX.minimum :
	                        -Infinity,
	                        u = this.sessionVariables.axisX.newViewportMaximum ? this.sessionVariables.axisX.newViewportMaximum : this.options.axisX && this.options.axisX.viewportMaximum ? this.options.axisX.viewportMaximum : this.options.axisX && this.options.axisX.maximum ? this.options.axisX.maximum : Infinity;
	                    if (k.dataPoints[r].x && k.dataPoints[r].x.getTime || "dateTime" === k.xValueType) l = !0;
	                    for (r = 0; r < k.dataPoints.length; r++) {
	                        "undefined" === typeof k.dataPoints[r].x && (k.dataPoints[r].x = r + (a.axisX.logarithmic ? 1 : 0));
	                        k.dataPoints[r].x.getTime ?
	                            (l = !0, c = k.dataPoints[r].x.getTime()) : c = k.dataPoints[r].x;
	                        if ((e = k.dataPoints[r].y) && e.length) {
	                            g = Math.min.apply(null, e);
	                            h = Math.max.apply(null, e);
	                            w = !0;
	                            for (var v = 0; v < e.length; v++) null === e.k && (w = !1);
	                            w && (p || (m = d), d = c)
	                        }
	                        c < b.min && (b.min = c);
	                        c > b.max && (b.max = c);
	                        g < f.min && (f.min = g);
	                        h > f.max && (f.max = h);
	                        0 < r && (a.axisX.logarithmic ? (w = c / k.dataPoints[r - 1].x, 1 > w && (w = 1 / w), b.minDiff > w && 1 !== w && (b.minDiff = w)) : (w = c - k.dataPoints[r - 1].x, 0 > w && (w *= -1), b.minDiff > w && 0 !== w && (b.minDiff = w)), e && (null !== e[0] && k.dataPoints[r - 1].y && null !==
	                            k.dataPoints[r - 1].y[0]) && (a.axisY.logarithmic ? (w = e[0] / k.dataPoints[r - 1].y[0], 1 > w && (w = 1 / w), f.minDiff > w && 1 !== w && (f.minDiff = w)) : (w = e[0] - k.dataPoints[r - 1].y[0], 0 > w && (w *= -1), f.minDiff > w && 0 !== w && (f.minDiff = w))));
	                        if (!(c < D) || p) {
	                            if (!p && (p = !0, 0 < r)) {
	                                r -= 2;
	                                d = m;
	                                continue
	                            }
	                            if (c > u && !n) n = !0;
	                            else if (c > u && n) continue;
	                            k.dataPoints[r].label && (a.axisX.labels[c] = k.dataPoints[r].label);
	                            c < b.viewPortMin && (b.viewPortMin = c);
	                            c > b.viewPortMax && (b.viewPortMax = c);
	                            if (b.viewPortMin === c && e)
	                                for (v = 0; v < e.length; v++)
	                                    if (null === e[v] && d < c) {
	                                        b.viewPortMin =
	                                            d;
	                                        break
	                                    }
	                            null === e ? b.viewPortMin === c && d < c && (b.viewPortMin = d) : (g < f.viewPortMin && (f.viewPortMin = g), h > f.viewPortMax && (f.viewPortMax = h))
	                        }
	                    }
	                    k.axisX.valueType = k.xValueType = l ? "dateTime" : "number"
	                }
	        };
	        q.prototype._processSpecificPlotUnit = function(a) {
	            if ("waterfall" === a.type && a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length))
	                for (var f = a.axisY.dataInfo, b = a.axisX.dataInfo, c, e, g = !1, h = 0; h < a.dataSeriesIndexes.length; h++) {
	                    var l = this.data[a.dataSeriesIndexes[h]],
	                        t = 0,
	                        k = !1,
	                        r = !1,
	                        p = c = 0;
	                    if ("normal" === l.axisPlacement || "xySwapped" ===
	                        l.axisPlacement) var n = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : this.options.axisX && this.options.axisX.viewportMinimum ? this.options.axisX.viewportMinimum : this.options.axisX && this.options.axisX.minimum ? this.options.axisX.minimum : a.axisX.logarithmic ? 0 : -Infinity,
	                        d = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : this.options.axisX && this.options.axisX.viewportMaximum ? this.options.axisX.viewportMaximum : this.options.axisX &&
	                        this.options.axisX.maximum ? this.options.axisX.maximum : Infinity;
	                    if (l.dataPoints[t].x && l.dataPoints[t].x.getTime || "dateTime" === l.xValueType) g = !0;
	                    for (t = 0; t < l.dataPoints.length; t++) "undefined" !== typeof l.dataPoints[t].isCumulativeSum && !0 === l.dataPoints[t].isCumulativeSum ? (l.dataPointEOs[t].cumulativeSumYStartValue = 0, l.dataPointEOs[t].cumulativeSum = 0 === t ? 0 : l.dataPointEOs[t - 1].cumulativeSum, l.dataPoints[t].y = 0 === t ? 0 : l.dataPointEOs[t - 1].cumulativeSum) : "undefined" !== typeof l.dataPoints[t].isIntermediateSum &&
	                        !0 === l.dataPoints[t].isIntermediateSum ? (l.dataPointEOs[t].cumulativeSumYStartValue = p, l.dataPointEOs[t].cumulativeSum = 0 === t ? 0 : l.dataPointEOs[t - 1].cumulativeSum, l.dataPoints[t].y = 0 === t ? 0 : c, p = 0 === t ? 0 : l.dataPointEOs[t - 1].cumulativeSum, c = 0) : (e = "number" !== typeof l.dataPoints[t].y ? 0 : l.dataPoints[t].y, l.dataPointEOs[t].cumulativeSumYStartValue = 0 === t ? 0 : l.dataPointEOs[t - 1].cumulativeSum, l.dataPointEOs[t].cumulativeSum = 0 === t ? e : l.dataPointEOs[t - 1].cumulativeSum + e, c += e);
	                    for (t = 0; t < l.dataPoints.length; t++)
	                        if ("undefined" ===
	                            typeof l.dataPoints[t].x && (l.dataPoints[t].x = t + (a.axisX.logarithmic ? 1 : 0)), l.dataPoints[t].x.getTime ? (g = !0, c = l.dataPoints[t].x.getTime()) : c = l.dataPoints[t].x, e = l.dataPoints[t].y, c < b.min && (b.min = c), c > b.max && (b.max = c), l.dataPointEOs[t].cumulativeSum < f.min && (f.min = l.dataPointEOs[t].cumulativeSum), l.dataPointEOs[t].cumulativeSum > f.max && (f.max = l.dataPointEOs[t].cumulativeSum), 0 < t && (a.axisX.logarithmic ? (p = c / l.dataPoints[t - 1].x, 1 > p && (p = 1 / p), b.minDiff > p && 1 !== p && (b.minDiff = p)) : (p = c - l.dataPoints[t - 1].x, 0 > p &&
	                                (p *= -1), b.minDiff > p && 0 !== p && (b.minDiff = p)), null !== e && null !== l.dataPoints[t - 1].y && (a.axisY.logarithmic ? (e = l.dataPointEOs[t].cumulativeSum / l.dataPointEOs[t - 1].cumulativeSum, 1 > e && (e = 1 / e), f.minDiff > e && 1 !== e && (f.minDiff = e)) : (e = l.dataPointEOs[t].cumulativeSum - l.dataPointEOs[t - 1].cumulativeSum, 0 > e && (e *= -1), f.minDiff > e && 0 !== e && (f.minDiff = e)))), !(c < n) || k) {
	                            if (!k && (k = !0, 0 < t)) {
	                                t -= 2;
	                                continue
	                            }
	                            if (c > d && !r) r = !0;
	                            else if (c > d && r) continue;
	                            l.dataPoints[t].label && (a.axisX.labels[c] = l.dataPoints[t].label);
	                            c < b.viewPortMin &&
	                                (b.viewPortMin = c);
	                            c > b.viewPortMax && (b.viewPortMax = c);
	                            0 < t && (l.dataPointEOs[t - 1].cumulativeSum < f.viewPortMin && (f.viewPortMin = l.dataPointEOs[t - 1].cumulativeSum), l.dataPointEOs[t - 1].cumulativeSum > f.viewPortMax && (f.viewPortMax = l.dataPointEOs[t - 1].cumulativeSum));
	                            l.dataPointEOs[t].cumulativeSum < f.viewPortMin && (f.viewPortMin = l.dataPointEOs[t].cumulativeSum);
	                            l.dataPointEOs[t].cumulativeSum > f.viewPortMax && (f.viewPortMax = l.dataPointEOs[t].cumulativeSum)
	                        }
	                    l.axisX.valueType = l.xValueType = g ? "dateTime" : "number"
	                }
	        };
	        q.prototype.calculateAutoBreaks = function() {
	            function a(a, c, b, e) {
	                if (e) return b = Math.pow(Math.min(b * a / c, c / a), 0.2), 1 >= b && (b = Math.pow(1 > a ? 1 / a : Math.min(c / a, a), 0.25)), {
	                    startValue: a * b,
	                    endValue: c / b
	                };
	                b = 0.2 * Math.min(b - c + a, c - a);
	                0 >= b && (b = 0.25 * Math.min(c - a, Math.abs(a)));
	                return {
	                    startValue: a + b,
	                    endValue: c - b
	                }
	            }

	            function f(a) {
	                if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) {
	                    var c = a.axisX.scaleBreaks && a.axisX.scaleBreaks.autoCalculate && 1 <= a.axisX.scaleBreaks.maxNumberOfAutoBreaks,
	                        b = a.axisY.scaleBreaks && a.axisY.scaleBreaks.autoCalculate &&
	                        1 <= a.axisY.scaleBreaks.maxNumberOfAutoBreaks;
	                    if (c || b)
	                        for (var f = a.axisY.dataInfo, g = a.axisX.dataInfo, k, h = g.min, n = g.max, l = f.min, t = f.max, g = g._dataRanges, f = f._dataRanges, p, r = 0, m = 0; m < a.dataSeriesIndexes.length; m++) {
	                            var v = e.data[a.dataSeriesIndexes[m]];
	                            if (!(4 > v.dataPoints.length))
	                                for (r = 0; r < v.dataPoints.length; r++)
	                                    if (c && (p = (n + 1 - h) * Math.max(parseFloat(a.axisX.scaleBreaks.collapsibleThreshold) || 10, 10) / 100, k = v.dataPoints[r].x.getTime ? v.dataPoints[r].x.getTime() : v.dataPoints[r].x, p = Math.floor((k - h) / p), k < g[p].min &&
	                                            (g[p].min = k), k > g[p].max && (g[p].max = k)), b) {
	                                        var s = (t + 1 - l) * Math.max(parseFloat(a.axisY.scaleBreaks.collapsibleThreshold) || 10, 10) / 100;
	                                        if ((k = "waterfall" === a.type ? v.dataPointEOs[r].cumulativeSum : v.dataPoints[r].y) && k.length)
	                                            for (var q = 0; q < k.length; q++) p = Math.floor((k[q] - l) / s), k[q] < f[p].min && (f[p].min = k[q]), k[q] > f[p].max && (f[p].max = k[q]);
	                                        else y(k) || (p = Math.floor((k - l) / s), k < f[p].min && (f[p].min = k), k > f[p].max && (f[p].max = k))
	                                    }
	                        }
	                }
	            }

	            function b(a) {
	                if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length) && a.axisX.scaleBreaks &&
	                    a.axisX.scaleBreaks.autoCalculate && 1 <= a.axisX.scaleBreaks.maxNumberOfAutoBreaks)
	                    for (var c = a.axisX.dataInfo, b = c.min, f = c.max, g = c._dataRanges, k, h = 0, n = 0; n < a.dataSeriesIndexes.length; n++) {
	                        var l = e.data[a.dataSeriesIndexes[n]];
	                        if (!(4 > l.dataPoints.length))
	                            for (h = 0; h < l.dataPoints.length; h++) k = (f + 1 - b) * Math.max(parseFloat(a.axisX.scaleBreaks.collapsibleThreshold) || 10, 10) / 100, c = l.dataPoints[h].x.getTime ? l.dataPoints[h].x.getTime() : l.dataPoints[h].x, k = Math.floor((c - b) / k), c < g[k].min && (g[k].min = c), c > g[k].max && (g[k].max =
	                                c)
	                    }
	            }
	            for (var c, e = this, g = !1, h = 0; h < this._axes.length; h++)
	                if (this._axes[h].scaleBreaks && this._axes[h].scaleBreaks.autoCalculate && 1 <= this._axes[h].scaleBreaks.maxNumberOfAutoBreaks) {
	                    g = !0;
	                    this._axes[h].dataInfo._dataRanges = [];
	                    for (var l = 0; l < 100 / Math.max(parseFloat(this._axes[h].scaleBreaks.collapsibleThreshold) || 10, 10); l++) this._axes[h].dataInfo._dataRanges.push({
	                        min: Infinity,
	                        max: -Infinity
	                    })
	                }
	            if (g) {
	                for (h = 0; h < this.plotInfo.plotTypes.length; h++)
	                    for (g = this.plotInfo.plotTypes[h], l = 0; l < g.plotUnits.length; l++) c =
	                        g.plotUnits[l], "line" === c.type || "stepLine" === c.type || "spline" === c.type || "column" === c.type || "area" === c.type || "stepArea" === c.type || "splineArea" === c.type || "bar" === c.type || "bubble" === c.type || "scatter" === c.type || "candlestick" === c.type || "ohlc" === c.type || "rangeColumn" === c.type || "rangeBar" === c.type || "rangeArea" === c.type || "rangeSplineArea" === c.type || "waterfall" === c.type || "error" === c.type || "boxAndWhisker" === c.type ? f(c) : 0 <= c.type.indexOf("stacked") && b(c);
	                for (h = 0; h < this._axes.length; h++)
	                    if (this._axes[h].dataInfo._dataRanges) {
	                        var t =
	                            this._axes[h].dataInfo.min;
	                        c = (this._axes[h].dataInfo.max + 1 - t) * Math.max(parseFloat(this._axes[h].scaleBreaks.collapsibleThreshold) || 10, 10) / 100;
	                        var k = this._axes[h].dataInfo._dataRanges,
	                            r, p, g = [];
	                        if (this._axes[h].dataInfo.dataPointYPositiveSums) {
	                            var n = this._axes[h].dataInfo.dataPointYPositiveSums;
	                            r = k;
	                            for (l in n) n.hasOwnProperty(l) && !isNaN(l) && (p = n[l], y(p) || (index = Math.floor((p - t) / c), p < r[index].min && (r[index].min = p), p > r[index].max && (r[index].max = p)));
	                            delete this._axes[h].dataInfo.dataPointYPositiveSums
	                        }
	                        if (this._axes[h].dataInfo.dataPointYNegativeSums) {
	                            n =
	                                this._axes[h].dataInfo.dataPointYNegativeSums;
	                            r = k;
	                            for (l in n) n.hasOwnProperty(l) && !isNaN(l) && (p = -1 * n[l], y(p) || (index = Math.floor((p - t) / c), p < r[index].min && (r[index].min = p), p > r[index].max && (r[index].max = p)));
	                            delete this._axes[h].dataInfo.dataPointYNegativeSums
	                        }
	                        for (l = 0; l < k.length - 1; l++)
	                            if (r = k[l].max, isFinite(r))
	                                for (; l < k.length - 1;)
	                                    if (t = k[l + 1].min, isFinite(t)) {
	                                        p = t - r;
	                                        p > c && g.push({
	                                            diff: p,
	                                            start: r,
	                                            end: t
	                                        });
	                                        break
	                                    } else l++;
	                        if (this._axes[h].scaleBreaks.customBreaks)
	                            for (l = 0; l < this._axes[h].scaleBreaks.customBreaks.length; l++)
	                                for (c =
	                                    0; c < g.length; c++)
	                                    if (this._axes[h].scaleBreaks.customBreaks[l].startValue <= g[c].start && g[c].start <= this._axes[h].scaleBreaks.customBreaks[l].endValue || this._axes[h].scaleBreaks.customBreaks[l].startValue <= g[c].start && g[c].start <= this._axes[h].scaleBreaks.customBreaks[l].endValue || g[c].start <= this._axes[h].scaleBreaks.customBreaks[l].startValue && this._axes[h].scaleBreaks.customBreaks[l].startValue <= g[c].end || g[c].start <= this._axes[h].scaleBreaks.customBreaks[l].endValue && this._axes[h].scaleBreaks.customBreaks[l].endValue <=
	                                        g[c].end) g.splice(c, 1), c--;
	                        g.sort(function(a, c) {
	                            return c.diff - a.diff
	                        });
	                        for (l = 0; l < Math.min(g.length, this._axes[h].scaleBreaks.maxNumberOfAutoBreaks); l++) c = a(g[l].start, g[l].end, this._axes[h].logarithmic ? this._axes[h].dataInfo.max / this._axes[h].dataInfo.min : this._axes[h].dataInfo.max - this._axes[h].dataInfo.min, this._axes[h].logarithmic), this._axes[h].scaleBreaks.autoBreaks.push(new aa(this, "autoBreaks", c, l, ++this._eventManager.lastObjectId, this._axes[h].scaleBreaks)), this._axes[h].scaleBreaks._appliedBreaks.push(this._axes[h].scaleBreaks.autoBreaks[this._axes[h].scaleBreaks.autoBreaks.length -
	                            1]);
	                        this._axes[h].scaleBreaks._appliedBreaks.sort(function(a, c) {
	                            return a.startValue - c.startValue
	                        })
	                    }
	            }
	        };
	        q.prototype.getDataPointAtXY = function(a, f, b) {
	            b = b || !1;
	            for (var c = [], e = this._dataInRenderedOrder.length - 1; 0 <= e; e--) {
	                var g = null;
	                (g = this._dataInRenderedOrder[e].getDataPointAtXY(a, f, b)) && c.push(g)
	            }
	            a = null;
	            f = !1;
	            for (b = 0; b < c.length; b++)
	                if ("line" === c[b].dataSeries.type || "stepLine" === c[b].dataSeries.type || "area" === c[b].dataSeries.type || "stepArea" === c[b].dataSeries.type)
	                    if (e = na("markerSize", c[b].dataPoint, c[b].dataSeries) ||
	                        8, c[b].distance <= e / 2) {
	                        f = !0;
	                        break
	                    }
	            for (b = 0; b < c.length; b++) f && "line" !== c[b].dataSeries.type && "stepLine" !== c[b].dataSeries.type && "area" !== c[b].dataSeries.type && "stepArea" !== c[b].dataSeries.type || (a ? c[b].distance <= a.distance && (a = c[b]) : a = c[b]);
	            return a
	        };
	        q.prototype.getObjectAtXY = function(a, f, b) {
	            var c = null;
	            if (b = this.getDataPointAtXY(a, f, b || !1)) c = b.dataSeries.dataPointIds[b.dataPointIndex];
	            else if (v) c = Wa(a, f, this._eventManager.ghostCtx);
	            else
	                for (b = 0; b < this.legend.items.length; b++) {
	                    var e = this.legend.items[b];
	                    a >= e.x1 && (a <= e.x2 && f >= e.y1 && f <= e.y2) && (c = e.id)
	                }
	            return c
	        };
	        q.prototype.getAutoFontSize = function(a, f, b) {
	            f = Math.min(this.width, this.height);
	            return Math.max("theme4" === this.theme ? 0 : 300 <= f ? 12 : 10, Math.round(f * (a / 400)))
	        };
	        q.prototype.resetOverlayedCanvas = function() {
	            this.overlaidCanvasCtx.clearRect(0, 0, this.width, this.height)
	        };
	        q.prototype.clearCanvas = function() {
	            this.ctx.clearRect(0, 0, this.width, this.height);
	            this.backgroundColor && (this.ctx.fillStyle = this.backgroundColor, this.ctx.fillRect(0, 0, this.width, this.height))
	        };
	        q.prototype.attachEvent = function(a) {
	            this._events.push(a)
	        };
	        q.prototype._touchEventHandler = function(a) {
	            if (a.changedTouches && this.interactivityEnabled) {
	                var f = [],
	                    b = a.changedTouches,
	                    c = b ? b[0] : a,
	                    e = null;
	                switch (a.type) {
	                    case "touchstart":
	                    case "MSPointerDown":
	                        f = ["mousemove", "mousedown"];
	                        this._lastTouchData = Oa(c);
	                        this._lastTouchData.time = new Date;
	                        break;
	                    case "touchmove":
	                    case "MSPointerMove":
	                        f = ["mousemove"];
	                        break;
	                    case "touchend":
	                    case "MSPointerUp":
	                        f = "touchstart" === this._lastTouchEventType || "MSPointerDown" === this._lastTouchEventType ? ["mouseup", "click"] : ["mouseup"];
	                        break;
	                    default:
	                        return
	                }
	                if (!(b && 1 < b.length)) {
	                    e = Oa(c);
	                    e.time = new Date;
	                    try {
	                        var g = e.y - this._lastTouchData.y;
	                        if (15 < Math.abs(g) && this._lastTouchData.scroll) {
	                            this._lastTouchData.scroll = !0;
	                            var h = window.parent || window;
	                            h && h.scrollBy && h.scrollBy(0, -g)
	                        }
	                    } catch (l) {}
	                    this._lastTouchEventType = a.type;
	                    if (this._lastTouchData.scroll && this.zoomEnabled) this.isDrag && this.resetOverlayedCanvas(), this.isDrag = !1;
	                    else
	                        for (b = 0; b < f.length; b++) e = f[b], g = document.createEvent("MouseEvent"), g.initMouseEvent(e, !0, !0, window, 1, c.screenX, c.screenY, c.clientX, c.clientY, !1, !1, !1, !1, 0, null), c.target.dispatchEvent(g), a.preventManipulation && a.preventManipulation()
	                }
	            }
	        };
	        q.prototype._dispatchRangeEvent = function(a, f) {
	            var b = {
	                chart: this
	            };
	            b.type = a;
	            b.trigger = f;
	            var c = [];
	            this.axisX && 0 < this.axisX.length && c.push("axisX");
	            this.axisX2 && 0 < this.axisX2.length && c.push("axisX2");
	            this.axisY && 0 < this.axisY.length && c.push("axisY");
	            this.axisY2 && 0 < this.axisY2.length && c.push("axisY2");
	            for (var e = 0; e < c.length; e++)
	                if (y(b[c[e]]) && (b[c[e]] = []),
	                    "axisY" === c[e])
	                    for (var g = 0; g < this.axisY.length; g++) b[c[e]].push({
	                        viewportMinimum: this[c[e]][g].sessionVariables.newViewportMinimum,
	                        viewportMaximum: this[c[e]][g].sessionVariables.newViewportMaximum
	                    });
	                else if ("axisY2" === c[e])
	                for (g = 0; g < this.axisY2.length; g++) b[c[e]].push({
	                    viewportMinimum: this[c[e]][g].sessionVariables.newViewportMinimum,
	                    viewportMaximum: this[c[e]][g].sessionVariables.newViewportMaximum
	                });
	            else if ("axisX" === c[e])
	                for (g = 0; g < this.axisX.length; g++) b[c[e]].push({
	                    viewportMinimum: this[c[e]][g].sessionVariables.newViewportMinimum,
	                    viewportMaximum: this[c[e]][g].sessionVariables.newViewportMaximum
	                });
	            else if ("axisX2" === c[e])
	                for (g = 0; g < this.axisX2.length; g++) b[c[e]].push({
	                    viewportMinimum: this[c[e]][g].sessionVariables.newViewportMinimum,
	                    viewportMaximum: this[c[e]][g].sessionVariables.newViewportMaximum
	                });
	            this.dispatchEvent(a, b, this)
	        };
	        q.prototype._mouseEventHandler = function(a) {
	            "undefined" === typeof a.target && a.srcElement && (a.target = a.srcElement);
	            var f = Oa(a),
	                b = a.type,
	                c, e;
	            a.which ? e = 3 == a.which : a.button && (e = 2 == a.button);
	            q.capturedEventParam &&
	                (c = q.capturedEventParam, "mouseup" === b && (q.capturedEventParam = null, c.chart.overlaidCanvas.releaseCapture ? c.chart.overlaidCanvas.releaseCapture() : document.documentElement.removeEventListener("mouseup", c.chart._mouseEventHandler, !1)), c.hasOwnProperty(b) && ("mouseup" !== b || c.chart.overlaidCanvas.releaseCapture ? a.target !== c.chart.overlaidCanvas && v || c[b].call(c.context, f.x, f.y) : a.target !== c.chart.overlaidCanvas && (c.chart.isDrag = !1)));
	            if (this.interactivityEnabled)
	                if (this._ignoreNextEvent) this._ignoreNextEvent = !1;
	                else if (a.preventManipulation && a.preventManipulation(), a.preventDefault && a.preventDefault(), !e) {
	                if (!q.capturedEventParam && this._events) {
	                    for (var g = 0; g < this._events.length; g++)
	                        if (this._events[g].hasOwnProperty(b))
	                            if (c = this._events[g], e = c.bounds, f.x >= e.x1 && f.x <= e.x2 && f.y >= e.y1 && f.y <= e.y2) {
	                                c[b].call(c.context, f.x, f.y);
	                                "mousedown" === b && !0 === c.capture ? (q.capturedEventParam = c, this.overlaidCanvas.setCapture ? this.overlaidCanvas.setCapture() : document.documentElement.addEventListener("mouseup", this._mouseEventHandler, !1)) : "mouseup" === b && (c.chart.overlaidCanvas.releaseCapture ? c.chart.overlaidCanvas.releaseCapture() : document.documentElement.removeEventListener("mouseup", this._mouseEventHandler, !1));
	                                break
	                            } else c = null;
	                    a.target.style.cursor = c && c.cursor ? c.cursor : this._defaultCursor
	                }
	                b = this.plotArea;
	                if (f.x < b.x1 || f.x > b.x2 || f.y < b.y1 || f.y > b.y2) this.toolTip && this.toolTip.enabled ? this.toolTip.hide() : this.resetOverlayedCanvas();
	                this.isDrag && this.zoomEnabled || !this._eventManager || this._eventManager.mouseEventHandler(a)
	            }
	        };
	        q.prototype._plotAreaMouseDown =
	            function(a, f) {
	                this.isDrag = !0;
	                this.dragStartPoint = {
	                    x: a,
	                    y: f
	                }
	            };
	        q.prototype._plotAreaMouseUp = function(a, f) {
	            if (("normal" === this.plotInfo.axisPlacement || "xySwapped" === this.plotInfo.axisPlacement) && this.isDrag) {
	                var b = f - this.dragStartPoint.y,
	                    c = a - this.dragStartPoint.x,
	                    e = 0 <= this.zoomType.indexOf("x"),
	                    g = 0 <= this.zoomType.indexOf("y"),
	                    h = !1;
	                this.resetOverlayedCanvas();
	                if ("xySwapped" === this.plotInfo.axisPlacement) var l = g,
	                    g = e,
	                    e = l;
	                if (this.panEnabled || this.zoomEnabled) {
	                    if (this.panEnabled)
	                        for (e = g = 0; e < this._axes.length; e++) b =
	                            this._axes[e], b.logarithmic ? b.viewportMinimum < b.minimum ? (g = b.minimum / b.viewportMinimum, b.sessionVariables.newViewportMinimum = b.viewportMinimum * g, b.sessionVariables.newViewportMaximum = b.viewportMaximum * g, h = !0) : b.viewportMaximum > b.maximum && (g = b.viewportMaximum / b.maximum, b.sessionVariables.newViewportMinimum = b.viewportMinimum / g, b.sessionVariables.newViewportMaximum = b.viewportMaximum / g, h = !0) : b.viewportMinimum < b.minimum ? (g = b.minimum - b.viewportMinimum, b.sessionVariables.newViewportMinimum = b.viewportMinimum +
	                                g, b.sessionVariables.newViewportMaximum = b.viewportMaximum + g, h = !0) : b.viewportMaximum > b.maximum && (g = b.viewportMaximum - b.maximum, b.sessionVariables.newViewportMinimum = b.viewportMinimum - g, b.sessionVariables.newViewportMaximum = b.viewportMaximum - g, h = !0);
	                    else if ((!e || 2 < Math.abs(c)) && (!g || 2 < Math.abs(b)) && this.zoomEnabled) {
	                        if (!this.dragStartPoint) return;
	                        b = e ? this.dragStartPoint.x : this.plotArea.x1;
	                        c = g ? this.dragStartPoint.y : this.plotArea.y1;
	                        e = e ? a : this.plotArea.x2;
	                        g = g ? f : this.plotArea.y2;
	                        2 < Math.abs(b - e) && 2 < Math.abs(c -
	                            g) && this._zoomPanToSelectedRegion(b, c, e, g) && (h = !0)
	                    }
	                    h && (this._ignoreNextEvent = !0, this._dispatchRangeEvent("rangeChanging", "zoom"), this.render(), this._dispatchRangeEvent("rangeChanged", "zoom"), h && (this.zoomEnabled && "none" === this._zoomButton.style.display) && (Ma(this._zoomButton, this._resetButton), va(this, this._zoomButton, "pan"), va(this, this._resetButton, "reset")))
	                }
	            }
	            this.isDrag = !1;
	            if ("none" !== this.plotInfo.axisPlacement) {
	                this.resetOverlayedCanvas();
	                if (this.axisX && 0 < this.axisX.length)
	                    for (h = 0; h < this.axisX.length; h++) this.axisX[h].crosshair &&
	                        this.axisX[h].crosshair.enabled && this.axisX[h].renderCrosshair(a, f);
	                if (this.axisX2 && 0 < this.axisX2.length)
	                    for (h = 0; h < this.axisX2.length; h++) this.axisX2[h].crosshair && this.axisX2[h].crosshair.enabled && this.axisX2[h].renderCrosshair(a, f);
	                if (this.axisY && 0 < this.axisY.length)
	                    for (h = 0; h < this.axisY.length; h++) this.axisY[h].crosshair && this.axisY[h].crosshair.enabled && this.axisY[h].renderCrosshair(a, f);
	                if (this.axisY2 && 0 < this.axisY2.length)
	                    for (h = 0; h < this.axisY2.length; h++) this.axisY2[h].crosshair && this.axisY2[h].crosshair.enabled &&
	                        this.axisY2[h].renderCrosshair(a, f)
	            }
	        };
	        q.prototype._plotAreaMouseMove = function(a, f) {
	            if (this.isDrag && "none" !== this.plotInfo.axisPlacement) {
	                var b = 0,
	                    c = 0,
	                    e = b = null,
	                    e = 0 <= this.zoomType.indexOf("x"),
	                    g = 0 <= this.zoomType.indexOf("y"),
	                    h = this;
	                "xySwapped" === this.plotInfo.axisPlacement && (b = g, g = e, e = b);
	                b = this.dragStartPoint.x - a;
	                c = this.dragStartPoint.y - f;
	                2 < Math.abs(b) && 8 > Math.abs(b) && (this.panEnabled || this.zoomEnabled) ? this.toolTip.hide() : this.panEnabled || this.zoomEnabled || this.toolTip.mouseMoveHandler(a, f);
	                if ((!e ||
	                        2 < Math.abs(b) || !g || 2 < Math.abs(c)) && (this.panEnabled || this.zoomEnabled))
	                    if (this.panEnabled) e = {
	                        x1: e ? this.plotArea.x1 + b : this.plotArea.x1,
	                        y1: g ? this.plotArea.y1 + c : this.plotArea.y1,
	                        x2: e ? this.plotArea.x2 + b : this.plotArea.x2,
	                        y2: g ? this.plotArea.y2 + c : this.plotArea.y2
	                    }, clearTimeout(h._panTimerId), h._panTimerId = setTimeout(function(c, b, e, d) {
	                        return function() {
	                            h._zoomPanToSelectedRegion(c, b, e, d, !0) && (h._dispatchRangeEvent("rangeChanging", "pan"), h.render(), h._dispatchRangeEvent("rangeChanged", "pan"), h.dragStartPoint.x =
	                                a, h.dragStartPoint.y = f)
	                        }
	                    }(e.x1, e.y1, e.x2, e.y2), 0);
	                    else if (this.zoomEnabled) {
	                    this.resetOverlayedCanvas();
	                    b = this.overlaidCanvasCtx.globalAlpha;
	                    this.overlaidCanvasCtx.fillStyle = "#A89896";
	                    var c = e ? this.dragStartPoint.x : this.plotArea.x1,
	                        l = g ? this.dragStartPoint.y : this.plotArea.y1,
	                        t = e ? a - this.dragStartPoint.x : this.plotArea.x2 - this.plotArea.x1,
	                        k = g ? f - this.dragStartPoint.y : this.plotArea.y2 - this.plotArea.y1;
	                    this.validateRegion(c, l, e ? a : this.plotArea.x2 - this.plotArea.x1, g ? f : this.plotArea.y2 - this.plotArea.y1, "xy" !==
	                        this.zoomType).isValid && (this.resetOverlayedCanvas(), this.overlaidCanvasCtx.fillStyle = "#99B2B5");
	                    this.overlaidCanvasCtx.globalAlpha = 0.7;
	                    this.overlaidCanvasCtx.fillRect(c, l, t, k);
	                    this.overlaidCanvasCtx.globalAlpha = b
	                }
	            } else if (this.toolTip.mouseMoveHandler(a, f), "none" !== this.plotInfo.axisPlacement) {
	                if (this.axisX && 0 < this.axisX.length)
	                    for (e = 0; e < this.axisX.length; e++) this.axisX[e].crosshair && this.axisX[e].crosshair.enabled && this.axisX[e].renderCrosshair(a, f);
	                if (this.axisX2 && 0 < this.axisX2.length)
	                    for (e = 0; e <
	                        this.axisX2.length; e++) this.axisX2[e].crosshair && this.axisX2[e].crosshair.enabled && this.axisX2[e].renderCrosshair(a, f);
	                if (this.axisY && 0 < this.axisY.length)
	                    for (e = 0; e < this.axisY.length; e++) this.axisY[e].crosshair && this.axisY[e].crosshair.enabled && this.axisY[e].renderCrosshair(a, f);
	                if (this.axisY2 && 0 < this.axisY2.length)
	                    for (e = 0; e < this.axisY2.length; e++) this.axisY2[e].crosshair && this.axisY2[e].crosshair.enabled && this.axisY2[e].renderCrosshair(a, f)
	            }
	        };
	        q.prototype._zoomPanToSelectedRegion = function(a, f, b, c,
	            e) {
	            a = this.validateRegion(a, f, b, c, e);
	            f = a.axesWithValidRange;
	            b = a.axesRanges;
	            if (a.isValid)
	                for (c = 0; c < f.length; c++) e = b[c], f[c].setViewPortRange(e.val1, e.val2);
	            return a.isValid
	        };
	        q.prototype.validateRegion = function(a, f, b, c, e) {
	            e = e || !1;
	            for (var g = 0 <= this.zoomType.indexOf("x"), h = 0 <= this.zoomType.indexOf("y"), l = !1, t = [], k = [], r = [], p = 0; p < this._axes.length; p++)("axisX" === this._axes[p].type && g || "axisY" === this._axes[p].type && h) && k.push(this._axes[p]);
	            for (h = 0; h < k.length; h++) {
	                var p = k[h],
	                    g = !1,
	                    n = p.convertPixelToValue({
	                        x: a,
	                        y: f
	                    }),
	                    d = p.convertPixelToValue({
	                        x: b,
	                        y: c
	                    });
	                if (n > d) var w = d,
	                    d = n,
	                    n = w;
	                if (p.scaleBreaks)
	                    for (w = 0; !g && w < p.scaleBreaks._appliedBreaks.length; w++) g = p.scaleBreaks._appliedBreaks[w].startValue <= n && p.scaleBreaks._appliedBreaks[w].endValue >= d;
	                if (isFinite(p.dataInfo.minDiff))
	                    if (w = p.getApparentDifference(n, d, null, !0), !(g || !(this.panEnabled && p.scaleBreaks && p.scaleBreaks._appliedBreaks.length) && (p.logarithmic && w < Math.pow(p.dataInfo.minDiff, 3) || !p.logarithmic && w < 3 * Math.abs(p.dataInfo.minDiff)) || n < p.minimum || d > p.maximum)) t.push(p),
	                        r.push({
	                            val1: n,
	                            val2: d
	                        }), l = !0;
	                    else if (!e) {
	                    l = !1;
	                    break
	                }
	            }
	            return {
	                isValid: l,
	                axesWithValidRange: t,
	                axesRanges: r
	            }
	        };
	        q.prototype.preparePlotArea = function() {
	            var a = this.plotArea;
	            !v && (0 < a.x1 || 0 < a.y1) && a.ctx.translate(a.x1, a.y1);
	            if ((this.axisX[0] || this.axisX2[0]) && (this.axisY[0] || this.axisY2[0])) {
	                var f = this.axisX[0] ? this.axisX[0].lineCoordinates : this.axisX2[0].lineCoordinates;
	                if (this.axisY && 0 < this.axisY.length && this.axisY[0]) {
	                    var b = this.axisY[0];
	                    a.x1 = f.x1 < f.x2 ? f.x1 : b.lineCoordinates.x1;
	                    a.y1 = f.y1 < b.lineCoordinates.y1 ?
	                        f.y1 : b.lineCoordinates.y1;
	                    a.x2 = f.x2 > b.lineCoordinates.x2 ? f.x2 : b.lineCoordinates.x2;
	                    a.y2 = f.y2 > f.y1 ? f.y2 : b.lineCoordinates.y2;
	                    a.width = a.x2 - a.x1;
	                    a.height = a.y2 - a.y1
	                }
	                this.axisY2 && 0 < this.axisY2.length && this.axisY2[0] && (b = this.axisY2[0], a.x1 = f.x1 < f.x2 ? f.x1 : b.lineCoordinates.x1, a.y1 = f.y1 < b.lineCoordinates.y1 ? f.y1 : b.lineCoordinates.y1, a.x2 = f.x2 > b.lineCoordinates.x2 ? f.x2 : b.lineCoordinates.x2, a.y2 = f.y2 > f.y1 ? f.y2 : b.lineCoordinates.y2, a.width = a.x2 - a.x1, a.height = a.y2 - a.y1)
	            } else f = this.layoutManager.getFreeSpace(),
	                a.x1 = f.x1, a.x2 = f.x2, a.y1 = f.y1, a.y2 = f.y2, a.width = f.width, a.height = f.height;
	            v || (a.canvas.width = a.width, a.canvas.height = a.height, a.canvas.style.left = a.x1 + "px", a.canvas.style.top = a.y1 + "px", (0 < a.x1 || 0 < a.y1) && a.ctx.translate(-a.x1, -a.y1));
	            a.layoutManager = new Ea(a.x1, a.y1, a.x2, a.y2, 2)
	        };
	        q.prototype.renderIndexLabels = function(a) {
	            var f = a || this.plotArea.ctx,
	                b = this.plotArea,
	                c = 0,
	                e = 0,
	                g = 0,
	                h = 0,
	                l = c = h = e = g = 0,
	                t = 0;
	            for (a = 0; a < this._indexLabels.length; a++) {
	                var k = this._indexLabels[a],
	                    r = k.chartType.toLowerCase(),
	                    p, n, l = na("indexLabelFontColor",
	                        k.dataPoint, k.dataSeries),
	                    t = na("indexLabelFontSize", k.dataPoint, k.dataSeries);
	                p = na("indexLabelFontFamily", k.dataPoint, k.dataSeries);
	                n = na("indexLabelFontStyle", k.dataPoint, k.dataSeries);
	                var h = na("indexLabelFontWeight", k.dataPoint, k.dataSeries),
	                    d = na("indexLabelBackgroundColor", k.dataPoint, k.dataSeries),
	                    e = na("indexLabelMaxWidth", k.dataPoint, k.dataSeries),
	                    g = na("indexLabelWrap", k.dataPoint, k.dataSeries),
	                    w = na("indexLabelLineDashType", k.dataPoint, k.dataSeries),
	                    m = na("indexLabelLineColor", k.dataPoint, k.dataSeries),
	                    D = y(k.dataPoint.indexLabelLineThickness) ? y(k.dataSeries.options.indexLabelLineThickness) ? 0 : k.dataSeries.options.indexLabelLineThickness : k.dataPoint.indexLabelLineThickness,
	                    c = 0 < D ? Math.min(10, ("normal" === this.plotInfo.axisPlacement ? this.plotArea.height : this.plotArea.width) << 0) : 0,
	                    u = {
	                        percent: null,
	                        total: null
	                    },
	                    S = null;
	                if (0 <= k.dataSeries.type.indexOf("stacked") || "pie" === k.dataSeries.type || "doughnut" === k.dataSeries.type) u = this.getPercentAndTotal(k.dataSeries, k.dataPoint);
	                if (k.dataSeries.indexLabelFormatter ||
	                    k.dataPoint.indexLabelFormatter) S = {
	                    chart: this,
	                    dataSeries: k.dataSeries,
	                    dataPoint: k.dataPoint,
	                    index: k.indexKeyword,
	                    total: u.total,
	                    percent: u.percent
	                };
	                var ca = k.dataPoint.indexLabelFormatter ? k.dataPoint.indexLabelFormatter(S) : k.dataPoint.indexLabel ? this.replaceKeywordsWithValue(k.dataPoint.indexLabel, k.dataPoint, k.dataSeries, null, k.indexKeyword) : k.dataSeries.indexLabelFormatter ? k.dataSeries.indexLabelFormatter(S) : k.dataSeries.indexLabel ? this.replaceKeywordsWithValue(k.dataSeries.indexLabel, k.dataPoint,
	                    k.dataSeries, null, k.indexKeyword) : null;
	                if (null !== ca && "" !== ca) {
	                    var u = na("indexLabelPlacement", k.dataPoint, k.dataSeries),
	                        S = na("indexLabelOrientation", k.dataPoint, k.dataSeries),
	                        s = k.direction,
	                        q = k.dataSeries.axisX,
	                        A = k.dataSeries.axisY,
	                        x = !1,
	                        d = new la(f, {
	                            x: 0,
	                            y: 0,
	                            maxWidth: e ? e : 0.5 * this.width,
	                            maxHeight: g ? 5 * t : 1.5 * t,
	                            angle: "horizontal" === S ? 0 : -90,
	                            text: ca,
	                            padding: 0,
	                            backgroundColor: d,
	                            horizontalAlign: "left",
	                            fontSize: t,
	                            fontFamily: p,
	                            fontWeight: h,
	                            fontColor: l,
	                            fontStyle: n,
	                            textBaseline: "top"
	                        });
	                    d.measureText();
	                    k.dataSeries.indexLabelMaxWidth =
	                        d.maxWidth;
	                    if ("stackedarea100" === r) {
	                        if (k.point.x < b.x1 || k.point.x > b.x2 || k.point.y < b.y1 - 1 || k.point.y > b.y2 + 1) continue
	                    } else if ("rangearea" === r || "rangesplinearea" === r) {
	                        if (k.dataPoint.x < q.viewportMinimum || k.dataPoint.x > q.viewportMaximum || Math.max.apply(null, k.dataPoint.y) < A.viewportMinimum || Math.min.apply(null, k.dataPoint.y) > A.viewportMaximum) continue
	                    } else if (0 <= r.indexOf("line") || 0 <= r.indexOf("area") || 0 <= r.indexOf("bubble") || 0 <= r.indexOf("scatter")) {
	                        if (k.dataPoint.x < q.viewportMinimum || k.dataPoint.x > q.viewportMaximum ||
	                            k.dataPoint.y < A.viewportMinimum || k.dataPoint.y > A.viewportMaximum) continue
	                    } else if (0 <= r.indexOf("column") || "waterfall" === r || "error" === r && !k.axisSwapped) {
	                        if (k.dataPoint.x < q.viewportMinimum || k.dataPoint.x > q.viewportMaximum || k.bounds.y1 > b.y2 || k.bounds.y2 < b.y1) continue
	                    } else if (0 <= r.indexOf("bar") || "error" === r) {
	                        if (k.dataPoint.x < q.viewportMinimum || k.dataPoint.x > q.viewportMaximum || k.bounds.x1 > b.x2 || k.bounds.x2 < b.x1) continue
	                    } else if ("candlestick" === r || "ohlc" === r) {
	                        if (k.dataPoint.x < q.viewportMinimum || k.dataPoint.x >
	                            q.viewportMaximum || Math.max.apply(null, k.dataPoint.y) < A.viewportMinimum || Math.min.apply(null, k.dataPoint.y) > A.viewportMaximum) continue
	                    } else if (k.dataPoint.x < q.viewportMinimum || k.dataPoint.x > q.viewportMaximum) continue;
	                    e = h = 2;
	                    "horizontal" === S ? (l = d.width, t = d.height) : (t = d.width, l = d.height);
	                    if ("normal" === this.plotInfo.axisPlacement) {
	                        if (0 <= r.indexOf("line") || 0 <= r.indexOf("area")) u = "auto", h = 4;
	                        else if (0 <= r.indexOf("stacked")) "auto" === u && (u = "inside");
	                        else if ("bubble" === r || "scatter" === r) u = "inside";
	                        p = k.point.x -
	                            l / 2;
	                        "inside" !== u ? (e = b.y1, g = b.y2, 0 < s ? (n = k.point.y - t - h - c, n < e && (n = "auto" === u ? Math.max(k.point.y, e) + h + c : e + h + c, x = n + t > k.point.y)) : (n = k.point.y + h + c, n > g - t - h - c && (n = "auto" === u ? Math.min(k.point.y, g) - t - h - c : g - t - h - c, x = n < k.point.y))) : (e = Math.max(k.bounds.y1, b.y1), g = Math.min(k.bounds.y2, b.y2), c = 0 <= r.indexOf("range") || "error" === r ? 0 < s ? Math.max(k.bounds.y1, b.y1) + t / 2 + h : Math.min(k.bounds.y2, b.y2) - t / 2 - h : (Math.max(k.bounds.y1, b.y1) + Math.min(k.bounds.y2, b.y2)) / 2, 0 < s ? (n = Math.max(k.point.y, c) - t / 2, n < e && ("bubble" === r || "scatter" ===
	                            r) && (n = Math.max(k.point.y - t - h, b.y1 + h))) : (n = Math.min(k.point.y, c) - t / 2, n > g - t - h && ("bubble" === r || "scatter" === r) && (n = Math.min(k.point.y + h, b.y2 - t - h))), n = Math.min(n, g - t))
	                    } else 0 <= r.indexOf("line") || 0 <= r.indexOf("area") || 0 <= r.indexOf("scatter") ? (u = "auto", e = 4) : 0 <= r.indexOf("stacked") ? "auto" === u && (u = "inside") : "bubble" === r && (u = "inside"), n = k.point.y - t / 2, "inside" !== u ? (h = b.x1, g = b.x2, 0 > s ? (p = k.point.x - l - e - c, p < h && (p = "auto" === u ? Math.max(k.point.x, h) + e + c : h + e + c, x = p + l > k.point.x)) : (p = k.point.x + e + c, p > g - l - e - c && (p = "auto" ===
	                        u ? Math.min(k.point.x, g) - l - e - c : g - l - e - c, x = p < k.point.x))) : (h = Math.max(k.bounds.x1, b.x1), Math.min(k.bounds.x2, b.x2), c = 0 <= r.indexOf("range") || "error" === r ? 0 > s ? Math.max(k.bounds.x1, b.x1) + l / 2 + e : Math.min(k.bounds.x2, b.x2) - l / 2 - e : (Math.max(k.bounds.x1, b.x1) + Math.min(k.bounds.x2, b.x2)) / 2, p = 0 > s ? Math.max(k.point.x, c) - l / 2 : Math.min(k.point.x, c) - l / 2, p = Math.max(p, h));
	                    "vertical" === S && (n += t);
	                    d.x = p;
	                    d.y = n;
	                    d.render(!0);
	                    D && ("inside" !== u && (0 > r.indexOf("bar") && ("error" !== r || !k.axisSwapped) && k.point.x > b.x1 && k.point.x < b.x2 ||
	                        !x) && (0 > r.indexOf("column") && ("error" !== r || k.axisSwapped) && k.point.y > b.y1 && k.point.y < b.y2 || !x)) && (f.lineWidth = D, f.strokeStyle = m ? m : "gray", f.setLineDash && f.setLineDash(G(w, D)), f.beginPath(), f.moveTo(k.point.x, k.point.y), 0 <= r.indexOf("bar") || "error" === r && k.axisSwapped ? f.lineTo(p + (0 < k.direction ? 0 : l), n + ("horizontal" === S ? t : -t) / 2) : 0 <= r.indexOf("column") || "error" === r && !k.axisSwapped ? f.lineTo(p + l / 2, n + ((0 < k.direction ? t : -t) + ("horizontal" === S ? t : -t)) / 2) : f.lineTo(p + l / 2, n + ((n < k.point.y ? t : -t) + ("horizontal" === S ? t :
	                        -t)) / 2), f.stroke())
	                }
	            }
	            f = {
	                source: f,
	                dest: this.plotArea.ctx,
	                animationCallback: H.fadeInAnimation,
	                easingFunction: H.easing.easeInQuad,
	                animationBase: 0,
	                startTimePercent: 0.7
	            };
	            for (a = 0; a < this._indexLabels.length; a++) k = this._indexLabels[a], d = na("indexLabelBackgroundColor", k.dataPoint, k.dataSeries), k.dataSeries.indexLabelBackgroundColor = y(d) ? v ? "transparent" : null : d;
	            return f
	        };
	        q.prototype.renderLine = function(a) {
	            var f = a.targetCanvasCtx || this.plotArea.ctx,
	                b = v ? this._preRenderCtx : f;
	            if (!(0 >= a.dataSeriesIndexes.length)) {
	                var c =
	                    this._eventManager.ghostCtx;
	                b.save();
	                var e = this.plotArea;
	                b.beginPath();
	                b.rect(e.x1, e.y1, e.width, e.height);
	                b.clip();
	                for (var g = [], h, l = 0; l < a.dataSeriesIndexes.length; l++) {
	                    var t = a.dataSeriesIndexes[l],
	                        k = this.data[t];
	                    b.lineWidth = k.lineThickness;
	                    var r = k.dataPoints,
	                        p = "solid";
	                    if (b.setLineDash) {
	                        var n = G(k.nullDataLineDashType, k.lineThickness),
	                            p = k.lineDashType,
	                            d = G(p, k.lineThickness);
	                        b.setLineDash(d)
	                    }
	                    var w = k.id;
	                    this._eventManager.objectMap[w] = {
	                        objectType: "dataSeries",
	                        dataSeriesIndex: t
	                    };
	                    w = R(w);
	                    c.strokeStyle = w;
	                    c.lineWidth = 0 < k.lineThickness ? Math.max(k.lineThickness, 4) : 0;
	                    var w = k._colorSet,
	                        m = w = k.lineColor = k.options.lineColor ? k.options.lineColor : w[0];
	                    b.strokeStyle = w;
	                    var D = !0,
	                        u = 0,
	                        S, ca;
	                    b.beginPath();
	                    if (0 < r.length) {
	                        for (var s = !1, u = 0; u < r.length; u++)
	                            if (S = r[u].x.getTime ? r[u].x.getTime() : r[u].x, !(S < a.axisX.dataInfo.viewPortMin || S > a.axisX.dataInfo.viewPortMax && (!k.connectNullData || !s)))
	                                if ("number" !== typeof r[u].y) 0 < u && !(k.connectNullData || s || D) && (b.stroke(), v && c.stroke()), s = !0;
	                                else {
	                                    S = a.axisX.convertValueToPixel(S);
	                                    ca = a.axisY.convertValueToPixel(r[u].y);
	                                    var q = k.dataPointIds[u];
	                                    this._eventManager.objectMap[q] = {
	                                        id: q,
	                                        objectType: "dataPoint",
	                                        dataSeriesIndex: t,
	                                        dataPointIndex: u,
	                                        x1: S,
	                                        y1: ca
	                                    };
	                                    D || s ? (!D && k.connectNullData ? (b.setLineDash && (k.options.nullDataLineDashType || p === k.lineDashType && k.lineDashType !== k.nullDataLineDashType) && (b.stroke(), b.beginPath(), b.moveTo(h.x, h.y), p = k.nullDataLineDashType, b.setLineDash(n)), b.lineTo(S, ca), v && c.lineTo(S, ca)) : (b.beginPath(), b.moveTo(S, ca), v && (c.beginPath(), c.moveTo(S, ca))), s = D = !1) :
	                                        (b.lineTo(S, ca), v && c.lineTo(S, ca), 0 == u % 500 && (b.stroke(), b.beginPath(), b.moveTo(S, ca), v && (c.stroke(), c.beginPath(), c.moveTo(S, ca))));
	                                    h = {
	                                        x: S,
	                                        y: ca
	                                    };
	                                    u < r.length - 1 && (m !== (r[u].lineColor || w) || p !== (r[u].lineDashType || k.lineDashType)) && (b.stroke(), b.beginPath(), b.moveTo(S, ca), m = r[u].lineColor || w, b.strokeStyle = m, b.setLineDash && (r[u].lineDashType ? (p = r[u].lineDashType, b.setLineDash(G(p, k.lineThickness))) : (p = k.lineDashType, b.setLineDash(d))));
	                                    if (0 < r[u].markerSize || 0 < k.markerSize) {
	                                        var A = k.getMarkerProperties(u,
	                                            S, ca, b);
	                                        g.push(A);
	                                        q = R(q);
	                                        v && g.push({
	                                            x: S,
	                                            y: ca,
	                                            ctx: c,
	                                            type: A.type,
	                                            size: A.size,
	                                            color: q,
	                                            borderColor: q,
	                                            borderThickness: A.borderThickness
	                                        })
	                                    }(r[u].indexLabel || k.indexLabel || r[u].indexLabelFormatter || k.indexLabelFormatter) && this._indexLabels.push({
	                                        chartType: "line",
	                                        dataPoint: r[u],
	                                        dataSeries: k,
	                                        point: {
	                                            x: S,
	                                            y: ca
	                                        },
	                                        direction: 0 > r[u].y === a.axisY.reversed ? 1 : -1,
	                                        color: w
	                                    })
	                                }
	                        b.stroke();
	                        v && c.stroke()
	                    }
	                }
	                ja.drawMarkers(g);
	                v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop",
	                    a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), c.beginPath());
	                b.restore();
	                b.beginPath();
	                return {
	                    source: f,
	                    dest: this.plotArea.ctx,
	                    animationCallback: H.xClipAnimation,
	                    easingFunction: H.easing.linear,
	                    animationBase: 0
	                }
	            }
	        };
	        q.prototype.renderStepLine = function(a) {
	            var f =
	                a.targetCanvasCtx || this.plotArea.ctx,
	                b = v ? this._preRenderCtx : f;
	            if (!(0 >= a.dataSeriesIndexes.length)) {
	                var c = this._eventManager.ghostCtx;
	                b.save();
	                var e = this.plotArea;
	                b.beginPath();
	                b.rect(e.x1, e.y1, e.width, e.height);
	                b.clip();
	                for (var g = [], h, l = 0; l < a.dataSeriesIndexes.length; l++) {
	                    var t = a.dataSeriesIndexes[l],
	                        k = this.data[t];
	                    b.lineWidth = k.lineThickness;
	                    var r = k.dataPoints,
	                        p = "solid";
	                    if (b.setLineDash) {
	                        var n = G(k.nullDataLineDashType, k.lineThickness),
	                            p = k.lineDashType,
	                            d = G(p, k.lineThickness);
	                        b.setLineDash(d)
	                    }
	                    var w =
	                        k.id;
	                    this._eventManager.objectMap[w] = {
	                        objectType: "dataSeries",
	                        dataSeriesIndex: t
	                    };
	                    w = R(w);
	                    c.strokeStyle = w;
	                    c.lineWidth = 0 < k.lineThickness ? Math.max(k.lineThickness, 4) : 0;
	                    var w = k._colorSet,
	                        m = w = k.lineColor = k.options.lineColor ? k.options.lineColor : w[0];
	                    b.strokeStyle = w;
	                    var D = !0,
	                        u = 0,
	                        S, ca;
	                    b.beginPath();
	                    if (0 < r.length) {
	                        for (var s = !1, u = 0; u < r.length; u++)
	                            if (S = r[u].getTime ? r[u].x.getTime() : r[u].x, !(S < a.axisX.dataInfo.viewPortMin || S > a.axisX.dataInfo.viewPortMax && (!k.connectNullData || !s)))
	                                if ("number" !== typeof r[u].y) 0 <
	                                    u && !(k.connectNullData || s || D) && (b.stroke(), v && c.stroke()), s = !0;
	                                else {
	                                    var q = ca;
	                                    S = a.axisX.convertValueToPixel(S);
	                                    ca = a.axisY.convertValueToPixel(r[u].y);
	                                    var A = k.dataPointIds[u];
	                                    this._eventManager.objectMap[A] = {
	                                        id: A,
	                                        objectType: "dataPoint",
	                                        dataSeriesIndex: t,
	                                        dataPointIndex: u,
	                                        x1: S,
	                                        y1: ca
	                                    };
	                                    D || s ? (!D && k.connectNullData ? (b.setLineDash && (k.options.nullDataLineDashType || p === k.lineDashType && k.lineDashType !== k.nullDataLineDashType) && (b.stroke(), b.beginPath(), b.moveTo(h.x, h.y), p = k.nullDataLineDashType, b.setLineDash(n)),
	                                        b.lineTo(S, q), b.lineTo(S, ca), v && (c.lineTo(S, q), c.lineTo(S, ca))) : (b.beginPath(), b.moveTo(S, ca), v && (c.beginPath(), c.moveTo(S, ca))), s = D = !1) : (b.lineTo(S, q), v && c.lineTo(S, q), b.lineTo(S, ca), v && c.lineTo(S, ca), 0 == u % 500 && (b.stroke(), b.beginPath(), b.moveTo(S, ca), v && (c.stroke(), c.beginPath(), c.moveTo(S, ca))));
	                                    h = {
	                                        x: S,
	                                        y: ca
	                                    };
	                                    u < r.length - 1 && (m !== (r[u].lineColor || w) || p !== (r[u].lineDashType || k.lineDashType)) && (b.stroke(), b.beginPath(), b.moveTo(S, ca), m = r[u].lineColor || w, b.strokeStyle = m, b.setLineDash && (r[u].lineDashType ?
	                                        (p = r[u].lineDashType, b.setLineDash(G(p, k.lineThickness))) : (p = k.lineDashType, b.setLineDash(d))));
	                                    if (0 < r[u].markerSize || 0 < k.markerSize) q = k.getMarkerProperties(u, S, ca, b), g.push(q), A = R(A), v && g.push({
	                                        x: S,
	                                        y: ca,
	                                        ctx: c,
	                                        type: q.type,
	                                        size: q.size,
	                                        color: A,
	                                        borderColor: A,
	                                        borderThickness: q.borderThickness
	                                    });
	                                    (r[u].indexLabel || k.indexLabel || r[u].indexLabelFormatter || k.indexLabelFormatter) && this._indexLabels.push({
	                                        chartType: "stepLine",
	                                        dataPoint: r[u],
	                                        dataSeries: k,
	                                        point: {
	                                            x: S,
	                                            y: ca
	                                        },
	                                        direction: 0 > r[u].y === a.axisY.reversed ?
	                                            1 : -1,
	                                        color: w
	                                    })
	                                }
	                        b.stroke();
	                        v && c.stroke()
	                    }
	                }
	                ja.drawMarkers(g);
	                v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), c.beginPath());
	                b.restore();
	                b.beginPath();
	                return {
	                    source: f,
	                    dest: this.plotArea.ctx,
	                    animationCallback: H.xClipAnimation,
	                    easingFunction: H.easing.linear,
	                    animationBase: 0
	                }
	            }
	        };
	        q.prototype.renderSpline = function(a) {
	            function f(a) {
	                a = x(a, 2);
	                if (0 < a.length) {
	                    c.beginPath();
	                    v && e.beginPath();
	                    c.moveTo(a[0].x, a[0].y);
	                    a[0].newStrokeStyle && (c.strokeStyle = a[0].newStrokeStyle);
	                    a[0].newLineDashArray && c.setLineDash(a[0].newLineDashArray);
	                    v && e.moveTo(a[0].x, a[0].y);
	                    for (var b = 0; b < a.length - 3; b += 3)
	                        if (c.bezierCurveTo(a[b + 1].x, a[b + 1].y, a[b + 2].x, a[b + 2].y, a[b + 3].x, a[b + 3].y),
	                            v && e.bezierCurveTo(a[b + 1].x, a[b + 1].y, a[b + 2].x, a[b + 2].y, a[b + 3].x, a[b + 3].y), 0 < b && 0 === b % 3E3 || a[b + 3].newStrokeStyle || a[b + 3].newLineDashArray) c.stroke(), c.beginPath(), c.moveTo(a[b + 3].x, a[b + 3].y), a[b + 3].newStrokeStyle && (c.strokeStyle = a[b + 3].newStrokeStyle), a[b + 3].newLineDashArray && c.setLineDash(a[b + 3].newLineDashArray), v && (e.stroke(), e.beginPath(), e.moveTo(a[b + 3].x, a[b + 3].y));
	                    c.stroke();
	                    v && e.stroke()
	                }
	            }
	            var b = a.targetCanvasCtx || this.plotArea.ctx,
	                c = v ? this._preRenderCtx : b;
	            if (!(0 >= a.dataSeriesIndexes.length)) {
	                var e =
	                    this._eventManager.ghostCtx;
	                c.save();
	                var g = this.plotArea;
	                c.beginPath();
	                c.rect(g.x1, g.y1, g.width, g.height);
	                c.clip();
	                for (var h = [], l = 0; l < a.dataSeriesIndexes.length; l++) {
	                    var t = a.dataSeriesIndexes[l],
	                        k = this.data[t];
	                    c.lineWidth = k.lineThickness;
	                    var r = k.dataPoints,
	                        p = "solid";
	                    if (c.setLineDash) {
	                        var n = G(k.nullDataLineDashType, k.lineThickness),
	                            p = k.lineDashType,
	                            d = G(p, k.lineThickness);
	                        c.setLineDash(d)
	                    }
	                    var w = k.id;
	                    this._eventManager.objectMap[w] = {
	                        objectType: "dataSeries",
	                        dataSeriesIndex: t
	                    };
	                    w = R(w);
	                    e.strokeStyle = w;
	                    e.lineWidth =
	                        0 < k.lineThickness ? Math.max(k.lineThickness, 4) : 0;
	                    var w = k._colorSet,
	                        m = w = k.lineColor = k.options.lineColor ? k.options.lineColor : w[0];
	                    c.strokeStyle = w;
	                    var D = 0,
	                        u, S, q = [];
	                    c.beginPath();
	                    if (0 < r.length)
	                        for (S = !1, D = 0; D < r.length; D++)
	                            if (u = r[D].getTime ? r[D].x.getTime() : r[D].x, !(u < a.axisX.dataInfo.viewPortMin || u > a.axisX.dataInfo.viewPortMax && (!k.connectNullData || !S)))
	                                if ("number" !== typeof r[D].y) 0 < D && !S && (k.connectNullData ? c.setLineDash && (0 < q.length && (k.options.nullDataLineDashType || !r[D - 1].lineDashType)) && (q[q.length -
	                                    1].newLineDashArray = n, p = k.nullDataLineDashType) : (f(q), q = [])), S = !0;
	                                else {
	                                    u = a.axisX.convertValueToPixel(u);
	                                    S = a.axisY.convertValueToPixel(r[D].y);
	                                    var s = k.dataPointIds[D];
	                                    this._eventManager.objectMap[s] = {
	                                        id: s,
	                                        objectType: "dataPoint",
	                                        dataSeriesIndex: t,
	                                        dataPointIndex: D,
	                                        x1: u,
	                                        y1: S
	                                    };
	                                    q[q.length] = {
	                                        x: u,
	                                        y: S
	                                    };
	                                    D < r.length - 1 && (m !== (r[D].lineColor || w) || p !== (r[D].lineDashType || k.lineDashType)) && (m = r[D].lineColor || w, q[q.length - 1].newStrokeStyle = m, c.setLineDash && (r[D].lineDashType ? (p = r[D].lineDashType, q[q.length - 1].newLineDashArray =
	                                        G(p, k.lineThickness)) : (p = k.lineDashType, q[q.length - 1].newLineDashArray = d)));
	                                    if (0 < r[D].markerSize || 0 < k.markerSize) {
	                                        var y = k.getMarkerProperties(D, u, S, c);
	                                        h.push(y);
	                                        s = R(s);
	                                        v && h.push({
	                                            x: u,
	                                            y: S,
	                                            ctx: e,
	                                            type: y.type,
	                                            size: y.size,
	                                            color: s,
	                                            borderColor: s,
	                                            borderThickness: y.borderThickness
	                                        })
	                                    }(r[D].indexLabel || k.indexLabel || r[D].indexLabelFormatter || k.indexLabelFormatter) && this._indexLabels.push({
	                                        chartType: "spline",
	                                        dataPoint: r[D],
	                                        dataSeries: k,
	                                        point: {
	                                            x: u,
	                                            y: S
	                                        },
	                                        direction: 0 > r[D].y === a.axisY.reversed ? 1 : -1,
	                                        color: w
	                                    });
	                                    S = !1
	                                }
	                    f(q)
	                }
	                ja.drawMarkers(h);
	                v && (b.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(g.x1, g.y1, g.width, g.height), e.beginPath());
	                c.restore();
	                c.beginPath();
	                return {
	                    source: b,
	                    dest: this.plotArea.ctx,
	                    animationCallback: H.xClipAnimation,
	                    easingFunction: H.easing.linear,
	                    animationBase: 0
	                }
	            }
	        };
	        var V = function(a, f, b, c, e, g, h, l, t, k, r, p, n) {
	            "undefined" === typeof n && (n = 1);
	            h = h || 0;
	            l = l || "black";
	            var d = 15 < c - f && 15 < e - b ? 8 : 0.35 * Math.min(c - f, e - b);
	            a.beginPath();
	            a.moveTo(f, b);
	            a.save();
	            a.fillStyle = g;
	            a.globalAlpha = n;
	            a.fillRect(f, b, c - f, e - b);
	            a.globalAlpha = 1;
	            0 < h && (n = 0 === h % 2 ? 0 : 0.5, a.beginPath(), a.lineWidth = h, a.strokeStyle = l, a.moveTo(f, b), a.rect(f - n, b - n, c - f + 2 * n, e - b + 2 * n), a.stroke());
	            a.restore();
	            !0 === t && (a.save(), a.beginPath(), a.moveTo(f, b), a.lineTo(f + d, b + d), a.lineTo(c -
	                d, b + d), a.lineTo(c, b), a.closePath(), h = a.createLinearGradient((c + f) / 2, b + d, (c + f) / 2, b), h.addColorStop(0, g), h.addColorStop(1, "rgba(255, 255, 255, .4)"), a.fillStyle = h, a.fill(), a.restore());
	            !0 === k && (a.save(), a.beginPath(), a.moveTo(f, e), a.lineTo(f + d, e - d), a.lineTo(c - d, e - d), a.lineTo(c, e), a.closePath(), h = a.createLinearGradient((c + f) / 2, e - d, (c + f) / 2, e), h.addColorStop(0, g), h.addColorStop(1, "rgba(255, 255, 255, .4)"), a.fillStyle = h, a.fill(), a.restore());
	            !0 === r && (a.save(), a.beginPath(), a.moveTo(f, b), a.lineTo(f + d, b +
	                d), a.lineTo(f + d, e - d), a.lineTo(f, e), a.closePath(), h = a.createLinearGradient(f + d, (e + b) / 2, f, (e + b) / 2), h.addColorStop(0, g), h.addColorStop(1, "rgba(255, 255, 255, 0.1)"), a.fillStyle = h, a.fill(), a.restore());
	            !0 === p && (a.save(), a.beginPath(), a.moveTo(c, b), a.lineTo(c - d, b + d), a.lineTo(c - d, e - d), a.lineTo(c, e), h = a.createLinearGradient(c - d, (e + b) / 2, c, (e + b) / 2), h.addColorStop(0, g), h.addColorStop(1, "rgba(255, 255, 255, 0.1)"), a.fillStyle = h, h.addColorStop(0, g), h.addColorStop(1, "rgba(255, 255, 255, 0.1)"), a.fillStyle = h, a.fill(),
	                a.closePath(), a.restore())
	        };
	        q.prototype.renderColumn = function(a) {
	            var f = a.targetCanvasCtx || this.plotArea.ctx,
	                b = v ? this._preRenderCtx : f;
	            if (!(0 >= a.dataSeriesIndexes.length)) {
	                var c = null,
	                    e = this.plotArea,
	                    g = 0,
	                    h, l, t, k = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0),
	                    g = this.dataPointMinWidth = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1,
	                    r = this.dataPointMaxWidth = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth :
	                    Math.min(0.15 * this.width, 0.9 * (this.plotArea.width / a.plotType.totalDataSeries)) << 0,
	                    p = a.axisX.dataInfo.minDiff;
	                isFinite(p) || (p = 0.3 * Math.abs(a.axisX.range));
	                p = this.dataPointWidth = this.dataPointWidth ? this.dataPointWidth : 0.9 * (e.width * (a.axisX.logarithmic ? Math.log(p) / Math.log(a.axisX.range) : Math.abs(p) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0;
	                this.dataPointMaxWidth && g > r && (g = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, r));
	                !this.dataPointMaxWidth && (this.dataPointMinWidth && r < g) &&
	                    (r = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, g));
	                p < g && (p = g);
	                p > r && (p = r);
	                b.save();
	                v && this._eventManager.ghostCtx.save();
	                b.beginPath();
	                b.rect(e.x1, e.y1, e.width, e.height);
	                b.clip();
	                v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());
	                for (r = 0; r < a.dataSeriesIndexes.length; r++) {
	                    var n = a.dataSeriesIndexes[r],
	                        d = this.data[n],
	                        w = d.dataPoints;
	                    if (0 < w.length)
	                        for (var m = 5 < p && d.bevelEnabled ? !0 : !1, g = 0; g < w.length; g++)
	                            if (w[g].getTime ?
	                                t = w[g].x.getTime() : t = w[g].x, !(t < a.axisX.dataInfo.viewPortMin || t > a.axisX.dataInfo.viewPortMax) && "number" === typeof w[g].y) {
	                                h = a.axisX.convertValueToPixel(t);
	                                l = a.axisY.convertValueToPixel(w[g].y);
	                                h = a.axisX.reversed ? h + a.plotType.totalDataSeries * p / 2 - (a.previousDataSeriesCount + r) * p << 0 : h - a.plotType.totalDataSeries * p / 2 + (a.previousDataSeriesCount + r) * p << 0;
	                                var D = a.axisX.reversed ? h - p << 0 : h + p << 0,
	                                    u;
	                                0 <= w[g].y ? u = k : (u = l, l = k);
	                                l > u && (c = l, l = u, u = c);
	                                c = w[g].color ? w[g].color : d._colorSet[g % d._colorSet.length];
	                                V(b, h, l, D, u, c,
	                                    0, null, m && 0 <= w[g].y, 0 > w[g].y && m, !1, !1, d.fillOpacity);
	                                c = d.dataPointIds[g];
	                                this._eventManager.objectMap[c] = {
	                                    id: c,
	                                    objectType: "dataPoint",
	                                    dataSeriesIndex: n,
	                                    dataPointIndex: g,
	                                    x1: h,
	                                    y1: l,
	                                    x2: D,
	                                    y2: u
	                                };
	                                c = R(c);
	                                v && V(this._eventManager.ghostCtx, h, l, D, u, c, 0, null, !1, !1, !1, !1);
	                                (w[g].indexLabel || d.indexLabel || w[g].indexLabelFormatter || d.indexLabelFormatter) && this._indexLabels.push({
	                                    chartType: "column",
	                                    dataPoint: w[g],
	                                    dataSeries: d,
	                                    point: {
	                                        x: h + (D - h) / 2,
	                                        y: 0 > w[g].y === a.axisY.reversed ? l : u
	                                    },
	                                    direction: 0 > w[g].y === a.axisY.reversed ?
	                                        1 : -1,
	                                    bounds: {
	                                        x1: h,
	                                        y1: Math.min(l, u),
	                                        x2: D,
	                                        y2: Math.max(l, u)
	                                    },
	                                    color: c
	                                })
	                            }
	                }
	                v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());
	                b.restore();
	                return {
	                    source: f,
	                    dest: this.plotArea.ctx,
	                    animationCallback: H.yScaleAnimation,
	                    easingFunction: H.easing.easeOutQuart,
	                    animationBase: k < a.axisY.bounds.y1 ? a.axisY.bounds.y1 : k > a.axisY.bounds.y2 ? a.axisY.bounds.y2 : k
	                }
	            }
	        };
	        q.prototype.renderStackedColumn = function(a) {
	            var f = a.targetCanvasCtx || this.plotArea.ctx,
	                b = v ? this._preRenderCtx : f;
	            if (!(0 >= a.dataSeriesIndexes.length)) {
	                var c = null,
	                    e = this.plotArea,
	                    g = [],
	                    h = [],
	                    l = [],
	                    t = [],
	                    k = 0,
	                    r, p, n = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0),
	                    k =
	                    this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1;
	                r = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : 0.15 * this.width << 0;
	                var d = a.axisX.dataInfo.minDiff;
	                isFinite(d) || (d = 0.3 * Math.abs(a.axisX.range));
	                d = this.dataPointWidth ? this.dataPointWidth : 0.9 * (e.width * (a.axisX.logarithmic ? Math.log(d) / Math.log(a.axisX.range) : Math.abs(d) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0;
	                this.dataPointMaxWidth && k > r && (k = Math.min(this.dataPointWidth ?
	                    this.dataPointWidth : Infinity, r));
	                !this.dataPointMaxWidth && (this.dataPointMinWidth && r < k) && (r = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, k));
	                d < k && (d = k);
	                d > r && (d = r);
	                b.save();
	                v && this._eventManager.ghostCtx.save();
	                b.beginPath();
	                b.rect(e.x1, e.y1, e.width, e.height);
	                b.clip();
	                v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());
	                for (var w = 0; w < a.dataSeriesIndexes.length; w++) {
	                    var m = a.dataSeriesIndexes[w],
	                        D = this.data[m],
	                        u = D.dataPoints;
	                    if (0 < u.length) {
	                        var q = 5 < d && D.bevelEnabled ? !0 : !1;
	                        b.strokeStyle = "#4572A7 ";
	                        for (k = 0; k < u.length; k++)
	                            if (c = u[k].x.getTime ? u[k].x.getTime() : u[k].x, !(c < a.axisX.dataInfo.viewPortMin || c > a.axisX.dataInfo.viewPortMax) && "number" === typeof u[k].y) {
	                                r = a.axisX.convertValueToPixel(c);
	                                var s = r - a.plotType.plotUnits.length * d / 2 + a.index * d << 0,
	                                    y = s + d << 0,
	                                    B;
	                                if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 < u[k].y) l[c] = u[k].y + (l[c] ? l[c] : 0), 0 < l[c] && (p = a.axisY.convertValueToPixel(l[c]),
	                                    B = "undefined" !== typeof g[c] ? g[c] : n, g[c] = p);
	                                else if (a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 >= u[k].y) t[c] = u[k].y + (t[c] ? t[c] : 0), B = a.axisY.convertValueToPixel(t[c]), p = "undefined" !== typeof h[c] ? h[c] : n, h[c] = B;
	                                else if (p = a.axisY.convertValueToPixel(u[k].y), 0 <= u[k].y) {
	                                    var A = "undefined" !== typeof g[c] ? g[c] : 0;
	                                    p -= A;
	                                    B = n - A;
	                                    g[c] = A + (B - p)
	                                } else A = h[c] ? h[c] : 0, B = p + A, p = n + A, h[c] = A + (B - p);
	                                c = u[k].color ? u[k].color : D._colorSet[k % D._colorSet.length];
	                                V(b, s, p, y, B, c, 0, null, q && 0 <= u[k].y, 0 > u[k].y && q, !1, !1, D.fillOpacity);
	                                c = D.dataPointIds[k];
	                                this._eventManager.objectMap[c] = {
	                                    id: c,
	                                    objectType: "dataPoint",
	                                    dataSeriesIndex: m,
	                                    dataPointIndex: k,
	                                    x1: s,
	                                    y1: p,
	                                    x2: y,
	                                    y2: B
	                                };
	                                c = R(c);
	                                v && V(this._eventManager.ghostCtx, s, p, y, B, c, 0, null, !1, !1, !1, !1);
	                                (u[k].indexLabel || D.indexLabel || u[k].indexLabelFormatter || D.indexLabelFormatter) && this._indexLabels.push({
	                                    chartType: "stackedColumn",
	                                    dataPoint: u[k],
	                                    dataSeries: D,
	                                    point: {
	                                        x: r,
	                                        y: 0 <= u[k].y ? p : B
	                                    },
	                                    direction: 0 > u[k].y === a.axisY.reversed ? 1 : -1,
	                                    bounds: {
	                                        x1: s,
	                                        y1: Math.min(p, B),
	                                        x2: y,
	                                        y2: Math.max(p,
	                                            B)
	                                    },
	                                    color: c
	                                })
	                            }
	                    }
	                }
	                v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());
	                b.restore();
	                return {
	                    source: f,
	                    dest: this.plotArea.ctx,
	                    animationCallback: H.yScaleAnimation,
	                    easingFunction: H.easing.easeOutQuart,
	                    animationBase: n < a.axisY.bounds.y1 ? a.axisY.bounds.y1 : n > a.axisY.bounds.y2 ? a.axisY.bounds.y2 : n
	                }
	            }
	        };
	        q.prototype.renderStackedColumn100 = function(a) {
	            var f = a.targetCanvasCtx || this.plotArea.ctx,
	                b = v ? this._preRenderCtx : f;
	            if (!(0 >= a.dataSeriesIndexes.length)) {
	                var c = null,
	                    e = this.plotArea,
	                    g = [],
	                    h = [],
	                    l = [],
	                    t = [],
	                    k = 0,
	                    r, p, n = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0),
	                    k = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ?
	                    this.dataPointWidth : 1;
	                r = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : 0.15 * this.width << 0;
	                var d = a.axisX.dataInfo.minDiff;
	                isFinite(d) || (d = 0.3 * Math.abs(a.axisX.range));
	                d = this.dataPointWidth ? this.dataPointWidth : 0.9 * (e.width * (a.axisX.logarithmic ? Math.log(d) / Math.log(a.axisX.range) : Math.abs(d) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0;
	                this.dataPointMaxWidth && k > r && (k = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, r));
	                !this.dataPointMaxWidth &&
	                    (this.dataPointMinWidth && r < k) && (r = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, k));
	                d < k && (d = k);
	                d > r && (d = r);
	                b.save();
	                v && this._eventManager.ghostCtx.save();
	                b.beginPath();
	                b.rect(e.x1, e.y1, e.width, e.height);
	                b.clip();
	                v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());
	                for (var w = 0; w < a.dataSeriesIndexes.length; w++) {
	                    var m = a.dataSeriesIndexes[w],
	                        D = this.data[m],
	                        u = D.dataPoints;
	                    if (0 < u.length)
	                        for (var q = 5 < d && D.bevelEnabled ?
	                                !0 : !1, k = 0; k < u.length; k++)
	                            if (c = u[k].x.getTime ? u[k].x.getTime() : u[k].x, !(c < a.axisX.dataInfo.viewPortMin || c > a.axisX.dataInfo.viewPortMax) && "number" === typeof u[k].y) {
	                                r = a.axisX.convertValueToPixel(c);
	                                p = 0 !== a.dataPointYSums[c] ? 100 * (u[k].y / a.dataPointYSums[c]) : 0;
	                                var s = r - a.plotType.plotUnits.length * d / 2 + a.index * d << 0,
	                                    y = s + d << 0,
	                                    B;
	                                if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 < u[k].y) {
	                                    l[c] = p + ("undefined" !== typeof l[c] ? l[c] : 0);
	                                    if (0 >= l[c]) continue;
	                                    p = a.axisY.convertValueToPixel(l[c]);
	                                    B = g[c] ? g[c] : n;
	                                    g[c] = p
	                                } else if (a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 >= u[k].y) t[c] = p + ("undefined" !== typeof t[c] ? t[c] : 0), B = a.axisY.convertValueToPixel(t[c]), p = h[c] ? h[c] : n, h[c] = B;
	                                else if (p = a.axisY.convertValueToPixel(p), 0 <= u[k].y) {
	                                    var A = "undefined" !== typeof g[c] ? g[c] : 0;
	                                    p -= A;
	                                    B = n - A;
	                                    g[c] = A + (B - p)
	                                } else A = "undefined" !== typeof h[c] ? h[c] : 0, B = p + A, p = n + A, h[c] = A + (B - p);
	                                c = u[k].color ? u[k].color : D._colorSet[k % D._colorSet.length];
	                                V(b, s, p, y, B, c, 0, null, q && 0 <= u[k].y, 0 > u[k].y && q, !1, !1, D.fillOpacity);
	                                c = D.dataPointIds[k];
	                                this._eventManager.objectMap[c] = {
	                                    id: c,
	                                    objectType: "dataPoint",
	                                    dataSeriesIndex: m,
	                                    dataPointIndex: k,
	                                    x1: s,
	                                    y1: p,
	                                    x2: y,
	                                    y2: B
	                                };
	                                c = R(c);
	                                v && V(this._eventManager.ghostCtx, s, p, y, B, c, 0, null, !1, !1, !1, !1);
	                                (u[k].indexLabel || D.indexLabel || u[k].indexLabelFormatter || D.indexLabelFormatter) && this._indexLabels.push({
	                                    chartType: "stackedColumn100",
	                                    dataPoint: u[k],
	                                    dataSeries: D,
	                                    point: {
	                                        x: r,
	                                        y: 0 <= u[k].y ? p : B
	                                    },
	                                    direction: 0 > u[k].y === a.axisY.reversed ? 1 : -1,
	                                    bounds: {
	                                        x1: s,
	                                        y1: Math.min(p, B),
	                                        x2: y,
	                                        y2: Math.max(p, B)
	                                    },
	                                    color: c
	                                })
	                            }
	                }
	                v &&
	                    (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());
	                b.restore();
	                return {
	                    source: f,
	                    dest: this.plotArea.ctx,
	                    animationCallback: H.yScaleAnimation,
	                    easingFunction: H.easing.easeOutQuart,
	                    animationBase: n < a.axisY.bounds.y1 ? a.axisY.bounds.y1 : n > a.axisY.bounds.y2 ? a.axisY.bounds.y2 : n
	                }
	            }
	        };
	        q.prototype.renderBar = function(a) {
	            var f = a.targetCanvasCtx || this.plotArea.ctx,
	                b = v ? this._preRenderCtx : f;
	            if (!(0 >= a.dataSeriesIndexes.length)) {
	                var c = null,
	                    e = this.plotArea,
	                    g = 0,
	                    h, l, t, k = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0),
	                    g = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1,
	                    r = this.dataPointMaxWidth ? this.dataPointMaxWidth :
	                    this.dataPointWidth ? this.dataPointWidth : Math.min(0.15 * this.height, 0.9 * (this.plotArea.height / a.plotType.totalDataSeries)) << 0,
	                    p = a.axisX.dataInfo.minDiff;
	                isFinite(p) || (p = 0.3 * Math.abs(a.axisX.range));
	                p = this.dataPointWidth ? this.dataPointWidth : 0.9 * (e.height * (a.axisX.logarithmic ? Math.log(p) / Math.log(a.axisX.range) : Math.abs(p) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0;
	                this.dataPointMaxWidth && g > r && (g = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, r));
	                !this.dataPointMaxWidth && (this.dataPointMinWidth &&
	                    r < g) && (r = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, g));
	                p < g && (p = g);
	                p > r && (p = r);
	                b.save();
	                v && this._eventManager.ghostCtx.save();
	                b.beginPath();
	                b.rect(e.x1, e.y1, e.width, e.height);
	                b.clip();
	                v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());
	                for (r = 0; r < a.dataSeriesIndexes.length; r++) {
	                    var n = a.dataSeriesIndexes[r],
	                        d = this.data[n],
	                        w = d.dataPoints;
	                    if (0 < w.length) {
	                        var m = 5 < p && d.bevelEnabled ? !0 : !1;
	                        b.strokeStyle =
	                            "#4572A7 ";
	                        for (g = 0; g < w.length; g++)
	                            if (w[g].getTime ? t = w[g].x.getTime() : t = w[g].x, !(t < a.axisX.dataInfo.viewPortMin || t > a.axisX.dataInfo.viewPortMax) && "number" === typeof w[g].y) {
	                                l = a.axisX.convertValueToPixel(t);
	                                h = a.axisY.convertValueToPixel(w[g].y);
	                                l = a.axisX.reversed ? l + a.plotType.totalDataSeries * p / 2 - (a.previousDataSeriesCount + r) * p << 0 : l - a.plotType.totalDataSeries * p / 2 + (a.previousDataSeriesCount + r) * p << 0;
	                                var D = a.axisX.reversed ? l - p << 0 : l + p << 0,
	                                    u;
	                                0 <= w[g].y ? u = k : (u = h, h = k);
	                                c = w[g].color ? w[g].color : d._colorSet[g % d._colorSet.length];
	                                V(b, u, l, h, D, c, 0, null, m, !1, !1, !1, d.fillOpacity);
	                                c = d.dataPointIds[g];
	                                this._eventManager.objectMap[c] = {
	                                    id: c,
	                                    objectType: "dataPoint",
	                                    dataSeriesIndex: n,
	                                    dataPointIndex: g,
	                                    x1: u,
	                                    y1: l,
	                                    x2: h,
	                                    y2: D
	                                };
	                                c = R(c);
	                                v && V(this._eventManager.ghostCtx, u, l, h, D, c, 0, null, !1, !1, !1, !1);
	                                (w[g].indexLabel || d.indexLabel || w[g].indexLabelFormatter || d.indexLabelFormatter) && this._indexLabels.push({
	                                    chartType: "bar",
	                                    dataPoint: w[g],
	                                    dataSeries: d,
	                                    point: {
	                                        x: 0 <= w[g].y ? h : u,
	                                        y: l + (D - l) / 2
	                                    },
	                                    direction: 0 > w[g].y === a.axisY.reversed ? 1 : -1,
	                                    bounds: {
	                                        x1: Math.min(u,
	                                            h),
	                                        y1: l,
	                                        x2: Math.max(u, h),
	                                        y2: D
	                                    },
	                                    color: c
	                                })
	                            }
	                    }
	                }
	                v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());
	                b.restore();
	                return {
	                    source: f,
	                    dest: this.plotArea.ctx,
	                    animationCallback: H.xScaleAnimation,
	                    easingFunction: H.easing.easeOutQuart,
	                    animationBase: k < a.axisY.bounds.x1 ? a.axisY.bounds.x1 : k > a.axisY.bounds.x2 ? a.axisY.bounds.x2 : k
	                }
	            }
	        };
	        q.prototype.renderStackedBar = function(a) {
	            var f = a.targetCanvasCtx || this.plotArea.ctx,
	                b = v ? this._preRenderCtx : f;
	            if (!(0 >= a.dataSeriesIndexes.length)) {
	                var c = null,
	                    e = this.plotArea,
	                    g = [],
	                    h = [],
	                    l = [],
	                    t = [],
	                    k = 0,
	                    r, p, n = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0),
	                    k = this.dataPointMinWidth ?
	                    this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1;
	                p = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : 0.15 * this.height << 0;
	                var d = a.axisX.dataInfo.minDiff;
	                isFinite(d) || (d = 0.3 * Math.abs(a.axisX.range));
	                d = this.dataPointWidth ? this.dataPointWidth : 0.9 * (e.height * (a.axisX.logarithmic ? Math.log(d) / Math.log(a.axisX.range) : Math.abs(d) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0;
	                this.dataPointMaxWidth && k > p && (k = Math.min(this.dataPointWidth ? this.dataPointWidth :
	                    Infinity, p));
	                !this.dataPointMaxWidth && (this.dataPointMinWidth && p < k) && (p = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, k));
	                d < k && (d = k);
	                d > p && (d = p);
	                b.save();
	                v && this._eventManager.ghostCtx.save();
	                b.beginPath();
	                b.rect(e.x1, e.y1, e.width, e.height);
	                b.clip();
	                v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());
	                for (var w = 0; w < a.dataSeriesIndexes.length; w++) {
	                    var m = a.dataSeriesIndexes[w],
	                        D = this.data[m],
	                        u = D.dataPoints;
	                    if (0 < u.length) {
	                        var q = 5 < d && D.bevelEnabled ? !0 : !1;
	                        b.strokeStyle = "#4572A7 ";
	                        for (k = 0; k < u.length; k++)
	                            if (c = u[k].x.getTime ? u[k].x.getTime() : u[k].x, !(c < a.axisX.dataInfo.viewPortMin || c > a.axisX.dataInfo.viewPortMax) && "number" === typeof u[k].y) {
	                                p = a.axisX.convertValueToPixel(c);
	                                var s = p - a.plotType.plotUnits.length * d / 2 + a.index * d << 0,
	                                    y = s + d << 0,
	                                    B;
	                                if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 < u[k].y) l[c] = u[k].y + (l[c] ? l[c] : 0), 0 < l[c] && (B = g[c] ? g[c] : n, g[c] = r = a.axisY.convertValueToPixel(l[c]));
	                                else if (a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 >= u[k].y) t[c] = u[k].y + (t[c] ? t[c] : 0), r = h[c] ? h[c] : n, h[c] = B = a.axisY.convertValueToPixel(t[c]);
	                                else if (r = a.axisY.convertValueToPixel(u[k].y), 0 <= u[k].y) {
	                                    var A = g[c] ? g[c] : 0;
	                                    B = n + A;
	                                    r += A;
	                                    g[c] = A + (r - B)
	                                } else A = h[c] ? h[c] : 0, B = r - A, r = n - A, h[c] = A + (r - B);
	                                c = u[k].color ? u[k].color : D._colorSet[k % D._colorSet.length];
	                                V(b, B, s, r, y, c, 0, null, q, !1, !1, !1, D.fillOpacity);
	                                c = D.dataPointIds[k];
	                                this._eventManager.objectMap[c] = {
	                                    id: c,
	                                    objectType: "dataPoint",
	                                    dataSeriesIndex: m,
	                                    dataPointIndex: k,
	                                    x1: B,
	                                    y1: s,
	                                    x2: r,
	                                    y2: y
	                                };
	                                c = R(c);
	                                v && V(this._eventManager.ghostCtx, B, s, r, y, c, 0, null, !1, !1, !1, !1);
	                                (u[k].indexLabel || D.indexLabel || u[k].indexLabelFormatter || D.indexLabelFormatter) && this._indexLabels.push({
	                                    chartType: "stackedBar",
	                                    dataPoint: u[k],
	                                    dataSeries: D,
	                                    point: {
	                                        x: 0 <= u[k].y ? r : B,
	                                        y: p
	                                    },
	                                    direction: 0 > u[k].y === a.axisY.reversed ? 1 : -1,
	                                    bounds: {
	                                        x1: Math.min(B, r),
	                                        y1: s,
	                                        x2: Math.max(B, r),
	                                        y2: y
	                                    },
	                                    color: c
	                                })
	                            }
	                    }
	                }
	                v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop",
	                    a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());
	                b.restore();
	                return {
	                    source: f,
	                    dest: this.plotArea.ctx,
	                    animationCallback: H.xScaleAnimation,
	                    easingFunction: H.easing.easeOutQuart,
	                    animationBase: n < a.axisY.bounds.x1 ? a.axisY.bounds.x1 : n > a.axisY.bounds.x2 ? a.axisY.bounds.x2 : n
	                }
	            }
	        };
	        q.prototype.renderStackedBar100 = function(a) {
	            var f = a.targetCanvasCtx || this.plotArea.ctx,
	                b = v ? this._preRenderCtx : f;
	            if (!(0 >= a.dataSeriesIndexes.length)) {
	                var c = null,
	                    e = this.plotArea,
	                    g = [],
	                    h = [],
	                    l = [],
	                    t = [],
	                    k = 0,
	                    r, p, n = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0),
	                    k = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1;
	                p = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth :
	                    0.15 * this.height << 0;
	                var d = a.axisX.dataInfo.minDiff;
	                isFinite(d) || (d = 0.3 * Math.abs(a.axisX.range));
	                d = this.dataPointWidth ? this.dataPointWidth : 0.9 * (e.height * (a.axisX.logarithmic ? Math.log(d) / Math.log(a.axisX.range) : Math.abs(d) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0;
	                this.dataPointMaxWidth && k > p && (k = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, p));
	                !this.dataPointMaxWidth && (this.dataPointMinWidth && p < k) && (p = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, k));
	                d < k && (d =
	                    k);
	                d > p && (d = p);
	                b.save();
	                v && this._eventManager.ghostCtx.save();
	                b.beginPath();
	                b.rect(e.x1, e.y1, e.width, e.height);
	                b.clip();
	                v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());
	                for (var w = 0; w < a.dataSeriesIndexes.length; w++) {
	                    var m = a.dataSeriesIndexes[w],
	                        D = this.data[m],
	                        u = D.dataPoints;
	                    if (0 < u.length) {
	                        var q = 5 < d && D.bevelEnabled ? !0 : !1;
	                        b.strokeStyle = "#4572A7 ";
	                        for (k = 0; k < u.length; k++)
	                            if (c = u[k].x.getTime ? u[k].x.getTime() : u[k].x, !(c < a.axisX.dataInfo.viewPortMin || c > a.axisX.dataInfo.viewPortMax) && "number" === typeof u[k].y) {
	                                p = a.axisX.convertValueToPixel(c);
	                                var s;
	                                s = 0 !== a.dataPointYSums[c] ? 100 * (u[k].y / a.dataPointYSums[c]) : 0;
	                                var y = p - a.plotType.plotUnits.length * d / 2 + a.index * d << 0,
	                                    B = y + d << 0;
	                                if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 < u[k].y) {
	                                    l[c] = s + (l[c] ? l[c] : 0);
	                                    if (0 >= l[c]) continue;
	                                    s = g[c] ? g[c] : n;
	                                    g[c] = r = a.axisY.convertValueToPixel(l[c])
	                                } else if (a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length &&
	                                    0 >= u[k].y) t[c] = s + (t[c] ? t[c] : 0), r = h[c] ? h[c] : n, h[c] = s = a.axisY.convertValueToPixel(t[c]);
	                                else if (r = a.axisY.convertValueToPixel(s), 0 <= u[k].y) {
	                                    var A = g[c] ? g[c] : 0;
	                                    s = n + A;
	                                    r += A;
	                                    g[c] = A + (r - s)
	                                } else A = h[c] ? h[c] : 0, s = r - A, r = n - A, h[c] = A + (r - s);
	                                c = u[k].color ? u[k].color : D._colorSet[k % D._colorSet.length];
	                                V(b, s, y, r, B, c, 0, null, q, !1, !1, !1, D.fillOpacity);
	                                c = D.dataPointIds[k];
	                                this._eventManager.objectMap[c] = {
	                                    id: c,
	                                    objectType: "dataPoint",
	                                    dataSeriesIndex: m,
	                                    dataPointIndex: k,
	                                    x1: s,
	                                    y1: y,
	                                    x2: r,
	                                    y2: B
	                                };
	                                c = R(c);
	                                v && V(this._eventManager.ghostCtx,
	                                    s, y, r, B, c, 0, null, !1, !1, !1, !1);
	                                (u[k].indexLabel || D.indexLabel || u[k].indexLabelFormatter || D.indexLabelFormatter) && this._indexLabels.push({
	                                    chartType: "stackedBar100",
	                                    dataPoint: u[k],
	                                    dataSeries: D,
	                                    point: {
	                                        x: 0 <= u[k].y ? r : s,
	                                        y: p
	                                    },
	                                    direction: 0 > u[k].y === a.axisY.reversed ? 1 : -1,
	                                    bounds: {
	                                        x1: Math.min(s, r),
	                                        y1: y,
	                                        x2: Math.max(s, r),
	                                        y2: B
	                                    },
	                                    color: c
	                                })
	                            }
	                    }
	                }
	                v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height),
	                    a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());
	                b.restore();
	                return {
	                    source: f,
	                    dest: this.plotArea.ctx,
	                    animationCallback: H.xScaleAnimation,
	                    easingFunction: H.easing.easeOutQuart,
	                    animationBase: n < a.axisY.bounds.x1 ? a.axisY.bounds.x1 : n > a.axisY.bounds.x2 ? a.axisY.bounds.x2 : n
	                }
	            }
	        };
	        q.prototype.renderArea =
	            function(a) {
	                var f, b;

	                function c() {
	                    A && (0 < w.lineThickness && g.stroke(), a.axisY.logarithmic || 0 >= a.axisY.viewportMinimum && 0 <= a.axisY.viewportMaximum ? B = y : 0 > a.axisY.viewportMaximum ? B = t.y1 : 0 < a.axisY.viewportMinimum && (B = l.y2), g.lineTo(u, B), g.lineTo(A.x, B), g.closePath(), g.globalAlpha = w.fillOpacity, g.fill(), g.globalAlpha = 1, v && (h.lineTo(u, B), h.lineTo(A.x, B), h.closePath(), h.fill()), g.beginPath(), g.moveTo(u, s), h.beginPath(), h.moveTo(u, s), A = {
	                        x: u,
	                        y: s
	                    })
	                }
	                var e = a.targetCanvasCtx || this.plotArea.ctx,
	                    g = v ? this._preRenderCtx :
	                    e;
	                if (!(0 >= a.dataSeriesIndexes.length)) {
	                    var h = this._eventManager.ghostCtx,
	                        l = a.axisX.lineCoordinates,
	                        t = a.axisY.lineCoordinates,
	                        k = [],
	                        r = this.plotArea,
	                        p;
	                    g.save();
	                    v && h.save();
	                    g.beginPath();
	                    g.rect(r.x1, r.y1, r.width, r.height);
	                    g.clip();
	                    v && (h.beginPath(), h.rect(r.x1, r.y1, r.width, r.height), h.clip());
	                    for (var n = 0; n < a.dataSeriesIndexes.length; n++) {
	                        var d = a.dataSeriesIndexes[n],
	                            w = this.data[d],
	                            m = w.dataPoints,
	                            k = w.id;
	                        this._eventManager.objectMap[k] = {
	                            objectType: "dataSeries",
	                            dataSeriesIndex: d
	                        };
	                        k = R(k);
	                        h.fillStyle = k;
	                        k = [];
	                        f = !0;
	                        var D = 0,
	                            u, s, q, y = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0),
	                            B, A = null;
	                        if (0 < m.length) {
	                            var x = w._colorSet[D % w._colorSet.length],
	                                z = w.lineColor = w.options.lineColor || x,
	                                J = z;
	                            g.fillStyle = x;
	                            g.strokeStyle = z;
	                            g.lineWidth = w.lineThickness;
	                            b = "solid";
	                            if (g.setLineDash) {
	                                var I = G(w.nullDataLineDashType, w.lineThickness);
	                                b = w.lineDashType;
	                                var da = G(b, w.lineThickness);
	                                g.setLineDash(da)
	                            }
	                            for (var ea = !0; D < m.length; D++)
	                                if (q = m[D].x.getTime ? m[D].x.getTime() : m[D].x, !(q < a.axisX.dataInfo.viewPortMin ||
	                                        q > a.axisX.dataInfo.viewPortMax && (!w.connectNullData || !ea)))
	                                    if ("number" !== typeof m[D].y) w.connectNullData || (ea || f) || c(), ea = !0;
	                                    else {
	                                        u = a.axisX.convertValueToPixel(q);
	                                        s = a.axisY.convertValueToPixel(m[D].y);
	                                        f || ea ? (!f && w.connectNullData ? (g.setLineDash && (w.options.nullDataLineDashType || b === w.lineDashType && w.lineDashType !== w.nullDataLineDashType) && (f = u, b = s, u = p.x, s = p.y, c(), g.moveTo(p.x, p.y), u = f, s = b, A = p, b = w.nullDataLineDashType, g.setLineDash(I)), g.lineTo(u, s), v && h.lineTo(u, s)) : (g.beginPath(), g.moveTo(u, s), v &&
	                                            (h.beginPath(), h.moveTo(u, s)), A = {
	                                                x: u,
	                                                y: s
	                                            }), ea = f = !1) : (g.lineTo(u, s), v && h.lineTo(u, s), 0 == D % 250 && c());
	                                        p = {
	                                            x: u,
	                                            y: s
	                                        };
	                                        D < m.length - 1 && (J !== (m[D].lineColor || z) || b !== (m[D].lineDashType || w.lineDashType)) && (c(), J = m[D].lineColor || z, g.strokeStyle = J, g.setLineDash && (m[D].lineDashType ? (b = m[D].lineDashType, g.setLineDash(G(b, w.lineThickness))) : (b = w.lineDashType, g.setLineDash(da))));
	                                        var $ = w.dataPointIds[D];
	                                        this._eventManager.objectMap[$] = {
	                                            id: $,
	                                            objectType: "dataPoint",
	                                            dataSeriesIndex: d,
	                                            dataPointIndex: D,
	                                            x1: u,
	                                            y1: s
	                                        };
	                                        0 !== m[D].markerSize &&
	                                            (0 < m[D].markerSize || 0 < w.markerSize) && (q = w.getMarkerProperties(D, u, s, g), k.push(q), $ = R($), v && k.push({
	                                                x: u,
	                                                y: s,
	                                                ctx: h,
	                                                type: q.type,
	                                                size: q.size,
	                                                color: $,
	                                                borderColor: $,
	                                                borderThickness: q.borderThickness
	                                            }));
	                                        (m[D].indexLabel || w.indexLabel || m[D].indexLabelFormatter || w.indexLabelFormatter) && this._indexLabels.push({
	                                            chartType: "area",
	                                            dataPoint: m[D],
	                                            dataSeries: w,
	                                            point: {
	                                                x: u,
	                                                y: s
	                                            },
	                                            direction: 0 > m[D].y === a.axisY.reversed ? 1 : -1,
	                                            color: x
	                                        })
	                                    }
	                            c();
	                            ja.drawMarkers(k)
	                        }
	                    }
	                    v && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height),
	                        g.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && g.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && g.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), g.clearRect(r.x1, r.y1, r.width, r.height), this._eventManager.ghostCtx.restore());
	                    g.restore();
	                    return {
	                        source: e,
	                        dest: this.plotArea.ctx,
	                        animationCallback: H.xClipAnimation,
	                        easingFunction: H.easing.linear,
	                        animationBase: 0
	                    }
	                }
	            };
	        q.prototype.renderSplineArea = function(a) {
	            function f() {
	                var b = x(q, 2);
	                if (0 < b.length) {
	                    if (0 < p.lineThickness) {
	                        c.beginPath();
	                        c.moveTo(b[0].x, b[0].y);
	                        b[0].newStrokeStyle && (c.strokeStyle = b[0].newStrokeStyle);
	                        b[0].newLineDashArray && c.setLineDash(b[0].newLineDashArray);
	                        for (var d = 0; d < b.length - 3; d += 3)
	                            if (c.bezierCurveTo(b[d + 1].x, b[d + 1].y, b[d + 2].x, b[d + 2].y, b[d + 3].x, b[d + 3].y), v && e.bezierCurveTo(b[d + 1].x, b[d + 1].y, b[d + 2].x, b[d + 2].y, b[d + 3].x, b[d + 3].y), b[d + 3].newStrokeStyle || b[d + 3].newLineDashArray) c.stroke(), c.beginPath(),
	                                c.moveTo(b[d + 3].x, b[d + 3].y), b[d + 3].newStrokeStyle && (c.strokeStyle = b[d + 3].newStrokeStyle), b[d + 3].newLineDashArray && c.setLineDash(b[d + 3].newLineDashArray);
	                        c.stroke()
	                    }
	                    c.beginPath();
	                    c.moveTo(b[0].x, b[0].y);
	                    v && (e.beginPath(), e.moveTo(b[0].x, b[0].y));
	                    for (d = 0; d < b.length - 3; d += 3) c.bezierCurveTo(b[d + 1].x, b[d + 1].y, b[d + 2].x, b[d + 2].y, b[d + 3].x, b[d + 3].y), v && e.bezierCurveTo(b[d + 1].x, b[d + 1].y, b[d + 2].x, b[d + 2].y, b[d + 3].x, b[d + 3].y);
	                    a.axisY.logarithmic || 0 >= a.axisY.viewportMinimum && 0 <= a.axisY.viewportMaximum ? u = D : 0 > a.axisY.viewportMaximum ?
	                        u = h.y1 : 0 < a.axisY.viewportMinimum && (u = g.y2);
	                    s = {
	                        x: b[0].x,
	                        y: b[0].y
	                    };
	                    c.lineTo(b[b.length - 1].x, u);
	                    c.lineTo(s.x, u);
	                    c.closePath();
	                    c.globalAlpha = p.fillOpacity;
	                    c.fill();
	                    c.globalAlpha = 1;
	                    v && (e.lineTo(b[b.length - 1].x, u), e.lineTo(s.x, u), e.closePath(), e.fill())
	                }
	            }
	            var b = a.targetCanvasCtx || this.plotArea.ctx,
	                c = v ? this._preRenderCtx : b;
	            if (!(0 >= a.dataSeriesIndexes.length)) {
	                var e = this._eventManager.ghostCtx,
	                    g = a.axisX.lineCoordinates,
	                    h = a.axisY.lineCoordinates,
	                    l = [],
	                    t = this.plotArea;
	                c.save();
	                v && e.save();
	                c.beginPath();
	                c.rect(t.x1,
	                    t.y1, t.width, t.height);
	                c.clip();
	                v && (e.beginPath(), e.rect(t.x1, t.y1, t.width, t.height), e.clip());
	                for (var k = 0; k < a.dataSeriesIndexes.length; k++) {
	                    var r = a.dataSeriesIndexes[k],
	                        p = this.data[r],
	                        n = p.dataPoints,
	                        l = p.id;
	                    this._eventManager.objectMap[l] = {
	                        objectType: "dataSeries",
	                        dataSeriesIndex: r
	                    };
	                    l = R(l);
	                    e.fillStyle = l;
	                    var l = [],
	                        d = 0,
	                        w, m, D = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0),
	                        u, s = null,
	                        q = [];
	                    if (0 < n.length) {
	                        var y = p._colorSet[d % p._colorSet.length],
	                            B = p.lineColor = p.options.lineColor ||
	                            y,
	                            A = B;
	                        c.fillStyle = y;
	                        c.strokeStyle = B;
	                        c.lineWidth = p.lineThickness;
	                        var z = "solid";
	                        if (c.setLineDash) {
	                            var L = G(p.nullDataLineDashType, p.lineThickness),
	                                z = p.lineDashType,
	                                J = G(z, p.lineThickness);
	                            c.setLineDash(J)
	                        }
	                        for (m = !1; d < n.length; d++)
	                            if (w = n[d].x.getTime ? n[d].x.getTime() : n[d].x, !(w < a.axisX.dataInfo.viewPortMin || w > a.axisX.dataInfo.viewPortMax && (!p.connectNullData || !m)))
	                                if ("number" !== typeof n[d].y) 0 < d && !m && (p.connectNullData ? c.setLineDash && (0 < q.length && (p.options.nullDataLineDashType || !n[d - 1].lineDashType)) &&
	                                    (q[q.length - 1].newLineDashArray = L, z = p.nullDataLineDashType) : (f(), q = [])), m = !0;
	                                else {
	                                    w = a.axisX.convertValueToPixel(w);
	                                    m = a.axisY.convertValueToPixel(n[d].y);
	                                    var I = p.dataPointIds[d];
	                                    this._eventManager.objectMap[I] = {
	                                        id: I,
	                                        objectType: "dataPoint",
	                                        dataSeriesIndex: r,
	                                        dataPointIndex: d,
	                                        x1: w,
	                                        y1: m
	                                    };
	                                    q[q.length] = {
	                                        x: w,
	                                        y: m
	                                    };
	                                    d < n.length - 1 && (A !== (n[d].lineColor || B) || z !== (n[d].lineDashType || p.lineDashType)) && (A = n[d].lineColor || B, q[q.length - 1].newStrokeStyle = A, c.setLineDash && (n[d].lineDashType ? (z = n[d].lineDashType, q[q.length -
	                                        1].newLineDashArray = G(z, p.lineThickness)) : (z = p.lineDashType, q[q.length - 1].newLineDashArray = J)));
	                                    if (0 !== n[d].markerSize && (0 < n[d].markerSize || 0 < p.markerSize)) {
	                                        var da = p.getMarkerProperties(d, w, m, c);
	                                        l.push(da);
	                                        I = R(I);
	                                        v && l.push({
	                                            x: w,
	                                            y: m,
	                                            ctx: e,
	                                            type: da.type,
	                                            size: da.size,
	                                            color: I,
	                                            borderColor: I,
	                                            borderThickness: da.borderThickness
	                                        })
	                                    }(n[d].indexLabel || p.indexLabel || n[d].indexLabelFormatter || p.indexLabelFormatter) && this._indexLabels.push({
	                                        chartType: "splineArea",
	                                        dataPoint: n[d],
	                                        dataSeries: p,
	                                        point: {
	                                            x: w,
	                                            y: m
	                                        },
	                                        direction: 0 >
	                                            n[d].y === a.axisY.reversed ? 1 : -1,
	                                        color: y
	                                    });
	                                    m = !1
	                                }
	                        f();
	                        ja.drawMarkers(l)
	                    }
	                }
	                v && (b.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(t.x1, t.y1, t.width, t.height), this._eventManager.ghostCtx.restore());
	                c.restore();
	                return {
	                    source: b,
	                    dest: this.plotArea.ctx,
	                    animationCallback: H.xClipAnimation,
	                    easingFunction: H.easing.linear,
	                    animationBase: 0
	                }
	            }
	        };
	        q.prototype.renderStepArea = function(a) {
	            var f, b;

	            function c() {
	                A && (0 < w.lineThickness && g.stroke(), a.axisY.logarithmic || 0 >= a.axisY.viewportMinimum && 0 <= a.axisY.viewportMaximum ? B = y : 0 > a.axisY.viewportMaximum ? B = t.y1 : 0 < a.axisY.viewportMinimum && (B = l.y2), g.lineTo(u, B), g.lineTo(A.x, B), g.closePath(), g.globalAlpha = w.fillOpacity, g.fill(), g.globalAlpha = 1, v && (h.lineTo(u, B), h.lineTo(A.x,
	                    B), h.closePath(), h.fill()), g.beginPath(), g.moveTo(u, s), h.beginPath(), h.moveTo(u, s), A = {
	                    x: u,
	                    y: s
	                })
	            }
	            var e = a.targetCanvasCtx || this.plotArea.ctx,
	                g = v ? this._preRenderCtx : e;
	            if (!(0 >= a.dataSeriesIndexes.length)) {
	                var h = this._eventManager.ghostCtx,
	                    l = a.axisX.lineCoordinates,
	                    t = a.axisY.lineCoordinates,
	                    k = [],
	                    r = this.plotArea,
	                    p;
	                g.save();
	                v && h.save();
	                g.beginPath();
	                g.rect(r.x1, r.y1, r.width, r.height);
	                g.clip();
	                v && (h.beginPath(), h.rect(r.x1, r.y1, r.width, r.height), h.clip());
	                for (var n = 0; n < a.dataSeriesIndexes.length; n++) {
	                    var d =
	                        a.dataSeriesIndexes[n],
	                        w = this.data[d],
	                        m = w.dataPoints,
	                        k = w.id;
	                    this._eventManager.objectMap[k] = {
	                        objectType: "dataSeries",
	                        dataSeriesIndex: d
	                    };
	                    k = R(k);
	                    h.fillStyle = k;
	                    k = [];
	                    f = !0;
	                    var D = 0,
	                        u, s, q, y = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0),
	                        B, A = null;
	                    b = !1;
	                    if (0 < m.length) {
	                        var x = w._colorSet[D % w._colorSet.length],
	                            z = w.lineColor = w.options.lineColor || x,
	                            J = z;
	                        g.fillStyle = x;
	                        g.strokeStyle = z;
	                        g.lineWidth = w.lineThickness;
	                        var I = "solid";
	                        if (g.setLineDash) {
	                            var da = G(w.nullDataLineDashType, w.lineThickness),
	                                I = w.lineDashType,
	                                ea = G(I, w.lineThickness);
	                            g.setLineDash(ea)
	                        }
	                        for (; D < m.length; D++)
	                            if (q = m[D].x.getTime ? m[D].x.getTime() : m[D].x, !(q < a.axisX.dataInfo.viewPortMin || q > a.axisX.dataInfo.viewPortMax && (!w.connectNullData || !b))) {
	                                var $ = s;
	                                "number" !== typeof m[D].y ? (w.connectNullData || (b || f) || c(), b = !0) : (u = a.axisX.convertValueToPixel(q), s = a.axisY.convertValueToPixel(m[D].y), f || b ? (!f && w.connectNullData ? (g.setLineDash && (w.options.nullDataLineDashType || I === w.lineDashType && w.lineDashType !== w.nullDataLineDashType) && (f =
	                                        u, b = s, u = p.x, s = p.y, c(), g.moveTo(p.x, p.y), u = f, s = b, A = p, I = w.nullDataLineDashType, g.setLineDash(da)), g.lineTo(u, $), g.lineTo(u, s), v && (h.lineTo(u, $), h.lineTo(u, s))) : (g.beginPath(), g.moveTo(u, s), v && (h.beginPath(), h.moveTo(u, s)), A = {
	                                        x: u,
	                                        y: s
	                                    }), b = f = !1) : (g.lineTo(u, $), v && h.lineTo(u, $), g.lineTo(u, s), v && h.lineTo(u, s), 0 == D % 250 && c()), p = {
	                                        x: u,
	                                        y: s
	                                    }, D < m.length - 1 && (J !== (m[D].lineColor || z) || I !== (m[D].lineDashType || w.lineDashType)) && (c(), J = m[D].lineColor || z, g.strokeStyle = J, g.setLineDash && (m[D].lineDashType ? (I = m[D].lineDashType,
	                                        g.setLineDash(G(I, w.lineThickness))) : (I = w.lineDashType, g.setLineDash(ea)))), q = w.dataPointIds[D], this._eventManager.objectMap[q] = {
	                                        id: q,
	                                        objectType: "dataPoint",
	                                        dataSeriesIndex: d,
	                                        dataPointIndex: D,
	                                        x1: u,
	                                        y1: s
	                                    }, 0 !== m[D].markerSize && (0 < m[D].markerSize || 0 < w.markerSize) && ($ = w.getMarkerProperties(D, u, s, g), k.push($), q = R(q), v && k.push({
	                                        x: u,
	                                        y: s,
	                                        ctx: h,
	                                        type: $.type,
	                                        size: $.size,
	                                        color: q,
	                                        borderColor: q,
	                                        borderThickness: $.borderThickness
	                                    })), (m[D].indexLabel || w.indexLabel || m[D].indexLabelFormatter || w.indexLabelFormatter) &&
	                                    this._indexLabels.push({
	                                        chartType: "stepArea",
	                                        dataPoint: m[D],
	                                        dataSeries: w,
	                                        point: {
	                                            x: u,
	                                            y: s
	                                        },
	                                        direction: 0 > m[D].y === a.axisY.reversed ? 1 : -1,
	                                        color: x
	                                    }))
	                            }
	                        c();
	                        ja.drawMarkers(k)
	                    }
	                }
	                v && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), g.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && g.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && g.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas,
	                    0, 0, this.width, this.height), g.clearRect(r.x1, r.y1, r.width, r.height), this._eventManager.ghostCtx.restore());
	                g.restore();
	                return {
	                    source: e,
	                    dest: this.plotArea.ctx,
	                    animationCallback: H.xClipAnimation,
	                    easingFunction: H.easing.linear,
	                    animationBase: 0
	                }
	            }
	        };
	        q.prototype.renderStackedArea = function(a) {
	            function f() {
	                if (!(1 > t.length)) {
	                    for (0 < A.lineThickness && c.stroke(); 0 < t.length;) {
	                        var a = t.pop();
	                        c.lineTo(a.x, a.y);
	                        v && s.lineTo(a.x, a.y)
	                    }
	                    c.closePath();
	                    c.globalAlpha = A.fillOpacity;
	                    c.fill();
	                    c.globalAlpha = 1;
	                    c.beginPath();
	                    v && (s.closePath(),
	                        s.fill(), s.beginPath());
	                    t = []
	                }
	            }
	            var b = a.targetCanvasCtx || this.plotArea.ctx,
	                c = v ? this._preRenderCtx : b;
	            if (!(0 >= a.dataSeriesIndexes.length)) {
	                var e = null,
	                    g = [],
	                    h = this.plotArea,
	                    l = [],
	                    t = [],
	                    k = [],
	                    r = [],
	                    p = 0,
	                    n, d, w, m = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0),
	                    s = this._eventManager.ghostCtx,
	                    u, q, y;
	                v && s.beginPath();
	                c.save();
	                v && s.save();
	                c.beginPath();
	                c.rect(h.x1, h.y1, h.width, h.height);
	                c.clip();
	                v && (s.beginPath(), s.rect(h.x1, h.y1, h.width, h.height), s.clip());
	                for (var e = [], x = 0; x < a.dataSeriesIndexes.length; x++) {
	                    var B =
	                        a.dataSeriesIndexes[x],
	                        A = this.data[B],
	                        z = A.dataPoints;
	                    A.dataPointIndexes = [];
	                    for (p = 0; p < z.length; p++) B = z[p].x.getTime ? z[p].x.getTime() : z[p].x, A.dataPointIndexes[B] = p, e[B] || (k.push(B), e[B] = !0);
	                    k.sort(Pa)
	                }
	                for (x = 0; x < a.dataSeriesIndexes.length; x++) {
	                    B = a.dataSeriesIndexes[x];
	                    A = this.data[B];
	                    z = A.dataPoints;
	                    q = !0;
	                    t = [];
	                    p = A.id;
	                    this._eventManager.objectMap[p] = {
	                        objectType: "dataSeries",
	                        dataSeriesIndex: B
	                    };
	                    p = R(p);
	                    s.fillStyle = p;
	                    if (0 < k.length) {
	                        var e = A._colorSet[0],
	                            L = A.lineColor = A.options.lineColor || e,
	                            J = L;
	                        c.fillStyle = e;
	                        c.strokeStyle = L;
	                        c.lineWidth = A.lineThickness;
	                        y = "solid";
	                        if (c.setLineDash) {
	                            var I = G(A.nullDataLineDashType, A.lineThickness);
	                            y = A.lineDashType;
	                            var da = G(y, A.lineThickness);
	                            c.setLineDash(da)
	                        }
	                        for (var ea = !0, p = 0; p < k.length; p++) {
	                            w = k[p];
	                            var $ = null,
	                                $ = 0 <= A.dataPointIndexes[w] ? z[A.dataPointIndexes[w]] : {
	                                    x: w,
	                                    y: null
	                                };
	                            if (!(w < a.axisX.dataInfo.viewPortMin || w > a.axisX.dataInfo.viewPortMax && (!A.connectNullData || !ea)))
	                                if ("number" !== typeof $.y) A.connectNullData || (ea || q) || f(), ea = !0;
	                                else {
	                                    n = a.axisX.convertValueToPixel(w);
	                                    var xa =
	                                        l[w] ? l[w] : 0;
	                                    if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length) {
	                                        r[w] = $.y + (r[w] ? r[w] : 0);
	                                        if (0 >= r[w] && a.axisY.logarithmic) continue;
	                                        d = a.axisY.convertValueToPixel(r[w])
	                                    } else d = a.axisY.convertValueToPixel($.y), d -= xa;
	                                    t.push({
	                                        x: n,
	                                        y: m - xa
	                                    });
	                                    l[w] = m - d;
	                                    q || ea ? (!q && A.connectNullData ? (c.setLineDash && (A.options.nullDataLineDashType || y === A.lineDashType && A.lineDashType !== A.nullDataLineDashType) && (q = t.pop(), y = t[t.length - 1], f(), c.moveTo(u.x, u.y), t.push(y), t.push(q), y = A.nullDataLineDashType,
	                                        c.setLineDash(I)), c.lineTo(n, d), v && s.lineTo(n, d)) : (c.beginPath(), c.moveTo(n, d), v && (s.beginPath(), s.moveTo(n, d))), ea = q = !1) : (c.lineTo(n, d), v && s.lineTo(n, d), 0 == p % 250 && (f(), c.moveTo(n, d), v && s.moveTo(n, d), t.push({
	                                        x: n,
	                                        y: m - xa
	                                    })));
	                                    u = {
	                                        x: n,
	                                        y: d
	                                    };
	                                    p < z.length - 1 && (J !== (z[p].lineColor || L) || y !== (z[p].lineDashType || A.lineDashType)) && (f(), c.beginPath(), c.moveTo(n, d), t.push({
	                                        x: n,
	                                        y: m - xa
	                                    }), J = z[p].lineColor || L, c.strokeStyle = J, c.setLineDash && (z[p].lineDashType ? (y = z[p].lineDashType, c.setLineDash(G(y, A.lineThickness))) : (y =
	                                        A.lineDashType, c.setLineDash(da))));
	                                    if (0 <= A.dataPointIndexes[w]) {
	                                        var oa = A.dataPointIds[A.dataPointIndexes[w]];
	                                        this._eventManager.objectMap[oa] = {
	                                            id: oa,
	                                            objectType: "dataPoint",
	                                            dataSeriesIndex: B,
	                                            dataPointIndex: A.dataPointIndexes[w],
	                                            x1: n,
	                                            y1: d
	                                        }
	                                    }
	                                    0 <= A.dataPointIndexes[w] && 0 !== $.markerSize && (0 < $.markerSize || 0 < A.markerSize) && (w = A.getMarkerProperties(A.dataPointIndexes[w], n, d, c), g.push(w), markerColor = R(oa), v && g.push({
	                                        x: n,
	                                        y: d,
	                                        ctx: s,
	                                        type: w.type,
	                                        size: w.size,
	                                        color: markerColor,
	                                        borderColor: markerColor,
	                                        borderThickness: w.borderThickness
	                                    }));
	                                    ($.indexLabel || A.indexLabel || $.indexLabelFormatter || A.indexLabelFormatter) && this._indexLabels.push({
	                                        chartType: "stackedArea",
	                                        dataPoint: $,
	                                        dataSeries: A,
	                                        point: {
	                                            x: n,
	                                            y: d
	                                        },
	                                        direction: 0 > z[p].y === a.axisY.reversed ? 1 : -1,
	                                        color: e
	                                    })
	                                }
	                        }
	                        f();
	                        c.moveTo(n, d);
	                        v && s.moveTo(n, d)
	                    }
	                    delete A.dataPointIndexes
	                }
	                ja.drawMarkers(g);
	                v && (b.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas &&
	                    c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(h.x1, h.y1, h.width, h.height), s.restore());
	                c.restore();
	                return {
	                    source: b,
	                    dest: this.plotArea.ctx,
	                    animationCallback: H.xClipAnimation,
	                    easingFunction: H.easing.linear,
	                    animationBase: 0
	                }
	            }
	        };
	        q.prototype.renderStackedArea100 = function(a) {
	            function f() {
	                for (0 < A.lineThickness && c.stroke(); 0 < t.length;) {
	                    var a = t.pop();
	                    c.lineTo(a.x, a.y);
	                    v && y.lineTo(a.x,
	                        a.y)
	                }
	                c.closePath();
	                c.globalAlpha = A.fillOpacity;
	                c.fill();
	                c.globalAlpha = 1;
	                c.beginPath();
	                v && (y.closePath(), y.fill(), y.beginPath());
	                t = []
	            }
	            var b = a.targetCanvasCtx || this.plotArea.ctx,
	                c = v ? this._preRenderCtx : b;
	            if (!(0 >= a.dataSeriesIndexes.length)) {
	                var e = null,
	                    g = this.plotArea,
	                    h = [],
	                    l = [],
	                    t = [],
	                    k = [],
	                    r = [],
	                    p = 0,
	                    n, d, w, m, s, u, q = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0),
	                    y = this._eventManager.ghostCtx;
	                c.save();
	                v && y.save();
	                c.beginPath();
	                c.rect(g.x1, g.y1, g.width, g.height);
	                c.clip();
	                v && (y.beginPath(),
	                    y.rect(g.x1, g.y1, g.width, g.height), y.clip());
	                for (var e = [], x = 0; x < a.dataSeriesIndexes.length; x++) {
	                    var B = a.dataSeriesIndexes[x],
	                        A = this.data[B],
	                        z = A.dataPoints;
	                    A.dataPointIndexes = [];
	                    for (p = 0; p < z.length; p++) B = z[p].x.getTime ? z[p].x.getTime() : z[p].x, A.dataPointIndexes[B] = p, e[B] || (k.push(B), e[B] = !0);
	                    k.sort(Pa)
	                }
	                for (x = 0; x < a.dataSeriesIndexes.length; x++) {
	                    B = a.dataSeriesIndexes[x];
	                    A = this.data[B];
	                    z = A.dataPoints;
	                    s = !0;
	                    e = A.id;
	                    this._eventManager.objectMap[e] = {
	                        objectType: "dataSeries",
	                        dataSeriesIndex: B
	                    };
	                    e = R(e);
	                    y.fillStyle =
	                        e;
	                    t = [];
	                    if (0 < k.length) {
	                        var e = A._colorSet[p % A._colorSet.length],
	                            L = A.lineColor = A.options.lineColor || e,
	                            J = L;
	                        c.fillStyle = e;
	                        c.strokeStyle = L;
	                        c.lineWidth = A.lineThickness;
	                        u = "solid";
	                        if (c.setLineDash) {
	                            var I = G(A.nullDataLineDashType, A.lineThickness);
	                            u = A.lineDashType;
	                            var da = G(u, A.lineThickness);
	                            c.setLineDash(da)
	                        }
	                        for (var ea = !0, p = 0; p < k.length; p++) {
	                            w = k[p];
	                            var $ = null,
	                                $ = 0 <= A.dataPointIndexes[w] ? z[A.dataPointIndexes[w]] : {
	                                    x: w,
	                                    y: null
	                                };
	                            if (!(w < a.axisX.dataInfo.viewPortMin || w > a.axisX.dataInfo.viewPortMax && (!A.connectNullData ||
	                                    !ea)))
	                                if ("number" !== typeof $.y) A.connectNullData || (ea || s) || f(), ea = !0;
	                                else {
	                                    var xa;
	                                    xa = 0 !== a.dataPointYSums[w] ? 100 * ($.y / a.dataPointYSums[w]) : 0;
	                                    n = a.axisX.convertValueToPixel(w);
	                                    var oa = l[w] ? l[w] : 0;
	                                    if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length) {
	                                        r[w] = xa + (r[w] ? r[w] : 0);
	                                        if (0 >= r[w] && a.axisY.logarithmic) continue;
	                                        d = a.axisY.convertValueToPixel(r[w])
	                                    } else d = a.axisY.convertValueToPixel(xa), d -= oa;
	                                    t.push({
	                                        x: n,
	                                        y: q - oa
	                                    });
	                                    l[w] = q - d;
	                                    s || ea ? (!s && A.connectNullData ? (c.setLineDash &&
	                                        (A.options.nullDataLineDashType || u === A.lineDashType && A.lineDashType !== A.nullDataLineDashType) && (s = t.pop(), u = t[t.length - 1], f(), c.moveTo(m.x, m.y), t.push(u), t.push(s), u = A.nullDataLineDashType, c.setLineDash(I)), c.lineTo(n, d), v && y.lineTo(n, d)) : (c.beginPath(), c.moveTo(n, d), v && (y.beginPath(), y.moveTo(n, d))), ea = s = !1) : (c.lineTo(n, d), v && y.lineTo(n, d), 0 == p % 250 && (f(), c.moveTo(n, d), v && y.moveTo(n, d), t.push({
	                                        x: n,
	                                        y: q - oa
	                                    })));
	                                    m = {
	                                        x: n,
	                                        y: d
	                                    };
	                                    p < z.length - 1 && (J !== (z[p].lineColor || L) || u !== (z[p].lineDashType || A.lineDashType)) &&
	                                        (f(), c.beginPath(), c.moveTo(n, d), t.push({
	                                            x: n,
	                                            y: q - oa
	                                        }), J = z[p].lineColor || L, c.strokeStyle = J, c.setLineDash && (z[p].lineDashType ? (u = z[p].lineDashType, c.setLineDash(G(u, A.lineThickness))) : (u = A.lineDashType, c.setLineDash(da))));
	                                    if (0 <= A.dataPointIndexes[w]) {
	                                        var E = A.dataPointIds[A.dataPointIndexes[w]];
	                                        this._eventManager.objectMap[E] = {
	                                            id: E,
	                                            objectType: "dataPoint",
	                                            dataSeriesIndex: B,
	                                            dataPointIndex: A.dataPointIndexes[w],
	                                            x1: n,
	                                            y1: d
	                                        }
	                                    }
	                                    0 <= A.dataPointIndexes[w] && 0 !== $.markerSize && (0 < $.markerSize || 0 < A.markerSize) && (w =
	                                        A.getMarkerProperties(p, n, d, c), h.push(w), markerColor = R(E), v && h.push({
	                                            x: n,
	                                            y: d,
	                                            ctx: y,
	                                            type: w.type,
	                                            size: w.size,
	                                            color: markerColor,
	                                            borderColor: markerColor,
	                                            borderThickness: w.borderThickness
	                                        }));
	                                    ($.indexLabel || A.indexLabel || $.indexLabelFormatter || A.indexLabelFormatter) && this._indexLabels.push({
	                                        chartType: "stackedArea100",
	                                        dataPoint: $,
	                                        dataSeries: A,
	                                        point: {
	                                            x: n,
	                                            y: d
	                                        },
	                                        direction: 0 > z[p].y === a.axisY.reversed ? 1 : -1,
	                                        color: e
	                                    })
	                                }
	                        }
	                        f();
	                        c.moveTo(n, d);
	                        v && y.moveTo(n, d)
	                    }
	                    delete A.dataPointIndexes
	                }
	                ja.drawMarkers(h);
	                v && (b.drawImage(this._preRenderCanvas,
	                    0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(g.x1, g.y1, g.width, g.height), y.restore());
	                c.restore();
	                return {
	                    source: b,
	                    dest: this.plotArea.ctx,
	                    animationCallback: H.xClipAnimation,
	                    easingFunction: H.easing.linear,
	                    animationBase: 0
	                }
	            }
	        };
	        q.prototype.renderBubble = function(a) {
	            var f = a.targetCanvasCtx || this.plotArea.ctx,
	                b = v ? this._preRenderCtx : f;
	            if (!(0 >= a.dataSeriesIndexes.length)) {
	                var c = this.plotArea,
	                    e = 0,
	                    g, h;
	                b.save();
	                v && this._eventManager.ghostCtx.save();
	                b.beginPath();
	                b.rect(c.x1, c.y1, c.width, c.height);
	                b.clip();
	                v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(c.x1, c.y1, c.width, c.height), this._eventManager.ghostCtx.clip());
	                for (var l = -Infinity, t = Infinity, k = 0; k < a.dataSeriesIndexes.length; k++)
	                    for (var r =
	                            a.dataSeriesIndexes[k], p = this.data[r], n = p.dataPoints, d = 0, e = 0; e < n.length; e++) g = n[e].getTime ? g = n[e].x.getTime() : g = n[e].x, g < a.axisX.dataInfo.viewPortMin || g > a.axisX.dataInfo.viewPortMax || "undefined" === typeof n[e].z || (d = n[e].z, d > l && (l = d), d < t && (t = d));
	                for (var w = 25 * Math.PI, m = Math.max(Math.pow(0.25 * Math.min(c.height, c.width) / 2, 2) * Math.PI, w), k = 0; k < a.dataSeriesIndexes.length; k++)
	                    if (r = a.dataSeriesIndexes[k], p = this.data[r], n = p.dataPoints, 0 < n.length)
	                        for (b.strokeStyle = "#4572A7 ", e = 0; e < n.length; e++)
	                            if (g = n[e].getTime ?
	                                g = n[e].x.getTime() : g = n[e].x, !(g < a.axisX.dataInfo.viewPortMin || g > a.axisX.dataInfo.viewPortMax) && "number" === typeof n[e].y) {
	                                g = a.axisX.convertValueToPixel(g);
	                                h = a.axisY.convertValueToPixel(n[e].y);
	                                var d = n[e].z,
	                                    s = 2 * Math.max(Math.sqrt((l === t ? m / 2 : w + (m - w) / (l - t) * (d - t)) / Math.PI) << 0, 1),
	                                    d = p.getMarkerProperties(e, b);
	                                d.size = s;
	                                b.globalAlpha = p.fillOpacity;
	                                ja.drawMarker(g, h, b, d.type, d.size, d.color, d.borderColor, d.borderThickness);
	                                b.globalAlpha = 1;
	                                var u = p.dataPointIds[e];
	                                this._eventManager.objectMap[u] = {
	                                    id: u,
	                                    objectType: "dataPoint",
	                                    dataSeriesIndex: r,
	                                    dataPointIndex: e,
	                                    x1: g,
	                                    y1: h,
	                                    size: s
	                                };
	                                s = R(u);
	                                v && ja.drawMarker(g, h, this._eventManager.ghostCtx, d.type, d.size, s, s, d.borderThickness);
	                                (n[e].indexLabel || p.indexLabel || n[e].indexLabelFormatter || p.indexLabelFormatter) && this._indexLabels.push({
	                                    chartType: "bubble",
	                                    dataPoint: n[e],
	                                    dataSeries: p,
	                                    point: {
	                                        x: g,
	                                        y: h
	                                    },
	                                    direction: 1,
	                                    bounds: {
	                                        x1: g - d.size / 2,
	                                        y1: h - d.size / 2,
	                                        x2: g + d.size / 2,
	                                        y2: h + d.size / 2
	                                    },
	                                    color: null
	                                })
	                            }
	                v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop",
	                    a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(c.x1, c.y1, c.width, c.height), this._eventManager.ghostCtx.restore());
	                b.restore();
	                return {
	                    source: f,
	                    dest: this.plotArea.ctx,
	                    animationCallback: H.fadeInAnimation,
	                    easingFunction: H.easing.easeInQuad,
	                    animationBase: 0
	                }
	            }
	        };
	        q.prototype.renderScatter =
	            function(a) {
	                var f = a.targetCanvasCtx || this.plotArea.ctx,
	                    b = v ? this._preRenderCtx : f;
	                if (!(0 >= a.dataSeriesIndexes.length)) {
	                    var c = this.plotArea,
	                        e = 0,
	                        g, h;
	                    b.save();
	                    v && this._eventManager.ghostCtx.save();
	                    b.beginPath();
	                    b.rect(c.x1, c.y1, c.width, c.height);
	                    b.clip();
	                    v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(c.x1, c.y1, c.width, c.height), this._eventManager.ghostCtx.clip());
	                    for (var l = 0; l < a.dataSeriesIndexes.length; l++) {
	                        var t = a.dataSeriesIndexes[l],
	                            k = this.data[t],
	                            r = k.dataPoints;
	                        if (0 <
	                            r.length) {
	                            b.strokeStyle = "#4572A7 ";
	                            Math.pow(0.3 * Math.min(c.height, c.width) / 2, 2);
	                            for (var p = 0, n = 0, e = 0; e < r.length; e++)
	                                if (g = r[e].getTime ? g = r[e].x.getTime() : g = r[e].x, !(g < a.axisX.dataInfo.viewPortMin || g > a.axisX.dataInfo.viewPortMax) && "number" === typeof r[e].y) {
	                                    g = a.axisX.convertValueToPixel(g);
	                                    h = a.axisY.convertValueToPixel(r[e].y);
	                                    var d = k.getMarkerProperties(e, g, h, b);
	                                    b.globalAlpha = k.fillOpacity;
	                                    ja.drawMarker(d.x, d.y, d.ctx, d.type, d.size, d.color, d.borderColor, d.borderThickness);
	                                    b.globalAlpha = 1;
	                                    Math.sqrt((p -
	                                        g) * (p - g) + (n - h) * (n - h)) < Math.min(d.size, 5) && r.length > Math.min(this.plotArea.width, this.plotArea.height) || (p = k.dataPointIds[e], this._eventManager.objectMap[p] = {
	                                        id: p,
	                                        objectType: "dataPoint",
	                                        dataSeriesIndex: t,
	                                        dataPointIndex: e,
	                                        x1: g,
	                                        y1: h
	                                    }, p = R(p), v && ja.drawMarker(d.x, d.y, this._eventManager.ghostCtx, d.type, d.size, p, p, d.borderThickness), (r[e].indexLabel || k.indexLabel || r[e].indexLabelFormatter || k.indexLabelFormatter) && this._indexLabels.push({
	                                        chartType: "scatter",
	                                        dataPoint: r[e],
	                                        dataSeries: k,
	                                        point: {
	                                            x: g,
	                                            y: h
	                                        },
	                                        direction: 1,
	                                        bounds: {
	                                            x1: g - d.size / 2,
	                                            y1: h - d.size / 2,
	                                            x2: g + d.size / 2,
	                                            y2: h + d.size / 2
	                                        },
	                                        color: null
	                                    }), p = g, n = h)
	                                }
	                        }
	                    }
	                    v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(c.x1, c.y1, c.width, c.height), this._eventManager.ghostCtx.restore());
	                    b.restore();
	                    return {
	                        source: f,
	                        dest: this.plotArea.ctx,
	                        animationCallback: H.fadeInAnimation,
	                        easingFunction: H.easing.easeInQuad,
	                        animationBase: 0
	                    }
	                }
	            };
	        q.prototype.renderCandlestick = function(a) {
	            var f = a.targetCanvasCtx || this.plotArea.ctx,
	                b = v ? this._preRenderCtx : f,
	                c = this._eventManager.ghostCtx;
	            if (!(0 >= a.dataSeriesIndexes.length)) {
	                var e = null,
	                    g = null,
	                    h = this.plotArea,
	                    l = 0,
	                    t, k, r, p, n, d, e = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1,
	                    g = this.dataPointMaxWidth ? this.dataPointMaxWidth :
	                    this.dataPointWidth ? this.dataPointWidth : 0.015 * this.width,
	                    w = a.axisX.dataInfo.minDiff;
	                isFinite(w) || (w = 0.3 * Math.abs(a.axisX.range));
	                w = this.dataPointWidth ? this.dataPointWidth : 0.7 * h.width * (a.axisX.logarithmic ? Math.log(w) / Math.log(a.axisX.range) : Math.abs(w) / Math.abs(a.axisX.range)) << 0;
	                this.dataPointMaxWidth && e > g && (e = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, g));
	                !this.dataPointMaxWidth && (this.dataPointMinWidth && g < e) && (g = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, e));
	                w < e &&
	                    (w = e);
	                w > g && (w = g);
	                b.save();
	                v && c.save();
	                b.beginPath();
	                b.rect(h.x1, h.y1, h.width, h.height);
	                b.clip();
	                v && (c.beginPath(), c.rect(h.x1, h.y1, h.width, h.height), c.clip());
	                for (var m = 0; m < a.dataSeriesIndexes.length; m++) {
	                    var s = a.dataSeriesIndexes[m],
	                        u = this.data[s],
	                        q = u.dataPoints;
	                    if (0 < q.length)
	                        for (var ca = 5 < w && u.bevelEnabled ? !0 : !1, l = 0; l < q.length; l++)
	                            if (q[l].getTime ? d = q[l].x.getTime() : d = q[l].x, !(d < a.axisX.dataInfo.viewPortMin || d > a.axisX.dataInfo.viewPortMax) && !y(q[l].y) && q[l].y.length && "number" === typeof q[l].y[0] &&
	                                "number" === typeof q[l].y[1] && "number" === typeof q[l].y[2] && "number" === typeof q[l].y[3]) {
	                                t = a.axisX.convertValueToPixel(d);
	                                k = a.axisY.convertValueToPixel(q[l].y[0]);
	                                r = a.axisY.convertValueToPixel(q[l].y[1]);
	                                p = a.axisY.convertValueToPixel(q[l].y[2]);
	                                n = a.axisY.convertValueToPixel(q[l].y[3]);
	                                var x = t - w / 2 << 0,
	                                    B = x + w << 0,
	                                    g = u.options.fallingColor ? u.fallingColor : u._colorSet[0],
	                                    e = q[l].color ? q[l].color : u._colorSet[0],
	                                    A = Math.round(Math.max(1, 0.15 * w)),
	                                    z = 0 === A % 2 ? 0 : 0.5,
	                                    L = u.dataPointIds[l];
	                                this._eventManager.objectMap[L] = {
	                                    id: L,
	                                    objectType: "dataPoint",
	                                    dataSeriesIndex: s,
	                                    dataPointIndex: l,
	                                    x1: x,
	                                    y1: k,
	                                    x2: B,
	                                    y2: r,
	                                    x3: t,
	                                    y3: p,
	                                    x4: t,
	                                    y4: n,
	                                    borderThickness: A,
	                                    color: e
	                                };
	                                b.strokeStyle = e;
	                                b.beginPath();
	                                b.lineWidth = A;
	                                c.lineWidth = Math.max(A, 4);
	                                "candlestick" === u.type ? (b.moveTo(t - z, r), b.lineTo(t - z, Math.min(k, n)), b.stroke(), b.moveTo(t - z, Math.max(k, n)), b.lineTo(t - z, p), b.stroke(), V(b, x, Math.min(k, n), B, Math.max(k, n), q[l].y[0] <= q[l].y[3] ? u.risingColor : g, A, e, ca, ca, !1, !1, u.fillOpacity), v && (e = R(L), c.strokeStyle = e, c.moveTo(t - z, r), c.lineTo(t - z, Math.min(k,
	                                    n)), c.stroke(), c.moveTo(t - z, Math.max(k, n)), c.lineTo(t - z, p), c.stroke(), V(c, x, Math.min(k, n), B, Math.max(k, n), e, 0, null, !1, !1, !1, !1))) : "ohlc" === u.type && (b.moveTo(t - z, r), b.lineTo(t - z, p), b.stroke(), b.beginPath(), b.moveTo(t, k), b.lineTo(x, k), b.stroke(), b.beginPath(), b.moveTo(t, n), b.lineTo(B, n), b.stroke(), v && (e = R(L), c.strokeStyle = e, c.moveTo(t - z, r), c.lineTo(t - z, p), c.stroke(), c.beginPath(), c.moveTo(t, k), c.lineTo(x, k), c.stroke(), c.beginPath(), c.moveTo(t, n), c.lineTo(B, n), c.stroke()));
	                                (q[l].indexLabel || u.indexLabel ||
	                                    q[l].indexLabelFormatter || u.indexLabelFormatter) && this._indexLabels.push({
	                                    chartType: u.type,
	                                    dataPoint: q[l],
	                                    dataSeries: u,
	                                    point: {
	                                        x: x + (B - x) / 2,
	                                        y: a.axisY.reversed ? p : r
	                                    },
	                                    direction: 1,
	                                    bounds: {
	                                        x1: x,
	                                        y1: Math.min(r, p),
	                                        x2: B,
	                                        y2: Math.max(r, p)
	                                    },
	                                    color: e
	                                })
	                            }
	                }
	                v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height),
	                    this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(h.x1, h.y1, h.width, h.height), c.restore());
	                b.restore();
	                return {
	                    source: f,
	                    dest: this.plotArea.ctx,
	                    animationCallback: H.fadeInAnimation,
	                    easingFunction: H.easing.easeInQuad,
	                    animationBase: 0
	                }
	            }
	        };
	        q.prototype.renderBoxAndWhisker = function(a) {
	            var f = a.targetCanvasCtx || this.plotArea.ctx,
	                b = v ? this._preRenderCtx : f,
	                c = this._eventManager.ghostCtx;
	            if (!(0 >= a.dataSeriesIndexes.length)) {
	                var e = null,
	                    g = this.plotArea,
	                    h = 0,
	                    l, t, k, r, p, n, d, e = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1,
	                    h = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : 0.015 * this.width,
	                    w = a.axisX.dataInfo.minDiff;
	                isFinite(w) || (w = 0.3 * Math.abs(a.axisX.range));
	                w = this.dataPointWidth ? this.dataPointWidth : 0.7 * g.width * (a.axisX.logarithmic ? Math.log(w) / Math.log(a.axisX.range) : Math.abs(w) / Math.abs(a.axisX.range)) << 0;
	                this.dataPointMaxWidth && e > h && (e = Math.min(this.dataPointWidth ? this.dataPointWidth :
	                    Infinity, h));
	                !this.dataPointMaxWidth && (this.dataPointMinWidth && h < e) && (h = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, e));
	                w < e && (w = e);
	                w > h && (w = h);
	                b.save();
	                v && c.save();
	                b.beginPath();
	                b.rect(g.x1, g.y1, g.width, g.height);
	                b.clip();
	                v && (c.beginPath(), c.rect(g.x1, g.y1, g.width, g.height), c.clip());
	                for (var m = !1, m = !!a.axisY.reversed, s = 0; s < a.dataSeriesIndexes.length; s++) {
	                    var u = a.dataSeriesIndexes[s],
	                        q = this.data[u],
	                        x = q.dataPoints;
	                    if (0 < x.length)
	                        for (var z = 5 < w && q.bevelEnabled ? !0 : !1, h = 0; h < x.length; h++)
	                            if (x[h].getTime ?
	                                d = x[h].x.getTime() : d = x[h].x, !(d < a.axisX.dataInfo.viewPortMin || d > a.axisX.dataInfo.viewPortMax) && !y(x[h].y) && x[h].y.length && "number" === typeof x[h].y[0] && "number" === typeof x[h].y[1] && "number" === typeof x[h].y[2] && "number" === typeof x[h].y[3] && "number" === typeof x[h].y[4] && 5 === x[h].y.length) {
	                                l = a.axisX.convertValueToPixel(d);
	                                t = a.axisY.convertValueToPixel(x[h].y[0]);
	                                k = a.axisY.convertValueToPixel(x[h].y[1]);
	                                r = a.axisY.convertValueToPixel(x[h].y[2]);
	                                p = a.axisY.convertValueToPixel(x[h].y[3]);
	                                n = a.axisY.convertValueToPixel(x[h].y[4]);
	                                var B = l - w / 2 << 0,
	                                    A = l + w / 2 << 0,
	                                    e = x[h].color ? x[h].color : q._colorSet[0],
	                                    C = Math.round(Math.max(1, 0.15 * w)),
	                                    L = 0 === C % 2 ? 0 : 0.5,
	                                    J = x[h].whiskerColor ? x[h].whiskerColor : x[h].color ? q.whiskerColor ? q.whiskerColor : x[h].color : q.whiskerColor ? q.whiskerColor : e,
	                                    I = "number" === typeof x[h].whiskerThickness ? x[h].whiskerThickness : "number" === typeof q.options.whiskerThickness ? q.whiskerThickness : C,
	                                    da = x[h].whiskerDashType ? x[h].whiskerDashType : q.whiskerDashType,
	                                    ea = y(x[h].whiskerLength) ? y(q.options.whiskerLength) ? w : q.whiskerLength : x[h].whiskerLength,
	                                    ea = "number" === typeof ea ? 0 >= ea ? 0 : ea >= w ? w : ea : "string" === typeof ea ? parseInt(ea) * w / 100 > w ? w : parseInt(ea) * w / 100 : w,
	                                    $ = 1 === Math.round(I) % 2 ? 0.5 : 0,
	                                    xa = x[h].stemColor ? x[h].stemColor : x[h].color ? q.stemColor ? q.stemColor : x[h].color : q.stemColor ? q.stemColor : e,
	                                    oa = "number" === typeof x[h].stemThickness ? x[h].stemThickness : "number" === typeof q.options.stemThickness ? q.stemThickness : C,
	                                    E = 1 === Math.round(oa) % 2 ? 0.5 : 0,
	                                    eb = x[h].stemDashType ? x[h].stemDashType : q.stemDashType,
	                                    P = x[h].lineColor ? x[h].lineColor : x[h].color ? q.lineColor ? q.lineColor :
	                                    x[h].color : q.lineColor ? q.lineColor : e,
	                                    O = "number" === typeof x[h].lineThickness ? x[h].lineThickness : "number" === typeof q.options.lineThickness ? q.lineThickness : C,
	                                    Q = x[h].lineDashType ? x[h].lineDashType : q.lineDashType,
	                                    K = 1 === Math.round(O) % 2 ? 0.5 : 0,
	                                    N = q.upperBoxColor,
	                                    U = q.lowerBoxColor,
	                                    ta = y(q.options.fillOpacity) ? 1 : q.fillOpacity,
	                                    M = q.dataPointIds[h];
	                                this._eventManager.objectMap[M] = {
	                                    id: M,
	                                    objectType: "dataPoint",
	                                    dataSeriesIndex: u,
	                                    dataPointIndex: h,
	                                    x1: B,
	                                    y1: t,
	                                    x2: A,
	                                    y2: k,
	                                    x3: l,
	                                    y3: r,
	                                    x4: l,
	                                    y4: p,
	                                    y5: n,
	                                    borderThickness: C,
	                                    color: e,
	                                    stemThickness: oa,
	                                    stemColor: xa,
	                                    whiskerThickness: I,
	                                    whiskerLength: ea,
	                                    whiskerColor: J,
	                                    lineThickness: O,
	                                    lineColor: P
	                                };
	                                b.save();
	                                0 < oa && (b.beginPath(), b.strokeStyle = xa, b.lineWidth = oa, b.setLineDash && b.setLineDash(G(eb, oa)), b.moveTo(l - E, k), b.lineTo(l - E, t), b.stroke(), b.moveTo(l - E, p), b.lineTo(l - E, r), b.stroke());
	                                b.restore();
	                                c.lineWidth = Math.max(C, 4);
	                                b.beginPath();
	                                V(b, B, Math.min(n, k), A, Math.max(k, n), U, 0, e, m ? z : !1, m ? !1 : z, !1, !1, ta);
	                                b.beginPath();
	                                V(b, B, Math.min(r, n), A, Math.max(n, r), N, 0, e, m ? !1 : z, m ? z : !1, !1, !1, ta);
	                                b.beginPath();
	                                b.lineWidth = C;
	                                b.strokeStyle = e;
	                                b.rect(B - L, Math.min(k, r) - L, A - B + 2 * L, Math.max(k, r) - Math.min(k, r) + 2 * L);
	                                b.stroke();
	                                b.save();
	                                0 < O && (b.beginPath(), b.globalAlpha = 1, b.setLineDash && b.setLineDash(G(Q, O)), b.strokeStyle = P, b.lineWidth = O, b.moveTo(B, n - K), b.lineTo(A, n - K), b.stroke());
	                                b.restore();
	                                b.save();
	                                0 < I && (b.beginPath(), b.setLineDash && b.setLineDash(G(da, I)), b.strokeStyle = J, b.lineWidth = I, b.moveTo(l - ea / 2 << 0, p - $), b.lineTo(l + ea / 2 << 0, p - $), b.stroke(), b.moveTo(l - ea / 2 << 0, t + $), b.lineTo(l + ea / 2 << 0, t + $), b.stroke());
	                                b.restore();
	                                v && (e = R(M), c.strokeStyle = e, c.lineWidth = oa, 0 < oa && (c.moveTo(l - L - E, k), c.lineTo(l - L - E, Math.max(t, p)), c.stroke(), c.moveTo(l - L - E, Math.min(t, p)), c.lineTo(l - L - E, r), c.stroke()), V(c, B, Math.max(k, r), A, Math.min(k, r), e, 0, null, !1, !1, !1, !1), 0 < I && (c.beginPath(), c.lineWidth = I, c.moveTo(l + ea / 2, p - $), c.lineTo(l - ea / 2, p - $), c.stroke(), c.moveTo(l + ea / 2, t + $), c.lineTo(l - ea / 2, t + $), c.stroke()));
	                                (x[h].indexLabel || q.indexLabel || x[h].indexLabelFormatter || q.indexLabelFormatter) && this._indexLabels.push({
	                                    chartType: q.type,
	                                    dataPoint: x[h],
	                                    dataSeries: q,
	                                    point: {
	                                        x: B + (A - B) / 2,
	                                        y: a.axisY.reversed ? t : p
	                                    },
	                                    direction: 1,
	                                    bounds: {
	                                        x1: B,
	                                        y1: Math.min(t, p),
	                                        x2: A,
	                                        y2: Math.max(t, p)
	                                    },
	                                    color: e
	                                })
	                            }
	                }
	                v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height),
	                    b.clearRect(g.x1, g.y1, g.width, g.height), c.restore());
	                b.restore();
	                return {
	                    source: f,
	                    dest: this.plotArea.ctx,
	                    animationCallback: H.fadeInAnimation,
	                    easingFunction: H.easing.easeInQuad,
	                    animationBase: 0
	                }
	            }
	        };
	        q.prototype.renderRangeColumn = function(a) {
	            var f = a.targetCanvasCtx || this.plotArea.ctx,
	                b = v ? this._preRenderCtx : f;
	            if (!(0 >= a.dataSeriesIndexes.length)) {
	                var c = null,
	                    e = this.plotArea,
	                    g = 0,
	                    h, l, t, g = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1;
	                h = this.dataPointMaxWidth ? this.dataPointMaxWidth :
	                    this.dataPointWidth ? this.dataPointWidth : 0.03 * this.width;
	                var k = a.axisX.dataInfo.minDiff;
	                isFinite(k) || (k = 0.3 * Math.abs(a.axisX.range));
	                k = this.dataPointWidth ? this.dataPointWidth : 0.9 * (e.width * (a.axisX.logarithmic ? Math.log(k) / Math.log(a.axisX.range) : Math.abs(k) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0;
	                this.dataPointMaxWidth && g > h && (g = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, h));
	                !this.dataPointMaxWidth && (this.dataPointMinWidth && h < g) && (h = Math.max(this.dataPointWidth ? this.dataPointWidth :
	                    -Infinity, g));
	                k < g && (k = g);
	                k > h && (k = h);
	                b.save();
	                v && this._eventManager.ghostCtx.save();
	                b.beginPath();
	                b.rect(e.x1, e.y1, e.width, e.height);
	                b.clip();
	                v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());
	                for (var r = 0; r < a.dataSeriesIndexes.length; r++) {
	                    var p = a.dataSeriesIndexes[r],
	                        n = this.data[p],
	                        d = n.dataPoints;
	                    if (0 < d.length)
	                        for (var w = 5 < k && n.bevelEnabled ? !0 : !1, g = 0; g < d.length; g++)
	                            if (d[g].getTime ? t = d[g].x.getTime() : t = d[g].x, !(t <
	                                    a.axisX.dataInfo.viewPortMin || t > a.axisX.dataInfo.viewPortMax) && !y(d[g].y) && d[g].y.length && "number" === typeof d[g].y[0] && "number" === typeof d[g].y[1]) {
	                                c = a.axisX.convertValueToPixel(t);
	                                h = a.axisY.convertValueToPixel(d[g].y[0]);
	                                l = a.axisY.convertValueToPixel(d[g].y[1]);
	                                var m = a.axisX.reversed ? c + a.plotType.totalDataSeries * k / 2 - (a.previousDataSeriesCount + r) * k << 0 : c - a.plotType.totalDataSeries * k / 2 + (a.previousDataSeriesCount + r) * k << 0,
	                                    q = a.axisX.reversed ? m - k << 0 : m + k << 0,
	                                    c = d[g].color ? d[g].color : n._colorSet[g % n._colorSet.length];
	                                if (h > l) {
	                                    var u = h;
	                                    h = l;
	                                    l = u
	                                }
	                                u = n.dataPointIds[g];
	                                this._eventManager.objectMap[u] = {
	                                    id: u,
	                                    objectType: "dataPoint",
	                                    dataSeriesIndex: p,
	                                    dataPointIndex: g,
	                                    x1: m,
	                                    y1: h,
	                                    x2: q,
	                                    y2: l
	                                };
	                                V(b, m, h, q, l, c, 0, c, w, w, !1, !1, n.fillOpacity);
	                                c = R(u);
	                                v && V(this._eventManager.ghostCtx, m, h, q, l, c, 0, null, !1, !1, !1, !1);
	                                if (d[g].indexLabel || n.indexLabel || d[g].indexLabelFormatter || n.indexLabelFormatter) this._indexLabels.push({
	                                    chartType: "rangeColumn",
	                                    dataPoint: d[g],
	                                    dataSeries: n,
	                                    indexKeyword: 0,
	                                    point: {
	                                        x: m + (q - m) / 2,
	                                        y: d[g].y[1] >= d[g].y[0] ? l : h
	                                    },
	                                    direction: d[g].y[1] >=
	                                        d[g].y[0] ? -1 : 1,
	                                    bounds: {
	                                        x1: m,
	                                        y1: Math.min(h, l),
	                                        x2: q,
	                                        y2: Math.max(h, l)
	                                    },
	                                    color: c
	                                }), this._indexLabels.push({
	                                    chartType: "rangeColumn",
	                                    dataPoint: d[g],
	                                    dataSeries: n,
	                                    indexKeyword: 1,
	                                    point: {
	                                        x: m + (q - m) / 2,
	                                        y: d[g].y[1] >= d[g].y[0] ? h : l
	                                    },
	                                    direction: d[g].y[1] >= d[g].y[0] ? 1 : -1,
	                                    bounds: {
	                                        x1: m,
	                                        y1: Math.min(h, l),
	                                        x2: q,
	                                        y2: Math.max(h, l)
	                                    },
	                                    color: c
	                                })
	                            }
	                }
	                v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height),
	                    a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());
	                b.restore();
	                return {
	                    source: f,
	                    dest: this.plotArea.ctx,
	                    animationCallback: H.fadeInAnimation,
	                    easingFunction: H.easing.easeInQuad,
	                    animationBase: 0
	                }
	            }
	        };
	        q.prototype.renderError = function(a) {
	            var f = a.targetCanvasCtx || this.plotArea.ctx,
	                b = v ? this._preRenderCtx :
	                f,
	                c = a.axisY._position ? "left" === a.axisY._position || "right" === a.axisY._position ? !1 : !0 : !1;
	            if (!(0 >= a.dataSeriesIndexes.length)) {
	                var e = null,
	                    g = !1,
	                    h = this.plotArea,
	                    l = 0,
	                    t, k, r, p, n, d, w, m = a.axisX.dataInfo.minDiff;
	                isFinite(m) || (m = 0.3 * Math.abs(a.axisX.range));
	                b.save();
	                v && this._eventManager.ghostCtx.save();
	                b.beginPath();
	                b.rect(h.x1, h.y1, h.width, h.height);
	                b.clip();
	                v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(h.x1, h.y1, h.width, h.height), this._eventManager.ghostCtx.clip());
	                for (var q =
	                        0, u = 0; u < this.data.length; u++) !this.data[u].type.match(/(bar|column)/ig) || !this.data[u].visible || this.data[u].type.match(/(stacked)/ig) && q || q++;
	                for (var s = 0; s < a.dataSeriesIndexes.length; s++) {
	                    var x = a.dataSeriesIndexes[s],
	                        ba = this.data[x],
	                        B = ba.dataPoints,
	                        A = y(ba._linkedSeries) ? !1 : ba._linkedSeries.type.match(/(bar|column)/ig) && ba._linkedSeries.visible ? !0 : !1,
	                        C = 0;
	                    if (A)
	                        for (e = ba._linkedSeries.id, u = 0; u < e; u++) !this.data[u].type.match(/(bar|column)/ig) || !this.data[u].visible || this.data[u].type.match(/(stacked)/ig) &&
	                            C || (this.data[u].type.match(/(range)/ig) && (g = !0), C++);
	                    e = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1;
	                    l = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : c ? Math.min(0.15 * this.height, 0.9 * (this.plotArea.height / (A ? q : 1))) << 0 : 0.3 * this.width;
	                    g && (l = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : c ? Math.min(0.15 * this.height, 0.9 * (this.plotArea.height / (A ? q : 1))) << 0 : 0.03 * this.width);
	                    u = this.options.dataPointWidth ?
	                        this.dataPointWidth : 0.9 * ((c ? h.height : h.width) * (a.axisX.logarithmic ? Math.log(m) / Math.log(a.axisX.range) : Math.abs(m) / Math.abs(a.axisX.range)) / (A ? q : 1)) << 0;
	                    this.dataPointMaxWidth && e > l && (e = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, l));
	                    !this.dataPointMaxWidth && (this.dataPointMinWidth && l < e) && (l = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, e));
	                    u < e && (u = e);
	                    u > l && (u = l);
	                    if (0 < B.length)
	                        for (var L = ba._colorSet, l = 0; l < B.length; l++) {
	                            var e = ba.lineColor = ba.options.color ? ba.options.color : L[0],
	                                J = {
	                                    color: B[l].whiskerColor ? B[l].whiskerColor : B[l].color ? ba.whiskerColor ? ba.whiskerColor : B[l].color : ba.whiskerColor ? ba.whiskerColor : e,
	                                    thickness: y(B[l].whiskerThickness) ? ba.whiskerThickness : B[l].whiskerThickness,
	                                    dashType: B[l].whiskerDashType ? B[l].whiskerDashType : ba.whiskerDashType,
	                                    length: y(B[l].whiskerLength) ? y(ba.options.whiskerLength) ? u : ba.options.whiskerLength : B[l].whiskerLength,
	                                    trimLength: y(B[l].whiskerLength) ? y(ba.options.whiskerLength) ? 50 : 0 : 0
	                                };
	                            J.length = "number" === typeof J.length ? 0 >= J.length ? 0 :
	                                J.length >= u ? u : J.length : "string" === typeof J.length ? parseInt(J.length) * u / 100 > u ? u : parseInt(J.length) * u / 100 > u : u;
	                            J.thickness = "number" === typeof J.thickness ? 0 > J.thickness ? 0 : Math.round(J.thickness) : 2;
	                            var I = {
	                                color: B[l].stemColor ? B[l].stemColor : B[l].color ? ba.stemColor ? ba.stemColor : B[l].color : ba.stemColor ? ba.stemColor : e,
	                                thickness: B[l].stemThickness ? B[l].stemThickness : ba.stemThickness,
	                                dashType: B[l].stemDashType ? B[l].stemDashType : ba.stemDashType
	                            };
	                            I.thickness = "number" === typeof I.thickness ? 0 > I.thickness ? 0 : Math.round(I.thickness) :
	                                2;
	                            B[l].getTime ? w = B[l].x.getTime() : w = B[l].x;
	                            if (!(w < a.axisX.dataInfo.viewPortMin || w > a.axisX.dataInfo.viewPortMax) && !y(B[l].y) && B[l].y.length && "number" === typeof B[l].y[0] && "number" === typeof B[l].y[1]) {
	                                var da = a.axisX.convertValueToPixel(w);
	                                c ? k = da : t = da;
	                                da = a.axisY.convertValueToPixel(B[l].y[0]);
	                                c ? r = da : n = da;
	                                da = a.axisY.convertValueToPixel(B[l].y[1]);
	                                c ? p = da : d = da;
	                                c ? (n = a.axisX.reversed ? k + (A ? q : 1) * u / 2 - (A ? C - 1 : 0) * u << 0 : k - (A ? q : 1) * u / 2 + (A ? C - 1 : 0) * u << 0, d = a.axisX.reversed ? n - u << 0 : n + u << 0) : (r = a.axisX.reversed ? t + (A ? q : 1) * u /
	                                    2 - (A ? C - 1 : 0) * u << 0 : t - (A ? q : 1) * u / 2 + (A ? C - 1 : 0) * u << 0, p = a.axisX.reversed ? r - u << 0 : r + u << 0);
	                                !c && n > d && (da = n, n = d, d = da);
	                                c && r > p && (da = r, r = p, p = da);
	                                da = ba.dataPointIds[l];
	                                this._eventManager.objectMap[da] = {
	                                    id: da,
	                                    objectType: "dataPoint",
	                                    dataSeriesIndex: x,
	                                    dataPointIndex: l,
	                                    x1: Math.min(r, p),
	                                    y1: Math.min(n, d),
	                                    x2: Math.max(p, r),
	                                    y2: Math.max(d, n),
	                                    isXYSwapped: c,
	                                    stemProperties: I,
	                                    whiskerProperties: J
	                                };
	                                z(b, Math.min(r, p), Math.min(n, d), Math.max(p, r), Math.max(d, n), e, J, I, c);
	                                v && z(this._eventManager.ghostCtx, r, n, p, d, e, J, I, c);
	                                if (B[l].indexLabel ||
	                                    ba.indexLabel || B[l].indexLabelFormatter || ba.indexLabelFormatter) this._indexLabels.push({
	                                    chartType: "error",
	                                    dataPoint: B[l],
	                                    dataSeries: ba,
	                                    indexKeyword: 0,
	                                    point: {
	                                        x: c ? B[l].y[1] >= B[l].y[0] ? r : p : r + (p - r) / 2,
	                                        y: c ? n + (d - n) / 2 : B[l].y[1] >= B[l].y[0] ? d : n
	                                    },
	                                    direction: B[l].y[1] >= B[l].y[0] ? -1 : 1,
	                                    bounds: {
	                                        x1: c ? Math.min(r, p) : r,
	                                        y1: c ? n : Math.min(n, d),
	                                        x2: c ? Math.max(r, p) : p,
	                                        y2: c ? d : Math.max(n, d)
	                                    },
	                                    color: e,
	                                    axisSwapped: c
	                                }), this._indexLabels.push({
	                                    chartType: "error",
	                                    dataPoint: B[l],
	                                    dataSeries: ba,
	                                    indexKeyword: 1,
	                                    point: {
	                                        x: c ? B[l].y[1] >= B[l].y[0] ?
	                                            p : r : r + (p - r) / 2,
	                                        y: c ? n + (d - n) / 2 : B[l].y[1] >= B[l].y[0] ? n : d
	                                    },
	                                    direction: B[l].y[1] >= B[l].y[0] ? 1 : -1,
	                                    bounds: {
	                                        x1: c ? Math.min(r, p) : r,
	                                        y1: c ? n : Math.min(n, d),
	                                        x2: c ? Math.max(r, p) : p,
	                                        y2: c ? d : Math.max(n, d)
	                                    },
	                                    color: e,
	                                    axisSwapped: c
	                                })
	                            }
	                        }
	                }
	                v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas,
	                    0, 0, this.width, this.height), b.clearRect(h.x1, h.y1, h.width, h.height), this._eventManager.ghostCtx.restore());
	                b.restore();
	                return {
	                    source: f,
	                    dest: this.plotArea.ctx,
	                    animationCallback: H.fadeInAnimation,
	                    easingFunction: H.easing.easeInQuad,
	                    animationBase: 0
	                }
	            }
	        };
	        q.prototype.renderRangeBar = function(a) {
	            var f = a.targetCanvasCtx || this.plotArea.ctx,
	                b = v ? this._preRenderCtx : f;
	            if (!(0 >= a.dataSeriesIndexes.length)) {
	                var c = null,
	                    e = this.plotArea,
	                    g = 0,
	                    h, l, t, k, g = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth :
	                    1;
	                h = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : Math.min(0.15 * this.height, 0.9 * (this.plotArea.height / a.plotType.totalDataSeries)) << 0;
	                var r = a.axisX.dataInfo.minDiff;
	                isFinite(r) || (r = 0.3 * Math.abs(a.axisX.range));
	                r = this.dataPointWidth ? this.dataPointWidth : 0.9 * (e.height * (a.axisX.logarithmic ? Math.log(r) / Math.log(a.axisX.range) : Math.abs(r) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0;
	                this.dataPointMaxWidth && g > h && (g = Math.min(this.dataPointWidth ? this.dataPointWidth :
	                    Infinity, h));
	                !this.dataPointMaxWidth && (this.dataPointMinWidth && h < g) && (h = Math.max(this.dataPointWidth ? this.dataPointWidth : -Infinity, g));
	                r < g && (r = g);
	                r > h && (r = h);
	                b.save();
	                v && this._eventManager.ghostCtx.save();
	                b.beginPath();
	                b.rect(e.x1, e.y1, e.width, e.height);
	                b.clip();
	                v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip());
	                for (var p = 0; p < a.dataSeriesIndexes.length; p++) {
	                    var n = a.dataSeriesIndexes[p],
	                        d = this.data[n],
	                        w = d.dataPoints;
	                    if (0 < w.length) {
	                        var m = 5 < r && d.bevelEnabled ? !0 : !1;
	                        b.strokeStyle = "#4572A7 ";
	                        for (g = 0; g < w.length; g++)
	                            if (w[g].getTime ? k = w[g].x.getTime() : k = w[g].x, !(k < a.axisX.dataInfo.viewPortMin || k > a.axisX.dataInfo.viewPortMax) && !y(w[g].y) && w[g].y.length && "number" === typeof w[g].y[0] && "number" === typeof w[g].y[1]) {
	                                h = a.axisY.convertValueToPixel(w[g].y[0]);
	                                l = a.axisY.convertValueToPixel(w[g].y[1]);
	                                t = a.axisX.convertValueToPixel(k);
	                                t = a.axisX.reversed ? t + a.plotType.totalDataSeries * r / 2 - (a.previousDataSeriesCount + p) * r << 0 : t - a.plotType.totalDataSeries *
	                                    r / 2 + (a.previousDataSeriesCount + p) * r << 0;
	                                var q = a.axisX.reversed ? t - r << 0 : t + r << 0;
	                                h > l && (c = h, h = l, l = c);
	                                c = w[g].color ? w[g].color : d._colorSet[g % d._colorSet.length];
	                                V(b, h, t, l, q, c, 0, null, m, !1, !1, !1, d.fillOpacity);
	                                c = d.dataPointIds[g];
	                                this._eventManager.objectMap[c] = {
	                                    id: c,
	                                    objectType: "dataPoint",
	                                    dataSeriesIndex: n,
	                                    dataPointIndex: g,
	                                    x1: h,
	                                    y1: t,
	                                    x2: l,
	                                    y2: q
	                                };
	                                c = R(c);
	                                v && V(this._eventManager.ghostCtx, h, t, l, q, c, 0, null, !1, !1, !1, !1);
	                                if (w[g].indexLabel || d.indexLabel || w[g].indexLabelFormatter || d.indexLabelFormatter) this._indexLabels.push({
	                                    chartType: "rangeBar",
	                                    dataPoint: w[g],
	                                    dataSeries: d,
	                                    indexKeyword: 0,
	                                    point: {
	                                        x: w[g].y[1] >= w[g].y[0] ? h : l,
	                                        y: t + (q - t) / 2
	                                    },
	                                    direction: w[g].y[1] >= w[g].y[0] ? -1 : 1,
	                                    bounds: {
	                                        x1: Math.min(h, l),
	                                        y1: t,
	                                        x2: Math.max(h, l),
	                                        y2: q
	                                    },
	                                    color: c
	                                }), this._indexLabels.push({
	                                    chartType: "rangeBar",
	                                    dataPoint: w[g],
	                                    dataSeries: d,
	                                    indexKeyword: 1,
	                                    point: {
	                                        x: w[g].y[1] >= w[g].y[0] ? l : h,
	                                        y: t + (q - t) / 2
	                                    },
	                                    direction: w[g].y[1] >= w[g].y[0] ? 1 : -1,
	                                    bounds: {
	                                        x1: Math.min(h, l),
	                                        y1: t,
	                                        x2: Math.max(h, l),
	                                        y2: q
	                                    },
	                                    color: c
	                                })
	                            }
	                    }
	                }
	                v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation =
	                    "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore());
	                b.restore();
	                return {
	                    source: f,
	                    dest: this.plotArea.ctx,
	                    animationCallback: H.fadeInAnimation,
	                    easingFunction: H.easing.easeInQuad,
	                    animationBase: 0
	                }
	            }
	        };
	        q.prototype.renderRangeArea =
	            function(a) {
	                function f() {
	                    if (s) {
	                        var a = null;
	                        0 < r.lineThickness && c.stroke();
	                        for (var b = t.length - 1; 0 <= b; b--) a = t[b], c.lineTo(a.x, a.y), e.lineTo(a.x, a.y);
	                        c.closePath();
	                        c.globalAlpha = r.fillOpacity;
	                        c.fill();
	                        c.globalAlpha = 1;
	                        e.fill();
	                        if (0 < r.lineThickness) {
	                            c.beginPath();
	                            c.moveTo(a.x, a.y);
	                            for (b = 0; b < t.length; b++) a = t[b], c.lineTo(a.x, a.y);
	                            c.stroke()
	                        }
	                        c.beginPath();
	                        c.moveTo(w, m);
	                        e.beginPath();
	                        e.moveTo(w, m);
	                        s = {
	                            x: w,
	                            y: m
	                        };
	                        t = [];
	                        t.push({
	                            x: w,
	                            y: q
	                        })
	                    }
	                }
	                var b = a.targetCanvasCtx || this.plotArea.ctx,
	                    c = v ? this._preRenderCtx : b;
	                if (!(0 >=
	                        a.dataSeriesIndexes.length)) {
	                    var e = this._eventManager.ghostCtx,
	                        g = [],
	                        h = this.plotArea;
	                    c.save();
	                    v && e.save();
	                    c.beginPath();
	                    c.rect(h.x1, h.y1, h.width, h.height);
	                    c.clip();
	                    v && (e.beginPath(), e.rect(h.x1, h.y1, h.width, h.height), e.clip());
	                    for (var l = 0; l < a.dataSeriesIndexes.length; l++) {
	                        var t = [],
	                            k = a.dataSeriesIndexes[l],
	                            r = this.data[k],
	                            p = r.dataPoints,
	                            g = r.id;
	                        this._eventManager.objectMap[g] = {
	                            objectType: "dataSeries",
	                            dataSeriesIndex: k
	                        };
	                        g = R(g);
	                        e.fillStyle = g;
	                        var g = [],
	                            n = !0,
	                            d = 0,
	                            w, m, q, u, s = null;
	                        if (0 < p.length) {
	                            var y = r._colorSet[d %
	                                    r._colorSet.length],
	                                x = r.lineColor = r.options.lineColor || y,
	                                B = x;
	                            c.fillStyle = y;
	                            c.strokeStyle = x;
	                            c.lineWidth = r.lineThickness;
	                            var A = "solid";
	                            if (c.setLineDash) {
	                                var z = G(r.nullDataLineDashType, r.lineThickness),
	                                    A = r.lineDashType,
	                                    C = G(A, r.lineThickness);
	                                c.setLineDash(C)
	                            }
	                            for (var J = !0; d < p.length; d++)
	                                if (u = p[d].x.getTime ? p[d].x.getTime() : p[d].x, !(u < a.axisX.dataInfo.viewPortMin || u > a.axisX.dataInfo.viewPortMax && (!r.connectNullData || !J)))
	                                    if (null !== p[d].y && p[d].y.length && "number" === typeof p[d].y[0] && "number" === typeof p[d].y[1]) {
	                                        w =
	                                            a.axisX.convertValueToPixel(u);
	                                        m = a.axisY.convertValueToPixel(p[d].y[0]);
	                                        q = a.axisY.convertValueToPixel(p[d].y[1]);
	                                        n || J ? (r.connectNullData && !n ? (c.setLineDash && (r.options.nullDataLineDashType || A === r.lineDashType && r.lineDashType !== r.nullDataLineDashType) && (t[t.length - 1].newLineDashArray = C, A = r.nullDataLineDashType, c.setLineDash(z)), c.lineTo(w, m), v && e.lineTo(w, m), t.push({
	                                            x: w,
	                                            y: q
	                                        })) : (c.beginPath(), c.moveTo(w, m), s = {
	                                            x: w,
	                                            y: m
	                                        }, t = [], t.push({
	                                            x: w,
	                                            y: q
	                                        }), v && (e.beginPath(), e.moveTo(w, m))), J = n = !1) : (c.lineTo(w, m), t.push({
	                                            x: w,
	                                            y: q
	                                        }), v && e.lineTo(w, m), 0 == d % 250 && f());
	                                        u = r.dataPointIds[d];
	                                        this._eventManager.objectMap[u] = {
	                                            id: u,
	                                            objectType: "dataPoint",
	                                            dataSeriesIndex: k,
	                                            dataPointIndex: d,
	                                            x1: w,
	                                            y1: m,
	                                            y2: q
	                                        };
	                                        d < p.length - 1 && (B !== (p[d].lineColor || x) || A !== (p[d].lineDashType || r.lineDashType)) && (f(), B = p[d].lineColor || x, t[t.length - 1].newStrokeStyle = B, c.strokeStyle = B, c.setLineDash && (p[d].lineDashType ? (A = p[d].lineDashType, t[t.length - 1].newLineDashArray = G(A, r.lineThickness), c.setLineDash(t[t.length - 1].newLineDashArray)) : (A = r.lineDashType, t[t.length -
	                                            1].newLineDashArray = C, c.setLineDash(C))));
	                                        if (0 !== p[d].markerSize && (0 < p[d].markerSize || 0 < r.markerSize)) {
	                                            var I = r.getMarkerProperties(d, w, q, c);
	                                            g.push(I);
	                                            var da = R(u);
	                                            v && g.push({
	                                                x: w,
	                                                y: q,
	                                                ctx: e,
	                                                type: I.type,
	                                                size: I.size,
	                                                color: da,
	                                                borderColor: da,
	                                                borderThickness: I.borderThickness
	                                            });
	                                            I = r.getMarkerProperties(d, w, m, c);
	                                            g.push(I);
	                                            da = R(u);
	                                            v && g.push({
	                                                x: w,
	                                                y: m,
	                                                ctx: e,
	                                                type: I.type,
	                                                size: I.size,
	                                                color: da,
	                                                borderColor: da,
	                                                borderThickness: I.borderThickness
	                                            })
	                                        }
	                                        if (p[d].indexLabel || r.indexLabel || p[d].indexLabelFormatter || r.indexLabelFormatter) this._indexLabels.push({
	                                            chartType: "rangeArea",
	                                            dataPoint: p[d],
	                                            dataSeries: r,
	                                            indexKeyword: 0,
	                                            point: {
	                                                x: w,
	                                                y: m
	                                            },
	                                            direction: p[d].y[0] > p[d].y[1] === a.axisY.reversed ? -1 : 1,
	                                            color: y
	                                        }), this._indexLabels.push({
	                                            chartType: "rangeArea",
	                                            dataPoint: p[d],
	                                            dataSeries: r,
	                                            indexKeyword: 1,
	                                            point: {
	                                                x: w,
	                                                y: q
	                                            },
	                                            direction: p[d].y[0] > p[d].y[1] === a.axisY.reversed ? 1 : -1,
	                                            color: y
	                                        })
	                                    } else J || n || f(), J = !0;
	                            f();
	                            ja.drawMarkers(g)
	                        }
	                    }
	                    v && (b.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width,
	                        this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(h.x1, h.y1, h.width, h.height), this._eventManager.ghostCtx.restore());
	                    c.restore();
	                    return {
	                        source: b,
	                        dest: this.plotArea.ctx,
	                        animationCallback: H.xClipAnimation,
	                        easingFunction: H.easing.linear,
	                        animationBase: 0
	                    }
	                }
	            };
	        q.prototype.renderRangeSplineArea = function(a) {
	            function f(a, b) {
	                var d = x(m, 2);
	                if (0 < d.length) {
	                    if (0 <
	                        k.lineThickness) {
	                        c.strokeStyle = b;
	                        c.setLineDash && c.setLineDash(a);
	                        c.beginPath();
	                        c.moveTo(d[0].x, d[0].y);
	                        for (var f = 0; f < d.length - 3; f += 3) {
	                            if (d[f].newStrokeStyle || d[f].newLineDashArray) c.stroke(), c.beginPath(), c.moveTo(d[f].x, d[f].y), d[f].newStrokeStyle && (c.strokeStyle = d[f].newStrokeStyle), d[f].newLineDashArray && c.setLineDash(d[f].newLineDashArray);
	                            c.bezierCurveTo(d[f + 1].x, d[f + 1].y, d[f + 2].x, d[f + 2].y, d[f + 3].x, d[f + 3].y)
	                        }
	                        c.stroke()
	                    }
	                    c.beginPath();
	                    c.moveTo(d[0].x, d[0].y);
	                    v && (e.beginPath(), e.moveTo(d[0].x, d[0].y));
	                    for (f = 0; f < d.length - 3; f += 3) c.bezierCurveTo(d[f + 1].x, d[f + 1].y, d[f + 2].x, d[f + 2].y, d[f + 3].x, d[f + 3].y), v && e.bezierCurveTo(d[f + 1].x, d[f + 1].y, d[f + 2].x, d[f + 2].y, d[f + 3].x, d[f + 3].y);
	                    d = x(q, 2);
	                    c.lineTo(q[q.length - 1].x, q[q.length - 1].y);
	                    for (f = d.length - 1; 2 < f; f -= 3) c.bezierCurveTo(d[f - 1].x, d[f - 1].y, d[f - 2].x, d[f - 2].y, d[f - 3].x, d[f - 3].y), v && e.bezierCurveTo(d[f - 1].x, d[f - 1].y, d[f - 2].x, d[f - 2].y, d[f - 3].x, d[f - 3].y);
	                    c.closePath();
	                    c.globalAlpha = k.fillOpacity;
	                    c.fill();
	                    v && (e.closePath(), e.fill());
	                    c.globalAlpha = 1;
	                    if (0 < k.lineThickness) {
	                        c.strokeStyle =
	                            b;
	                        c.setLineDash && c.setLineDash(a);
	                        c.beginPath();
	                        c.moveTo(d[0].x, d[0].y);
	                        for (var g = f = 0; f < d.length - 3; f += 3, g++) {
	                            if (m[g].newStrokeStyle || m[g].newLineDashArray) c.stroke(), c.beginPath(), c.moveTo(d[f].x, d[f].y), m[g].newStrokeStyle && (c.strokeStyle = m[g].newStrokeStyle), m[g].newLineDashArray && c.setLineDash(m[g].newLineDashArray);
	                            c.bezierCurveTo(d[f + 1].x, d[f + 1].y, d[f + 2].x, d[f + 2].y, d[f + 3].x, d[f + 3].y)
	                        }
	                        c.stroke()
	                    }
	                    c.beginPath()
	                }
	            }
	            var b = a.targetCanvasCtx || this.plotArea.ctx,
	                c = v ? this._preRenderCtx : b;
	            if (!(0 >= a.dataSeriesIndexes.length)) {
	                var e =
	                    this._eventManager.ghostCtx,
	                    g = [],
	                    h = this.plotArea;
	                c.save();
	                v && e.save();
	                c.beginPath();
	                c.rect(h.x1, h.y1, h.width, h.height);
	                c.clip();
	                v && (e.beginPath(), e.rect(h.x1, h.y1, h.width, h.height), e.clip());
	                for (var l = 0; l < a.dataSeriesIndexes.length; l++) {
	                    var t = a.dataSeriesIndexes[l],
	                        k = this.data[t],
	                        r = k.dataPoints,
	                        g = k.id;
	                    this._eventManager.objectMap[g] = {
	                        objectType: "dataSeries",
	                        dataSeriesIndex: t
	                    };
	                    g = R(g);
	                    e.fillStyle = g;
	                    var g = [],
	                        p = 0,
	                        n, d, w, m = [],
	                        q = [];
	                    if (0 < r.length) {
	                        var u = k._colorSet[p % k._colorSet.length],
	                            s = k.lineColor = k.options.lineColor ||
	                            u,
	                            y = s;
	                        c.fillStyle = u;
	                        c.lineWidth = k.lineThickness;
	                        var z = "solid",
	                            B;
	                        if (c.setLineDash) {
	                            var A = G(k.nullDataLineDashType, k.lineThickness),
	                                z = k.lineDashType;
	                            B = G(z, k.lineThickness)
	                        }
	                        for (d = !1; p < r.length; p++)
	                            if (n = r[p].x.getTime ? r[p].x.getTime() : r[p].x, !(n < a.axisX.dataInfo.viewPortMin || n > a.axisX.dataInfo.viewPortMax && (!k.connectNullData || !d)))
	                                if (null !== r[p].y && r[p].y.length && "number" === typeof r[p].y[0] && "number" === typeof r[p].y[1]) {
	                                    n = a.axisX.convertValueToPixel(n);
	                                    d = a.axisY.convertValueToPixel(r[p].y[0]);
	                                    w = a.axisY.convertValueToPixel(r[p].y[1]);
	                                    var C = k.dataPointIds[p];
	                                    this._eventManager.objectMap[C] = {
	                                        id: C,
	                                        objectType: "dataPoint",
	                                        dataSeriesIndex: t,
	                                        dataPointIndex: p,
	                                        x1: n,
	                                        y1: d,
	                                        y2: w
	                                    };
	                                    m[m.length] = {
	                                        x: n,
	                                        y: d
	                                    };
	                                    q[q.length] = {
	                                        x: n,
	                                        y: w
	                                    };
	                                    p < r.length - 1 && (y !== (r[p].lineColor || s) || z !== (r[p].lineDashType || k.lineDashType)) && (y = r[p].lineColor || s, m[m.length - 1].newStrokeStyle = y, c.setLineDash && (r[p].lineDashType ? (z = r[p].lineDashType, m[m.length - 1].newLineDashArray = G(z, k.lineThickness)) : (z = k.lineDashType, m[m.length - 1].newLineDashArray = B)));
	                                    if (0 !== r[p].markerSize && (0 <
	                                            r[p].markerSize || 0 < k.markerSize)) {
	                                        var L = k.getMarkerProperties(p, n, d, c);
	                                        g.push(L);
	                                        var J = R(C);
	                                        v && g.push({
	                                            x: n,
	                                            y: d,
	                                            ctx: e,
	                                            type: L.type,
	                                            size: L.size,
	                                            color: J,
	                                            borderColor: J,
	                                            borderThickness: L.borderThickness
	                                        });
	                                        L = k.getMarkerProperties(p, n, w, c);
	                                        g.push(L);
	                                        J = R(C);
	                                        v && g.push({
	                                            x: n,
	                                            y: w,
	                                            ctx: e,
	                                            type: L.type,
	                                            size: L.size,
	                                            color: J,
	                                            borderColor: J,
	                                            borderThickness: L.borderThickness
	                                        })
	                                    }
	                                    if (r[p].indexLabel || k.indexLabel || r[p].indexLabelFormatter || k.indexLabelFormatter) this._indexLabels.push({
	                                        chartType: "rangeSplineArea",
	                                        dataPoint: r[p],
	                                        dataSeries: k,
	                                        indexKeyword: 0,
	                                        point: {
	                                            x: n,
	                                            y: d
	                                        },
	                                        direction: r[p].y[0] <= r[p].y[1] ? -1 : 1,
	                                        color: u
	                                    }), this._indexLabels.push({
	                                        chartType: "rangeSplineArea",
	                                        dataPoint: r[p],
	                                        dataSeries: k,
	                                        indexKeyword: 1,
	                                        point: {
	                                            x: n,
	                                            y: w
	                                        },
	                                        direction: r[p].y[0] <= r[p].y[1] ? 1 : -1,
	                                        color: u
	                                    });
	                                    d = !1
	                                } else 0 < p && !d && (k.connectNullData ? c.setLineDash && (0 < m.length && (k.options.nullDataLineDashType || !r[p - 1].lineDashType)) && (m[m.length - 1].newLineDashArray = A, z = k.nullDataLineDashType) : (f(B, s), m = [], q = [])), d = !0;
	                        f(B, s);
	                        ja.drawMarkers(g)
	                    }
	                }
	                v && (b.drawImage(this._preRenderCanvas,
	                    0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(h.x1, h.y1, h.width, h.height), this._eventManager.ghostCtx.restore());
	                c.restore();
	                return {
	                    source: b,
	                    dest: this.plotArea.ctx,
	                    animationCallback: H.xClipAnimation,
	                    easingFunction: H.easing.linear,
	                    animationBase: 0
	                }
	            }
	        };
	        q.prototype.renderWaterfall = function(a) {
	            var f = a.targetCanvasCtx || this.plotArea.ctx,
	                b = v ? this._preRenderCtx : f;
	            if (!(0 >= a.dataSeriesIndexes.length)) {
	                var c = this._eventManager.ghostCtx,
	                    e = null,
	                    g = this.plotArea,
	                    h = 0,
	                    l, t, k, r, p = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0),
	                    h = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1;
	                t = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : Math.min(0.15 *
	                    this.width, 0.9 * (this.plotArea.width / a.plotType.totalDataSeries)) << 0;
	                var n = a.axisX.dataInfo.minDiff;
	                isFinite(n) || (n = 0.3 * Math.abs(a.axisX.range));
	                n = this.dataPointWidth ? this.dataPointWidth : 0.6 * (g.width * (a.axisX.logarithmic ? Math.log(n) / Math.log(a.axisX.range) : Math.abs(n) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0;
	                this.dataPointMaxWidth && h > t && (h = Math.min(this.dataPointWidth ? this.dataPointWidth : Infinity, t));
	                !this.dataPointMaxWidth && (this.dataPointMinWidth && t < h) && (t = Math.max(this.dataPointWidth ?
	                    this.dataPointWidth : -Infinity, h));
	                n < h && (n = h);
	                n > t && (n = t);
	                b.save();
	                v && this._eventManager.ghostCtx.save();
	                b.beginPath();
	                b.rect(g.x1, g.y1, g.width, g.height);
	                b.clip();
	                v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(g.x1, g.y1, g.width, g.height), this._eventManager.ghostCtx.clip());
	                for (var d = 0; d < a.dataSeriesIndexes.length; d++) {
	                    var w = a.dataSeriesIndexes[d],
	                        m = this.data[w],
	                        q = m.dataPoints,
	                        e = m._colorSet[0];
	                    m.risingColor = m.options.risingColor ? m.options.risingColor : e;
	                    m.fallingColor = m.options.fallingColor ?
	                        m.options.fallingColor : "#e40a0a";
	                    var u = "number" === typeof m.options.lineThickness ? Math.round(m.lineThickness) : 1,
	                        s = 1 === Math.round(u) % 2 ? -0.5 : 0;
	                    if (0 < q.length)
	                        for (var y = 5 < n && m.bevelEnabled ? !0 : !1, x = !1, B = null, A = null, h = 0; h < q.length; h++)
	                            if (q[h].getTime ? r = q[h].x.getTime() : r = q[h].x, "number" !== typeof q[h].y) {
	                                if (0 < h && !x && m.connectNullData) var z = m.options.nullDataLineDashType || !q[h - 1].lineDashType ? m.nullDataLineDashType : q[h - 1].lineDashType;
	                                x = !0
	                            } else {
	                                l = a.axisX.convertValueToPixel(r);
	                                t = 0 === m.dataPointEOs[h].cumulativeSum ?
	                                    p : a.axisY.convertValueToPixel(m.dataPointEOs[h].cumulativeSum);
	                                k = 0 === m.dataPointEOs[h].cumulativeSumYStartValue ? p : a.axisY.convertValueToPixel(m.dataPointEOs[h].cumulativeSumYStartValue);
	                                l = a.axisX.reversed ? l + a.plotType.totalDataSeries * n / 2 - (a.previousDataSeriesCount + d) * n << 0 : l - a.plotType.totalDataSeries * n / 2 + (a.previousDataSeriesCount + d) * n << 0;
	                                var C = a.axisX.reversed ? l - n << 0 : l + n << 0;
	                                t > k && (e = t, t = k, k = e);
	                                a.axisY.reversed && (e = t, t = k, k = e);
	                                e = m.dataPointIds[h];
	                                this._eventManager.objectMap[e] = {
	                                    id: e,
	                                    objectType: "dataPoint",
	                                    dataSeriesIndex: w,
	                                    dataPointIndex: h,
	                                    x1: l,
	                                    y1: t,
	                                    x2: C,
	                                    y2: k
	                                };
	                                var J = q[h].color ? q[h].color : -1 < q[h].y ? m.risingColor : m.fallingColor;
	                                V(b, l, t, C, k, J, 0, J, y, y, !1, !1, m.fillOpacity);
	                                e = R(e);
	                                v && V(this._eventManager.ghostCtx, l, t, C, k, e, 0, null, !1, !1, !1, !1);
	                                var I, J = l;
	                                I = "undefined" !== typeof q[h].isIntermediateSum && !0 === q[h].isIntermediateSum || "undefined" !== typeof q[h].isCumulativeSum && !0 === q[h].isCumulativeSum ? -1 < q[h].y ? t : k : -1 < q[h].y ? k : t;
	                                0 < h && B && (!x || m.connectNullData) && (x && b.setLineDash && b.setLineDash(G(z, u)), b.beginPath(),
	                                    b.moveTo(B, A - s), b.lineTo(J, I - s), 0 < u && b.stroke(), v && (c.beginPath(), c.moveTo(B, A - s), c.lineTo(J, I - s), 0 < u && c.stroke()));
	                                x = !1;
	                                B = C;
	                                A = -1 < q[h].y ? t : k;
	                                J = q[h].lineDashType ? q[h].lineDashType : m.options.lineDashType ? m.options.lineDashType : "shortDash";
	                                b.strokeStyle = q[h].lineColor ? q[h].lineColor : m.options.lineColor ? m.options.lineColor : "#9e9e9e";
	                                b.lineWidth = u;
	                                b.setLineDash && (J = G(J, u), b.setLineDash(J));
	                                (q[h].indexLabel || m.indexLabel || q[h].indexLabelFormatter || m.indexLabelFormatter) && this._indexLabels.push({
	                                    chartType: "waterfall",
	                                    dataPoint: q[h],
	                                    dataSeries: m,
	                                    point: {
	                                        x: l + (C - l) / 2,
	                                        y: 0 <= q[h].y ? t : k
	                                    },
	                                    direction: 0 > q[h].y === a.axisY.reversed ? 1 : -1,
	                                    bounds: {
	                                        x1: l,
	                                        y1: Math.min(t, k),
	                                        x2: C,
	                                        y2: Math.max(t, k)
	                                    },
	                                    color: e
	                                })
	                            }
	                }
	                v && (f.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas,
	                    0, 0, this.width, this.height), b.clearRect(g.x1, g.y1, g.width, g.height), this._eventManager.ghostCtx.restore());
	                b.restore();
	                return {
	                    source: f,
	                    dest: this.plotArea.ctx,
	                    animationCallback: H.fadeInAnimation,
	                    easingFunction: H.easing.easeInQuad,
	                    animationBase: 0
	                }
	            }
	        };
	        var ra = function(a, f, b, c, e, g, h, l, t) {
	            if (!(0 > b)) {
	                "undefined" === typeof l && (l = 1);
	                if (!v) {
	                    var k = Number((h % (2 * Math.PI)).toFixed(8));
	                    Number((g % (2 * Math.PI)).toFixed(8)) === k && (h -= 1E-4)
	                }
	                a.save();
	                a.globalAlpha = l;
	                "pie" === e ? (a.beginPath(), a.moveTo(f.x, f.y), a.arc(f.x, f.y,
	                    b, g, h, !1), a.fillStyle = c, a.strokeStyle = "white", a.lineWidth = 2, a.closePath(), a.fill()) : "doughnut" === e && (a.beginPath(), a.arc(f.x, f.y, b, g, h, !1), 0 <= t && a.arc(f.x, f.y, t * b, h, g, !0), a.closePath(), a.fillStyle = c, a.strokeStyle = "white", a.lineWidth = 2, a.fill());
	                a.globalAlpha = 1;
	                a.restore()
	            }
	        };
	        q.prototype.renderPie = function(a) {
	            function f() {
	                if (k && r) {
	                    for (var a = 0, b = 0, c = 0, e = 0, f = 0; f < r.length; f++) {
	                        var g = r[f],
	                            h = k.dataPointIds[f];
	                        d[f].id = h;
	                        d[f].objectType = "dataPoint";
	                        d[f].dataPointIndex = f;
	                        d[f].dataSeriesIndex = 0;
	                        var l = d[f],
	                            p = {
	                                percent: null,
	                                total: null
	                            },
	                            m = null,
	                            p = t.getPercentAndTotal(k, g);
	                        if (k.indexLabelFormatter || g.indexLabelFormatter) m = {
	                            chart: t.options,
	                            dataSeries: k,
	                            dataPoint: g,
	                            total: p.total,
	                            percent: p.percent
	                        };
	                        p = g.indexLabelFormatter ? g.indexLabelFormatter(m) : g.indexLabel ? t.replaceKeywordsWithValue(g.indexLabel, g, k, f) : k.indexLabelFormatter ? k.indexLabelFormatter(m) : k.indexLabel ? t.replaceKeywordsWithValue(k.indexLabel, g, k, f) : g.label ? g.label : "";
	                        t._eventManager.objectMap[h] = l;
	                        l.center = {
	                            x: x.x,
	                            y: x.y
	                        };
	                        l.y = g.y;
	                        l.radius = A;
	                        l.percentInnerRadius =
	                            L;
	                        l.indexLabelText = p;
	                        l.indexLabelPlacement = k.indexLabelPlacement;
	                        l.indexLabelLineColor = g.indexLabelLineColor ? g.indexLabelLineColor : k.options.indexLabelLineColor ? k.options.indexLabelLineColor : g.color ? g.color : k._colorSet[f % k._colorSet.length];
	                        l.indexLabelLineThickness = y(g.indexLabelLineThickness) ? k.indexLabelLineThickness : g.indexLabelLineThickness;
	                        l.indexLabelLineDashType = g.indexLabelLineDashType ? g.indexLabelLineDashType : k.indexLabelLineDashType;
	                        l.indexLabelFontColor = g.indexLabelFontColor ? g.indexLabelFontColor :
	                            k.indexLabelFontColor;
	                        l.indexLabelFontStyle = g.indexLabelFontStyle ? g.indexLabelFontStyle : k.indexLabelFontStyle;
	                        l.indexLabelFontWeight = g.indexLabelFontWeight ? g.indexLabelFontWeight : k.indexLabelFontWeight;
	                        l.indexLabelFontSize = y(g.indexLabelFontSize) ? k.indexLabelFontSize : g.indexLabelFontSize;
	                        l.indexLabelFontFamily = g.indexLabelFontFamily ? g.indexLabelFontFamily : k.indexLabelFontFamily;
	                        l.indexLabelBackgroundColor = g.indexLabelBackgroundColor ? g.indexLabelBackgroundColor : k.options.indexLabelBackgroundColor ?
	                            k.options.indexLabelBackgroundColor : k.indexLabelBackgroundColor;
	                        l.indexLabelMaxWidth = g.indexLabelMaxWidth ? g.indexLabelMaxWidth : k.indexLabelMaxWidth ? k.indexLabelMaxWidth : 0.33 * n.width;
	                        l.indexLabelWrap = "undefined" !== typeof g.indexLabelWrap ? g.indexLabelWrap : k.indexLabelWrap;
	                        l.startAngle = 0 === f ? k.startAngle ? k.startAngle / 180 * Math.PI : 0 : d[f - 1].endAngle;
	                        l.startAngle = (l.startAngle + 2 * Math.PI) % (2 * Math.PI);
	                        l.endAngle = l.startAngle + 2 * Math.PI / z * Math.abs(g.y);
	                        g = (l.endAngle + l.startAngle) / 2;
	                        g = (g + 2 * Math.PI) % (2 * Math.PI);
	                        l.midAngle = g;
	                        if (l.midAngle > Math.PI / 2 - u && l.midAngle < Math.PI / 2 + u) {
	                            if (0 === a || d[c].midAngle > l.midAngle) c = f;
	                            a++
	                        } else if (l.midAngle > 3 * Math.PI / 2 - u && l.midAngle < 3 * Math.PI / 2 + u) {
	                            if (0 === b || d[e].midAngle > l.midAngle) e = f;
	                            b++
	                        }
	                        l.hemisphere = g > Math.PI / 2 && g <= 3 * Math.PI / 2 ? "left" : "right";
	                        l.indexLabelTextBlock = new la(t.plotArea.ctx, {
	                            fontSize: l.indexLabelFontSize,
	                            fontFamily: l.indexLabelFontFamily,
	                            fontColor: l.indexLabelFontColor,
	                            fontStyle: l.indexLabelFontStyle,
	                            fontWeight: l.indexLabelFontWeight,
	                            horizontalAlign: "left",
	                            backgroundColor: l.indexLabelBackgroundColor,
	                            maxWidth: l.indexLabelMaxWidth,
	                            maxHeight: l.indexLabelWrap ? 5 * l.indexLabelFontSize : 1.5 * l.indexLabelFontSize,
	                            text: l.indexLabelText,
	                            padding: 0,
	                            textBaseline: "top"
	                        });
	                        l.indexLabelTextBlock.measureText()
	                    }
	                    h = g = 0;
	                    p = !1;
	                    for (f = 0; f < r.length; f++) l = d[(c + f) % r.length], 1 < a && (l.midAngle > Math.PI / 2 - u && l.midAngle < Math.PI / 2 + u) && (g <= a / 2 && !p ? (l.hemisphere = "right", g++) : (l.hemisphere = "left", p = !0));
	                    p = !1;
	                    for (f = 0; f < r.length; f++) l = d[(e + f) % r.length], 1 < b && (l.midAngle > 3 * Math.PI / 2 - u && l.midAngle < 3 * Math.PI / 2 + u) && (h <= b / 2 && !p ? (l.hemisphere =
	                        "left", h++) : (l.hemisphere = "right", p = !0))
	                }
	            }

	            function b(a) {
	                var b = t.plotArea.ctx;
	                b.clearRect(n.x1, n.y1, n.width, n.height);
	                b.fillStyle = t.backgroundColor;
	                b.fillRect(n.x1, n.y1, n.width, n.height);
	                for (b = 0; b < r.length; b++) {
	                    var c = d[b].startAngle,
	                        e = d[b].endAngle;
	                    if (e > c) {
	                        var f = 0.07 * A * Math.cos(d[b].midAngle),
	                            g = 0.07 * A * Math.sin(d[b].midAngle),
	                            h = !1;
	                        if (r[b].exploded) {
	                            if (1E-9 < Math.abs(d[b].center.x - (x.x + f)) || 1E-9 < Math.abs(d[b].center.y - (x.y + g))) d[b].center.x = x.x + f * a, d[b].center.y = x.y + g * a, h = !0
	                        } else if (0 < Math.abs(d[b].center.x -
	                                x.x) || 0 < Math.abs(d[b].center.y - x.y)) d[b].center.x = x.x + f * (1 - a), d[b].center.y = x.y + g * (1 - a), h = !0;
	                        h && (f = {}, f.dataSeries = k, f.dataPoint = k.dataPoints[b], f.index = b, t.toolTip.highlightObjects([f]));
	                        ra(t.plotArea.ctx, d[b].center, d[b].radius, r[b].color ? r[b].color : k._colorSet[b % k._colorSet.length], k.type, c, e, k.fillOpacity, d[b].percentInnerRadius)
	                    }
	                }
	                a = t.plotArea.ctx;
	                a.save();
	                a.fillStyle = "black";
	                a.strokeStyle = "grey";
	                a.textBaseline = "middle";
	                a.lineJoin = "round";
	                for (b = b = 0; b < r.length; b++) c = d[b], c.indexLabelText && (c.indexLabelTextBlock.y -=
	                    c.indexLabelTextBlock.height / 2, e = 0, e = "left" === c.hemisphere ? "inside" !== k.indexLabelPlacement ? -(c.indexLabelTextBlock.width + p) : -c.indexLabelTextBlock.width / 2 : "inside" !== k.indexLabelPlacement ? p : -c.indexLabelTextBlock.width / 2, c.indexLabelTextBlock.x += e, c.indexLabelTextBlock.render(!0), c.indexLabelTextBlock.x -= e, c.indexLabelTextBlock.y += c.indexLabelTextBlock.height / 2, "inside" !== c.indexLabelPlacement && 0 < c.indexLabelLineThickness && (e = c.center.x + A * Math.cos(c.midAngle), f = c.center.y + A * Math.sin(c.midAngle),
	                        a.strokeStyle = c.indexLabelLineColor, a.lineWidth = c.indexLabelLineThickness, a.setLineDash && a.setLineDash(G(c.indexLabelLineDashType, c.indexLabelLineThickness)), a.beginPath(), a.moveTo(e, f), a.lineTo(c.indexLabelTextBlock.x, c.indexLabelTextBlock.y), a.lineTo(c.indexLabelTextBlock.x + ("left" === c.hemisphere ? -p : p), c.indexLabelTextBlock.y), a.stroke()), a.lineJoin = "miter");
	                a.save()
	            }

	            function c(a, b) {
	                var c = 0,
	                    c = a.indexLabelTextBlock.y - a.indexLabelTextBlock.height / 2,
	                    d = a.indexLabelTextBlock.y + a.indexLabelTextBlock.height /
	                    2,
	                    e = b.indexLabelTextBlock.y - b.indexLabelTextBlock.height / 2,
	                    f = b.indexLabelTextBlock.y + b.indexLabelTextBlock.height / 2;
	                return c = b.indexLabelTextBlock.y > a.indexLabelTextBlock.y ? e - d : c - f
	            }

	            function e(a) {
	                for (var b = null, e = 1; e < r.length; e++)
	                    if (b = (a + e + d.length) % d.length, d[b].hemisphere !== d[a].hemisphere) {
	                        b = null;
	                        break
	                    } else if (d[b].indexLabelText && b !== a && (0 > c(d[b], d[a]) || ("right" === d[a].hemisphere ? d[b].indexLabelTextBlock.y >= d[a].indexLabelTextBlock.y : d[b].indexLabelTextBlock.y <= d[a].indexLabelTextBlock.y))) break;
	                else b = null;
	                return b
	            }

	            function g(a, b, f) {
	                f = (f || 0) + 1;
	                if (1E3 < f) return 0;
	                b = b || 0;
	                var k = 0,
	                    h = x.y - 1 * q,
	                    n = x.y + 1 * q;
	                if (0 <= a && a < r.length) {
	                    var l = d[a];
	                    if (0 > b && l.indexLabelTextBlock.y < h || 0 < b && l.indexLabelTextBlock.y > n) return 0;
	                    var t = 0,
	                        p = 0,
	                        p = t = t = 0;
	                    0 > b ? l.indexLabelTextBlock.y - l.indexLabelTextBlock.height / 2 > h && l.indexLabelTextBlock.y - l.indexLabelTextBlock.height / 2 + b < h && (b = -(h - (l.indexLabelTextBlock.y - l.indexLabelTextBlock.height / 2 + b))) : l.indexLabelTextBlock.y + l.indexLabelTextBlock.height / 2 < h && l.indexLabelTextBlock.y +
	                        l.indexLabelTextBlock.height / 2 + b > n && (b = l.indexLabelTextBlock.y + l.indexLabelTextBlock.height / 2 + b - n);
	                    b = l.indexLabelTextBlock.y + b;
	                    h = 0;
	                    h = "right" === l.hemisphere ? x.x + Math.sqrt(Math.pow(q, 2) - Math.pow(b - x.y, 2)) : x.x - Math.sqrt(Math.pow(q, 2) - Math.pow(b - x.y, 2));
	                    p = x.x + A * Math.cos(l.midAngle);
	                    t = x.y + A * Math.sin(l.midAngle);
	                    t = Math.sqrt(Math.pow(h - p, 2) + Math.pow(b - t, 2));
	                    p = Math.acos(A / q);
	                    t = Math.acos((q * q + A * A - t * t) / (2 * A * q));
	                    b = t < p ? b - l.indexLabelTextBlock.y : 0;
	                    h = null;
	                    for (n = 1; n < r.length; n++)
	                        if (h = (a - n + d.length) % d.length, d[h].hemisphere !==
	                            d[a].hemisphere) {
	                            h = null;
	                            break
	                        } else if (d[h].indexLabelText && d[h].hemisphere === d[a].hemisphere && h !== a && (0 > c(d[h], d[a]) || ("right" === d[a].hemisphere ? d[h].indexLabelTextBlock.y <= d[a].indexLabelTextBlock.y : d[h].indexLabelTextBlock.y >= d[a].indexLabelTextBlock.y))) break;
	                    else h = null;
	                    p = h;
	                    t = e(a);
	                    n = h = 0;
	                    0 > b ? (n = "right" === l.hemisphere ? p : t, k = b, null !== n && (p = -b, b = l.indexLabelTextBlock.y - l.indexLabelTextBlock.height / 2 - (d[n].indexLabelTextBlock.y + d[n].indexLabelTextBlock.height / 2), b - p < m && (h = -p, n = g(n, h, f + 1), +n.toFixed(v) >
	                        +h.toFixed(v) && (k = b > m ? -(b - m) : -(p - (n - h)))))) : 0 < b && (n = "right" === l.hemisphere ? t : p, k = b, null !== n && (p = b, b = d[n].indexLabelTextBlock.y - d[n].indexLabelTextBlock.height / 2 - (l.indexLabelTextBlock.y + l.indexLabelTextBlock.height / 2), b - p < m && (h = p, n = g(n, h, f + 1), +n.toFixed(v) < +h.toFixed(v) && (k = b > m ? b - m : p - (h - n)))));
	                    k && (f = l.indexLabelTextBlock.y + k, b = 0, b = "right" === l.hemisphere ? x.x + Math.sqrt(Math.pow(q, 2) - Math.pow(f - x.y, 2)) : x.x - Math.sqrt(Math.pow(q, 2) - Math.pow(f - x.y, 2)), l.midAngle > Math.PI / 2 - u && l.midAngle < Math.PI / 2 + u ? (h = (a -
	                        1 + d.length) % d.length, h = d[h], a = d[(a + 1 + d.length) % d.length], "left" === l.hemisphere && "right" === h.hemisphere && b > h.indexLabelTextBlock.x ? b = h.indexLabelTextBlock.x - 15 : "right" === l.hemisphere && ("left" === a.hemisphere && b < a.indexLabelTextBlock.x) && (b = a.indexLabelTextBlock.x + 15)) : l.midAngle > 3 * Math.PI / 2 - u && l.midAngle < 3 * Math.PI / 2 + u && (h = (a - 1 + d.length) % d.length, h = d[h], a = d[(a + 1 + d.length) % d.length], "right" === l.hemisphere && "left" === h.hemisphere && b < h.indexLabelTextBlock.x ? b = h.indexLabelTextBlock.x + 15 : "left" === l.hemisphere &&
	                        ("right" === a.hemisphere && b > a.indexLabelTextBlock.x) && (b = a.indexLabelTextBlock.x - 15)), l.indexLabelTextBlock.y = f, l.indexLabelTextBlock.x = b, l.indexLabelAngle = Math.atan2(l.indexLabelTextBlock.y - x.y, l.indexLabelTextBlock.x - x.x))
	                }
	                return k
	            }

	            function h() {
	                var a = t.plotArea.ctx;
	                a.fillStyle = "grey";
	                a.strokeStyle = "grey";
	                a.font = "16px Arial";
	                a.textBaseline = "middle";
	                for (var b = a = 0, f = 0, h = !0, b = 0; 10 > b && (1 > b || 0 < f); b++) {
	                    if (k.radius || !k.radius && "undefined" !== typeof k.innerRadius && null !== k.innerRadius && A - f <= C) h = !1;
	                    h && (A -=
	                        f);
	                    f = 0;
	                    if ("inside" !== k.indexLabelPlacement) {
	                        q = A * s;
	                        for (a = 0; a < r.length; a++) {
	                            var l = d[a];
	                            l.indexLabelTextBlock.x = x.x + q * Math.cos(l.midAngle);
	                            l.indexLabelTextBlock.y = x.y + q * Math.sin(l.midAngle);
	                            l.indexLabelAngle = l.midAngle;
	                            l.radius = A;
	                            l.percentInnerRadius = L
	                        }
	                        for (var u, y, a = 0; a < r.length; a++) {
	                            var l = d[a],
	                                B = e(a);
	                            if (null !== B) {
	                                u = d[a];
	                                y = d[B];
	                                var z = 0,
	                                    z = c(u, y) - m;
	                                if (0 > z) {
	                                    for (var ba = y = 0, G = 0; G < r.length; G++) G !== a && d[G].hemisphere === l.hemisphere && (d[G].indexLabelTextBlock.y < l.indexLabelTextBlock.y ? y++ : ba++);
	                                    y = z / (y + ba || 1) *
	                                        ba;
	                                    var ba = -1 * (z - y),
	                                        H = G = 0;
	                                    "right" === l.hemisphere ? (G = g(a, y), ba = -1 * (z - G), H = g(B, ba), +H.toFixed(v) < +ba.toFixed(v) && +G.toFixed(v) <= +y.toFixed(v) && g(a, -(ba - H))) : (G = g(B, y), ba = -1 * (z - G), H = g(a, ba), +H.toFixed(v) < +ba.toFixed(v) && +G.toFixed(v) <= +y.toFixed(v) && g(B, -(ba - H)))
	                                }
	                            }
	                        }
	                    } else
	                        for (a = 0; a < r.length; a++) l = d[a], q = "pie" === k.type ? 0.7 * A : 0.8 * A, B = x.x + q * Math.cos(l.midAngle), y = x.y + q * Math.sin(l.midAngle), l.indexLabelTextBlock.x = B, l.indexLabelTextBlock.y = y;
	                    for (a = 0; a < r.length; a++)
	                        if (l = d[a], B = l.indexLabelTextBlock.measureText(),
	                            0 !== B.height && 0 !== B.width) B = B = 0, "right" === l.hemisphere ? (B = n.x2 - (l.indexLabelTextBlock.x + l.indexLabelTextBlock.width + p), B *= -1) : B = n.x1 - (l.indexLabelTextBlock.x - l.indexLabelTextBlock.width - p), 0 < B && (!h && l.indexLabelText && (y = "right" === l.hemisphere ? n.x2 - l.indexLabelTextBlock.x : l.indexLabelTextBlock.x - n.x1, 0.3 * l.indexLabelTextBlock.maxWidth > y ? l.indexLabelText = "" : l.indexLabelTextBlock.maxWidth = 0.85 * y, 0.3 * l.indexLabelTextBlock.maxWidth < y && (l.indexLabelTextBlock.x -= "right" === l.hemisphere ? 2 : -2)), Math.abs(l.indexLabelTextBlock.y -
	                            l.indexLabelTextBlock.height / 2 - x.y) < A || Math.abs(l.indexLabelTextBlock.y + l.indexLabelTextBlock.height / 2 - x.y) < A) && (B /= Math.abs(Math.cos(l.indexLabelAngle)), 9 < B && (B *= 0.3), B > f && (f = B)), B = B = 0, 0 < l.indexLabelAngle && l.indexLabelAngle < Math.PI ? (B = n.y2 - (l.indexLabelTextBlock.y + l.indexLabelTextBlock.height / 2 + 5), B *= -1) : B = n.y1 - (l.indexLabelTextBlock.y - l.indexLabelTextBlock.height / 2 - 5), 0 < B && (!h && l.indexLabelText && (y = 0 < l.indexLabelAngle && l.indexLabelAngle < Math.PI ? -1 : 1, 0 === g(a, B * y) && g(a, 2 * y)), Math.abs(l.indexLabelTextBlock.x -
	                            x.x) < A && (B /= Math.abs(Math.sin(l.indexLabelAngle)), 9 < B && (B *= 0.3), B > f && (f = B)));
	                    var K = function(a, b, c) {
	                        for (var e = [], f = 0; e.push(d[b]), b !== c; b = (b + 1 + r.length) % r.length);
	                        e.sort(function(a, b) {
	                            return a.y - b.y
	                        });
	                        for (b = 0; b < e.length; b++)
	                            if (c = e[b], f < 0.7 * a) f += c.indexLabelTextBlock.height, c.indexLabelTextBlock.text = "", c.indexLabelText = "", c.indexLabelTextBlock.measureText();
	                            else break
	                    };
	                    (function() {
	                        for (var a = -1, b = -1, f = 0, g = !1, h = 0; h < r.length; h++)
	                            if (g = !1, u = d[h], u.indexLabelText) {
	                                var k = e(h);
	                                if (null !== k) {
	                                    var l = d[k];
	                                    z = 0;
	                                    z = c(u, l);
	                                    var n;
	                                    if (n = 0 > z) {
	                                        n = u.indexLabelTextBlock.x;
	                                        var t = u.indexLabelTextBlock.y - u.indexLabelTextBlock.height / 2,
	                                            m = u.indexLabelTextBlock.y + u.indexLabelTextBlock.height / 2,
	                                            w = l.indexLabelTextBlock.y - l.indexLabelTextBlock.height / 2,
	                                            q = l.indexLabelTextBlock.x + l.indexLabelTextBlock.width,
	                                            s = l.indexLabelTextBlock.y + l.indexLabelTextBlock.height / 2;
	                                        n = u.indexLabelTextBlock.x + u.indexLabelTextBlock.width < l.indexLabelTextBlock.x - p || n > q + p || t > s + p || m < w - p ? !1 : !0
	                                    }
	                                    n ? (0 > a && (a = h), k !== a && (b = k, f += -z), 0 === h % Math.max(r.length /
	                                        10, 3) && (g = !0)) : g = !0;
	                                    g && (0 < f && 0 <= a && 0 <= b) && (K(f, a, b), b = a = -1, f = 0)
	                                }
	                            }
	                        0 < f && K(f, a, b)
	                    })()
	                }
	            }

	            function l() {
	                t.plotArea.layoutManager.reset();
	                t.title && (t.title.dockInsidePlotArea || "center" === t.title.horizontalAlign && "center" === t.title.verticalAlign) && t.title.render();
	                if (t.subtitles)
	                    for (var a = 0; a < t.subtitles.length; a++) {
	                        var b = t.subtitles[a];
	                        (b.dockInsidePlotArea || "center" === b.horizontalAlign && "center" === b.verticalAlign) && b.render()
	                    }
	                t.legend && (t.legend.dockInsidePlotArea || "center" === t.legend.horizontalAlign && "center" ===
	                    t.legend.verticalAlign) && t.legend.render()
	            }
	            var t = this;
	            if (!(0 >= a.dataSeriesIndexes.length)) {
	                var k = this.data[a.dataSeriesIndexes[0]],
	                    r = k.dataPoints,
	                    p = 10,
	                    n = this.plotArea,
	                    d = k.dataPointEOs,
	                    m = 2,
	                    q, s = 1.3,
	                    u = 20 / 180 * Math.PI,
	                    v = 6,
	                    x = {
	                        x: (n.x2 + n.x1) / 2,
	                        y: (n.y2 + n.y1) / 2
	                    },
	                    z = 0;
	                a = !1;
	                for (var B = 0; B < r.length; B++) z += Math.abs(r[B].y), !a && ("undefined" !== typeof r[B].indexLabel && null !== r[B].indexLabel && 0 < r[B].indexLabel.toString().length) && (a = !0), !a && ("undefined" !== typeof r[B].label && null !== r[B].label && 0 < r[B].label.toString().length) &&
	                    (a = !0);
	                if (0 !== z) {
	                    a = a || "undefined" !== typeof k.indexLabel && null !== k.indexLabel && 0 < k.indexLabel.toString().length;
	                    var A = "inside" !== k.indexLabelPlacement && a ? 0.75 * Math.min(n.width, n.height) / 2 : 0.92 * Math.min(n.width, n.height) / 2;
	                    k.radius && (A = O(k.radius, A));
	                    var C = "undefined" !== typeof k.innerRadius && null !== k.innerRadius ? O(k.innerRadius, A) : 0.7 * A;
	                    k.radius = A;
	                    "doughnut" === k.type && (k.innerRadius = C);
	                    var L = Math.min(C / A, (A - 1) / A);
	                    this.pieDoughnutClickHandler = function(a) {
	                        t.isAnimating || !y(a.dataSeries.explodeOnClick) &&
	                            !a.dataSeries.explodeOnClick || (a = a.dataPoint, a.exploded = a.exploded ? !1 : !0, 1 < this.dataPoints.length && t._animator.animate(0, 500, function(a) {
	                                b(a);
	                                l()
	                            }))
	                    };
	                    f();
	                    h();
	                    h();
	                    h();
	                    h();
	                    this.disableToolTip = !0;
	                    this._animator.animate(0, this.animatedRender ? this.animationDuration : 0, function(a) {
	                        var b = t.plotArea.ctx;
	                        b.clearRect(n.x1, n.y1, n.width, n.height);
	                        b.fillStyle = t.backgroundColor;
	                        b.fillRect(n.x1, n.y1, n.width, n.height);
	                        a = d[0].startAngle + 2 * Math.PI * a;
	                        for (b = 0; b < r.length; b++) {
	                            var c = 0 === b ? d[b].startAngle : e,
	                                e = c + (d[b].endAngle -
	                                    d[b].startAngle),
	                                f = !1;
	                            e > a && (e = a, f = !0);
	                            var g = r[b].color ? r[b].color : k._colorSet[b % k._colorSet.length];
	                            e > c && ra(t.plotArea.ctx, d[b].center, d[b].radius, g, k.type, c, e, k.fillOpacity, d[b].percentInnerRadius);
	                            if (f) break
	                        }
	                        l()
	                    }, function() {
	                        t.disableToolTip = !1;
	                        t._animator.animate(0, t.animatedRender ? 500 : 0, function(a) {
	                            b(a);
	                            l()
	                        })
	                    })
	                }
	            }
	        };
	        var sa = function(a, f, b, c) {
	            "undefined" === typeof b && (b = 1);
	            0 >= Math.round(f.y4 - f.y1) || (a.save(), a.globalAlpha = b, a.beginPath(), a.moveTo(Math.round(f.x1), Math.round(f.y1)), a.lineTo(Math.round(f.x2),
	                Math.round(f.y2)), a.lineTo(Math.round(f.x3), Math.round(f.y3)), a.lineTo(Math.round(f.x4), Math.round(f.y4)), "undefined" !== f.x5 && (a.lineTo(Math.round(f.x5), Math.round(f.y5)), a.lineTo(Math.round(f.x6), Math.round(f.y6))), a.closePath(), a.fillStyle = c ? c : f.color, a.fill(), a.globalAplha = 1, a.restore())
	        };
	        q.prototype.renderFunnel = function(a) {
	            function f() {
	                for (var a = 0, b = [], c = 0; c < x.length; c++) {
	                    if ("undefined" === typeof x[c].y) return -1;
	                    x[c].y = "number" === typeof x[c].y ? x[c].y : 0;
	                    a += Math.abs(x[c].y)
	                }
	                if (0 === a) return -1;
	                for (c =
	                    b[0] = 0; c < x.length; c++) b.push(Math.abs(x[c].y) * O / a);
	                return b
	            }

	            function b() {
	                var a = X,
	                    b = V,
	                    c = K,
	                    d = Y,
	                    e, f;
	                e = Q;
	                f = $ - N;
	                headArea = (f - e) * (b - a + (d - c)) / 2;
	                headArea = Math.abs(headArea);
	                c = Y - K;
	                e = f - e;
	                f = c * (f - $);
	                f = Math.abs(f);
	                f = headArea + f;
	                for (var d = [], g = 0, h = 0; h < x.length; h++) {
	                    if ("undefined" === typeof x[h].y) return -1;
	                    x[h].y = "number" === typeof x[h].y ? x[h].y : 0;
	                    g += Math.abs(x[h].y)
	                }
	                if (0 === g) return -1;
	                for (var k = d[0] = 0, l = 0, n, b = b - a, t = !1, h = 0; h < x.length; h++) a = Math.abs(x[h].y) * f / g, t ? k = 0 == Number(c.toFixed(3)) ? 0 : a / c : (sqrt = fa * fa * b * b - 4 * Math.abs(fa) *
	                    a, 0 > sqrt ? (n = c, k = (b + n) * (e - l) / 2, a -= k, k = e - l, l += e - l, k += 0 == n ? 0 : a / n, l += a / n, t = !0) : (k = (Math.abs(fa) * b - Math.sqrt(sqrt)) / 2, n = b - 2 * k / Math.abs(fa), l += k, l > e && (l -= k, n = c, k = (b + n) * (e - l) / 2, a -= k, k = e - l, l += e - l, k += a / n, l += a / n, t = !0), b = n)), d.push(k);
	                return d
	            }

	            function c() {
	                if (u && x) {
	                    for (var a, b, c, e, f, g, h, k, l, n, t, p, r, m, w = [], q = [], A = {
	                            percent: null,
	                            total: null
	                        }, B = null, z = 0; z < x.length; z++) m = M[z], m = "undefined" !== typeof m.x5 ? (m.y2 + m.y4) / 2 : (m.y2 + m.y3) / 2, m = d(m).x2 + 1, w[z] = P - m - U;
	                    m = 0.5 * U;
	                    for (var z = 0, za = x.length - 1; z < x.length || 0 <= za; z++, za--) {
	                        b =
	                            u.reversed ? x[za] : x[z];
	                        a = b.color ? b.color : u.reversed ? u._colorSet[(x.length - 1 - z) % u._colorSet.length] : u._colorSet[z % u._colorSet.length];
	                        c = b.indexLabelPlacement || u.indexLabelPlacement || "outside";
	                        e = b.indexLabelBackgroundColor || u.indexLabelBackgroundColor || (v ? "transparent" : null);
	                        f = b.indexLabelFontColor || u.indexLabelFontColor || "#979797";
	                        g = y(b.indexLabelFontSize) ? u.indexLabelFontSize : b.indexLabelFontSize;
	                        h = b.indexLabelFontStyle || u.indexLabelFontStyle || "normal";
	                        k = b.indexLabelFontFamily || u.indexLabelFontFamily ||
	                            "arial";
	                        l = b.indexLabelFontWeight || u.indexLabelFontWeight || "normal";
	                        a = b.indexLabelLineColor || u.options.indexLabelLineColor || a;
	                        n = "number" === typeof b.indexLabelLineThickness ? b.indexLabelLineThickness : "number" === typeof u.indexLabelLineThickness ? u.indexLabelLineThickness : 2;
	                        t = b.indexLabelLineDashType || u.indexLabelLineDashType || "solid";
	                        p = "undefined" !== typeof b.indexLabelWrap ? b.indexLabelWrap : "undefined" !== typeof u.indexLabelWrap ? u.indexLabelWrap : !0;
	                        r = u.dataPointIds[z];
	                        s._eventManager.objectMap[r] = {
	                            id: r,
	                            objectType: "dataPoint",
	                            dataPointIndex: z,
	                            dataSeriesIndex: 0,
	                            funnelSection: M[u.reversed ? x.length - 1 - z : z]
	                        };
	                        "inside" === u.indexLabelPlacement && (w[z] = z !== ga ? u.reversed ? M[z].x2 - M[z].x1 : M[z].x3 - M[z].x4 : M[z].x3 - M[z].x6, 20 > w[z] && (w[z] = z !== ga ? u.reversed ? M[z].x3 - M[z].x4 : M[z].x2 - M[z].x1 : M[z].x2 - M[z].x1, w[z] /= 2));
	                        r = b.indexLabelMaxWidth ? b.indexLabelMaxWidth : u.options.indexLabelMaxWidth ? u.indexLabelMaxWidth : w[z];
	                        if (r > w[z] || 0 > r) r = w[z];
	                        q[z] = "inside" === u.indexLabelPlacement ? M[z].height : !1;
	                        A = s.getPercentAndTotal(u, b);
	                        if (u.indexLabelFormatter || b.indexLabelFormatter) B = {
	                            chart: s.options,
	                            dataSeries: u,
	                            dataPoint: b,
	                            total: A.total,
	                            percent: A.percent
	                        };
	                        b = b.indexLabelFormatter ? b.indexLabelFormatter(B) : b.indexLabel ? s.replaceKeywordsWithValue(b.indexLabel, b, u, z) : u.indexLabelFormatter ? u.indexLabelFormatter(B) : u.indexLabel ? s.replaceKeywordsWithValue(u.indexLabel, b, u, z) : b.label ? b.label : "";
	                        0 >= n && (n = 0);
	                        1E3 > r && 1E3 - r < m && (r += 1E3 - r);
	                        R.roundRect || Ca(R);
	                        c = new la(R, {
	                            fontSize: g,
	                            fontFamily: k,
	                            fontColor: f,
	                            fontStyle: h,
	                            fontWeight: l,
	                            horizontalAlign: c,
	                            backgroundColor: e,
	                            maxWidth: r,
	                            maxHeight: !1 === q[z] ? p ? 4.28571429 * g : 1.5 * g : q[z],
	                            text: b,
	                            padding: ha
	                        });
	                        c.measureText();
	                        F.push({
	                            textBlock: c,
	                            id: u.reversed ? za : z,
	                            isDirty: !1,
	                            lineColor: a,
	                            lineThickness: n,
	                            lineDashType: t,
	                            height: c.height < c.maxHeight ? c.height : c.maxHeight,
	                            width: c.width < c.maxWidth ? c.width : c.maxWidth
	                        })
	                    }
	                }
	            }

	            function e() {
	                var a, b, c, d, e, f = [];
	                e = !1;
	                c = 0;
	                for (var g = P - V - U / 2, g = u.options.indexLabelMaxWidth ? u.indexLabelMaxWidth > g ? g : u.indexLabelMaxWidth : g, h = F.length - 1; 0 <= h; h--) {
	                    dataPoint = x[F[h].id];
	                    c = F[h];
	                    d = c.textBlock;
	                    b = (a = n(h) < M.length ? F[n(h)] : null) ? a.textBlock : null;
	                    c = c.height;
	                    a && d.y + c + ha > b.y && (e = !0);
	                    c = dataPoint.indexLabelMaxWidth || g;
	                    if (c > g || 0 > c) c = g;
	                    f.push(c)
	                }
	                if (e)
	                    for (h = F.length - 1; 0 <= h; h--) a = M[h], F[h].textBlock.maxWidth = f[f.length - (h + 1)], F[h].textBlock.measureText(), F[h].textBlock.x = P - g, c = F[h].textBlock.height < F[h].textBlock.maxHeight ? F[h].textBlock.height : F[h].textBlock.maxHeight, e = F[h].textBlock.width < F[h].textBlock.maxWidth ? F[h].textBlock.width : F[h].textBlock.maxWidth, F[h].height = c, F[h].width = e, c = "undefined" !==
	                        typeof a.x5 ? (a.y2 + a.y4) / 2 : (a.y2 + a.y3) / 2, F[h].textBlock.y = c - F[h].height / 2, u.reversed ? (F[h].textBlock.y + F[h].height > T + C && (F[h].textBlock.y = T + C - F[h].height), F[h].textBlock.y < ta - C && (F[h].textBlock.y = ta - C)) : (F[h].textBlock.y < T - C && (F[h].textBlock.y = T - C), F[h].textBlock.y + F[h].height > ta + C && (F[h].textBlock.y = ta + C - F[h].height))
	            }

	            function g() {
	                var a, b, c, e;
	                if ("inside" !== u.indexLabelPlacement)
	                    for (var f = 0; f < M.length; f++) 0 == F[f].textBlock.text.length ? F[f].isDirty = !0 : (a = M[f], c = "undefined" !== typeof a.x5 ? (a.y2 + a.y4) /
	                        2 : (a.y2 + a.y3) / 2, b = u.reversed ? "undefined" !== typeof a.x5 ? c > aa ? d(c).x2 + 1 : (a.x2 + a.x3) / 2 + 1 : (a.x2 + a.x3) / 2 + 1 : "undefined" !== typeof a.x5 ? c < aa ? d(c).x2 + 1 : (a.x4 + a.x3) / 2 + 1 : (a.x2 + a.x3) / 2 + 1, F[f].textBlock.x = b + U, F[f].textBlock.y = c - F[f].height / 2, u.reversed ? (F[f].textBlock.y + F[f].height > T + C && (F[f].textBlock.y = T + C - F[f].height), F[f].textBlock.y < ta - C && (F[f].textBlock.y = ta - C)) : (F[f].textBlock.y < T - C && (F[f].textBlock.y = T - C), F[f].textBlock.y + F[f].height > ta + C && (F[f].textBlock.y = ta + C - F[f].height)));
	                else
	                    for (f = 0; f < M.length; f++) 0 ==
	                        F[f].textBlock.text.length ? F[f].isDirty = !0 : (a = M[f], b = a.height, c = F[f].height, e = F[f].width, b >= c ? (b = f != ga ? (a.x4 + a.x3) / 2 - e / 2 : (a.x5 + a.x4) / 2 - e / 2, c = f != ga ? (a.y1 + a.y3) / 2 - c / 2 : (a.y1 + a.y4) / 2 - c / 2, F[f].textBlock.x = b, F[f].textBlock.y = c) : F[f].isDirty = !0)
	            }

	            function h() {
	                function a(b, c) {
	                    var d;
	                    if (0 > b || b >= F.length) return 0;
	                    var e, f = F[b].textBlock;
	                    if (0 > c) {
	                        c *= -1;
	                        e = p(b);
	                        d = l(e, b);
	                        if (d >= c) return f.y -= c, c;
	                        if (0 == b) return 0 < d && (f.y -= d), d;
	                        d += a(e, -(c - d));
	                        0 < d && (f.y -= d);
	                        return d
	                    }
	                    e = n(b);
	                    d = l(b, e);
	                    if (d >= c) return f.y += c, c;
	                    if (b == M.length -
	                        1) return 0 < d && (f.y += d), d;
	                    d += a(e, c - d);
	                    0 < d && (f.y += d);
	                    return d
	                }

	                function b() {
	                    var a, d, e, f, g = 0,
	                        h;
	                    f = ($ - Q + 2 * C) / t;
	                    h = t;
	                    for (var k, l = 1; l < h; l++) {
	                        e = l * f;
	                        for (var r = F.length - 1; 0 <= r; r--) !F[r].isDirty && (F[r].textBlock.y < e && F[r].textBlock.y + F[r].height > e) && (k = n(r), !(k >= F.length - 1) && F[r].textBlock.y + F[r].height + ha > F[k].textBlock.y && (F[r].textBlock.y = F[r].textBlock.y + F[r].height - e > e - F[r].textBlock.y ? e + 1 : e - F[r].height - 1))
	                    }
	                    for (k = M.length - 1; 0 < k; k--)
	                        if (!F[k].isDirty) {
	                            e = p(k);
	                            if (0 > e && (e = 0, F[e].isDirty)) break;
	                            if (F[k].textBlock.y <
	                                F[e].textBlock.y + F[e].height) {
	                                d = d || k;
	                                f = k;
	                                for (h = 0; F[f].textBlock.y < F[e].textBlock.y + F[e].height + ha;) {
	                                    a = a || F[f].textBlock.y + F[f].height;
	                                    h += F[f].height;
	                                    h += ha;
	                                    f = e;
	                                    if (0 >= f) {
	                                        f = 0;
	                                        h += F[f].height;
	                                        break
	                                    }
	                                    e = p(f);
	                                    if (0 > e) {
	                                        f = 0;
	                                        h += F[f].height;
	                                        break
	                                    }
	                                }
	                                if (f != k) {
	                                    g = F[f].textBlock.y;
	                                    a -= g;
	                                    a = h - a;
	                                    g = c(a, d, f);
	                                    break
	                                }
	                            }
	                        }
	                    return g
	                }

	                function c(a, b, d) {
	                    var e = [],
	                        f = 0,
	                        g = 0;
	                    for (a = Math.abs(a); d <= b; d++) e.push(M[d]);
	                    e.sort(function(a, b) {
	                        return a.height - b.height
	                    });
	                    for (d = 0; d < e.length; d++)
	                        if (b = e[d], f < a) g++, f += F[b.id].height + ha, F[b.id].textBlock.text =
	                            "", F[b.id].indexLabelText = "", F[b.id].isDirty = !0, F[b.id].textBlock.measureText();
	                        else break;
	                    return g
	                }
	                for (var d, e, f, g, h, k, t = 1, r = 0; r < 2 * t; r++) {
	                    for (var m = F.length - 1; 0 <= m && !(previousTextBlock = (previousLabel = 0 <= p(m) ? F[p(m)] : null) ? previousLabel.textBlock : null, f = F[m], g = f.textBlock, k = (h = n(m) < M.length ? F[n(m)] : null) ? h.textBlock : null, d = +f.height.toFixed(6), e = +g.y.toFixed(6), !f.isDirty && (h && e + d + ha > +k.y.toFixed(6)) && (d = g.y + d + ha - k.y, e = a(m, -d), e < d && (0 < e && (d -= e), e = a(n(m), d), e != d))); m--);
	                    b()
	                }
	            }

	            function l(a, b) {
	                return (b <
	                    M.length ? F[b].textBlock.y : u.reversed ? T + C : ta + C) - (0 > a ? u.reversed ? ta - C : T - C : F[a].textBlock.y + F[a].height + ha)
	            }

	            function t(a, b, c) {
	                var d, e, f, h = [],
	                    l = C,
	                    n = []; - 1 !== b && (0 <= ma.indexOf(b) ? (e = ma.indexOf(b), ma.splice(e, 1)) : (ma.push(b), ma = ma.sort(function(a, b) {
	                    return a - b
	                })));
	                if (0 === ma.length) h = ka;
	                else {
	                    e = C * (1 != ma.length || 0 != ma[0] && ma[0] != M.length - 1 ? 2 : 1) / k();
	                    for (var t = 0; t < M.length; t++) {
	                        if (1 == ma.length && 0 == ma[0]) {
	                            if (0 === t) {
	                                h.push(ka[t]);
	                                d = l;
	                                continue
	                            }
	                        } else 0 === t && (d = -1 * l);
	                        h.push(ka[t] + d);
	                        if (0 <= ma.indexOf(t) || t < M.length &&
	                            0 <= ma.indexOf(t + 1)) d += e
	                    }
	                }
	                f = function() {
	                    for (var a = [], b = 0; b < M.length; b++) a.push(h[b] - M[b].y1);
	                    return a
	                }();
	                var p = {
	                    startTime: (new Date).getTime(),
	                    duration: c || 500,
	                    easingFunction: function(a, b, c, d) {
	                        return H.easing.easeOutQuart(a, b, c, d)
	                    },
	                    changeSection: function(a) {
	                        for (var b, c, d = 0; d < M.length; d++) b = f[d], c = M[d], newY = b * a, "undefined" === typeof n[d] && (n[d] = 0), 0 > n && (n *= -1), c.y1 += newY - n[d], c.y2 += newY - n[d], c.y3 += newY - n[d], c.y4 += newY - n[d], c.y5 && (c.y5 += newY - n[d], c.y6 += newY - n[d]), n[d] = newY
	                    }
	                };
	                a._animator.animate(0, c, function(c) {
	                    var d =
	                        a.plotArea.ctx || a.ctx;
	                    ja = !0;
	                    d.clearRect(z.x1, z.y1, z.x2 - z.x1, z.y2 - z.y1);
	                    d.fillStyle = a.backgroundColor;
	                    d.fillRect(z.x1, z.y1, z.width, z.height);
	                    p.changeSection(c, b);
	                    var e = {};
	                    e.dataSeries = u;
	                    e.dataPoint = u.reversed ? u.dataPoints[x.length - 1 - b] : u.dataPoints[b];
	                    e.index = u.reversed ? x.length - 1 - b : b;
	                    a.toolTip.highlightObjects([e]);
	                    for (e = 0; e < M.length; e++) sa(d, M[e], u.fillOpacity);
	                    q(d);
	                    J && ("inside" !== u.indexLabelPlacement ? r(d) : g(), m(d));
	                    1 <= c && (ja = !1)
	                }, null, H.easing.easeOutQuart)
	            }

	            function k() {
	                for (var a = 0, b = 0; b < M.length -
	                    1; b++)(0 <= ma.indexOf(b) || 0 <= ma.indexOf(b + 1)) && a++;
	                return a
	            }

	            function r(a) {
	                for (var b, c, e, f, g = 0; g < M.length; g++) f = 1 === F[g].lineThickness % 2 ? 0.5 : 0, c = ((M[g].y2 + M[g].y4) / 2 << 0) + f, b = d(c).x2 - 1, e = F[g].textBlock.x, f = (F[g].textBlock.y + F[g].height / 2 << 0) + f, F[g].isDirty || 0 == F[g].lineThickness || (a.strokeStyle = F[g].lineColor, a.lineWidth = F[g].lineThickness, a.setLineDash && a.setLineDash(G(F[g].lineDashType, F[g].lineThickness)), a.beginPath(), a.moveTo(b, c), a.lineTo(e, f), a.stroke())
	            }

	            function p(a) {
	                for (a -= 1; - 1 <= a && -1 != a && F[a].isDirty; a--);
	                return a
	            }

	            function n(a) {
	                for (a += 1; a <= M.length && a != M.length && F[a].isDirty; a++);
	                return a
	            }

	            function d(a) {
	                for (var b, c = 0; c < x.length; c++)
	                    if (M[c].y1 < a && M[c].y4 > a) {
	                        b = M[c];
	                        break
	                    }
	                return b ? (a = b.y6 ? a > b.y6 ? b.x3 + (b.x4 - b.x3) / (b.y4 - b.y3) * (a - b.y3) : b.x2 + (b.x3 - b.x2) / (b.y3 - b.y2) * (a - b.y2) : b.x2 + (b.x3 - b.x2) / (b.y3 - b.y2) * (a - b.y2), {
	                    x1: a,
	                    x2: a
	                }) : -1
	            }

	            function m(a) {
	                for (var b = 0; b < M.length; b++) F[b].isDirty || (a && (F[b].textBlock.ctx = a), F[b].textBlock.render(!0))
	            }

	            function q(a) {
	                s.plotArea.layoutManager.reset();
	                a.roundRect || Ca(a);
	                s.title &&
	                    (s.title.dockInsidePlotArea || "center" === s.title.horizontalAlign && "center" === s.title.verticalAlign) && (s.title.ctx = a, s.title.render());
	                if (s.subtitles)
	                    for (var b = 0; b < s.subtitles.length; b++) {
	                        var c = s.subtitles[b];
	                        if (c.dockInsidePlotArea || "center" === c.horizontalAlign && "center" === c.verticalAlign) s.subtitles.ctx = a, c.render()
	                    }
	                s.legend && (s.legend.dockInsidePlotArea || "center" === s.legend.horizontalAlign && "center" === s.legend.verticalAlign) && (s.legend.ctx = a, s.legend.render());
	                Z.fNg && Z.fNg(s)
	            }
	            var s = this;
	            if (!(0 >=
	                    a.dataSeriesIndexes.length)) {
	                for (var u = this.data[a.dataSeriesIndexes[0]], x = u.dataPoints, z = this.plotArea, C = 0.025 * z.width, B = 0.01 * z.width, A = 0, O = z.height - 2 * C, L = Math.min(z.width - 2 * B, 2.8 * z.height), J = !1, I = 0; I < x.length; I++)
	                    if (!J && ("undefined" !== typeof x[I].indexLabel && null !== x[I].indexLabel && 0 < x[I].indexLabel.toString().length) && (J = !0), !J && ("undefined" !== typeof x[I].label && null !== x[I].label && 0 < x[I].label.toString().length) && (J = !0), !J && "function" === typeof u.indexLabelFormatter || "function" === typeof x[I].indexLabelFormatter) J = !0;
	                J = J || "undefined" !== typeof u.indexLabel && null !== u.indexLabel && 0 < u.indexLabel.toString().length;
	                "inside" !== u.indexLabelPlacement && J || (B = (z.width - 0.75 * L) / 2);
	                var I = z.x1 + B,
	                    P = z.x2 - B,
	                    Q = z.y1 + C,
	                    $ = z.y2 - C,
	                    R = a.targetCanvasCtx || this.plotArea.ctx || this.ctx;
	                if (0 != u.length && (u.dataPoints && u.visible) && 0 !== x.length) {
	                    var N, E;
	                    a = 75 * L / 100;
	                    var U = 30 * (P - a) / 100;
	                    "funnel" === u.type ? (N = y(u.options.neckHeight) ? 0.35 * O : u.neckHeight, E = y(u.options.neckWidth) ? 0.25 * a : u.neckWidth, "string" === typeof N && N.match(/%$/) ? (N = parseInt(N), N =
	                        N * O / 100) : N = parseInt(N), "string" === typeof E && E.match(/%$/) ? (E = parseInt(E), E = E * a / 100) : E = parseInt(E), N > O ? N = O : 0 >= N && (N = 0), E > a ? E = a - 0.5 : 0 >= E && (E = 0)) : "pyramid" === u.type && (E = N = 0, u.reversed = u.reversed ? !1 : !0);
	                    var B = I + a / 2,
	                        X = I,
	                        V = I + a,
	                        T = u.reversed ? $ : Q,
	                        K = B - E / 2,
	                        Y = B + E / 2,
	                        aa = u.reversed ? Q + N : $ - N,
	                        ta = u.reversed ? Q : $;
	                    a = [];
	                    var B = [],
	                        M = [],
	                        L = [],
	                        W = Q,
	                        ga, fa = (aa - T) / (K - X),
	                        ia = -fa,
	                        I = "area" === (u.valueRepresents ? u.valueRepresents : "height") ? b() : f();
	                    if (-1 !== I) {
	                        if (u.reversed)
	                            for (L.push(W), E = I.length - 1; 0 < E; E--) W += I[E], L.push(W);
	                        else
	                            for (E =
	                                0; E < I.length; E++) W += I[E], L.push(W);
	                        if (u.reversed)
	                            for (E = 0; E < I.length; E++) L[E] < aa ? (a.push(K), B.push(Y), ga = E) : (a.push((L[E] - T + fa * X) / fa), B.push((L[E] - T + ia * V) / ia));
	                        else
	                            for (E = 0; E < I.length; E++) L[E] < aa ? (a.push((L[E] - T + fa * X) / fa), B.push((L[E] - T + ia * V) / ia), ga = E) : (a.push(K), B.push(Y));
	                        for (E = 0; E < I.length - 1; E++) W = u.reversed ? x[x.length - 1 - E].color ? x[x.length - 1 - E].color : u._colorSet[(x.length - 1 - E) % u._colorSet.length] : x[E].color ? x[E].color : u._colorSet[E % u._colorSet.length], E === ga ? M.push({
	                            x1: a[E],
	                            y1: L[E],
	                            x2: B[E],
	                            y2: L[E],
	                            x3: Y,
	                            y3: aa,
	                            x4: B[E + 1],
	                            y4: L[E + 1],
	                            x5: a[E + 1],
	                            y5: L[E + 1],
	                            x6: K,
	                            y6: aa,
	                            id: E,
	                            height: L[E + 1] - L[E],
	                            color: W
	                        }) : M.push({
	                            x1: a[E],
	                            y1: L[E],
	                            x2: B[E],
	                            y2: L[E],
	                            x3: B[E + 1],
	                            y3: L[E + 1],
	                            x4: a[E + 1],
	                            y4: L[E + 1],
	                            id: E,
	                            height: L[E + 1] - L[E],
	                            color: W
	                        });
	                        var ha = 2,
	                            F = [],
	                            ja = !1,
	                            ma = [],
	                            ka = [],
	                            I = !1;
	                        a = a = 0;
	                        Da(ma);
	                        for (E = 0; E < x.length; E++) x[E].exploded && (I = !0, u.reversed ? ma.push(x.length - 1 - E) : ma.push(E));
	                        R.clearRect(z.x1, z.y1, z.width, z.height);
	                        R.fillStyle = s.backgroundColor;
	                        R.fillRect(z.x1, z.y1, z.width, z.height);
	                        if (J && u.visible && (c(), g(), e(), "inside" !== u.indexLabelPlacement)) {
	                            h();
	                            for (E = 0; E < x.length; E++) F[E].isDirty || (a = F[E].textBlock.x + F[E].width, a = (P - a) / 2, 0 == E && (A = a), A > a && (A = a));
	                            for (E = 0; E < M.length; E++) M[E].x1 += A, M[E].x2 += A, M[E].x3 += A, M[E].x4 += A, M[E].x5 && (M[E].x5 += A, M[E].x6 += A), F[E].textBlock.x += A
	                        }
	                        for (E = 0; E < M.length; E++) A = M[E], sa(R, A, u.fillOpacity), ka.push(A.y1);
	                        q(R);
	                        J && u.visible && ("inside" === u.indexLabelPlacement || s.animationEnabled || r(R), s.animationEnabled || m());
	                        if (!J)
	                            for (E = 0; E < x.length; E++) A = u.dataPointIds[E], a = {
	                                id: A,
	                                objectType: "dataPoint",
	                                dataPointIndex: E,
	                                dataSeriesIndex: 0,
	                                funnelSection: M[u.reversed ? x.length - 1 - E : E]
	                            }, s._eventManager.objectMap[A] = a;
	                        !s.animationEnabled && I ? t(s, -1, 0) : s.animationEnabled && !s.animatedRender && t(s, -1, 0);
	                        this.funnelPyramidClickHandler = function(a) {
	                            var b = -1;
	                            if (!ja && !s.isAnimating && (y(a.dataSeries.explodeOnClick) || a.dataSeries.explodeOnClick) && (b = u.reversed ? x.length - 1 - a.dataPointIndex : a.dataPointIndex, 0 <= b)) {
	                                a = b;
	                                if ("funnel" === u.type || "pyramid" === u.type) u.reversed ? x[x.length - 1 - a].exploded = x[x.length - 1 - a].exploded ? !1 : !0 : x[a].exploded = x[a].exploded ?
	                                    !1 : !0;
	                                t(s, b, 500)
	                            }
	                        };
	                        return {
	                            source: R,
	                            dest: this.plotArea.ctx,
	                            animationCallback: function(a, b) {
	                                H.fadeInAnimation(a, b);
	                                1 <= a && (t(s, -1, 500), q(s.plotArea.ctx || s.ctx))
	                            },
	                            easingFunction: H.easing.easeInQuad,
	                            animationBase: 0
	                        }
	                    }
	                }
	            }
	        };
	        q.prototype.animationRequestId = null;
	        q.prototype.requestAnimFrame = function() {
	            return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(a) {
	                window.setTimeout(a, 1E3 / 60)
	            }
	        }();
	        q.prototype.cancelRequestAnimFrame = window.cancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || clearTimeout;
	        q.prototype.set = function(a, f, b) {
	            b = "undefined" === typeof b ? !0 : b;
	            "options" === a ? (this.options = f, b && this.render()) : q.base.set.call(this, a, f, b)
	        };
	        q.prototype.exportChart = function(a) {
	            a = "undefined" === typeof a ? {} : a;
	            var f = a.format ? a.format : "png",
	                b = a.fileName ? a.fileName : this.exportFileName;
	            if (a.toDataURL) return this.canvas.toDataURL("image/" + f);
	            s(this.canvas, f, b)
	        };
	        q.prototype.print = function() {
	            var a = this.exportChart({
	                    toDataURL: !0
	                }),
	                f = document.createElement("iframe");
	            f.setAttribute("class", "canvasjs-chart-print-frame");
	            f.setAttribute("style", "position:absolute; width:100%; border: 0px; margin: 0px 0px 0px 0px; padding 0px 0px 0px 0px;");
	            f.style.height = this.height + "px";
	            this._canvasJSContainer.appendChild(f);
	            var b = this,
	                c = f.contentWindow || f.contentDocument.document || f.contentDocument;
	            c.document.open();
	            c.document.write('<!DOCTYPE HTML>\n<html><body style="margin: 0px 0px 0px 0px; padding: 0px 0px 0px 0px;"><img src="' + a + '"/><body/></html>');
	            c.document.close();
	            setTimeout(function() {
	                c.focus();
	                c.print();
	                setTimeout(function() {
	                    b._canvasJSContainer.removeChild(f)
	                }, 1E3)
	            }, 500)
	        };
	        q.prototype.getPercentAndTotal = function(a, f) {
	            var b = null,
	                c = null,
	                e = null;
	            if (0 <= a.type.indexOf("stacked")) c = 0, b = f.x.getTime ? f.x.getTime() : f.x, b in a.plotUnit.yTotals && (c = a.plotUnit.yTotals[b], e = isNaN(f.y) ? 0 : 100 * (f.y / c));
	            else if ("pie" ===
	                a.type || "doughnut" === a.type || "funnel" === a.type || "pyramid" === a.type) {
	                for (i = c = 0; i < a.dataPoints.length; i++) isNaN(a.dataPoints[i].y) || (c += a.dataPoints[i].y);
	                e = isNaN(f.y) ? 0 : 100 * (f.y / c)
	            }
	            return {
	                percent: e,
	                total: c
	            }
	        };
	        q.prototype.replaceKeywordsWithValue = function(a, f, b, c, e) {
	            var g = this;
	            e = "undefined" === typeof e ? 0 : e;
	            if ((0 <= b.type.indexOf("stacked") || "pie" === b.type || "doughnut" === b.type || "funnel" === b.type || "pyramid" === b.type) && (0 <= a.indexOf("#percent") || 0 <= a.indexOf("#total"))) {
	                var h = "#percent",
	                    l = "#total",
	                    t = this.getPercentAndTotal(b,
	                        f),
	                    l = isNaN(t.total) ? l : t.total,
	                    h = isNaN(t.percent) ? h : t.percent;
	                do {
	                    t = "";
	                    if (b.percentFormatString) t = b.percentFormatString;
	                    else {
	                        var t = "#,##0.",
	                            k = Math.max(Math.ceil(Math.log(1 / Math.abs(h)) / Math.LN10), 2);
	                        if (isNaN(k) || !isFinite(k)) k = 2;
	                        for (var r = 0; r < k; r++) t += "#";
	                        b.percentFormatString = t
	                    }
	                    a = a.replace("#percent", W(h, t, g._cultureInfo));
	                    a = a.replace("#total", W(l, b.yValueFormatString ? b.yValueFormatString : "#,##0.########", g._cultureInfo))
	                } while (0 <= a.indexOf("#percent") || 0 <= a.indexOf("#total"))
	            }
	            return a.replace(/\{.*?\}|"[^"]*"|'[^']*'/g,
	                function(a) {
	                    if ('"' === a[0] && '"' === a[a.length - 1] || "'" === a[0] && "'" === a[a.length - 1]) return a.slice(1, a.length - 1);
	                    a = Ga(a.slice(1, a.length - 1));
	                    a = a.replace("#index", e);
	                    var h = null;
	                    try {
	                        var d = a.match(/(.*?)\s*\[\s*(.*?)\s*\]/);
	                        d && 0 < d.length && (h = Ga(d[2]), a = Ga(d[1]))
	                    } catch (k) {}
	                    d = null;
	                    if ("color" === a) return "waterfall" === b.type ? f.color ? f.color : -1 < f.y ? b.risingColor : b.fallingColor : "error" === b.type ? b.color ? b.color : b._colorSet[h % b._colorSet.length] : f.color ? f.color : b.color ? b.color : b._colorSet[c % b._colorSet.length];
	                    if (f.hasOwnProperty(a)) d =
	                        f;
	                    else if (b.hasOwnProperty(a)) d = b;
	                    else return "";
	                    d = d[a];
	                    null !== h && (d = d[h]);
	                    if ("x" === a)
	                        if ("dateTime" === b.axisX.valueType || "dateTime" === b.xValueType || f.x && f.x.getTime) {
	                            if (g.plotInfo.plotTypes[0].plotUnits[0].axisX && !g.plotInfo.plotTypes[0].plotUnits[0].axisX.logarithmic) return Ba(d, f.xValueFormatString ? f.xValueFormatString : b.xValueFormatString ? b.xValueFormatString : b.xValueFormatString = g.axisX && g.axisX.autoValueFormatString ? g.axisX.autoValueFormatString : "DD MMM YY", g._cultureInfo)
	                        } else return W(d, f.xValueFormatString ?
	                            f.xValueFormatString : b.xValueFormatString ? b.xValueFormatString : b.xValueFormatString = "#,##0.########", g._cultureInfo);
	                    else return "y" === a ? W(d, f.yValueFormatString ? f.yValueFormatString : b.yValueFormatString ? b.yValueFormatString : b.yValueFormatString = "#,##0.########", g._cultureInfo) : "z" === a ? W(d, f.zValueFormatString ? f.zValueFormatString : b.zValueFormatString ? b.zValueFormatString : b.zValueFormatString = "#,##0.########", g._cultureInfo) : d
	                })
	        };
	        pa(T, X);
	        T.prototype.render = function() {
	            var a = this.dockInsidePlotArea ?
	                this.chart.plotArea : this.chart,
	                f = a.layoutManager.getFreeSpace(),
	                b = null,
	                c = 0,
	                e = 0,
	                g = 0,
	                h = 0,
	                l = this.markerMargin = this.chart.options.legend && !y(this.chart.options.legend.markerMargin) ? this.chart.options.legend.markerMargin : 0.3 * this.fontSize;
	            this.height = 0;
	            var t = [],
	                k = [];
	            "top" === this.verticalAlign || "bottom" === this.verticalAlign ? (this.orientation = "horizontal", b = this.verticalAlign, g = this.maxWidth = null !== this.maxWidth ? this.maxWidth : f.width, h = this.maxHeight = null !== this.maxHeight ? this.maxHeight : 0.5 * f.height) : "center" ===
	                this.verticalAlign && (this.orientation = "vertical", b = this.horizontalAlign, g = this.maxWidth = null !== this.maxWidth ? this.maxWidth : 0.5 * f.width, h = this.maxHeight = null !== this.maxHeight ? this.maxHeight : f.height);
	            for (var r = [], p = 0; p < this.dataSeries.length; p++) {
	                var n = this.dataSeries[p];
	                if (n.dataPoints && n.dataPoints.length)
	                    if ("pie" !== n.type && "doughnut" !== n.type && "funnel" !== n.type && "pyramid" !== n.type) {
	                        var d = n.legendMarkerType = n.legendMarkerType ? n.legendMarkerType : "line" !== n.type && "stepLine" !== n.type && "spline" !== n.type &&
	                            "scatter" !== n.type && "bubble" !== n.type || !n.markerType ? "error" === n.type && n._linkedSeries ? n._linkedSeries.legendMarkerType ? n._linkedSeries.legendMarkerType : Q.getDefaultLegendMarker(n._linkedSeries.type) : Q.getDefaultLegendMarker(n.type) : n.markerType,
	                            m = n.legendText ? n.legendText : this.itemTextFormatter ? this.itemTextFormatter({
	                                chart: this.chart,
	                                legend: this.options,
	                                dataSeries: n,
	                                dataPoint: null
	                            }) : n.name,
	                            q = n.legendMarkerColor = n.legendMarkerColor ? n.legendMarkerColor : n.markerColor ? n.markerColor : "error" === n.type ?
	                            y(n.whiskerColor) ? n._colorSet[0] : n.whiskerColor : n._colorSet[0],
	                            s = n.markerSize || "line" !== n.type && "stepLine" !== n.type && "spline" !== n.type ? 0.75 * this.lineHeight : 0,
	                            u = n.legendMarkerBorderColor ? n.legendMarkerBorderColor : n.markerBorderColor,
	                            v = n.legendMarkerBorderThickness ? n.legendMarkerBorderThickness : n.markerBorderThickness ? Math.max(1, Math.round(0.2 * s)) : 0;
	                        "error" === n.type && r.push(q);
	                        m = this.chart.replaceKeywordsWithValue(m, n.dataPoints[0], n, p);
	                        d = {
	                            markerType: d,
	                            markerColor: q,
	                            text: m,
	                            textBlock: null,
	                            chartType: n.type,
	                            markerSize: s,
	                            lineColor: n._colorSet[0],
	                            dataSeriesIndex: n.index,
	                            dataPointIndex: null,
	                            markerBorderColor: u,
	                            markerBorderThickness: v
	                        };
	                        t.push(d)
	                    } else
	                        for (var x = 0; x < n.dataPoints.length; x++) {
	                            var z = n.dataPoints[x],
	                                d = z.legendMarkerType ? z.legendMarkerType : n.legendMarkerType ? n.legendMarkerType : Q.getDefaultLegendMarker(n.type),
	                                m = z.legendText ? z.legendText : n.legendText ? n.legendText : this.itemTextFormatter ? this.itemTextFormatter({
	                                    chart: this.chart,
	                                    legend: this.options,
	                                    dataSeries: n,
	                                    dataPoint: z
	                                }) : z.name ? z.name : "DataPoint: " +
	                                (x + 1),
	                                q = z.legendMarkerColor ? z.legendMarkerColor : n.legendMarkerColor ? n.legendMarkerColor : z.color ? z.color : n.color ? n.color : n._colorSet[x % n._colorSet.length],
	                                s = 0.75 * this.lineHeight,
	                                u = z.legendMarkerBorderColor ? z.legendMarkerBorderColor : n.legendMarkerBorderColor ? n.legendMarkerBorderColor : z.markerBorderColor ? z.markerBorderColor : n.markerBorderColor,
	                                v = z.legendMarkerBorderThickness ? z.legendMarkerBorderThickness : n.legendMarkerBorderThickness ? n.legendMarkerBorderThickness : z.markerBorderThickness || n.markerBorderThickness ?
	                                Math.max(1, Math.round(0.2 * s)) : 0,
	                                m = this.chart.replaceKeywordsWithValue(m, z, n, x),
	                                d = {
	                                    markerType: d,
	                                    markerColor: q,
	                                    text: m,
	                                    textBlock: null,
	                                    chartType: n.type,
	                                    markerSize: s,
	                                    dataSeriesIndex: p,
	                                    dataPointIndex: x,
	                                    markerBorderColor: u,
	                                    markerBorderThickness: v
	                                };
	                            (z.showInLegend || n.showInLegend && !1 !== z.showInLegend) && t.push(d)
	                        }
	            }!0 === this.reversed && t.reverse();
	            if (0 < t.length) {
	                n = null;
	                m = x = z = v = 0;
	                z = null !== this.itemWidth ? null !== this.itemMaxWidth ? Math.min(this.itemWidth, this.itemMaxWidth, g) : this.itemMaxWidth = Math.min(this.itemWidth,
	                    g) : null !== this.itemMaxWidth ? Math.min(this.itemMaxWidth, g) : this.itemMaxWidth = g;
	                s = 0 === s ? 0.75 * this.lineHeight : s;
	                z -= s + l;
	                for (p = 0; p < t.length; p++) {
	                    d = t[p];
	                    q = z;
	                    if ("line" === d.chartType || "spline" === d.chartType || "stepLine" === d.chartType) q -= 2 * 0.1 * this.lineHeight;
	                    if (!(0 >= h || "undefined" === typeof h || 0 >= q || "undefined" === typeof q)) {
	                        if ("horizontal" === this.orientation) {
	                            d.textBlock = new la(this.ctx, {
	                                x: 0,
	                                y: 0,
	                                maxWidth: q,
	                                maxHeight: this.itemWrap ? h : this.lineHeight,
	                                angle: 0,
	                                text: d.text,
	                                horizontalAlign: "left",
	                                fontSize: this.fontSize,
	                                fontFamily: this.fontFamily,
	                                fontWeight: this.fontWeight,
	                                fontColor: this.fontColor,
	                                fontStyle: this.fontStyle,
	                                textBaseline: "middle"
	                            });
	                            d.textBlock.measureText();
	                            null !== this.itemWidth && (d.textBlock.width = this.itemWidth - (s + l + ("line" === d.chartType || "spline" === d.chartType || "stepLine" === d.chartType ? 2 * 0.1 * this.lineHeight : 0)));
	                            if (!n || n.width + Math.round(d.textBlock.width + s + l + (0 === n.width ? 0 : this.horizontalSpacing) + ("line" === d.chartType || "spline" === d.chartType || "stepLine" === d.chartType ? 2 * 0.1 * this.lineHeight : 0)) > g) n = {
	                                items: [],
	                                width: 0
	                            }, k.push(n), this.height += x, x = 0;
	                            x = Math.max(x, d.textBlock.height)
	                        } else d.textBlock = new la(this.ctx, {
	                            x: 0,
	                            y: 0,
	                            maxWidth: z,
	                            maxHeight: !0 === this.itemWrap ? h : 1.5 * this.fontSize,
	                            angle: 0,
	                            text: d.text,
	                            horizontalAlign: "left",
	                            fontSize: this.fontSize,
	                            fontFamily: this.fontFamily,
	                            fontWeight: this.fontWeight,
	                            fontColor: this.fontColor,
	                            fontStyle: this.fontStyle,
	                            textBaseline: "middle"
	                        }), d.textBlock.measureText(), null !== this.itemWidth && (d.textBlock.width = this.itemWidth - (s + l + ("line" === d.chartType || "spline" === d.chartType ||
	                            "stepLine" === d.chartType ? 2 * 0.1 * this.lineHeight : 0))), this.height < h - this.lineHeight ? (n = {
	                            items: [],
	                            width: 0
	                        }, k.push(n)) : (n = k[v], v = (v + 1) % k.length), this.height += d.textBlock.height;
	                        d.textBlock.x = n.width;
	                        d.textBlock.y = 0;
	                        n.width += Math.round(d.textBlock.width + s + l + (0 === n.width ? 0 : this.horizontalSpacing) + ("line" === d.chartType || "spline" === d.chartType || "stepLine" === d.chartType ? 2 * 0.1 * this.lineHeight : 0));
	                        n.items.push(d);
	                        this.width = Math.max(n.width, this.width);
	                        m = d.textBlock.width + (s + l + ("line" === d.chartType || "spline" ===
	                            d.chartType || "stepLine" === d.chartType ? 2 * 0.1 * this.lineHeight : 0))
	                    }
	                }
	                this.itemWidth = m;
	                this.height = !1 === this.itemWrap ? k.length * this.lineHeight : this.height + x;
	                this.height = Math.min(h, this.height);
	                this.width = Math.min(g, this.width)
	            }
	            "top" === this.verticalAlign ? (e = "left" === this.horizontalAlign ? f.x1 : "right" === this.horizontalAlign ? f.x2 - this.width : f.x1 + f.width / 2 - this.width / 2, c = f.y1) : "center" === this.verticalAlign ? (e = "left" === this.horizontalAlign ? f.x1 : "right" === this.horizontalAlign ? f.x2 - this.width : f.x1 + f.width / 2 - this.width /
	                2, c = f.y1 + f.height / 2 - this.height / 2) : "bottom" === this.verticalAlign && (e = "left" === this.horizontalAlign ? f.x1 : "right" === this.horizontalAlign ? f.x2 - this.width : f.x1 + f.width / 2 - this.width / 2, c = f.y2 - this.height);
	            this.items = t;
	            for (p = 0; p < this.items.length; p++) d = t[p], d.id = ++this.chart._eventManager.lastObjectId, this.chart._eventManager.objectMap[d.id] = {
	                id: d.id,
	                objectType: "legendItem",
	                legendItemIndex: p,
	                dataSeriesIndex: d.dataSeriesIndex,
	                dataPointIndex: d.dataPointIndex
	            };
	            (0 < this.borderThickness && this.borderColor || this.backgroundColor) &&
	            this.ctx.roundRect(e, c, this.width, this.height, this.cornerRadius, this.borderThickness, this.backgroundColor, this.borderColor);
	            for (p = f = 0; p < k.length; p++) {
	                n = k[p];
	                for (z = x = 0; z < n.items.length; z++) {
	                    d = n.items[z];
	                    q = d.textBlock.x + e + (0 === z ? 0.2 * s : this.horizontalSpacing);
	                    u = c + f;
	                    m = q;
	                    this.chart.data[d.dataSeriesIndex].visible || (this.ctx.globalAlpha = 0.5);
	                    this.ctx.save();
	                    this.ctx.beginPath();
	                    this.ctx.rect(e, c, g, Math.max(h - h % this.lineHeight, 0));
	                    this.ctx.clip();
	                    if ("line" === d.chartType || "stepLine" === d.chartType || "spline" ===
	                        d.chartType) this.ctx.strokeStyle = d.lineColor, this.ctx.lineWidth = Math.ceil(this.lineHeight / 8), this.ctx.beginPath(), this.ctx.moveTo(q - 0.1 * this.lineHeight, u + this.lineHeight / 2), this.ctx.lineTo(q + 0.85 * this.lineHeight, u + this.lineHeight / 2), this.ctx.stroke(), m -= 0.1 * this.lineHeight;
	                    if ("error" === d.chartType) {
	                        this.ctx.strokeStyle = r[0];
	                        v = s / 8;
	                        this.ctx.lineWidth = v;
	                        this.ctx.beginPath();
	                        var v = q - 0.08 * this.lineHeight + 0.1 * this.lineHeight,
	                            B = u + 0.15 * this.lineHeight,
	                            A = 0.7 * this.lineHeight,
	                            C = A + 0.02 * this.lineHeight;
	                        this.ctx.moveTo(v,
	                            B);
	                        this.ctx.lineTo(v + A, B);
	                        this.ctx.stroke();
	                        this.ctx.beginPath();
	                        this.ctx.moveTo(v + A / 2, B);
	                        this.ctx.lineTo(v + A / 2, B + C);
	                        this.ctx.stroke();
	                        this.ctx.beginPath();
	                        this.ctx.moveTo(v, B + C);
	                        this.ctx.lineTo(v + A, B + C);
	                        this.ctx.stroke();
	                        r.shift()
	                    }
	                    ja.drawMarker(q + s / 2, u + this.lineHeight / 2, this.ctx, d.markerType, "error" === d.chartType || "line" === d.chartType || "spline" === d.chartType ? d.markerSize / 2 : d.markerSize, d.markerColor, d.markerBorderColor, d.markerBorderThickness);
	                    d.textBlock.x = q + l + s;
	                    if ("line" === d.chartType || "stepLine" ===
	                        d.chartType || "spline" === d.chartType) d.textBlock.x += 0.1 * this.lineHeight;
	                    d.textBlock.y = Math.round(u + this.lineHeight / 2);
	                    d.textBlock.render(!0);
	                    this.ctx.restore();
	                    x = 0 < z ? Math.max(x, d.textBlock.height) : d.textBlock.height;
	                    this.chart.data[d.dataSeriesIndex].visible || (this.ctx.globalAlpha = 1);
	                    v = R(d.id);
	                    this.ghostCtx.fillStyle = v;
	                    this.ghostCtx.beginPath();
	                    this.ghostCtx.fillRect(m, d.textBlock.y - this.lineHeight / 2, d.textBlock.x + d.textBlock.width - m, d.textBlock.height);
	                    d.x1 = this.chart._eventManager.objectMap[d.id].x1 =
	                        m;
	                    d.y1 = this.chart._eventManager.objectMap[d.id].y1 = d.textBlock.y - this.lineHeight / 2;
	                    d.x2 = this.chart._eventManager.objectMap[d.id].x2 = d.textBlock.x + d.textBlock.width;
	                    d.y2 = this.chart._eventManager.objectMap[d.id].y2 = d.textBlock.y + d.textBlock.height - this.lineHeight / 2
	                }
	                f += x
	            }
	            0 < t.length && a.layoutManager.registerSpace(b, {
	                width: this.width + 2 + 2,
	                height: this.height + 5 + 5
	            });
	            this.bounds = {
	                x1: e,
	                y1: c,
	                x2: e + this.width,
	                y2: c + this.height
	            }
	        };
	        pa(Q, X);
	        Q.prototype.getDefaultAxisPlacement = function() {
	            var a = this.type;
	            if ("column" ===
	                a || "line" === a || "stepLine" === a || "spline" === a || "area" === a || "stepArea" === a || "splineArea" === a || "stackedColumn" === a || "stackedLine" === a || "bubble" === a || "scatter" === a || "stackedArea" === a || "stackedColumn100" === a || "stackedLine100" === a || "stackedArea100" === a || "candlestick" === a || "ohlc" === a || "rangeColumn" === a || "rangeArea" === a || "rangeSplineArea" === a || "boxAndWhisker" === a || "waterfall" === a) return "normal";
	            if ("bar" === a || "stackedBar" === a || "stackedBar100" === a || "rangeBar" === a) return "xySwapped";
	            if ("pie" === a || "doughnut" ===
	                a || "funnel" === a || "pyramid" === a) return "none";
	            "error" !== a && window.console.log("Unknown Chart Type: " + a);
	            return null
	        };
	        Q.getDefaultLegendMarker = function(a) {
	            if ("column" === a || "stackedColumn" === a || "stackedLine" === a || "bar" === a || "stackedBar" === a || "stackedBar100" === a || "bubble" === a || "scatter" === a || "stackedColumn100" === a || "stackedLine100" === a || "stepArea" === a || "candlestick" === a || "ohlc" === a || "rangeColumn" === a || "rangeBar" === a || "rangeArea" === a || "rangeSplineArea" === a || "boxAndWhisker" === a || "waterfall" === a) return "square";
	            if ("line" === a || "stepLine" === a || "spline" === a || "pie" === a || "doughnut" === a) return "circle";
	            if ("area" === a || "splineArea" === a || "stackedArea" === a || "stackedArea100" === a || "funnel" === a || "pyramid" === a) return "triangle";
	            if ("error" === a) return "none";
	            window.console.log("Unknown Chart Type: " + a);
	            return null
	        };
	        Q.prototype.getDataPointAtX = function(a, f) {
	            if (!this.dataPoints || 0 === this.dataPoints.length) return null;
	            var b = {
	                    dataPoint: null,
	                    distance: Infinity,
	                    index: NaN
	                },
	                c = null,
	                e = 0,
	                g = 0,
	                h = 1,
	                l = Infinity,
	                t = 0,
	                k = 0,
	                r = 0;
	            "none" !== this.chart.plotInfo.axisPlacement &&
	                (this.axisX.logarithmic ? (r = Math.log(this.dataPoints[this.dataPoints.length - 1].x / this.dataPoints[0].x), r = 1 < r ? Math.min(Math.max((this.dataPoints.length - 1) / r * Math.log(a / this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0) : (r = this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x, r = 0 < r ? Math.min(Math.max((this.dataPoints.length - 1) / r * (a - this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0));
	            for (;;) {
	                g = 0 < h ? r + e : r - e;
	                if (0 <= g && g < this.dataPoints.length) {
	                    var c = this.dataPoints[g],
	                        p = this.axisX.logarithmic ?
	                        c.x > a ? c.x / a : a / c.x : Math.abs(c.x - a);
	                    p < b.distance && (b.dataPoint = c, b.distance = p, b.index = g);
	                    c = p;
	                    c <= l ? l = c : 0 < h ? t++ : k++;
	                    if (1E3 < t && 1E3 < k) break
	                } else if (0 > r - e && r + e >= this.dataPoints.length) break; - 1 === h ? (e++, h = 1) : h = -1
	            }
	            return f || b.dataPoint.x !== a ? f && null !== b.dataPoint ? b : null : b
	        };
	        Q.prototype.getDataPointAtXY = function(a, f, b) {
	            if (!this.dataPoints || 0 === this.dataPoints.length || a < this.chart.plotArea.x1 || a > this.chart.plotArea.x2 || f < this.chart.plotArea.y1 || f > this.chart.plotArea.y2) return null;
	            b = b || !1;
	            var c = [],
	                e = 0,
	                g = 0,
	                h =
	                1,
	                l = !1,
	                t = Infinity,
	                k = 0,
	                r = 0,
	                p = 0;
	            if ("none" !== this.chart.plotInfo.axisPlacement)
	                if (p = (this.chart.axisX[0] ? this.chart.axisX[0] : this.chart.axisX2[0]).getXValueAt({
	                        x: a,
	                        y: f
	                    }), this.axisX.logarithmic) var n = Math.log(this.dataPoints[this.dataPoints.length - 1].x / this.dataPoints[0].x),
	                    p = 1 < n ? Math.min(Math.max((this.dataPoints.length - 1) / n * Math.log(p / this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0;
	                else n = this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x, p = 0 < n ? Math.min(Math.max((this.dataPoints.length -
	                    1) / n * (p - this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0;
	            for (;;) {
	                g = 0 < h ? p + e : p - e;
	                if (0 <= g && g < this.dataPoints.length) {
	                    var n = this.chart._eventManager.objectMap[this.dataPointIds[g]],
	                        d = this.dataPoints[g],
	                        m = null;
	                    if (n) {
	                        switch (this.type) {
	                            case "column":
	                            case "stackedColumn":
	                            case "stackedColumn100":
	                            case "bar":
	                            case "stackedBar":
	                            case "stackedBar100":
	                            case "rangeColumn":
	                            case "rangeBar":
	                            case "waterfall":
	                            case "error":
	                                a >= n.x1 && (a <= n.x2 && f >= n.y1 && f <= n.y2) && (c.push({
	                                    dataPoint: d,
	                                    dataPointIndex: g,
	                                    dataSeries: this,
	                                    distance: Math.min(Math.abs(n.x1 -
	                                        a), Math.abs(n.x2 - a), Math.abs(n.y1 - f), Math.abs(n.y2 - f))
	                                }), l = !0);
	                                break;
	                            case "line":
	                            case "stepLine":
	                            case "spline":
	                            case "area":
	                            case "stepArea":
	                            case "stackedArea":
	                            case "stackedArea100":
	                            case "splineArea":
	                            case "scatter":
	                                var q = na("markerSize", d, this) || 4,
	                                    s = b ? 20 : q,
	                                    m = Math.sqrt(Math.pow(n.x1 - a, 2) + Math.pow(n.y1 - f, 2));
	                                m <= s && c.push({
	                                    dataPoint: d,
	                                    dataPointIndex: g,
	                                    dataSeries: this,
	                                    distance: m
	                                });
	                                n = Math.abs(n.x1 - a);
	                                n <= t ? t = n : 0 < h ? k++ : r++;
	                                m <= q / 2 && (l = !0);
	                                break;
	                            case "rangeArea":
	                            case "rangeSplineArea":
	                                q = na("markerSize", d, this) ||
	                                    4;
	                                s = b ? 20 : q;
	                                m = Math.min(Math.sqrt(Math.pow(n.x1 - a, 2) + Math.pow(n.y1 - f, 2)), Math.sqrt(Math.pow(n.x1 - a, 2) + Math.pow(n.y2 - f, 2)));
	                                m <= s && c.push({
	                                    dataPoint: d,
	                                    dataPointIndex: g,
	                                    dataSeries: this,
	                                    distance: m
	                                });
	                                n = Math.abs(n.x1 - a);
	                                n <= t ? t = n : 0 < h ? k++ : r++;
	                                m <= q / 2 && (l = !0);
	                                break;
	                            case "bubble":
	                                q = n.size;
	                                m = Math.sqrt(Math.pow(n.x1 - a, 2) + Math.pow(n.y1 - f, 2));
	                                m <= q / 2 && (c.push({
	                                    dataPoint: d,
	                                    dataPointIndex: g,
	                                    dataSeries: this,
	                                    distance: m
	                                }), l = !0);
	                                break;
	                            case "pie":
	                            case "doughnut":
	                                q = n.center;
	                                s = "doughnut" === this.type ? n.percentInnerRadius * n.radius :
	                                    0;
	                                m = Math.sqrt(Math.pow(q.x - a, 2) + Math.pow(q.y - f, 2));
	                                m < n.radius && m > s && (m = Math.atan2(f - q.y, a - q.x), 0 > m && (m += 2 * Math.PI), m = Number(((180 * (m / Math.PI) % 360 + 360) % 360).toFixed(12)), q = Number(((180 * (n.startAngle / Math.PI) % 360 + 360) % 360).toFixed(12)), s = Number(((180 * (n.endAngle / Math.PI) % 360 + 360) % 360).toFixed(12)), 0 === s && 1 < n.endAngle && (s = 360), q >= s && 0 !== d.y && (s += 360, m < q && (m += 360)), m > q && m < s && (c.push({
	                                    dataPoint: d,
	                                    dataPointIndex: g,
	                                    dataSeries: this,
	                                    distance: 0
	                                }), l = !0));
	                                break;
	                            case "funnel":
	                            case "pyramid":
	                                m = n.funnelSection;
	                                f > m.y1 && f < m.y4 && (m.y6 ? f > m.y6 ? (g = m.x6 + (m.x5 - m.x6) / (m.y5 - m.y6) * (f - m.y6), m = m.x3 + (m.x4 - m.x3) / (m.y4 - m.y3) * (f - m.y3)) : (g = m.x1 + (m.x6 - m.x1) / (m.y6 - m.y1) * (f - m.y1), m = m.x2 + (m.x3 - m.x2) / (m.y3 - m.y2) * (f - m.y2)) : (g = m.x1 + (m.x4 - m.x1) / (m.y4 - m.y1) * (f - m.y1), m = m.x2 + (m.x3 - m.x2) / (m.y3 - m.y2) * (f - m.y2)), a > g && a < m && (c.push({
	                                    dataPoint: d,
	                                    dataPointIndex: n.dataPointIndex,
	                                    dataSeries: this,
	                                    distance: 0
	                                }), l = !0));
	                                break;
	                            case "boxAndWhisker":
	                                if (a >= n.x1 - n.borderThickness / 2 && a <= n.x2 + n.borderThickness / 2 && f >= n.y4 - n.borderThickness / 2 && f <= n.y1 + n.borderThickness /
	                                    2 || Math.abs(n.x2 - a + n.x1 - a) < n.borderThickness && f >= n.y1 && f <= n.y4) c.push({
	                                    dataPoint: d,
	                                    dataPointIndex: g,
	                                    dataSeries: this,
	                                    distance: Math.min(Math.abs(n.x1 - a), Math.abs(n.x2 - a), Math.abs(n.y2 - f), Math.abs(n.y3 - f))
	                                }), l = !0;
	                                break;
	                            case "candlestick":
	                                if (a >= n.x1 - n.borderThickness / 2 && a <= n.x2 + n.borderThickness / 2 && f >= n.y2 - n.borderThickness / 2 && f <= n.y3 + n.borderThickness / 2 || Math.abs(n.x2 - a + n.x1 - a) < n.borderThickness && f >= n.y1 && f <= n.y4) c.push({
	                                    dataPoint: d,
	                                    dataPointIndex: g,
	                                    dataSeries: this,
	                                    distance: Math.min(Math.abs(n.x1 - a),
	                                        Math.abs(n.x2 - a), Math.abs(n.y2 - f), Math.abs(n.y3 - f))
	                                }), l = !0;
	                                break;
	                            case "ohlc":
	                                if (Math.abs(n.x2 - a + n.x1 - a) < n.borderThickness && f >= n.y2 && f <= n.y3 || a >= n.x1 && a <= (n.x2 + n.x1) / 2 && f >= n.y1 - n.borderThickness / 2 && f <= n.y1 + n.borderThickness / 2 || a >= (n.x1 + n.x2) / 2 && a <= n.x2 && f >= n.y4 - n.borderThickness / 2 && f <= n.y4 + n.borderThickness / 2) c.push({
	                                    dataPoint: d,
	                                    dataPointIndex: g,
	                                    dataSeries: this,
	                                    distance: Math.min(Math.abs(n.x1 - a), Math.abs(n.x2 - a), Math.abs(n.y2 - f), Math.abs(n.y3 - f))
	                                }), l = !0
	                        }
	                        if (l || 1E3 < k && 1E3 < r) break
	                    }
	                } else if (0 > p - e && p + e >=
	                    this.dataPoints.length) break; - 1 === h ? (e++, h = 1) : h = -1
	            }
	            a = null;
	            for (f = 0; f < c.length; f++) a ? c[f].distance <= a.distance && (a = c[f]) : a = c[f];
	            return a
	        };
	        Q.prototype.getMarkerProperties = function(a, f, b, c) {
	            var e = this.dataPoints;
	            return {
	                x: f,
	                y: b,
	                ctx: c,
	                type: e[a].markerType ? e[a].markerType : this.markerType,
	                size: e[a].markerSize ? e[a].markerSize : this.markerSize,
	                color: e[a].markerColor ? e[a].markerColor : this.markerColor ? this.markerColor : e[a].color ? e[a].color : this.color ? this.color : this._colorSet[a % this._colorSet.length],
	                borderColor: e[a].markerBorderColor ?
	                    e[a].markerBorderColor : this.markerBorderColor ? this.markerBorderColor : null,
	                borderThickness: e[a].markerBorderThickness ? e[a].markerBorderThickness : this.markerBorderThickness ? this.markerBorderThickness : null
	            }
	        };
	        pa(C, X);
	        C.prototype.createExtraLabelsForLog = function(a) {
	            a = (a || 0) + 1;
	            if (!(5 < a)) {
	                var f = this.logLabelValues[0] || this.intervalStartPosition;
	                if (Math.log(this.range) / Math.log(f / this.viewportMinimum) < this.noTicks - 1) {
	                    for (var b = C.getNiceNumber((f - this.viewportMinimum) / Math.min(Math.max(2, this.noTicks - this.logLabelValues.length),
	                            3), !0), c = Math.ceil(this.viewportMinimum / b) * b; c < f; c += b) c < this.viewportMinimum || this.logLabelValues.push(c);
	                    this.logLabelValues.sort(Pa);
	                    this.createExtraLabelsForLog(a)
	                }
	            }
	        };
	        C.prototype.createLabels = function() {
	            var a, f, b = 0,
	                c = 0,
	                e, g = 0,
	                h = 0,
	                c = 0,
	                c = this.interval,
	                l = 0,
	                t, k = 0.6 * this.chart.height,
	                m;
	            a = !1;
	            var p = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [],
	                n = p.length ? y(this.scaleBreaks.firstBreakIndex) ? 0 : this.scaleBreaks.firstBreakIndex : 0;
	            if ("axisX" !== this.type || "dateTime" !== this.valueType || this.logarithmic) {
	                e =
	                    this.viewportMaximum;
	                if (this.labels) {
	                    a = Math.ceil(c);
	                    for (var c = Math.ceil(this.intervalStartPosition), d = !1, b = c; b < this.viewportMaximum; b += a)
	                        if (this.labels[b]) d = !0;
	                        else {
	                            d = !1;
	                            break
	                        }
	                    d && (this.interval = a, this.intervalStartPosition = c)
	                }
	                if (this.logarithmic && !this.equidistantInterval)
	                    for (this.logLabelValues || (this.logLabelValues = [], this.createExtraLabelsForLog()), c = 0, d = n; c < this.logLabelValues.length; c++)
	                        if (b = this.logLabelValues[c], b < this.viewportMinimum) c++;
	                        else {
	                            for (; d < p.length && b > p[d].endValue; d++);
	                            a = d < p.length &&
	                                b >= p[d].startValue && b <= p[d].endValue;
	                            m = b;
	                            a || (a = this.labelFormatter ? this.labelFormatter({
	                                chart: this.chart,
	                                axis: this.options,
	                                value: m,
	                                label: this.labels[m] ? this.labels[m] : null
	                            }) : "axisX" === this.type && this.labels[m] ? this.labels[m] : W(m, this.valueFormatString, this.chart._cultureInfo), a = new la(this.ctx, {
	                                x: 0,
	                                y: 0,
	                                maxWidth: g,
	                                maxHeight: h,
	                                angle: this.labelAngle,
	                                text: this.prefix + a + this.suffix,
	                                backgroundColor: this.labelBackgroundColor,
	                                borderColor: this.labelBorderColor,
	                                borderThickness: this.labelBorderThickness,
	                                cornerRadius: this.labelCornerRadius,
	                                horizontalAlign: "left",
	                                fontSize: this.labelFontSize,
	                                fontFamily: this.labelFontFamily,
	                                fontWeight: this.labelFontWeight,
	                                fontColor: this.labelFontColor,
	                                fontStyle: this.labelFontStyle,
	                                textBaseline: "middle",
	                                borderThickness: 0
	                            }), this._labels.push({
	                                position: m,
	                                textBlock: a,
	                                effectiveHeight: null
	                            }))
	                        }
	                d = n;
	                for (b = this.intervalStartPosition; b <= e; b = parseFloat((this.logarithmic && this.equidistantInterval ? b * Math.pow(this.logarithmBase, this.interval) : b + this.interval).toFixed(12))) {
	                    for (; d < p.length && b > p[d].endValue; d++);
	                    a = d < p.length &&
	                        b >= p[d].startValue && b <= p[d].endValue;
	                    m = b;
	                    a || (a = this.labelFormatter ? this.labelFormatter({
	                        chart: this.chart,
	                        axis: this.options,
	                        value: m,
	                        label: this.labels[m] ? this.labels[m] : null
	                    }) : "axisX" === this.type && this.labels[m] ? this.labels[m] : W(m, this.valueFormatString, this.chart._cultureInfo), a = new la(this.ctx, {
	                        x: 0,
	                        y: 0,
	                        maxWidth: g,
	                        maxHeight: h,
	                        angle: this.labelAngle,
	                        text: this.prefix + a + this.suffix,
	                        horizontalAlign: "left",
	                        backgroundColor: this.labelBackgroundColor,
	                        borderColor: this.labelBorderColor,
	                        borderThickness: this.labelBorderThickness,
	                        cornerRadius: this.labelCornerRadius,
	                        fontSize: this.labelFontSize,
	                        fontFamily: this.labelFontFamily,
	                        fontWeight: this.labelFontWeight,
	                        fontColor: this.labelFontColor,
	                        fontStyle: this.labelFontStyle,
	                        textBaseline: "middle"
	                    }), this._labels.push({
	                        position: m,
	                        textBlock: a,
	                        effectiveHeight: null
	                    }))
	                }
	            } else
	                for (this.intervalStartPosition = this.getLabelStartPoint(new Date(this.viewportMinimum), this.intervalType, this.interval), e = Ta(new Date(this.viewportMaximum), this.interval, this.intervalType), d = n, b = this.intervalStartPosition; b <
	                    e; Ta(b, c, this.intervalType)) {
	                    for (a = b.getTime(); d < p.length && a > p[d].endValue; d++);
	                    m = a;
	                    a = d < p.length && a >= p[d].startValue && a <= p[d].endValue;
	                    a || (a = this.labelFormatter ? this.labelFormatter({
	                        chart: this.chart,
	                        axis: this.options,
	                        value: new Date(m),
	                        label: this.labels[m] ? this.labels[m] : null
	                    }) : "axisX" === this.type && this.labels[m] ? this.labels[m] : Ba(m, this.valueFormatString, this.chart._cultureInfo), a = new la(this.ctx, {
	                        x: 0,
	                        y: 0,
	                        maxWidth: g,
	                        backgroundColor: this.labelBackgroundColor,
	                        borderColor: this.labelBorderColor,
	                        borderThickness: this.labelBorderThickness,
	                        cornerRadius: this.labelCornerRadius,
	                        maxHeight: h,
	                        angle: this.labelAngle,
	                        text: this.prefix + a + this.suffix,
	                        horizontalAlign: "left",
	                        fontSize: this.labelFontSize,
	                        fontFamily: this.labelFontFamily,
	                        fontWeight: this.labelFontWeight,
	                        fontColor: this.labelFontColor,
	                        fontStyle: this.labelFontStyle,
	                        textBaseline: "middle"
	                    }), this._labels.push({
	                        position: m,
	                        textBlock: a,
	                        effectiveHeight: null,
	                        breaksLabelType: void 0
	                    }))
	                }
	            if ("bottom" === this._position || "top" === this._position) l = this.logarithmic && !this.equidistantInterval && 2 <= this._labels.length ?
	                this.lineCoordinates.width * Math.log(Math.min(this._labels[this._labels.length - 1].position / this._labels[this._labels.length - 2].position, this._labels[1].position / this._labels[0].position)) / Math.log(this.range) : this.lineCoordinates.width / (this.logarithmic && this.equidistantInterval ? Math.log(this.range) / Math.log(this.logarithmBase) : Math.abs(this.range)) * U[this.intervalType + "Duration"] * this.interval, g = "undefined" === typeof this.options.labelMaxWidth ? 0.5 * this.chart.width >> 0 : this.options.labelMaxWidth, this.chart.panEnabled ||
	                (h = "undefined" === typeof this.options.labelWrap || this.labelWrap ? 0.8 * this.chart.height >> 0 : 1.5 * this.labelFontSize);
	            else if ("left" === this._position || "right" === this._position) l = this.logarithmic && !this.equidistantInterval && 2 <= this._labels.length ? this.lineCoordinates.height * Math.log(Math.min(this._labels[this._labels.length - 1].position / this._labels[this._labels.length - 2].position, this._labels[1].position / this._labels[0].position)) / Math.log(this.range) : this.lineCoordinates.height / (this.logarithmic && this.equidistantInterval ?
	                Math.log(this.range) / Math.log(this.logarithmBase) : Math.abs(this.range)) * U[this.intervalType + "Duration"] * this.interval, this.chart.panEnabled || (g = "undefined" === typeof this.options.labelMaxWidth ? 0.3 * this.chart.width >> 0 : this.options.labelMaxWidth), h = "undefined" === typeof this.options.labelWrap || this.labelWrap ? 0.3 * this.chart.height >> 0 : 1.5 * this.labelFontSize;
	            for (c = 0; c < this._labels.length; c++) {
	                a = this._labels[c].textBlock;
	                a.maxWidth = g;
	                a.maxHeight = h;
	                var q = a.measureText();
	                t = q.height
	            }
	            e = [];
	            n = p = 0;
	            if (this.labelAutoFit ||
	                this.options.labelAutoFit)
	                if (y(this.labelAngle) || (this.labelAngle = (this.labelAngle % 360 + 360) % 360, 90 < this.labelAngle && 270 > this.labelAngle ? this.labelAngle -= 180 : 270 <= this.labelAngle && 360 >= this.labelAngle && (this.labelAngle -= 360)), "bottom" === this._position || "top" === this._position)
	                    if (g = 0.9 * l >> 0, n = 0, !this.chart.panEnabled && 1 <= this._labels.length) {
	                        this.sessionVariables.labelFontSize = this.labelFontSize;
	                        this.sessionVariables.labelMaxWidth = g;
	                        this.sessionVariables.labelMaxHeight = h;
	                        this.sessionVariables.labelAngle =
	                            this.labelAngle;
	                        this.sessionVariables.labelWrap = this.labelWrap;
	                        for (b = 0; b < this._labels.length; b++)
	                            if (!this._labels[b].breaksLabelType) {
	                                a = this._labels[b].textBlock;
	                                for (var s, d = a.text.split(" "), c = 0; c < d.length; c++) m = d[c], this.ctx.font = a.fontStyle + " " + a.fontWeight + " " + a.fontSize + "px " + a.fontFamily, m = this.ctx.measureText(m), m.width > n && (s = b, n = m.width)
	                            }
	                        b = 0;
	                        for (b = this.intervalStartPosition < this.viewportMinimum ? 1 : 0; b < this._labels.length; b++)
	                            if (!this._labels[b].breaksLabelType) {
	                                a = this._labels[b].textBlock;
	                                q = a.measureText();
	                                for (d = b + 1; d < this._labels.length; d++)
	                                    if (!this._labels[d].breaksLabelType) {
	                                        f = this._labels[d].textBlock;
	                                        f = f.measureText();
	                                        break
	                                    }
	                                e.push(a.height);
	                                this.sessionVariables.labelMaxHeight = Math.max.apply(Math, e);
	                                Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));
	                                Math.sin(Math.PI / 180 * Math.abs(this.labelAngle));
	                                c = g * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (h - a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));
	                                if (y(this.options.labelAngle) && isNaN(this.options.labelAngle) && 0 !== this.options.labelAngle)
	                                    if (this.sessionVariables.labelMaxHeight =
	                                        0 === this.labelAngle ? h : Math.min((c - g * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), c), m = (k - (t + a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(-25))) / Math.sin(Math.PI / 180 * Math.abs(-25)), !y(this.options.labelWrap)) this.labelWrap ? y(this.options.labelMaxWidth) ? (this.sessionVariables.labelMaxWidth = Math.min(Math.max(g, n), m), this.sessionVariables.labelWrap = this.labelWrap, q.width + f.width >> 0 > 2 * g && (this.sessionVariables.labelAngle = -25)) : (this.sessionVariables.labelWrap =
	                                        this.labelWrap, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelAngle = this.sessionVariables.labelMaxWidth > g ? -25 : this.sessionVariables.labelAngle) : y(this.options.labelMaxWidth) ? (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxHeight = h, this.sessionVariables.labelMaxWidth = g, q.width + f.width >> 0 > 2 * g && (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = m)) : (this.sessionVariables.labelAngle = this.sessionVariables.labelMaxWidth >
	                                        g ? -25 : this.sessionVariables.labelAngle, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelMaxHeight = h, this.sessionVariables.labelWrap = this.labelWrap);
	                                    else {
	                                        if (y(this.options.labelWrap))
	                                            if (!y(this.options.labelMaxWidth)) this.options.labelMaxWidth < g ? (this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelMaxHeight = c) : (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelMaxHeight =
	                                                h);
	                                            else if (!y(f))
	                                            if (c = q.width + f.width >> 0, d = this.labelFontSize, n < g) c - 2 * g > p && (p = c - 2 * g, c >= 2 * g && c < 2.2 * g ? (this.sessionVariables.labelMaxWidth = g, y(this.options.labelFontSize) && 12 < d && (d = Math.floor(12 / 13 * d), a.measureText()), this.sessionVariables.labelFontSize = y(this.options.labelFontSize) ? d : this.options.labelFontSize, this.sessionVariables.labelAngle = this.labelAngle) : c >= 2.2 * g && c < 2.8 * g ? (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = m, this.sessionVariables.labelFontSize = d) : c >= 2.8 *
	                                                g && c < 3.2 * g ? (this.sessionVariables.labelMaxWidth = Math.max(g, n), this.sessionVariables.labelWrap = !0, y(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelFontSize = y(this.options.labelFontSize) ? d : this.options.labelFontSize, this.sessionVariables.labelAngle = this.labelAngle) : c >= 3.2 * g && c < 3.6 * g ? (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelWrap = !0, this.sessionVariables.labelMaxWidth = m, this.sessionVariables.labelFontSize =
	                                                    this.labelFontSize) : c > 3.6 * g && c < 5 * g ? (y(this.options.labelFontSize) && 12 < d && (d = Math.floor(12 / 13 * d), a.measureText()), this.sessionVariables.labelFontSize = y(this.options.labelFontSize) ? d : this.options.labelFontSize, this.sessionVariables.labelWrap = !0, this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = m) : c > 5 * g && (this.sessionVariables.labelWrap = !0, this.sessionVariables.labelMaxWidth = g, this.sessionVariables.labelFontSize = d, this.sessionVariables.labelMaxHeight = h, this.sessionVariables.labelAngle =
	                                                    this.labelAngle));
	                                            else if (s === b && (0 === s && n + this._labels[s + 1].textBlock.measureText().width - 2 * g > p || s === this._labels.length - 1 && n + this._labels[s - 1].textBlock.measureText().width - 2 * g > p || 0 < s && s < this._labels.length - 1 && n + this._labels[s + 1].textBlock.measureText().width - 2 * g > p && n + this._labels[s - 1].textBlock.measureText().width - 2 * g > p)) p = 0 === s ? n + this._labels[s + 1].textBlock.measureText().width - 2 * g : n + this._labels[s - 1].textBlock.measureText().width - 2 * g, this.sessionVariables.labelFontSize = y(this.options.labelFontSize) ?
	                                            d : this.options.labelFontSize, this.sessionVariables.labelWrap = !0, this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = m;
	                                        else if (0 === p)
	                                            for (this.sessionVariables.labelFontSize = y(this.options.labelFontSize) ? d : this.options.labelFontSize, this.sessionVariables.labelWrap = !0, c = 0; c < this._labels.length; c++) a = this._labels[c].textBlock, a.maxWidth = this.sessionVariables.labelMaxWidth = Math.min(Math.max(g, n), m), q = a.measureText(), c < this._labels.length - 1 && (d = c + 1, f = this._labels[d].textBlock, f.maxWidth =
	                                                this.sessionVariables.labelMaxWidth = Math.min(Math.max(g, n), m), f = f.measureText(), q.width + f.width >> 0 > 2 * g && (this.sessionVariables.labelAngle = -25))
	                                    }
	                                else(this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? h : Math.min((c - g * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), c), m = 0 != this.labelAngle ? (k - (t + a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) :
	                                    g, this.sessionVariables.labelMaxHeight = h = this.labelWrap ? (k - m * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) : 1.5 * this.labelFontSize, y(this.options.labelWrap)) ? y(this.options.labelWrap) && (this.labelWrap && !y(this.options.labelMaxWidth) ? (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : m, this.sessionVariables.labelMaxHeight = h) : (this.sessionVariables.labelAngle = this.labelAngle,
	                                    this.sessionVariables.labelMaxWidth = m, this.sessionVariables.labelMaxHeight = c < 0.9 * l ? 0.9 * l : c, this.sessionVariables.labelWrap = this.labelWrap)) : (this.options.labelWrap ? (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : m) : (y(this.options.labelMaxWidth), this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : m, this.sessionVariables.labelWrap = this.labelWrap), this.sessionVariables.labelMaxHeight =
	                                    h)
	                            }
	                        for (c = 0; c < this._labels.length; c++) a = this._labels[c].textBlock, a.maxWidth = this.labelMaxWidth = this.sessionVariables.labelMaxWidth, a.fontSize = this.sessionVariables.labelFontSize, a.angle = this.labelAngle = this.sessionVariables.labelAngle, a.wrap = this.labelWrap = this.sessionVariables.labelWrap, a.maxHeight = this.sessionVariables.labelMaxHeight, a.measureText()
	                    } else
	                        for (b = 0; b < this._labels.length; b++) a = this._labels[b].textBlock, a.maxWidth = this.labelMaxWidth = y(this.options.labelMaxWidth) ? this.sessionVariables.labelMaxWidth :
	                            this.options.labelMaxWidth, a.fontSize = this.labelFontSize = y(this.options.labelFontSize) ? this.sessionVariables.labelFontSize : this.options.labelFontSize, a.angle = this.labelAngle = y(this.options.labelAngle) ? this.sessionVariables.labelAngle : this.labelAngle, a.wrap = this.labelWrap = y(this.options.labelWrap) ? this.sessionVariables.labelWrap : this.options.labelWrap, a.maxHeight = this.sessionVariables.labelMaxHeight, a.measureText();
	            else if ("left" === this._position || "right" === this._position)
	                if (g = y(this.options.labelMaxWidth) ?
	                    0.3 * this.chart.width >> 0 : this.options.labelMaxWidth, h = "undefined" === typeof this.options.labelWrap || this.labelWrap ? 0.3 * this.chart.height >> 0 : 1.5 * this.labelFontSize, !this.chart.panEnabled && 1 <= this._labels.length) {
	                    this.sessionVariables.labelFontSize = this.labelFontSize;
	                    this.sessionVariables.labelMaxWidth = g;
	                    this.sessionVariables.labelMaxHeight = h;
	                    this.sessionVariables.labelAngle = y(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle;
	                    this.sessionVariables.labelWrap = this.labelWrap;
	                    for (b = 0; b <
	                        this._labels.length; b++)
	                        if (!this._labels[b].breaksLabelType) {
	                            a = this._labels[b].textBlock;
	                            q = a.measureText();
	                            for (d = b + 1; d < this._labels.length; d++)
	                                if (!this._labels[d].breaksLabelType) {
	                                    f = this._labels[d].textBlock;
	                                    f = f.measureText();
	                                    break
	                                }
	                            e.push(a.height);
	                            this.sessionVariables.labelMaxHeight = Math.max.apply(Math, e);
	                            c = g * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (h - a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));
	                            Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));
	                            Math.sin(Math.PI / 180 * Math.abs(this.labelAngle));
	                            y(this.options.labelAngle) && isNaN(this.options.labelAngle) && 0 !== this.options.labelAngle ? y(this.options.labelWrap) ? y(this.options.labelWrap) && (y(this.options.labelMaxWidth) ? y(f) || (l = q.height + f.height >> 0, l - 2 * h > n && (n = l - 2 * h, l >= 2 * h && l < 2.4 * h ? (y(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelMaxHeight = h, this.sessionVariables.labelFontSize = y(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize) :
	                                l >= 2.4 * h && l < 2.8 * h ? (this.sessionVariables.labelMaxHeight = c, this.sessionVariables.labelFontSize = this.labelFontSize, this.sessionVariables.labelWrap = !0) : l >= 2.8 * h && l < 3.2 * h ? (this.sessionVariables.labelMaxHeight = h, this.sessionVariables.labelWrap = !0, y(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelFontSize = y(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize, this.sessionVariables.labelAngle =
	                                    y(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle) : l >= 3.2 * h && l < 3.6 * h ? (this.sessionVariables.labelMaxHeight = c, this.sessionVariables.labelWrap = !0, this.sessionVariables.labelFontSize = this.labelFontSize) : l > 3.6 * h && l < 10 * h ? (y(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelFontSize = y(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize, this.sessionVariables.labelMaxWidth =
	                                    g, this.sessionVariables.labelMaxHeight = h, this.sessionVariables.labelAngle = y(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle) : l > 10 * h && l < 50 * h && (y(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelFontSize = y(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize, this.sessionVariables.labelMaxHeight = h, this.sessionVariables.labelMaxWidth = g, this.sessionVariables.labelAngle =
	                                    y(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle))) : (this.sessionVariables.labelMaxHeight = h, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth)) : (this.sessionVariables.labelMaxWidth = this.labelWrap ? this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth : this.labelMaxWidth ? this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth : g, this.sessionVariables.labelMaxHeight =
	                                h) : (this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelMaxWidth = 0 === this.labelAngle ? g : Math.min((c - h * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)), h), y(this.options.labelWrap)) ? y(this.options.labelWrap) && (this.labelWrap && !y(this.options.labelMaxWidth) ? (this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth > this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth, this.sessionVariables.labelWrap =
	                                this.labelWrap, this.sessionVariables.labelMaxHeight = c) : (this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : g, this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? h : c, y(this.options.labelMaxWidth) && (this.sessionVariables.labelAngle = this.labelAngle))) : this.options.labelWrap ? (this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? h : c, this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = g) : (this.sessionVariables.labelMaxHeight =
	                                h, y(this.options.labelMaxWidth), this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth, this.sessionVariables.labelWrap = this.labelWrap)
	                        }
	                    for (c = 0; c < this._labels.length; c++) a = this._labels[c].textBlock, a.maxWidth = this.labelMaxWidth = this.sessionVariables.labelMaxWidth, a.fontSize = this.labelFontSize = this.sessionVariables.labelFontSize, a.angle = this.labelAngle = this.sessionVariables.labelAngle, a.wrap = this.labelWrap = this.sessionVariables.labelWrap,
	                        a.maxHeight = this.sessionVariables.labelMaxHeight, a.measureText()
	                } else
	                    for (b = 0; b < this._labels.length; b++) a = this._labels[b].textBlock, a.maxWidth = this.labelMaxWidth = y(this.options.labelMaxWidth) ? this.sessionVariables.labelMaxWidth : this.options.labelMaxWidth, a.fontSize = this.labelFontSize = y(this.options.labelFontSize) ? this.sessionVariables.labelFontSize : this.options.labelFontSize, a.angle = this.labelAngle = y(this.options.labelAngle) ? this.sessionVariables.labelAngle : this.labelAngle, a.wrap = this.labelWrap = y(this.options.labelWrap) ?
	                        this.sessionVariables.labelWrap : this.options.labelWrap, a.maxHeight = this.sessionVariables.labelMaxHeight, a.measureText();
	            for (b = 0; b < this.stripLines.length; b++) {
	                var g = this.stripLines[b],
	                    x;
	                if ("outside" === g.labelPlacement) {
	                    h = this.sessionVariables.labelMaxWidth;
	                    if ("bottom" === this._position || "top" === this._position) x = y(g.options.labelWrap) ? this.sessionVariables.labelMaxHeight : g.labelWrap ? 0.8 * this.chart.height >> 0 : 1.5 * this.labelFontSize;
	                    if ("left" === this._position || "right" === this._position) x = y(g.options.labelWrap) ?
	                        this.sessionVariables.labelMaxHeight : g.labelWrap ? 0.8 * this.chart.width >> 0 : 1.5 * this.labelFontSize;
	                    y(g.labelBackgroundColor) && (g.labelBackgroundColor = "#EEEEEE")
	                } else h = "bottom" === this._position || "top" === this._position ? 0.9 * this.chart.width >> 0 : 0.9 * this.chart.height >> 0, x = y(g.options.labelWrap) || g.labelWrap ? "bottom" === this._position || "top" === this._position ? 0.8 * this.chart.width >> 0 : 0.8 * this.chart.height >> 0 : 1.5 * this.labelFontSize, y(g.labelBackgroundColor) && (y(g.startValue) && 0 !== g.startValue ? g.labelBackgroundColor =
	                    v ? "transparent" : null : g.labelBackgroundColor = "#EEEEEE");
	                a = new la(this.ctx, {
	                    x: 0,
	                    y: 0,
	                    backgroundColor: g.labelBackgroundColor,
	                    borderColor: g.labelBorderColor,
	                    borderThickness: g.labelBorderThickness,
	                    cornerRadius: g.labelCornerRadius,
	                    maxWidth: g.options.labelMaxWidth ? g.options.labelMaxWidth : h,
	                    maxHeight: x,
	                    angle: this.labelAngle,
	                    text: g.labelFormatter ? g.labelFormatter({
	                        chart: this.chart,
	                        axis: this,
	                        stripLine: g
	                    }) : g.label,
	                    horizontalAlign: "left",
	                    fontSize: "outside" === g.labelPlacement ? g.options.labelFontSize ? g.labelFontSize :
	                        this.labelFontSize : g.labelFontSize,
	                    fontFamily: "outside" === g.labelPlacement ? g.options.labelFontFamily ? g.labelFontFamily : this.labelFontFamily : g.labelFontFamily,
	                    fontWeight: "outside" === g.labelPlacement ? g.options.labelFontWeight ? g.labelFontWeight : this.labelFontWeight : g.labelFontWeight,
	                    fontColor: g.labelFontColor || g.color,
	                    fontStyle: "outside" === g.labelPlacement ? g.options.labelFontStyle ? g.labelFontStyle : this.fontWeight : g.labelFontStyle,
	                    textBaseline: "middle"
	                });
	                this._stripLineLabels.push({
	                    position: g.value,
	                    textBlock: a,
	                    effectiveHeight: null,
	                    stripLine: g
	                })
	            }
	        };
	        C.prototype.createLabelsAndCalculateWidth = function() {
	            var a = 0,
	                f = 0;
	            this._labels = [];
	            this._stripLineLabels = [];
	            if ("left" === this._position || "right" === this._position) {
	                this.createLabels();
	                for (f = 0; f < this._labels.length; f++) {
	                    var b = this._labels[f].textBlock,
	                        c = b.measureText(),
	                        e = 0,
	                        e = 0 === this.labelAngle ? c.width : c.width * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) + (c.height - b.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle));
	                    a < e && (a = e);
	                    this._labels[f].effectiveWidth =
	                        e
	                }
	                for (f = 0; f < this._stripLineLabels.length; f++) "outside" === this._stripLineLabels[f].stripLine.labelPlacement && (this._stripLineLabels[f].stripLine.value > this.viewportMinimum && this._stripLineLabels[f].stripLine.value < this.viewportMaximum) && (b = this._stripLineLabels[f].textBlock, c = b.measureText(), e = 0 === this.labelAngle ? c.width : c.width * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) + (c.height - b.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), a < e && (a = e), this._stripLineLabels[f].effectiveWidth =
	                    e)
	            }
	            f = this.title ? this._titleTextBlock.measureText().height + 2 : 0;
	            return b = "inside" === this.labelPlacement ? b = f + 5 : f + a + this.tickLength + 5
	        };
	        C.prototype.createLabelsAndCalculateHeight = function() {
	            var a = 0;
	            this._labels = [];
	            this._stripLineLabels = [];
	            var f, b = 0;
	            this.createLabels();
	            if ("bottom" === this._position || "top" === this._position) {
	                for (b = 0; b < this._labels.length; b++) {
	                    f = this._labels[b].textBlock;
	                    var c = f.measureText(),
	                        e = 0,
	                        e = 0 === this.labelAngle ? c.height : c.width * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (c.height -
	                            f.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));
	                    a < e && (a = e);
	                    this._labels[b].effectiveHeight = e
	                }
	                for (b = 0; b < this._stripLineLabels.length; b++) "outside" === this._stripLineLabels[b].stripLine.labelPlacement && (f = this._stripLineLabels[b].textBlock, c = f.measureText(), e = 0 === this.labelAngle ? c.height : c.width * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (c.height - f.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)), a < e && (a = e), this._stripLineLabels[b].effectiveHeight = e)
	            }
	            f = this.title ? this._titleTextBlock.measureText().height +
	                2 : 0;
	            return b = "inside" === this.labelPlacement ? b = f + 5 : f + a + this.tickLength + 5
	        };
	        C.setLayoutAndRender = function(a, f, b, c, e, g) {
	            var h, l, t, k, m = a[0] ? a[0].chart : f[0].chart,
	                p = m.ctx,
	                n = m._axes;
	            if (a && 0 < a.length)
	                for (var d = 0; d < a.length; d++) a[d] && a[d].calculateAxisParameters();
	            if (f && 0 < f.length)
	                for (d = 0; d < f.length; d++) f[d].calculateAxisParameters();
	            if (b && 0 < b.length)
	                for (d = 0; d < b.length; d++) b[d].calculateAxisParameters();
	            if (c && 0 < c.length)
	                for (d = 0; d < c.length; d++) c[d].calculateAxisParameters();
	            for (d = 0; d < n.length; d++)
	                if (n[d] &&
	                    n[d].scaleBreaks && n[d].scaleBreaks._appliedBreaks.length)
	                    for (var q = n[d].scaleBreaks._appliedBreaks, s = 0; s < q.length && !(q[s].startValue > n[d].viewportMaximum); s++) q[s].endValue < n[d].viewportMinimum || (y(n[d].scaleBreaks.firstBreakIndex) && (n[d].scaleBreaks.firstBreakIndex = s), q[s].startValue >= n[d].viewPortMinimum && (n[d].scaleBreaks.lastBreakIndex = s));
	            for (var x = s = 0, u = 0, z = 0, C = 0, G = 0, B = 0, A, H, L = l = 0, J, I, N, q = J = I = N = !1, d = 0; d < n.length; d++) n[d] && n[d].title && (n[d]._titleTextBlock = new la(n[d].ctx, {
	                text: n[d].title,
	                horizontalAlign: "center",
	                fontSize: n[d].titleFontSize,
	                fontFamily: n[d].titleFontFamily,
	                fontWeight: n[d].titleFontWeight,
	                fontColor: n[d].titleFontColor,
	                fontStyle: n[d].titleFontStyle,
	                borderColor: n[d].titleBorderColor,
	                borderThickness: n[d].titleBorderThickness,
	                backgroundColor: n[d].titleBackgroundColor,
	                cornerRadius: n[d].titleCornerRadius,
	                textBaseline: "top"
	            }));
	            for (d = 0; d < n.length; d++)
	                if (n[d].title) switch (n[d]._position) {
	                    case "left":
	                        n[d]._titleTextBlock.maxWidth = n[d].titleMaxWidth || g.height;
	                        n[d]._titleTextBlock.maxHeight = n[d].titleWrap ?
	                            0.8 * g.width : 1.5 * n[d].titleFontSize;
	                        n[d]._titleTextBlock.angle = -90;
	                        break;
	                    case "right":
	                        n[d]._titleTextBlock.maxWidth = n[d].titleMaxWidth || g.height;
	                        n[d]._titleTextBlock.maxHeight = n[d].titleWrap ? 0.8 * g.width : 1.5 * n[d].titleFontSize;
	                        n[d]._titleTextBlock.angle = 90;
	                        break;
	                    default:
	                        n[d]._titleTextBlock.maxWidth = n[d].titleMaxWidth || g.width, n[d]._titleTextBlock.maxHeight = n[d].titleWrap ? 0.8 * g.height : 1.5 * n[d].titleFontSize, n[d]._titleTextBlock.angle = 0
	                }
	            if ("normal" === e) {
	                for (var z = [], C = [], G = [], B = [], O = [], P = [], R = [], Q = []; 4 >
	                    s;) {
	                    var E = 0,
	                        T = 0,
	                        U = 0,
	                        X = 0,
	                        V = e = 0,
	                        K = 0,
	                        Z = 0,
	                        Y = 0,
	                        W = 0,
	                        M = 0,
	                        aa = 0;
	                    if (b && 0 < b.length)
	                        for (G = [], d = M = 0; d < b.length; d++) G.push(Math.ceil(b[d] ? b[d].createLabelsAndCalculateWidth() : 0)), M += G[d], K += b[d] ? b[d].margin : 0;
	                    else G.push(Math.ceil(b[0] ? b[0].createLabelsAndCalculateWidth() : 0));
	                    R.push(G);
	                    if (c && 0 < c.length)
	                        for (B = [], d = aa = 0; d < c.length; d++) B.push(Math.ceil(c[d] ? c[d].createLabelsAndCalculateWidth() : 0)), aa += B[d], Z += c[d] ? c[d].margin : 0;
	                    else B.push(Math.ceil(c[0] ? c[0].createLabelsAndCalculateWidth() : 0));
	                    Q.push(B);
	                    h = Math.round(g.x1 +
	                        M + K);
	                    t = Math.round(g.x2 - aa - Z > m.width - 10 ? m.width - 10 : g.x2 - aa - Z);
	                    if (a && 0 < a.length)
	                        for (z = [], d = Y = 0; d < a.length; d++) a[d] && (a[d].lineCoordinates = {}), a[d].lineCoordinates.width = Math.abs(t - h), a[d].title && (a[d]._titleTextBlock.maxWidth = 0 < a[d].titleMaxWidth && a[d].titleMaxWidth < a[d].lineCoordinates.width ? a[d].titleMaxWidth : a[d].lineCoordinates.width), z.push(Math.ceil(a[d] ? a[d].createLabelsAndCalculateHeight() : 0)), Y += z[d], e += a[d] ? a[d].margin : 0;
	                    else z.push(Math.ceil(a[0] ? a[0].createLabelsAndCalculateHeight() : 0));
	                    O.push(z);
	                    if (f && 0 < f.length)
	                        for (C = [], d = W = 0; d < f.length; d++) f[d] && (f[d].lineCoordinates = {}), f[d].lineCoordinates.width = Math.abs(t - h), f[d].title && (f[d]._titleTextBlock.maxWidth = 0 < f[d].titleMaxWidth && f[d].titleMaxWidth < f[d].lineCoordinates.width ? f[d].titleMaxWidth : f[d].lineCoordinates.width), C.push(Math.ceil(f[d] ? f[d].createLabelsAndCalculateHeight() : 0)), W += C[d], V += f[d] ? f[d].margin : 0;
	                    else C.push(Math.ceil(f[0] ? f[0].createLabelsAndCalculateHeight() : 0));
	                    P.push(C);
	                    if (a && 0 < a.length)
	                        for (d = 0; d < a.length; d++) a[d] &&
	                            (a[d].lineCoordinates.x1 = h, t = Math.round(g.x2 - aa - Z > m.width - 10 ? m.width - 10 : g.x2 - aa - Z), a[d]._labels && 1 < a[d]._labels.length && (l = k = 0, k = a[d]._labels[1], l = "dateTime" === a[d].valueType ? a[d]._labels[a[d]._labels.length - 2] : a[d]._labels[a[d]._labels.length - 1], x = k.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(k.textBlock.angle)) + (k.textBlock.height - l.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(k.textBlock.angle)), u = l.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(l.textBlock.angle)) + (l.textBlock.height -
	                                l.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(l.textBlock.angle))), a[d] && (a[d].labelAutoFit && !y(A) && !y(H)) && (l = 0, 0 < a[d].labelAngle ? H + u > t && (l += 0 < a[d].labelAngle ? H + u - t - aa : 0) : 0 > a[d].labelAngle ? A - x < h && A - x < a[d].viewportMinimum && (L = h - (K + a[d].tickLength + G + A - x + a[d].labelFontSize / 2)) : 0 === a[d].labelAngle && (H + u > t && (l = H + u / 2 - t - aa), A - x < h && A - x < a[d].viewportMinimum && (L = h - K - a[d].tickLength - G - A + x / 2)), a[d].viewportMaximum === a[d].maximum && a[d].viewportMinimum === a[d].minimum && 0 < a[d].labelAngle && 0 < l ? t -= l : a[d].viewportMaximum ===
	                                a[d].maximum && a[d].viewportMinimum === a[d].minimum && 0 > a[d].labelAngle && 0 < L ? h += L : a[d].viewportMaximum === a[d].maximum && a[d].viewportMinimum === a[d].minimum && 0 === a[d].labelAngle && (0 < L && (h += L), 0 < l && (t -= l))), m.panEnabled ? Y = m.sessionVariables.axisX.height : m.sessionVariables.axisX.height = Y, l = Math.round(g.y2 - Y - e + E), k = Math.round(g.y2), a[d].lineCoordinates.x2 = t, a[d].lineCoordinates.width = t - h, a[d].lineCoordinates.y1 = l, a[d].lineCoordinates.y2 = l, a[d].bounds = {
	                                x1: h,
	                                y1: l,
	                                x2: t,
	                                y2: k - (Y + e - z[d] - E),
	                                width: t - h,
	                                height: k - l
	                            }),
	                            E += z[d] + a[d].margin;
	                    if (f && 0 < f.length)
	                        for (d = 0; d < f.length; d++) f[d].lineCoordinates.x1 = Math.round(g.x1 + M + K), f[d].lineCoordinates.x2 = Math.round(g.x2 - aa - Z > m.width - 10 ? m.width - 10 : g.x2 - aa - Z), f[d].lineCoordinates.width = Math.abs(t - h), f[d]._labels && 1 < f[d]._labels.length && (k = f[d]._labels[1], l = "dateTime" === f[d].valueType ? f[d]._labels[f[d]._labels.length - 2] : f[d]._labels[f[d]._labels.length - 1], x = k.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(k.textBlock.angle)) + (k.textBlock.height - l.textBlock.fontSize / 2) * Math.sin(Math.PI /
	                            180 * Math.abs(k.textBlock.angle)), u = l.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(l.textBlock.angle)) + (l.textBlock.height - l.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(l.textBlock.angle))), m.panEnabled ? W = m.sessionVariables.axisX2.height : m.sessionVariables.axisX2.height = W, l = Math.round(g.y1), k = Math.round(g.y2 + f[d].margin), f[d].lineCoordinates.y1 = l + W + V - T, f[d].lineCoordinates.y2 = l, f[d].bounds = {
	                            x1: h,
	                            y1: l + (W + V - C[d] - T),
	                            x2: t,
	                            y2: k,
	                            width: t - h,
	                            height: k - l
	                        }, T += C[d] + f[d].margin;
	                    if (b && 0 < b.length)
	                        for (d = 0; d <
	                            b.length; d++) K = 10, b[d] && (h = Math.round(a[0] ? a[0].lineCoordinates.x1 : f[0].lineCoordinates.x1), K = b[d]._labels && 0 < b[d]._labels.length ? b[d]._labels[b[d]._labels.length - 1].textBlock.height / 2 : 10, l = Math.round(g.y1 + W + V < Math.max(K, 10) ? Math.max(K, 10) : g.y1 + W + V), t = Math.round(a[0] ? a[0].lineCoordinates.x1 : f[0].lineCoordinates.x1), K = 0 < a.length ? 0 : b[d]._labels && 0 < b[d]._labels.length ? b[d]._labels[0].textBlock.height / 2 : 10, k = Math.round(g.y2 - Y - e - K), b[d].lineCoordinates = {
	                            x1: t - U,
	                            y1: l,
	                            x2: t - U,
	                            y2: k,
	                            height: Math.abs(k - l)
	                        }, b[d].bounds = {
	                            x1: h - (G[d] + U),
	                            y1: l,
	                            x2: t,
	                            y2: k,
	                            width: t - h,
	                            height: k - l
	                        }, b[d].title && (b[d]._titleTextBlock.maxWidth = 0 < b[d].titleMaxWidth && b[d].titleMaxWidth < b[d].lineCoordinates.height ? b[d].titleMaxWidth : b[d].lineCoordinates.height), U += G[d] + b[d].margin);
	                    if (c && 0 < c.length)
	                        for (d = 0; d < c.length; d++) c[d] && (h = Math.round(a[0] ? a[0].lineCoordinates.x2 : f[0].lineCoordinates.x2), t = Math.round(h), K = c[d]._labels && 0 < c[d]._labels.length ? c[d]._labels[c[d]._labels.length - 1].textBlock.height / 2 : 0, l = Math.round(g.y1 + W + V < Math.max(K, 10) ? Math.max(K,
	                            10) : g.y1 + W + V), K = 0 < a.length ? 0 : c[d]._labels && 0 < c[d]._labels.length ? c[d]._labels[0].textBlock.height / 2 : 0, k = Math.round(g.y2 - (Y + e + K)), c[d].lineCoordinates = {
	                            x1: h + X,
	                            y1: l,
	                            x2: h + X,
	                            y2: k,
	                            height: Math.abs(k - l)
	                        }, c[d].bounds = {
	                            x1: h,
	                            y1: l,
	                            x2: t + (B[d] + X),
	                            y2: k,
	                            width: t - h,
	                            height: k - l
	                        }, c[d].title && (c[d]._titleTextBlock.maxWidth = 0 < c[d].titleMaxWidth && c[d].titleMaxWidth < c[d].lineCoordinates.height ? c[d].titleMaxWidth : c[d].lineCoordinates.height), X += B[d] + c[d].margin);
	                    if (a && 0 < a.length)
	                        for (d = 0; d < a.length; d++) a[d] && (a[d].calculateValueToPixelConversionParameters(),
	                            a[d].calculateBreaksSizeInValues(), a[d]._labels && 1 < a[d]._labels.length && (A = (a[d].logarithmic ? Math.log(a[d]._labels[1].position / a[d].viewportMinimum) / a[d].conversionParameters.lnLogarithmBase : a[d]._labels[1].position - a[d].viewportMinimum) * Math.abs(a[d].conversionParameters.pixelPerUnit) + a[d].lineCoordinates.x1, h = a[d]._labels[a[d]._labels.length - ("dateTime" === a[d].valueType ? 2 : 1)].position, h = a[d].getApparentDifference(a[d].viewportMinimum, h), H = a[d].logarithmic ? (1 < h ? Math.log(h) / a[d].conversionParameters.lnLogarithmBase *
	                                Math.abs(a[d].conversionParameters.pixelPerUnit) : 0) + a[d].lineCoordinates.x1 : (0 < h ? h * Math.abs(a[d].conversionParameters.pixelPerUnit) : 0) + a[d].lineCoordinates.x1));
	                    if (f && 0 < f.length)
	                        for (d = 0; d < f.length; d++) f[d].calculateValueToPixelConversionParameters(), f[d].calculateBreaksSizeInValues(), f[d]._labels && 1 < f[d]._labels.length && (A = (f[d].logarithmic ? Math.log(f[d]._labels[1].position / f[d].viewportMinimum) / f[d].conversionParameters.lnLogarithmBase : f[d]._labels[1].position - f[d].viewportMinimum) * Math.abs(f[d].conversionParameters.pixelPerUnit) +
	                            f[d].lineCoordinates.x1, h = f[d]._labels[f[d]._labels.length - ("dateTime" === f[d].valueType ? 2 : 1)].position, h = f[d].getApparentDifference(f[d].viewportMinimum, h), H = f[d].logarithmic ? (1 < h ? Math.log(h) / f[d].conversionParameters.lnLogarithmBase * Math.abs(f[d].conversionParameters.pixelPerUnit) : 0) + f[d].lineCoordinates.x1 : (0 < h ? h * Math.abs(f[d].conversionParameters.pixelPerUnit) : 0) + f[d].lineCoordinates.x1);
	                    for (d = 0; d < n.length; d++) "axisY" === n[d].type && (n[d].calculateValueToPixelConversionParameters(), n[d].calculateBreaksSizeInValues());
	                    if (0 < s) {
	                        if (a && 0 < a.length)
	                            for (d = 0; d < a.length; d++) q = O[s - 1][d] === O[s][d] ? !0 : !1;
	                        else q = !0;
	                        if (f && 0 < f.length)
	                            for (d = 0; d < f.length; d++) J = P[s - 1][d] === P[s][d] ? !0 : !1;
	                        else J = !0;
	                        if (b && 0 < b.length)
	                            for (d = 0; d < b.length; d++) I = R[s - 1][d] === R[s][d] ? !0 : !1;
	                        else I = !0;
	                        if (c && 0 < c.length)
	                            for (d = 0; d < c.length; d++) N = Q[s - 1][d] === Q[s][d] ? !0 : !1;
	                        else N = !0
	                    }
	                    if (q && J && I && N) break;
	                    s++
	                }
	                p.save();
	                p.beginPath();
	                a[0] && p.rect(5, a[0].bounds.y1, a[0].chart.width - 10, a[0].bounds.height);
	                f[0] && p.rect(5, f[f.length - 1].bounds.y1, f[0].chart.width - 10, f[0].bounds.height);
	                p.clip();
	                if (a && 0 < a.length)
	                    for (d = 0; d < a.length; d++) a[d].calculateStripLinesThicknessInValues(), a[d].calculateBreaksInPixels(), a[d].renderLabelsTicksAndTitle();
	                if (f && 0 < f.length)
	                    for (d = 0; d < f.length; d++) f[d].calculateStripLinesThicknessInValues(), f[d].calculateBreaksInPixels(), f[d].renderLabelsTicksAndTitle();
	                p.restore();
	                if (b && 0 < b.length)
	                    for (d = 0; d < b.length; d++) b[d].calculateStripLinesThicknessInValues(), b[d].calculateBreaksInPixels(), b[d].renderLabelsTicksAndTitle();
	                if (c && 0 < c.length)
	                    for (d = 0; d < c.length; d++) c[d].calculateStripLinesThicknessInValues(),
	                        c[d].calculateBreaksInPixels(), c[d].renderLabelsTicksAndTitle()
	            } else {
	                A = [];
	                L = [];
	                x = [];
	                H = [];
	                u = [];
	                O = [];
	                P = [];
	                for (R = []; 4 > s;) {
	                    W = Y = M = X = Z = K = V = e = U = Q = T = E = 0;
	                    if (a && 0 < a.length)
	                        for (x = [], d = Y = 0; d < a.length; d++) x.push(Math.ceil(a[d] ? a[d].createLabelsAndCalculateWidth() : 0)), Y += x[d], e += a[d] ? a[d].margin : 0;
	                    else x.push(Math.ceil(a[0] ? a[0].createLabelsAndCalculateWidth() : 0));
	                    P.push(x);
	                    if (f && 0 < f.length)
	                        for (H = [], d = W = 0; d < f.length; d++) H.push(Math.ceil(f[d] ? f[d].createLabelsAndCalculateWidth() : 0)), W += H[d], V += f[d] ? f[d].margin :
	                            0;
	                    else H.push(Math.ceil(f[0] ? f[0].createLabelsAndCalculateWidth() : 0));
	                    R.push(H);
	                    if (b && 0 < b.length)
	                        for (d = 0; d < b.length; d++) b[d].lineCoordinates = {}, h = Math.round(g.x1 + Y + e), t = Math.round(g.x2 - W - V > m.width - 10 ? m.width - 10 : g.x2 - W - V), b[d].labelAutoFit && !y(z) && (0 < !a.length && (h = 0 > b[d].labelAngle ? Math.max(h, z) : 0 === b[d].labelAngle ? Math.max(h, z / 2) : h), 0 < !f.length && (t = 0 < b[d].labelAngle ? t - C / 2 : 0 === b[d].labelAngle ? t - C / 2 : t)), b[d].lineCoordinates.x1 = h, b[d].lineCoordinates.x2 = t, b[d].lineCoordinates.width = Math.abs(t - h), b[d].title &&
	                            (b[d]._titleTextBlock.maxWidth = 0 < b[d].titleMaxWidth && b[d].titleMaxWidth < b[d].lineCoordinates.width ? b[d].titleMaxWidth : b[d].lineCoordinates.width);
	                    if (c && 0 < c.length)
	                        for (d = 0; d < c.length; d++) c[d].lineCoordinates = {}, h = Math.round(g.x1 + Y + e), t = Math.round(g.x2 - W - V > c[d].chart.width - 10 ? c[d].chart.width - 10 : g.x2 - W - V), c[d] && c[d].labelAutoFit && !y(G) && (0 < !a.length && (h = 0 < c[d].labelAngle ? Math.max(h, G) : 0 === c[d].labelAngle ? Math.max(h, G / 2) : h), 0 < !f.length && (t -= B / 2)), c[d].lineCoordinates.x1 = h, c[d].lineCoordinates.x2 = t, c[d].lineCoordinates.width =
	                            Math.abs(t - h), c[d].title && (c[d]._titleTextBlock.maxWidth = 0 < c[d].titleMaxWidth && c[d].titleMaxWidth < c[d].lineCoordinates.width ? c[d].titleMaxWidth : c[d].lineCoordinates.width);
	                    if (b && 0 < b.length)
	                        for (A = [], d = X = 0; d < b.length; d++) A.push(Math.ceil(b[d] ? b[d].createLabelsAndCalculateHeight() : 0)), X += A[d] + b[d].margin, K += b[d].margin;
	                    else A.push(Math.ceil(b[0] ? b[0].createLabelsAndCalculateHeight() : 0));
	                    u.push(A);
	                    if (c && 0 < c.length)
	                        for (L = [], d = M = 0; d < c.length; d++) L.push(Math.ceil(c[d] ? c[d].createLabelsAndCalculateHeight() :
	                            0)), M += L[d], Z += c[d].margin;
	                    else L.push(Math.ceil(c[0] ? c[0].createLabelsAndCalculateHeight() : 0));
	                    O.push(L);
	                    if (b && 0 < b.length)
	                        for (d = 0; d < b.length; d++) 0 < b[d]._labels.length && (k = b[d]._labels[0], l = b[d]._labels[b[d]._labels.length - 1], z = k.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(k.textBlock.angle)) + (k.textBlock.height - l.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(k.textBlock.angle)), C = l.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(l.textBlock.angle)) + (l.textBlock.height - l.textBlock.fontSize /
	                            2) * Math.sin(Math.PI / 180 * Math.abs(l.textBlock.angle)));
	                    if (c && 0 < c.length)
	                        for (d = 0; d < c.length; d++) c[d] && 0 < c[d]._labels.length && (k = c[d]._labels[0], l = c[d]._labels[c[d]._labels.length - 1], G = k.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(k.textBlock.angle)) + (k.textBlock.height - l.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(k.textBlock.angle)), B = l.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(l.textBlock.angle)) + (l.textBlock.height - l.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(l.textBlock.angle)));
	                    if (m.panEnabled)
	                        for (d = 0; d < b.length; d++) A[d] = m.sessionVariables.axisY.height;
	                    else
	                        for (d = 0; d < b.length; d++) m.sessionVariables.axisY.height = A[d];
	                    if (b && 0 < b.length)
	                        for (d = b.length - 1; 0 <= d; d--) l = Math.round(g.y2), k = Math.round(g.y2 > b[d].chart.height - 10 ? b[d].chart.height - 10 : g.y2), b[d].lineCoordinates.y1 = l - (A[d] + b[d].margin + E), b[d].lineCoordinates.y2 = l - (A[d] + b[d].margin + E), b[d].bounds = {
	                            x1: h,
	                            y1: l - (A[d] + E + b[d].margin),
	                            x2: t,
	                            y2: k - (E + b[d].margin),
	                            width: t - h,
	                            height: A[d]
	                        }, b[d].title && (b[d]._titleTextBlock.maxWidth = 0 <
	                            b[d].titleMaxWidth && b[d].titleMaxWidth < b[d].lineCoordinates.width ? b[d].titleMaxWidth : b[d].lineCoordinates.width), E += A[d] + b[d].margin;
	                    if (c && 0 < c.length)
	                        for (d = c.length - 1; 0 <= d; d--) c[d] && (l = Math.round(g.y1), k = Math.round(g.y1 + (L[d] + c[d].margin + T)), c[d].lineCoordinates.y1 = k, c[d].lineCoordinates.y2 = k, c[d].bounds = {
	                                x1: h,
	                                y1: l + (c[d].margin + T),
	                                x2: t,
	                                y2: k,
	                                width: t - h,
	                                height: M
	                            }, c[d].title && (c[d]._titleTextBlock.maxWidth = 0 < c[d].titleMaxWidth && c[d].titleMaxWidth < c[d].lineCoordinates.width ? c[d].titleMaxWidth : c[d].lineCoordinates.width),
	                            T += L[d] + c[d].margin);
	                    if (a && 0 < a.length)
	                        for (d = 0; d < a.length; d++) {
	                            K = a[d]._labels && 0 < a[d]._labels.length ? a[d]._labels[0].textBlock.fontSize / 2 : 0;
	                            h = Math.round(g.x1 + e);
	                            l = c && 0 < c.length ? Math.round(c[0] ? c[0].lineCoordinates.y2 : g.y1 < Math.max(K, 10) ? Math.max(K, 10) : g.y1) : g.y1 < Math.max(K, 10) ? Math.max(K, 10) : g.y1;
	                            t = Math.round(g.x1 + Y + e);
	                            k = b && 0 < b.length ? Math.round(b[0] ? b[0].lineCoordinates.y1 : g.y2 - X > m.height - Math.max(K, 10) ? m.height - Math.max(K, 10) : g.y2 - X) : g.y2 > m.height - Math.max(K, 10) ? m.height - Math.max(K, 10) : g.y2;
	                            if (b &&
	                                0 < b.length)
	                                for (K = 0; K < b.length; K++) b[K] && b[K].labelAutoFit && (t = 0 > b[K].labelAngle ? Math.max(t, z) : 0 === b[K].labelAngle ? Math.max(t, z / 2) : t, h = 0 > b[K].labelAngle || 0 === b[K].labelAngle ? t - Y : h);
	                            if (c && 0 < c.length)
	                                for (K = 0; K < c.length; K++) c[K] && c[K].labelAutoFit && (t = c[K].lineCoordinates.x1, h = t - Y);
	                            a[d].lineCoordinates = {
	                                x1: t - Q,
	                                y1: l,
	                                x2: t - Q,
	                                y2: k,
	                                height: Math.abs(k - l)
	                            };
	                            a[d].bounds = {
	                                x1: t - (x[d] + Q),
	                                y1: l,
	                                x2: t,
	                                y2: k,
	                                width: t - h,
	                                height: k - l
	                            };
	                            a[d].title && (a[d]._titleTextBlock.maxWidth = 0 < a[d].titleMaxWidth && a[d].titleMaxWidth < a[d].lineCoordinates.height ?
	                                a[d].titleMaxWidth : a[d].lineCoordinates.height);
	                            a[d].calculateValueToPixelConversionParameters();
	                            a[d].calculateBreaksSizeInValues();
	                            Q += x[d] + a[d].margin
	                        }
	                    if (f && 0 < f.length)
	                        for (d = 0; d < f.length; d++) {
	                            K = f[d]._labels && 0 < f[d]._labels.length ? f[d]._labels[0].textBlock.fontSize / 2 : 0;
	                            h = Math.round(g.x1 - e);
	                            l = c && 0 < c.length ? Math.round(c[0] ? c[0].lineCoordinates.y2 : g.y1 < Math.max(K, 10) ? Math.max(K, 10) : g.y1) : g.y1 < Math.max(K, 10) ? Math.max(K, 10) : g.y1;
	                            t = Math.round(g.x2 - W - V);
	                            k = b && 0 < b.length ? Math.round(b[0] ? b[0].lineCoordinates.y1 :
	                                g.y2 - X > m.height - Math.max(K, 10) ? m.height - Math.max(K, 10) : g.y2 - X) : g.y2 > m.height - Math.max(K, 10) ? m.height - Math.max(K, 10) : g.y2;
	                            if (b && 0 < b.length)
	                                for (K = 0; K < b.length; K++) b[K] && b[K].labelAutoFit && (t = 0 > b[K].labelAngle ? Math.max(t, z) : 0 === b[K].labelAngle ? Math.max(t, z / 2) : t, h = 0 > b[K].labelAngle || 0 === b[K].labelAngle ? t - W : h);
	                            if (c && 0 < c.length)
	                                for (K = 0; K < c.length; K++) c[K] && c[K].labelAutoFit && (t = c[K].lineCoordinates.x2, h = t - W);
	                            f[d].lineCoordinates = {
	                                x1: t + U,
	                                y1: l,
	                                x2: t + U,
	                                y2: k,
	                                height: Math.abs(k - l)
	                            };
	                            f[d].bounds = {
	                                x1: h,
	                                y1: l,
	                                x2: t +
	                                    H[d] + U,
	                                y2: k,
	                                width: t - h,
	                                height: k - l
	                            };
	                            f[d].title && (f[d]._titleTextBlock.maxWidth = 0 < f[d].titleMaxWidth && f[d].titleMaxWidth < f[d].lineCoordinates.height ? f[d].titleMaxWidth : f[d].lineCoordinates.height);
	                            f[d].calculateValueToPixelConversionParameters();
	                            f[d].calculateBreaksSizeInValues();
	                            U += H[d] + f[d].margin
	                        }
	                    for (d = 0; d < n.length; d++) "axisY" === n[d].type && (n[d].calculateValueToPixelConversionParameters(), n[d].calculateBreaksSizeInValues());
	                    if (0 < s) {
	                        if (a && 0 < a.length)
	                            for (d = 0; d < a.length; d++) q = P[s - 1][d] === P[s][d] ? !0 :
	                                !1;
	                        else q = !0;
	                        if (f && 0 < f.length)
	                            for (d = 0; d < f.length; d++) J = R[s - 1][d] === R[s][d] ? !0 : !1;
	                        else J = !0;
	                        if (b && 0 < b.length)
	                            for (d = 0; d < b.length; d++) I = u[s - 1][d] === u[s][d] ? !0 : !1;
	                        else I = !0;
	                        if (c && 0 < c.length)
	                            for (d = 0; d < c.length; d++) N = O[s - 1][d] === O[s][d] ? !0 : !1;
	                        else N = !0
	                    }
	                    if (q && J && I && N) break;
	                    s++
	                }
	                if (b && 0 < b.length)
	                    for (d = 0; d < b.length; d++) b[d].calculateBreaksInPixels(), b[d].renderLabelsTicksAndTitle();
	                if (c && 0 < c.length)
	                    for (d = 0; d < c.length; d++) c[d].calculateBreaksInPixels(), c[d].renderLabelsTicksAndTitle();
	                if (a && 0 < a.length)
	                    for (d =
	                        0; d < a.length; d++) a[d].calculateBreaksInPixels(), a[d].renderLabelsTicksAndTitle();
	                if (f && 0 < f.length)
	                    for (d = 0; d < f.length; d++) f[d].calculateBreaksInPixels(), f[d].renderLabelsTicksAndTitle()
	            }
	            m.preparePlotArea();
	            g = m.plotArea;
	            p.save();
	            p.beginPath();
	            p.rect(g.x1, g.y1, Math.abs(g.x2 - g.x1), Math.abs(g.y2 - g.y1));
	            p.clip();
	            if (a && 0 < a.length)
	                for (d = 0; d < n.length; d++) n[d].renderStripLinesOfThicknessType("value");
	            if (f && 0 < f.length)
	                for (d = 0; d < f.length; d++) f[d].renderStripLinesOfThicknessType("value");
	            if (b && 0 < b.length)
	                for (d =
	                    0; d < b.length; d++) b[d].renderStripLinesOfThicknessType("value");
	            if (c && 0 < c.length)
	                for (d = 0; d < c.length; d++) c[d].renderStripLinesOfThicknessType("value");
	            if (a && 0 < a.length)
	                for (d = 0; d < a.length; d++) a[d].renderInterlacedColors();
	            if (f && 0 < f.length)
	                for (d = 0; d < f.length; d++) f[d].renderInterlacedColors();
	            if (b && 0 < b.length)
	                for (d = 0; d < b.length; d++) b[d].renderInterlacedColors();
	            if (c && 0 < c.length)
	                for (d = 0; d < c.length; d++) c[d].renderInterlacedColors();
	            p.restore();
	            if (a && 0 < a.length)
	                for (d = 0; d < a.length; d++) a[d].renderGrid(), v &&
	                    (a[d].createMask(), a[d].renderBreaksBackground());
	            if (f && 0 < f.length)
	                for (d = 0; d < f.length; d++) f[d].renderGrid(), v && (f[d].createMask(), f[d].renderBreaksBackground());
	            if (b && 0 < b.length)
	                for (d = 0; d < b.length; d++) b[d].renderGrid(), v && (b[d].createMask(), b[d].renderBreaksBackground());
	            if (c && 0 < c.length)
	                for (d = 0; d < c.length; d++) c[d].renderGrid(), v && (c[d].createMask(), c[d].renderBreaksBackground());
	            if (a && 0 < a.length)
	                for (d = 0; d < a.length; d++) a[d].renderAxisLine();
	            if (f && 0 < f.length)
	                for (d = 0; d < f.length; d++) f[d].renderAxisLine();
	            if (b && 0 < b.length)
	                for (d = 0; d < b.length; d++) b[d].renderAxisLine();
	            if (c && 0 < c.length)
	                for (d = 0; d < c.length; d++) c[d].renderAxisLine();
	            if (a && 0 < a.length)
	                for (d = 0; d < a.length; d++) a[d].renderStripLinesOfThicknessType("pixel");
	            if (f && 0 < f.length)
	                for (d = 0; d < f.length; d++) f[d].renderStripLinesOfThicknessType("pixel");
	            if (b && 0 < b.length)
	                for (d = 0; d < b.length; d++) b[d].renderStripLinesOfThicknessType("pixel");
	            if (c && 0 < c.length)
	                for (d = 0; d < c.length; d++) c[d].renderStripLinesOfThicknessType("pixel")
	        };
	        C.prototype.calculateStripLinesThicknessInValues =
	            function() {
	                for (var a = 0; a < this.stripLines.length; a++)
	                    if (null !== this.stripLines[a].startValue && null !== this.stripLines[a].endValue) {
	                        var f = Math.min(this.stripLines[a].startValue, this.stripLines[a].endValue),
	                            b = Math.max(this.stripLines[a].startValue, this.stripLines[a].endValue),
	                            f = this.getApparentDifference(f, b);
	                        this.stripLines[a].value = this.logarithmic ? this.stripLines[a].value * Math.sqrt(Math.log(this.stripLines[a].endValue / this.stripLines[a].startValue) / Math.log(f)) : this.stripLines[a].value + (Math.abs(this.stripLines[a].endValue -
	                            this.stripLines[a].startValue) - f) / 2;
	                        this.stripLines[a].thickness = f;
	                        this.stripLines[a]._thicknessType = "value"
	                    }
	            };
	        C.prototype.calculateBreaksSizeInValues = function() {
	            for (var a = "left" === this._position || "right" === this._position ? this.lineCoordinates.height || this.chart.height : this.lineCoordinates.width || this.chart.width, f = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [], b = this.conversionParameters.pixelPerUnit || a / (this.logarithmic ? this.conversionParameters.maximum / this.conversionParameters.minimum : this.conversionParameters.maximum -
	                    this.conversionParameters.minimum), c = this.scaleBreaks && !y(this.scaleBreaks.options.spacing), e, g = 0; g < f.length; g++) e = c || !y(f[g].options.spacing), f[g].spacing = O(f[g].spacing, a, 8, e ? 0.1 * a : 8, e ? 0 : 3) << 0, f[g].size = 0 > f[g].spacing ? 0 : Math.abs(f[g].spacing / b), this.logarithmic && (f[g].size = Math.pow(this.logarithmBase, f[g].size))
	        };
	        C.prototype.calculateBreaksInPixels = function() {
	            if (!(this.scaleBreaks && 0 >= this.scaleBreaks._appliedBreaks.length)) {
	                var a = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [];
	                a.length && (this.scaleBreaks.firstBreakIndex =
	                    this.scaleBreaks.lastBreakIndex = null);
	                for (var f = 0; f < a.length && !(a[f].startValue > this.conversionParameters.maximum); f++) a[f].endValue < this.conversionParameters.minimum || (y(this.scaleBreaks.firstBreakIndex) && (this.scaleBreaks.firstBreakIndex = f), a[f].startValue >= this.conversionParameters.minimum && (a[f].startPixel = this.convertValueToPixel(a[f].startValue), this.scaleBreaks.lastBreakIndex = f), a[f].endValue <= this.conversionParameters.maximum && (a[f].endPixel = this.convertValueToPixel(a[f].endValue)))
	            }
	        };
	        C.prototype.renderLabelsTicksAndTitle =
	            function() {
	                var a = this,
	                    f = !1,
	                    b = 0,
	                    c = 0,
	                    e = 1,
	                    g = 0;
	                0 !== this.labelAngle && 360 !== this.labelAngle && (e = 1.2);
	                if ("undefined" === typeof this.options.interval) {
	                    if ("bottom" === this._position || "top" === this._position)
	                        if (this.logarithmic && !this.equidistantInterval && this.labelAutoFit) {
	                            for (var b = [], e = 0 !== this.labelAngle && 360 !== this.labelAngle ? 1 : 1.2, h, l = this.viewportMaximum, m = this.lineCoordinates.width / Math.log(this.range), k = this._labels.length - 1; 0 <= k; k--) {
	                                p = this._labels[k];
	                                if (p.position < this.viewportMinimum) break;
	                                p.position >
	                                    this.viewportMaximum || !(k === this._labels.length - 1 || h < Math.log(l / p.position) * m / e) || (b.push(p), l = p.position, h = p.textBlock.width * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + p.textBlock.height * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)))
	                            }
	                            this._labels = b
	                        } else {
	                            for (k = 0; k < this._labels.length; k++) p = this._labels[k], p.position < this.viewportMinimum || (h = p.textBlock.width * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + p.textBlock.height * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)), b += h);
	                            b > this.lineCoordinates.width *
	                                e && this.labelAutoFit && (f = !0)
	                        }
	                    if ("left" === this._position || "right" === this._position)
	                        if (this.logarithmic && !this.equidistantInterval && this.labelAutoFit) {
	                            for (var b = [], r, l = this.viewportMaximum, m = this.lineCoordinates.height / Math.log(this.range), k = this._labels.length - 1; 0 <= k; k--) {
	                                p = this._labels[k];
	                                if (p.position < this.viewportMinimum) break;
	                                p.position > this.viewportMaximum || !(k === this._labels.length - 1 || r < Math.log(l / p.position) * m) || (b.push(p), l = p.position, r = p.textBlock.height * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) +
	                                    p.textBlock.width * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)))
	                            }
	                            this._labels = b
	                        } else {
	                            for (k = 0; k < this._labels.length; k++) p = this._labels[k], p.position < this.viewportMinimum || (r = p.textBlock.height * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + p.textBlock.width * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)), c += r);
	                            c > this.lineCoordinates.height * e && this.labelAutoFit && (f = !0)
	                        }
	                }
	                this.logarithmic && (!this.equidistantInterval && this.labelAutoFit) && this._labels.sort(function(a, b) {
	                    return a.position - b.position
	                });
	                var k = 0,
	                    p, n;
	                if ("bottom" === this._position) {
	                    for (k = 0; k < this._labels.length; k++) p = this._labels[k], p.position < this.viewportMinimum || (p.position > this.viewportMaximum || f && 0 !== g++ % 2 && this.labelAutoFit) || (n = this.getPixelCoordinatesOnAxis(p.position), this.tickThickness && "inside" != this.labelPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, c = 1 === this.ctx.lineWidth % 2 ? (n.x << 0) + 0.5 : n.x << 0, this.ctx.beginPath(), this.ctx.moveTo(c, n.y << 0), this.ctx.lineTo(c, n.y + this.tickLength << 0),
	                        this.ctx.stroke()), 0 === p.textBlock.angle ? (n.x -= p.textBlock.width / 2, n.y = "inside" === this.labelPlacement ? n.y - (this.tickLength + p.textBlock.fontSize / 2) : n.y + this.tickLength + p.textBlock.fontSize / 2) : (n.x = "inside" === this.labelPlacement ? 0 > this.labelAngle ? n.x : n.x - p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : n.x - (0 > this.labelAngle ? p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0), n.y = "inside" === this.labelPlacement ? 0 > this.labelAngle ? n.y - this.tickLength - 5 : n.y - this.tickLength - Math.abs(p.textBlock.width *
	                        Math.sin(Math.PI / 180 * this.labelAngle) + 5) : n.y + this.tickLength + Math.abs(0 > this.labelAngle ? p.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) - 5 : 5)), p.textBlock.x = n.x, p.textBlock.y = n.y);
	                    "inside" === this.labelPlacement && this.chart.addEventListener("dataAnimationIterationEnd", function() {
	                        for (k = 0; k < a._labels.length; k++)
	                            if (p = a._labels[k], !(p.position < a.viewportMinimum || p.position > a.viewportMaximum || f && 0 !== g++ % 2 && a.labelAutoFit) && (n = a.getPixelCoordinatesOnAxis(p.position), a.tickThickness)) {
	                                a.ctx.lineWidth =
	                                    a.tickThickness;
	                                a.ctx.strokeStyle = a.tickColor;
	                                var b = 1 === a.ctx.lineWidth % 2 ? (n.x << 0) + 0.5 : n.x << 0;
	                                a.ctx.save();
	                                a.ctx.beginPath();
	                                a.ctx.moveTo(b, n.y << 0);
	                                a.ctx.lineTo(b, n.y - a.tickLength << 0);
	                                a.ctx.stroke();
	                                a.ctx.restore()
	                            }
	                    }, this);
	                    this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.lineCoordinates.x1 + this.lineCoordinates.width / 2 - this._titleTextBlock.width / 2, this._titleTextBlock.y = this.bounds.y2 - this._titleTextBlock.height - 3, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(!0))
	                } else if ("top" ===
	                    this._position) {
	                    for (k = 0; k < this._labels.length; k++) p = this._labels[k], p.position < this.viewportMinimum || (p.position > this.viewportMaximum || f && 0 !== g++ % 2 && this.labelAutoFit) || (n = this.getPixelCoordinatesOnAxis(p.position), this.tickThickness && "inside" != this.labelPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, c = 1 === this.ctx.lineWidth % 2 ? (n.x << 0) + 0.5 : n.x << 0, this.ctx.beginPath(), this.ctx.moveTo(c, n.y << 0), this.ctx.lineTo(c, n.y - this.tickLength << 0), this.ctx.stroke()), 0 === p.textBlock.angle ?
	                        (n.x -= p.textBlock.width / 2, n.y = "inside" === this.labelPlacement ? n.y + this.labelFontSize / 2 + this.tickLength + 5 : n.y - (this.tickLength + p.textBlock.height - p.textBlock.fontSize / 2)) : (n.x = "inside" === this.labelPlacement ? 0 < this.labelAngle ? n.x : n.x - p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : n.x + (p.textBlock.height - this.tickLength - this.labelFontSize) * Math.sin(Math.PI / 180 * this.labelAngle) - (0 < this.labelAngle ? p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0), n.y = "inside" === this.labelPlacement ? 0 < this.labelAngle ?
	                            n.y + this.tickLength + 5 : n.y - p.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) + this.tickLength + 5 : n.y - (this.tickLength + ((p.textBlock.height - p.textBlock.fontSize / 2) * Math.cos(Math.PI / 180 * this.labelAngle) + (0 < this.labelAngle ? p.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : 0)))), p.textBlock.x = n.x, p.textBlock.y = n.y);
	                    "inside" === this.labelPlacement && this.chart.addEventListener("dataAnimationIterationEnd", function() {
	                        for (k = 0; k < a._labels.length; k++)
	                            if (p = a._labels[k], !(p.position < a.viewportMinimum ||
	                                    p.position > a.viewportMaximum || f && 0 !== g++ % 2 && a.labelAutoFit) && (n = a.getPixelCoordinatesOnAxis(p.position), a.tickThickness)) {
	                                a.ctx.lineWidth = a.tickThickness;
	                                a.ctx.strokeStyle = a.tickColor;
	                                var b = 1 === this.ctx.lineWidth % 2 ? (n.x << 0) + 0.5 : n.x << 0;
	                                a.ctx.save();
	                                a.ctx.beginPath();
	                                a.ctx.moveTo(b, n.y << 0);
	                                a.ctx.lineTo(b, n.y + a.tickLength << 0);
	                                a.ctx.stroke();
	                                a.ctx.restore()
	                            }
	                    }, this);
	                    this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.lineCoordinates.x1 + this.lineCoordinates.width / 2 - this._titleTextBlock.width /
	                        2, this._titleTextBlock.y = this.bounds.y1 + 1, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(!0))
	                } else if ("left" === this._position) {
	                    for (k = 0; k < this._labels.length; k++) p = this._labels[k], p.position < this.viewportMinimum || (p.position > this.viewportMaximum || f && 0 !== g++ % 2 && this.labelAutoFit) || (n = this.getPixelCoordinatesOnAxis(p.position), this.tickThickness && "inside" != this.labelPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, c = 1 === this.ctx.lineWidth %
	                        2 ? (n.y << 0) + 0.5 : n.y << 0, this.ctx.beginPath(), this.ctx.moveTo(n.x << 0, c), this.ctx.lineTo(n.x - this.tickLength << 0, c), this.ctx.stroke()), 0 === this.labelAngle ? (p.textBlock.y = n.y, p.textBlock.x = "inside" === this.labelPlacement ? n.x + this.tickLength + 5 : n.x - p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5) : (p.textBlock.y = "inside" === this.labelPlacement ? n.y : n.y - p.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle), p.textBlock.x = "inside" === this.labelPlacement ? n.x + this.tickLength + 5 : 0 < this.labelAngle ?
	                        n.x - p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5 : n.x - p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) + (p.textBlock.height - p.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) - this.tickLength));
	                    "inside" === this.labelPlacement && this.chart.addEventListener("dataAnimationIterationEnd", function() {
	                        for (k = 0; k < a._labels.length; k++)
	                            if (p = a._labels[k], !(p.position < a.viewportMinimum || p.position > a.viewportMaximum || f && 0 !== g++ % 2 && a.labelAutoFit) && (n = a.getPixelCoordinatesOnAxis(p.position),
	                                    a.tickThickness)) {
	                                a.ctx.lineWidth = a.tickThickness;
	                                a.ctx.strokeStyle = a.tickColor;
	                                var b = 1 === a.ctx.lineWidth % 2 ? (n.y << 0) + 0.5 : n.y << 0;
	                                a.ctx.save();
	                                a.ctx.beginPath();
	                                a.ctx.moveTo(n.x << 0, b);
	                                a.ctx.lineTo(n.x + a.tickLength << 0, b);
	                                a.ctx.stroke();
	                                a.ctx.restore()
	                            }
	                    }, this);
	                    this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.bounds.x1 + 1, this._titleTextBlock.y = this.lineCoordinates.height / 2 + this._titleTextBlock.width / 2 + this.lineCoordinates.y1, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(!0))
	                } else if ("right" ===
	                    this._position) {
	                    for (k = 0; k < this._labels.length; k++) p = this._labels[k], p.position < this.viewportMinimum || (p.position > this.viewportMaximum || f && 0 !== g++ % 2 && this.labelAutoFit) || (n = this.getPixelCoordinatesOnAxis(p.position), this.tickThickness && "inside" != this.labelPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, c = 1 === this.ctx.lineWidth % 2 ? (n.y << 0) + 0.5 : n.y << 0, this.ctx.beginPath(), this.ctx.moveTo(n.x << 0, c), this.ctx.lineTo(n.x + this.tickLength << 0, c), this.ctx.stroke()), 0 === this.labelAngle ?
	                        (p.textBlock.y = n.y, p.textBlock.x = "inside" === this.labelPlacement ? n.x - p.textBlock.width - this.tickLength - 5 : n.x + this.tickLength + 5) : (p.textBlock.y = "inside" === this.labelPlacement ? n.y - p.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : 0 > this.labelAngle ? n.y : n.y - (p.textBlock.height - p.textBlock.fontSize / 2 - 5) * Math.cos(Math.PI / 180 * this.labelAngle), p.textBlock.x = "inside" === this.labelPlacement ? n.x - p.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5 : 0 < this.labelAngle ? n.x + (p.textBlock.height -
	                            p.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) + this.tickLength : n.x + this.tickLength + 5));
	                    "inside" === this.labelPlacement && this.chart.addEventListener("dataAnimationIterationEnd", function() {
	                        for (k = 0; k < a._labels.length; k++)
	                            if (p = a._labels[k], !(p.position < a.viewportMinimum || p.position > a.viewportMaximum || f && 0 !== g++ % 2 && a.labelAutoFit) && (n = a.getPixelCoordinatesOnAxis(p.position), a.tickThickness)) {
	                                a.ctx.lineWidth = a.tickThickness;
	                                a.ctx.strokeStyle = a.tickColor;
	                                var b = 1 === a.ctx.lineWidth % 2 ? (n.y <<
	                                    0) + 0.5 : n.y << 0;
	                                a.ctx.save();
	                                a.ctx.beginPath();
	                                a.ctx.moveTo(n.x << 0, b);
	                                a.ctx.lineTo(n.x - a.tickLength << 0, b);
	                                a.ctx.stroke();
	                                a.ctx.restore()
	                            }
	                    }, this);
	                    this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.bounds.x2 - 1, this._titleTextBlock.y = this.lineCoordinates.height / 2 - this._titleTextBlock.width / 2 + this.lineCoordinates.y1, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(!0))
	                }
	                g = 0;
	                if ("inside" === this.labelPlacement) this.chart.addEventListener("dataAnimationIterationEnd",
	                    function() {
	                        for (k = 0; k < a._labels.length; k++) p = a._labels[k], p.position < a.viewportMinimum || (p.position > a.viewportMaximum || f && 0 !== g++ % 2 && a.labelAutoFit && p.skipFlag) || (a.ctx.save(), a.ctx.beginPath(), p.textBlock.render(!0), a.ctx.restore())
	                    }, p.textBlock);
	                else
	                    for (k = 0; k < this._labels.length; k++) p = this._labels[k], p.position < this.viewportMinimum || (p.position > this.viewportMaximum || f && 0 !== g++ % 2 && this.labelAutoFit && p.skipFlag) || p.textBlock.render(!0)
	            };
	        C.prototype.renderInterlacedColors = function() {
	            var a = this.chart.plotArea.ctx,
	                f, b, c = this.chart.plotArea,
	                e = 0;
	            f = !0;
	            if (("bottom" === this._position || "top" === this._position) && this.interlacedColor)
	                for (a.fillStyle = this.interlacedColor, e = 0; e < this._labels.length; e++) f ? (f = this.getPixelCoordinatesOnAxis(this._labels[e].position), b = e + 1 > this._labels.length - 1 ? this.getPixelCoordinatesOnAxis(this.viewportMaximum) : this.getPixelCoordinatesOnAxis(this._labels[e + 1].position), a.fillRect(Math.min(b.x, f.x), c.y1, Math.abs(b.x - f.x), Math.abs(c.y1 - c.y2)), f = !1) : f = !0;
	            else if (("left" === this._position || "right" ===
	                    this._position) && this.interlacedColor)
	                for (a.fillStyle = this.interlacedColor, e = 0; e < this._labels.length; e++) f ? (b = this.getPixelCoordinatesOnAxis(this._labels[e].position), f = e + 1 > this._labels.length - 1 ? this.getPixelCoordinatesOnAxis(this.viewportMaximum) : this.getPixelCoordinatesOnAxis(this._labels[e + 1].position), a.fillRect(c.x1, Math.min(b.y, f.y), Math.abs(c.x1 - c.x2), Math.abs(f.y - b.y)), f = !1) : f = !0;
	            a.beginPath()
	        };
	        C.prototype.renderStripLinesOfThicknessType = function(a) {
	            if (this.stripLines && 0 < this.stripLines.length &&
	                a) {
	                for (var f = this, b, c = 0, e = 0, g = !1, h = !1, l = [], m = [], h = !1, c = 0; c < this.stripLines.length; c++) {
	                    var k = this.stripLines[c];
	                    k._thicknessType === a && ("pixel" === a && (k.value < this.viewportMinimum || k.value > this.viewportMaximum || y(k.value) || isNaN(this.range)) || l.push(k))
	                }
	                for (c = 0; c < this._stripLineLabels.length; c++)
	                    if (k = this.stripLines[c], b = this._stripLineLabels[c], !(b.position < this.viewportMinimum || b.position > this.viewportMaximum || isNaN(this.range))) {
	                        a = this.getPixelCoordinatesOnAxis(b.position);
	                        if ("outside" === b.stripLine.labelPlacement)
	                            if (k &&
	                                (this.ctx.strokeStyle = k.color, "pixel" === k._thicknessType && (this.ctx.lineWidth = k.thickness)), "bottom" === this._position) {
	                                var r = 1 === this.ctx.lineWidth % 2 ? (a.x << 0) + 0.5 : a.x << 0;
	                                this.ctx.beginPath();
	                                this.ctx.moveTo(r, a.y << 0);
	                                this.ctx.lineTo(r, a.y + this.tickLength << 0);
	                                this.ctx.stroke();
	                                0 === this.labelAngle ? (a.x -= b.textBlock.width / 2, a.y += this.tickLength + b.textBlock.fontSize / 2) : (a.x -= 0 > this.labelAngle ? b.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0, a.y += this.tickLength + Math.abs(0 > this.labelAngle ? b.textBlock.width *
	                                    Math.sin(Math.PI / 180 * this.labelAngle) - 5 : 5))
	                            } else "top" === this._position ? (r = 1 === this.ctx.lineWidth % 2 ? (a.x << 0) + 0.5 : a.x << 0, this.ctx.beginPath(), this.ctx.moveTo(r, a.y << 0), this.ctx.lineTo(r, a.y - this.tickLength << 0), this.ctx.stroke(), 0 === this.labelAngle ? (a.x -= b.textBlock.width / 2, a.y -= this.tickLength + b.textBlock.height) : (a.x += (b.textBlock.height - this.tickLength - this.labelFontSize / 2) * Math.sin(Math.PI / 180 * this.labelAngle) - (0 < this.labelAngle ? b.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0), a.y -= this.tickLength +
	                                (b.textBlock.height * Math.cos(Math.PI / 180 * this.labelAngle) + (0 < this.labelAngle ? b.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : 0)))) : "left" === this._position ? (r = 1 === this.ctx.lineWidth % 2 ? (a.y << 0) + 0.5 : a.y << 0, this.ctx.beginPath(), this.ctx.moveTo(a.x << 0, r), this.ctx.lineTo(a.x - this.tickLength << 0, r), this.ctx.stroke(), 0 === this.labelAngle ? a.x = a.x - b.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5 : (a.y -= b.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle), a.x = 0 < this.labelAngle ?
	                                a.x - b.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5 : a.x - b.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) + (b.textBlock.height - b.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) - this.tickLength)) : "right" === this._position && (r = 1 === this.ctx.lineWidth % 2 ? (a.y << 0) + 0.5 : a.y << 0, this.ctx.beginPath(), this.ctx.moveTo(a.x << 0, r), this.ctx.lineTo(a.x + this.tickLength << 0, r), this.ctx.stroke(), 0 === this.labelAngle ? a.x = a.x + this.tickLength + 5 : (a.y = 0 > this.labelAngle ? a.y : a.y - (b.textBlock.height -
	                                b.textBlock.fontSize / 2 - 5) * Math.cos(Math.PI / 180 * this.labelAngle), a.x = 0 < this.labelAngle ? a.x + (b.textBlock.height - b.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) + this.tickLength : a.x + this.tickLength + 5));
	                        else b.textBlock.angle = -90, "bottom" === this._position ? (b.textBlock.maxWidth = this.options.stripLines[c].labelMaxWidth ? this.options.stripLines[c].labelMaxWidth : this.chart.plotArea.height - 3, b.textBlock.measureText(), a.x - b.textBlock.height > this.chart.plotArea.x1 ? y(k.startValue) ? a.x -= b.textBlock.height -
	                            b.textBlock.fontSize / 2 : a.x -= b.textBlock.height / 2 - b.textBlock.fontSize / 2 + 3 : (b.textBlock.angle = 90, y(k.startValue) ? a.x += b.textBlock.height - b.textBlock.fontSize / 2 : a.x += b.textBlock.height / 2 - b.textBlock.fontSize / 2 + 3), a.y = -90 === b.textBlock.angle ? "near" === b.stripLine.labelAlign ? this.chart.plotArea.y2 - 3 : "center" === b.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 + b.textBlock.width) / 2 : this.chart.plotArea.y1 + b.textBlock.width + 3 : "near" === b.stripLine.labelAlign ? this.chart.plotArea.y2 - b.textBlock.width -
	                            3 : "center" === b.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 - b.textBlock.width) / 2 : this.chart.plotArea.y1 + 3) : "top" === this._position ? (b.textBlock.maxWidth = this.options.stripLines[c].labelMaxWidth ? this.options.stripLines[c].labelMaxWidth : this.chart.plotArea.height - 3, b.textBlock.measureText(), a.x - b.textBlock.height > this.chart.plotArea.x1 ? y(k.startValue) ? a.x -= b.textBlock.height - b.textBlock.fontSize / 2 : a.x -= b.textBlock.height / 2 - b.textBlock.fontSize / 2 + 3 : (b.textBlock.angle = 90, y(k.startValue) ?
	                                a.x += b.textBlock.height - b.textBlock.fontSize / 2 : a.x += b.textBlock.height / 2 - b.textBlock.fontSize / 2 + 3), a.y = -90 === b.textBlock.angle ? "near" === b.stripLine.labelAlign ? this.chart.plotArea.y1 + b.textBlock.width + 3 : "center" === b.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 + b.textBlock.width) / 2 : this.chart.plotArea.y2 - 3 : "near" === b.stripLine.labelAlign ? this.chart.plotArea.y1 + 3 : "center" === b.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 - b.textBlock.width) / 2 : this.chart.plotArea.y2 -
	                            b.textBlock.width - 3) : "left" === this._position ? (b.textBlock.maxWidth = this.options.stripLines[c].labelMaxWidth ? this.options.stripLines[c].labelMaxWidth : this.chart.plotArea.width - 3, b.textBlock.angle = 0, b.textBlock.measureText(), a.y - b.textBlock.height > this.chart.plotArea.y1 ? y(k.startValue) ? a.y -= b.textBlock.height - b.textBlock.fontSize / 2 : a.y -= b.textBlock.height / 2 - b.textBlock.fontSize + 3 : a.y - b.textBlock.height < this.chart.plotArea.y2 ? a.y += b.textBlock.fontSize / 2 + 3 : y(k.startValue) ? a.y -= b.textBlock.height - b.textBlock.fontSize /
	                            2 : a.y -= b.textBlock.height / 2 - b.textBlock.fontSize + 3, a.x = "near" === b.stripLine.labelAlign ? this.chart.plotArea.x1 + 3 : "center" === b.stripLine.labelAlign ? (this.chart.plotArea.x2 + this.chart.plotArea.x1) / 2 - b.textBlock.width / 2 : this.chart.plotArea.x2 - b.textBlock.width - 3) : "right" === this._position && (b.textBlock.maxWidth = this.options.stripLines[c].labelMaxWidth ? this.options.stripLines[c].labelMaxWidth : this.chart.plotArea.width - 3, b.textBlock.angle = 0, b.textBlock.measureText(), a.y - +b.textBlock.height > this.chart.plotArea.y1 ?
	                            y(k.startValue) ? a.y -= b.textBlock.height - b.textBlock.fontSize / 2 : a.y -= b.textBlock.height / 2 - b.textBlock.fontSize / 2 - 3 : a.y - b.textBlock.height < this.chart.plotArea.y2 ? a.y += b.textBlock.fontSize / 2 + 3 : y(k.startValue) ? a.y -= b.textBlock.height - b.textBlock.fontSize / 2 : a.y -= b.textBlock.height / 2 - b.textBlock.fontSize / 2 + 3, a.x = "near" === b.stripLine.labelAlign ? this.chart.plotArea.x2 - b.textBlock.width - 3 : "center" === b.stripLine.labelAlign ? (this.chart.plotArea.x2 + this.chart.plotArea.x1) / 2 - b.textBlock.width / 2 : this.chart.plotArea.x1 +
	                            3);
	                        b.textBlock.x = a.x;
	                        b.textBlock.y = a.y;
	                        m.push(b)
	                    }
	                if (!h) {
	                    h = !1;
	                    this.ctx.save();
	                    this.ctx.beginPath();
	                    this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height);
	                    this.ctx.clip();
	                    for (c = 0; c < l.length; c++) k = l[c], k.showOnTop ? g || (g = !0, this.chart.addEventListener("dataAnimationIterationEnd", function() {
	                        this.ctx.save();
	                        this.ctx.beginPath();
	                        this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height);
	                        this.ctx.clip();
	                        for (e = 0; e < l.length; e++) k = l[e], k.showOnTop && k.render();
	                        this.ctx.restore()
	                    }, k)) : k.render();
	                    for (c = 0; c < m.length; c++) b = m[c], b.stripLine.showOnTop ? h || (h = !0, this.chart.addEventListener("dataAnimationIterationEnd", function() {
	                            for (e = 0; e < m.length; e++) b = m[e], "inside" === b.stripLine.labelPlacement && b.stripLine.showOnTop && (f.ctx.save(), f.ctx.beginPath(), f.ctx.rect(f.chart.plotArea.x1, f.chart.plotArea.y1, f.chart.plotArea.width, f.chart.plotArea.height), f.ctx.clip(), b.textBlock.render(!0), f.ctx.restore())
	                        }, b.textBlock)) :
	                        "inside" === b.stripLine.labelPlacement && b.textBlock.render(!0);
	                    this.ctx.restore();
	                    h = !0
	                }
	                if (h)
	                    for (h = !1, c = 0; c < m.length; c++) b = m[c], b.stripLine.showOnTop ? h || (h = !0, this.chart.addEventListener("dataAnimationIterationEnd", function() {
	                        for (e = 0; e < m.length; e++) b = m[e], "outside" === b.stripLine.labelPlacement && b.stripLine.showOnTop && b.textBlock.render(!0)
	                    }, b.textBlock)) : "outside" === b.stripLine.labelPlacement && b.textBlock.render(!0)
	            }
	        };
	        C.prototype.renderBreaksBackground = function() {
	            this.chart._breaksCanvas && (this.scaleBreaks &&
	                0 < this.scaleBreaks._appliedBreaks.length && this.maskCanvas) && (this.chart._breaksCanvasCtx.save(), this.chart._breaksCanvasCtx.beginPath(), this.chart._breaksCanvasCtx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height), this.chart._breaksCanvasCtx.clip(), this.chart._breaksCanvasCtx.drawImage(this.maskCanvas, 0, 0, this.chart.width, this.chart.height), this.chart._breaksCanvasCtx.restore())
	        };
	        C.prototype.createMask = function() {
	            if (this.scaleBreaks && 0 < this.scaleBreaks._appliedBreaks.length) {
	                var a =
	                    this.scaleBreaks._appliedBreaks;
	                v ? (this.maskCanvas = ua(this.chart.width, this.chart.height), this.maskCtx = this.maskCanvas.getContext("2d")) : (this.maskCanvas = this.chart.plotArea.canvas, this.maskCtx = this.chart.plotArea.ctx);
	                this.maskCtx.save();
	                this.maskCtx.beginPath();
	                this.maskCtx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height);
	                this.maskCtx.clip();
	                for (var f = 0; f < a.length; f++) a[f].endValue < this.viewportMinimum || (a[f].startValue > this.viewportMaximum ||
	                    isNaN(this.range)) || a[f].render(this.maskCtx);
	                this.maskCtx.restore()
	            }
	        };
	        C.prototype.renderCrosshair = function(a, f) {
	            this.crosshair.render(a, f)
	        };
	        C.prototype.renderGrid = function() {
	            if (this.gridThickness && 0 < this.gridThickness) {
	                var a = this.chart.ctx;
	                a.save();
	                var f, b = this.chart.plotArea;
	                a.lineWidth = this.gridThickness;
	                a.strokeStyle = this.gridColor;
	                a.setLineDash && a.setLineDash(G(this.gridDashType, this.gridThickness));
	                if ("bottom" === this._position || "top" === this._position)
	                    for (c = 0; c < this._labels.length; c++) this._labels[c].position <
	                        this.viewportMinimum || (this._labels[c].position > this.viewportMaximum || this._labels[c].breaksLabelType) || (a.beginPath(), f = this.getPixelCoordinatesOnAxis(this._labels[c].position), f = 1 === a.lineWidth % 2 ? (f.x << 0) + 0.5 : f.x << 0, a.moveTo(f, b.y1 << 0), a.lineTo(f, b.y2 << 0), a.stroke());
	                else if ("left" === this._position || "right" === this._position)
	                    for (var c = 0; c < this._labels.length; c++) this._labels[c].position < this.viewportMinimum || (this._labels[c].position > this.viewportMaximum || this._labels[c].breaksLabelType) || (a.beginPath(),
	                        f = this.getPixelCoordinatesOnAxis(this._labels[c].position), f = 1 === a.lineWidth % 2 ? (f.y << 0) + 0.5 : f.y << 0, a.moveTo(b.x1 << 0, f), a.lineTo(b.x2 << 0, f), a.stroke());
	                a.restore()
	            }
	        };
	        C.prototype.renderAxisLine = function() {
	            var a = this.chart.ctx,
	                f = v ? this.chart._preRenderCtx : a,
	                b = Math.ceil(this.tickThickness / (this.reversed ? -2 : 2)),
	                c = Math.ceil(this.tickThickness / (this.reversed ? 2 : -2)),
	                e, g;
	            f.save();
	            if ("bottom" === this._position || "top" === this._position) {
	                if (this.lineThickness) {
	                    this.reversed ? (e = this.lineCoordinates.x2, g = this.lineCoordinates.x1) :
	                        (e = this.lineCoordinates.x1, g = this.lineCoordinates.x2);
	                    f.lineWidth = this.lineThickness;
	                    f.strokeStyle = this.lineColor ? this.lineColor : "black";
	                    f.setLineDash && f.setLineDash(G(this.lineDashType, this.lineThickness));
	                    var h = 1 === this.lineThickness % 2 ? (this.lineCoordinates.y1 << 0) + 0.5 : this.lineCoordinates.y1 << 0;
	                    f.beginPath();
	                    if (this.scaleBreaks && !y(this.scaleBreaks.firstBreakIndex))
	                        if (y(this.scaleBreaks.lastBreakIndex)) e = this.scaleBreaks._appliedBreaks[this.scaleBreaks.firstBreakIndex].endPixel + c;
	                        else
	                            for (var l =
	                                    this.scaleBreaks.firstBreakIndex; l <= this.scaleBreaks.lastBreakIndex; l++) f.moveTo(e, h), f.lineTo(this.scaleBreaks._appliedBreaks[l].startPixel + b, h), e = this.scaleBreaks._appliedBreaks[l].endPixel + c;
	                    e && (f.moveTo(e, h), f.lineTo(g, h));
	                    f.stroke()
	                }
	            } else if (("left" === this._position || "right" === this._position) && this.lineThickness) {
	                this.reversed ? (e = this.lineCoordinates.y1, g = this.lineCoordinates.y2) : (e = this.lineCoordinates.y2, g = this.lineCoordinates.y1);
	                f.lineWidth = this.lineThickness;
	                f.strokeStyle = this.lineColor;
	                f.setLineDash && f.setLineDash(G(this.lineDashType, this.lineThickness));
	                h = 1 === this.lineThickness % 2 ? (this.lineCoordinates.x1 << 0) + 0.5 : this.lineCoordinates.x1 << 0;
	                f.beginPath();
	                if (this.scaleBreaks && !y(this.scaleBreaks.firstBreakIndex))
	                    if (y(this.scaleBreaks.lastBreakIndex)) e = this.scaleBreaks._appliedBreaks[this.scaleBreaks.firstBreakIndex].endPixel + b;
	                    else
	                        for (l = this.scaleBreaks.firstBreakIndex; l <= this.scaleBreaks.lastBreakIndex; l++) f.moveTo(h, e), f.lineTo(h, this.scaleBreaks._appliedBreaks[l].startPixel + c),
	                            e = this.scaleBreaks._appliedBreaks[l].endPixel + b;
	                e && (f.moveTo(h, e), f.lineTo(h, g));
	                f.stroke()
	            }
	            v && (a.drawImage(this.chart._preRenderCanvas, 0, 0, this.chart.width, this.chart.height), this.chart._breaksCanvasCtx && this.chart._breaksCanvasCtx.drawImage(this.chart._preRenderCanvas, 0, 0, this.chart.width, this.chart.height), f.clearRect(0, 0, this.chart.width, this.chart.height));
	            f.restore()
	        };
	        C.prototype.getPixelCoordinatesOnAxis = function(a) {
	            var f = {};
	            if ("bottom" === this._position || "top" === this._position) f.x = this.convertValueToPixel(a),
	                f.y = this.lineCoordinates.y1;
	            if ("left" === this._position || "right" === this._position) f.y = this.convertValueToPixel(a), f.x = this.lineCoordinates.x2;
	            return f
	        };
	        C.prototype.convertPixelToValue = function(a) {
	            if ("undefined" === typeof a) return null;
	            var f = 0,
	                b = 0,
	                c, f = !0,
	                e = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [],
	                b = "number" === typeof a ? a : "left" === this._position || "right" === this._position ? a.y : a.x;
	            if (this.logarithmic) {
	                a = c = Math.pow(this.logarithmBase, (b - this.conversionParameters.reference) / this.conversionParameters.pixelPerUnit);
	                if (b <= this.conversionParameters.reference === ("left" === this._position || "right" === this._position) !== this.reversed)
	                    for (b = 0; b < e.length; b++) {
	                        if (!(e[b].endValue < this.conversionParameters.minimum))
	                            if (f)
	                                if (e[b].startValue < this.conversionParameters.minimum) {
	                                    if (1 < e[b].size && this.conversionParameters.minimum * Math.pow(e[b].endValue / e[b].startValue, Math.log(c) / Math.log(e[b].size)) < e[b].endValue) {
	                                        a = Math.pow(e[b].endValue / e[b].startValue, Math.log(c) / Math.log(e[b].size));
	                                        break
	                                    } else a *= e[b].endValue / this.conversionParameters.minimum /
	                                        Math.pow(e[b].size, Math.log(e[b].endValue / this.conversionParameters.minimum) / Math.log(e[b].endValue / e[b].startValue)), c /= Math.pow(e[b].size, Math.log(e[b].endValue / this.conversionParameters.minimum) / Math.log(e[b].endValue / e[b].startValue));
	                                    f = !1
	                                } else if (c > e[b].startValue / this.conversionParameters.minimum) {
	                            c /= e[b].startValue / this.conversionParameters.minimum;
	                            if (c < e[b].size) {
	                                a *= Math.pow(e[b].endValue / e[b].startValue, 1 === e[b].size ? 1 : Math.log(c) / Math.log(e[b].size)) / c;
	                                break
	                            } else a *= e[b].endValue / e[b].startValue /
	                                e[b].size;
	                            c /= e[b].size;
	                            f = !1
	                        } else break;
	                        else if (c > e[b].startValue / e[b - 1].endValue) {
	                            c /= e[b].startValue / e[b - 1].endValue;
	                            if (c < e[b].size) {
	                                a *= Math.pow(e[b].endValue / e[b].startValue, 1 === e[b].size ? 1 : Math.log(c) / Math.log(e[b].size)) / c;
	                                break
	                            } else a *= e[b].endValue / e[b].startValue / e[b].size;
	                            c /= e[b].size
	                        } else break
	                    } else
	                        for (b = e.length - 1; 0 <= b; b--)
	                            if (!(e[b].startValue > this.conversionParameters.minimum))
	                                if (f)
	                                    if (e[b].endValue > this.conversionParameters.minimum) {
	                                        if (1 < e[b].size && this.conversionParameters.minimum * Math.pow(e[b].endValue /
	                                                e[b].startValue, Math.log(c) / Math.log(e[b].size)) > e[b].startValue) {
	                                            a = Math.pow(e[b].endValue / e[b].startValue, Math.log(c) / Math.log(e[b].size));
	                                            break
	                                        } else a *= e[b].startValue / this.conversionParameters.minimum * Math.pow(e[b].size, Math.log(e[b].startValue / this.conversionParameters.minimum) / Math.log(e[b].endValue / e[b].startValue)) * c, c *= Math.pow(e[b].size, Math.log(this.conversionParameters.minimum / e[b].startValue) / Math.log(e[b].endValue / e[b].startValue));
	                                        f = !1
	                                    } else if (c < e[b].endValue / this.conversionParameters.minimum) {
	                    c /=
	                        e[b].endValue / this.conversionParameters.minimum;
	                    if (c > 1 / e[b].size) {
	                        a *= Math.pow(e[b].endValue / e[b].startValue, 1 >= e[b].size ? 1 : Math.log(c) / Math.log(e[b].size)) * c;
	                        break
	                    } else a /= e[b].endValue / e[b].startValue / e[b].size;
	                    c *= e[b].size;
	                    f = !1
	                } else break;
	                else if (c < e[b].endValue / e[b + 1].startValue) {
	                    c /= e[b].endValue / e[b + 1].startValue;
	                    if (c > 1 / e[b].size) {
	                        a *= Math.pow(e[b].endValue / e[b].startValue, 1 >= e[b].size ? 1 : Math.log(c) / Math.log(e[b].size)) * c;
	                        break
	                    } else a /= e[b].endValue / e[b].startValue / e[b].size;
	                    c *= e[b].size
	                } else break;
	                f = a * this.viewportMinimum
	            } else {
	                a = c = (b - this.conversionParameters.reference) / this.conversionParameters.pixelPerUnit;
	                if (b <= this.conversionParameters.reference === ("left" === this._position || "right" === this._position) !== this.reversed)
	                    for (b = 0; b < e.length; b++) {
	                        if (!(e[b].endValue < this.conversionParameters.minimum))
	                            if (f)
	                                if (e[b].startValue < this.conversionParameters.minimum) {
	                                    if (e[b].size && this.conversionParameters.minimum + c * (e[b].endValue - e[b].startValue) / e[b].size < e[b].endValue) {
	                                        a = 0 >= e[b].size ? 0 : c * (e[b].endValue -
	                                            e[b].startValue) / e[b].size;
	                                        break
	                                    } else a += e[b].endValue - this.conversionParameters.minimum - e[b].size * (e[b].endValue - this.conversionParameters.minimum) / (e[b].endValue - e[b].startValue), c -= e[b].size * (e[b].endValue - this.conversionParameters.minimum) / (e[b].endValue - e[b].startValue);
	                                    f = !1
	                                } else if (c > e[b].startValue - this.conversionParameters.minimum) {
	                            c -= e[b].startValue - this.conversionParameters.minimum;
	                            if (c < e[b].size) {
	                                a += (e[b].endValue - e[b].startValue) * (0 === e[b].size ? 1 : c / e[b].size) - c;
	                                break
	                            } else a += e[b].endValue -
	                                e[b].startValue - e[b].size;
	                            c -= e[b].size;
	                            f = !1
	                        } else break;
	                        else if (c > e[b].startValue - e[b - 1].endValue) {
	                            c -= e[b].startValue - e[b - 1].endValue;
	                            if (c < e[b].size) {
	                                a += (e[b].endValue - e[b].startValue) * (0 === e[b].size ? 1 : c / e[b].size) - c;
	                                break
	                            } else a += e[b].endValue - e[b].startValue - e[b].size;
	                            c -= e[b].size
	                        } else break
	                    } else
	                        for (b = e.length - 1; 0 <= b; b--)
	                            if (!(e[b].startValue > this.conversionParameters.minimum))
	                                if (f)
	                                    if (e[b].endValue > this.conversionParameters.minimum)
	                                        if (e[b].size && this.conversionParameters.minimum + c * (e[b].endValue -
	                                                e[b].startValue) / e[b].size > e[b].startValue) {
	                                            a = 0 >= e[b].size ? 0 : c * (e[b].endValue - e[b].startValue) / e[b].size;
	                                            break
	                                        } else a += e[b].startValue - this.conversionParameters.minimum + e[b].size * (this.conversionParameters.minimum - e[b].startValue) / (e[b].endValue - e[b].startValue), c += e[b].size * (this.conversionParameters.minimum - e[b].startValue) / (e[b].endValue - e[b].startValue), f = !1;
	                else if (c < e[b].endValue - this.conversionParameters.minimum) {
	                    c -= e[b].endValue - this.conversionParameters.minimum;
	                    if (c > -1 * e[b].size) {
	                        a += (e[b].endValue -
	                            e[b].startValue) * (0 === e[b].size ? 1 : c / e[b].size) + c;
	                        break
	                    } else a -= e[b].endValue - e[b].startValue - e[b].size;
	                    c += e[b].size;
	                    f = !1
	                } else break;
	                else if (c < e[b].endValue - e[b + 1].startValue) {
	                    c -= e[b].endValue - e[b + 1].startValue;
	                    if (c > -1 * e[b].size) {
	                        a += (e[b].endValue - e[b].startValue) * (0 === e[b].size ? 1 : c / e[b].size) + c;
	                        break
	                    } else a -= e[b].endValue - e[b].startValue - e[b].size;
	                    c += e[b].size
	                } else break;
	                f = this.conversionParameters.minimum + a
	            }
	            return f
	        };
	        C.prototype.convertValueToPixel = function(a) {
	            a = this.getApparentDifference(this.conversionParameters.minimum,
	                a, a);
	            return this.logarithmic ? this.conversionParameters.reference + this.conversionParameters.pixelPerUnit * Math.log(a / this.conversionParameters.minimum) / this.conversionParameters.lnLogarithmBase + 0.5 << 0 : this.conversionParameters.reference + this.conversionParameters.pixelPerUnit * (a - this.conversionParameters.minimum) + 0.5 << 0
	        };
	        C.prototype.getApparentDifference = function(a, f, b, c) {
	            var e = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [];
	            if (this.logarithmic) {
	                b = y(b) ? f / a : b;
	                for (var g = 0; g < e.length && !(f < e[g].startValue); g++) a >
	                    e[g].endValue || (a <= e[g].startValue && f >= e[g].endValue ? b = b / e[g].endValue * e[g].startValue * e[g].size : a >= e[g].startValue && f >= e[g].endValue ? b = b / e[g].endValue * a * Math.pow(e[g].size, Math.log(e[g].endValue / a) / Math.log(e[g].endValue / e[g].startValue)) : a <= e[g].startValue && f <= e[g].endValue ? b = b / f * e[g].startValue * Math.pow(e[g].size, Math.log(f / e[g].startValue) / Math.log(e[g].endValue / e[g].startValue)) : !c && (a > e[g].startValue && f < e[g].endValue) && (b = a * Math.pow(e[g].size, Math.log(f / a) / Math.log(e[g].endValue / e[g].startValue))))
	            } else
	                for (b =
	                    y(b) ? Math.abs(f - a) : b, g = 0; g < e.length && !(f < e[g].startValue); g++) a > e[g].endValue || (a <= e[g].startValue && f >= e[g].endValue ? b = b - e[g].endValue + e[g].startValue + e[g].size : a > e[g].startValue && f >= e[g].endValue ? b = b - e[g].endValue + a + e[g].size * (e[g].endValue - a) / (e[g].endValue - e[g].startValue) : a <= e[g].startValue && f < e[g].endValue ? b = b - f + e[g].startValue + e[g].size * (f - e[g].startValue) / (e[g].endValue - e[g].startValue) : !c && (a > e[g].startValue && f < e[g].endValue) && (b = a + e[g].size * (f - a) / (e[g].endValue - e[g].startValue)));
	            return b
	        };
	        C.prototype.setViewPortRange = function(a, f) {
	            this.sessionVariables.newViewportMinimum = this.viewportMinimum = Math.min(a, f);
	            this.sessionVariables.newViewportMaximum = this.viewportMaximum = Math.max(a, f)
	        };
	        C.prototype.getXValueAt = function(a) {
	            if (!a) return null;
	            var f = null;
	            "left" === this._position ? f = this.convertPixelToValue(a.y) : "bottom" === this._position && (f = this.convertPixelToValue(a.x));
	            return f
	        };
	        C.prototype.calculateValueToPixelConversionParameters = function(a) {
	            a = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [];
	            var f = {
	                    pixelPerUnit: null,
	                    minimum: null,
	                    reference: null
	                },
	                b = this.lineCoordinates.width,
	                c = this.lineCoordinates.height,
	                b = "bottom" === this._position || "top" === this._position ? b : c,
	                c = Math.abs(this.range);
	            if (this.logarithmic)
	                for (var e = 0; e < a.length && !(this.viewportMaximum < a[e].startValue); e++) this.viewportMinimum > a[e].endValue || (this.viewportMinimum >= a[e].startValue && this.viewportMaximum <= a[e].endValue ? b = 0 : this.viewportMinimum <= a[e].startValue && this.viewportMaximum >= a[e].endValue ? (c = c / a[e].endValue * a[e].startValue,
	                        b = 0 < a[e].spacing.toString().indexOf("%") ? b * (1 - parseFloat(a[e].spacing) / 100) : b - Math.min(a[e].spacing, 0.1 * b)) : this.viewportMinimum > a[e].startValue && this.viewportMaximum >= a[e].endValue ? (c = c / a[e].endValue * this.viewportMinimum, b = 0 < a[e].spacing.toString().indexOf("%") ? b * (1 - parseFloat(a[e].spacing) / 100 * Math.log(a[e].endValue / this.viewportMinimum) / Math.log(a[e].endValue / a[e].startValue)) : b - Math.min(a[e].spacing, 0.1 * b) * Math.log(a[e].endValue / this.viewportMinimum) / Math.log(a[e].endValue / a[e].startValue)) : this.viewportMinimum <=
	                    a[e].startValue && this.viewportMaximum < a[e].endValue && (c = c / this.viewportMaximum * a[e].startValue, b = 0 < a[e].spacing.toString().indexOf("%") ? b * (1 - parseFloat(a[e].spacing) / 100 * Math.log(this.viewportMaximum / a[e].startValue) / Math.log(a[e].endValue / a[e].startValue)) : b - Math.min(a[e].spacing, 0.1 * b) * Math.log(this.viewportMaximum / a[e].startValue) / Math.log(a[e].endValue / a[e].startValue)));
	            else
	                for (e = 0; e < a.length && !(this.viewportMaximum < a[e].startValue); e++) this.viewportMinimum > a[e].endValue || (this.viewportMinimum >=
	                    a[e].startValue && this.viewportMaximum <= a[e].endValue ? b = 0 : this.viewportMinimum <= a[e].startValue && this.viewportMaximum >= a[e].endValue ? (c = c - a[e].endValue + a[e].startValue, b = 0 < a[e].spacing.toString().indexOf("%") ? b * (1 - parseFloat(a[e].spacing) / 100) : b - Math.min(a[e].spacing, 0.1 * b)) : this.viewportMinimum > a[e].startValue && this.viewportMaximum >= a[e].endValue ? (c = c - a[e].endValue + this.viewportMinimum, b = 0 < a[e].spacing.toString().indexOf("%") ? b * (1 - parseFloat(a[e].spacing) / 100 * (a[e].endValue - this.viewportMinimum) /
	                        (a[e].endValue - a[e].startValue)) : b - Math.min(a[e].spacing, 0.1 * b) * (a[e].endValue - this.viewportMinimum) / (a[e].endValue - a[e].startValue)) : this.viewportMinimum <= a[e].startValue && this.viewportMaximum < a[e].endValue && (c = c - this.viewportMaximum + a[e].startValue, b = 0 < a[e].spacing.toString().indexOf("%") ? b * (1 - parseFloat(a[e].spacing) / 100 * (this.viewportMaximum - a[e].startValue) / (a[e].endValue - a[e].startValue)) : b - Math.min(a[e].spacing, 0.1 * b) * (this.viewportMaximum - a[e].startValue) / (a[e].endValue - a[e].startValue)));
	            f.minimum = this.viewportMinimum;
	            f.maximum = this.viewportMaximum;
	            f.range = c;
	            if ("bottom" === this._position || "top" === this._position) this.logarithmic ? (f.lnLogarithmBase = Math.log(this.logarithmBase), f.pixelPerUnit = (this.reversed ? -1 : 1) * b * f.lnLogarithmBase / Math.log(Math.abs(c))) : f.pixelPerUnit = (this.reversed ? -1 : 1) * b / Math.abs(c), f.reference = this.reversed ? this.lineCoordinates.x2 : this.lineCoordinates.x1;
	            if ("left" === this._position || "right" === this._position) this.logarithmic ? (f.lnLogarithmBase = Math.log(this.logarithmBase),
	                f.pixelPerUnit = (this.reversed ? 1 : -1) * b * f.lnLogarithmBase / Math.log(Math.abs(c))) : f.pixelPerUnit = (this.reversed ? 1 : -1) * b / Math.abs(c), f.reference = this.reversed ? this.lineCoordinates.y1 : this.lineCoordinates.y2;
	            this.conversionParameters = f
	        };
	        C.prototype.calculateAxisParameters = function() {
	            if (this.logarithmic) this.calculateLogarithmicAxisParameters();
	            else {
	                var a = this.chart.layoutManager.getFreeSpace(),
	                    f = !1,
	                    b = !1;
	                "bottom" === this._position || "top" === this._position ? (this.maxWidth = a.width, this.maxHeight = a.height) : (this.maxWidth =
	                    a.height, this.maxHeight = a.width);
	                var a = "axisX" === this.type ? "xySwapped" === this.chart.plotInfo.axisPlacement ? 62 : 70 : "xySwapped" === this.chart.plotInfo.axisPlacement ? 50 : 40,
	                    c = 4;
	                "axisX" === this.type && (c = 600 > this.maxWidth ? 8 : 6);
	                var a = Math.max(c, Math.floor(this.maxWidth / a)),
	                    e, g, h, c = 0;
	                !y(this.options.viewportMinimum) && (!y(this.options.viewportMaximum) && this.options.viewportMinimum >= this.options.viewportMaximum) && (this.viewportMinimum = this.viewportMaximum = null);
	                if (y(this.options.viewportMinimum) && !y(this.sessionVariables.newViewportMinimum) &&
	                    !isNaN(this.sessionVariables.newViewportMinimum)) this.viewportMinimum = this.sessionVariables.newViewportMinimum;
	                else if (null === this.viewportMinimum || isNaN(this.viewportMinimum)) this.viewportMinimum = this.minimum;
	                if (y(this.options.viewportMaximum) && !y(this.sessionVariables.newViewportMaximum) && !isNaN(this.sessionVariables.newViewportMaximum)) this.viewportMaximum = this.sessionVariables.newViewportMaximum;
	                else if (null === this.viewportMaximum || isNaN(this.viewportMaximum)) this.viewportMaximum = this.maximum;
	                if (this.scaleBreaks)
	                    for (c = 0; c < this.scaleBreaks._appliedBreaks.length; c++)
	                        if ((!y(this.sessionVariables.newViewportMinimum) && this.sessionVariables.newViewportMinimum >= this.scaleBreaks._appliedBreaks[c].startValue || !y(this.options.minimum) && this.options.minimum >= this.scaleBreaks._appliedBreaks[c].startValue || !y(this.options.viewportMinimum) && this.viewportMinimum >= this.scaleBreaks._appliedBreaks[c].startValue) && (!y(this.sessionVariables.newViewportMaximum) && this.sessionVariables.newViewportMaximum <= this.scaleBreaks._appliedBreaks[c].endValue ||
	                                !y(this.options.maximum) && this.options.maximum <= this.scaleBreaks._appliedBreaks[c].endValue || !y(this.options.viewportMaximum) && this.viewportMaximum <= this.scaleBreaks._appliedBreaks[c].endValue)) {
	                            this.scaleBreaks._appliedBreaks.splice(c, 1);
	                            break
	                        }
	                if ("axisX" === this.type) {
	                    if (this.dataSeries && 0 < this.dataSeries.length)
	                        for (e = 0; e < this.dataSeries.length; e++) "dateTime" === this.dataSeries[e].xValueType && (b = !0);
	                    e = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin;
	                    g = null !== this.viewportMaximum ?
	                        this.viewportMaximum : this.dataInfo.viewPortMax;
	                    0 === g - e && (c = "undefined" === typeof this.options.interval ? 0.4 : this.options.interval, g += c, e -= c);
	                    Infinity !== this.dataInfo.minDiff ? h = this.dataInfo.minDiff : 1 < g - e ? h = 0.5 * Math.abs(g - e) : (h = 1, b && (f = !0))
	                } else "axisY" === this.type && (e = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, g = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax, isFinite(e) || isFinite(g) ? isFinite(e) ? isFinite(g) || (g = e) : e = g : (g = "undefined" === typeof this.options.interval ?
	                        -Infinity : this.options.interval, e = "undefined" !== typeof this.options.interval || isFinite(this.dataInfo.minDiff) ? 0 : Infinity), 0 === e && 0 === g ? (g += 9, e = 0) : 0 === g - e ? (c = Math.min(Math.abs(0.01 * Math.abs(g)), 5), g += c, e -= c) : e > g ? (c = Math.min(0.01 * Math.abs(this.getApparentDifference(g, e, null, !0)), 5), 0 <= g ? e = g - c : g = isFinite(e) ? e + c : 0) : (c = Math.min(0.01 * Math.abs(this.getApparentDifference(e, g, null, !0)), 0.05), 0 !== g && (g += c), 0 !== e && (e -= c)), h = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : 1 < g - e ? 0.5 * Math.abs(g - e) : 1, this.includeZero &&
	                    (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && 0 < e && (e = 0), this.includeZero && (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && 0 > g && (g = 0));
	                c = this.getApparentDifference(isNaN(this.viewportMinimum) || null === this.viewportMinimum ? e : this.viewportMinimum, isNaN(this.viewportMaximum) || null === this.viewportMaximum ? g : this.viewportMaximum, null, !0);
	                if ("axisX" === this.type && b) {
	                    this.intervalType || (c / 1 <= a ? (this.interval = 1, this.intervalType = "millisecond") : c / 2 <= a ? (this.interval = 2, this.intervalType =
	                            "millisecond") : c / 5 <= a ? (this.interval = 5, this.intervalType = "millisecond") : c / 10 <= a ? (this.interval = 10, this.intervalType = "millisecond") : c / 20 <= a ? (this.interval = 20, this.intervalType = "millisecond") : c / 50 <= a ? (this.interval = 50, this.intervalType = "millisecond") : c / 100 <= a ? (this.interval = 100, this.intervalType = "millisecond") : c / 200 <= a ? (this.interval = 200, this.intervalType = "millisecond") : c / 250 <= a ? (this.interval = 250, this.intervalType = "millisecond") : c / 300 <= a ? (this.interval = 300, this.intervalType = "millisecond") : c / 400 <= a ?
	                        (this.interval = 400, this.intervalType = "millisecond") : c / 500 <= a ? (this.interval = 500, this.intervalType = "millisecond") : c / (1 * U.secondDuration) <= a ? (this.interval = 1, this.intervalType = "second") : c / (2 * U.secondDuration) <= a ? (this.interval = 2, this.intervalType = "second") : c / (5 * U.secondDuration) <= a ? (this.interval = 5, this.intervalType = "second") : c / (10 * U.secondDuration) <= a ? (this.interval = 10, this.intervalType = "second") : c / (15 * U.secondDuration) <= a ? (this.interval = 15, this.intervalType = "second") : c / (20 * U.secondDuration) <= a ? (this.interval =
	                            20, this.intervalType = "second") : c / (30 * U.secondDuration) <= a ? (this.interval = 30, this.intervalType = "second") : c / (1 * U.minuteDuration) <= a ? (this.interval = 1, this.intervalType = "minute") : c / (2 * U.minuteDuration) <= a ? (this.interval = 2, this.intervalType = "minute") : c / (5 * U.minuteDuration) <= a ? (this.interval = 5, this.intervalType = "minute") : c / (10 * U.minuteDuration) <= a ? (this.interval = 10, this.intervalType = "minute") : c / (15 * U.minuteDuration) <= a ? (this.interval = 15, this.intervalType = "minute") : c / (20 * U.minuteDuration) <= a ? (this.interval =
	                            20, this.intervalType = "minute") : c / (30 * U.minuteDuration) <= a ? (this.interval = 30, this.intervalType = "minute") : c / (1 * U.hourDuration) <= a ? (this.interval = 1, this.intervalType = "hour") : c / (2 * U.hourDuration) <= a ? (this.interval = 2, this.intervalType = "hour") : c / (3 * U.hourDuration) <= a ? (this.interval = 3, this.intervalType = "hour") : c / (6 * U.hourDuration) <= a ? (this.interval = 6, this.intervalType = "hour") : c / (1 * U.dayDuration) <= a ? (this.interval = 1, this.intervalType = "day") : c / (2 * U.dayDuration) <= a ? (this.interval = 2, this.intervalType = "day") :
	                        c / (4 * U.dayDuration) <= a ? (this.interval = 4, this.intervalType = "day") : c / (1 * U.weekDuration) <= a ? (this.interval = 1, this.intervalType = "week") : c / (2 * U.weekDuration) <= a ? (this.interval = 2, this.intervalType = "week") : c / (3 * U.weekDuration) <= a ? (this.interval = 3, this.intervalType = "week") : c / (1 * U.monthDuration) <= a ? (this.interval = 1, this.intervalType = "month") : c / (2 * U.monthDuration) <= a ? (this.interval = 2, this.intervalType = "month") : c / (3 * U.monthDuration) <= a ? (this.interval = 3, this.intervalType = "month") : c / (6 * U.monthDuration) <= a ? (this.interval =
	                            6, this.intervalType = "month") : (this.interval = c / (1 * U.yearDuration) <= a ? 1 : c / (2 * U.yearDuration) <= a ? 2 : c / (4 * U.yearDuration) <= a ? 4 : Math.floor(C.getNiceNumber(c / (a - 1), !0) / U.yearDuration), this.intervalType = "year"));
	                    if (null === this.viewportMinimum || isNaN(this.viewportMinimum)) this.viewportMinimum = e - h / 2;
	                    if (null === this.viewportMaximum || isNaN(this.viewportMaximum)) this.viewportMaximum = g + h / 2;
	                    f ? this.autoValueFormatString = "MMM DD YYYY HH:mm" : "year" === this.intervalType ? this.autoValueFormatString = "YYYY" : "month" === this.intervalType ?
	                        this.autoValueFormatString = "MMM YYYY" : "week" === this.intervalType ? this.autoValueFormatString = "MMM DD YYYY" : "day" === this.intervalType ? this.autoValueFormatString = "MMM DD YYYY" : "hour" === this.intervalType ? this.autoValueFormatString = "hh:mm TT" : "minute" === this.intervalType ? this.autoValueFormatString = "hh:mm TT" : "second" === this.intervalType ? this.autoValueFormatString = "hh:mm:ss TT" : "millisecond" === this.intervalType && (this.autoValueFormatString = "fff'ms'");
	                    this.valueFormatString || (this.valueFormatString = this.autoValueFormatString)
	                } else {
	                    this.intervalType =
	                        "number";
	                    c = C.getNiceNumber(c, !1);
	                    this.interval = this.options && 0 < this.options.interval ? this.options.interval : C.getNiceNumber(c / (a - 1), !0);
	                    if (null === this.viewportMinimum || isNaN(this.viewportMinimum)) this.viewportMinimum = "axisX" === this.type ? e - h / 2 : Math.floor(e / this.interval) * this.interval;
	                    if (null === this.viewportMaximum || isNaN(this.viewportMaximum)) this.viewportMaximum = "axisX" === this.type ? g + h / 2 : Math.ceil(g / this.interval) * this.interval;
	                    0 === this.viewportMaximum && 0 === this.viewportMinimum && (0 === this.options.viewportMinimum ?
	                        this.viewportMaximum += 10 : 0 === this.options.viewportMaximum && (this.viewportMinimum -= 10), this.options && "undefined" === typeof this.options.interval && (this.interval = C.getNiceNumber((this.viewportMaximum - this.viewportMinimum) / (a - 1), !0)))
	                }
	                if (null === this.minimum || null === this.maximum)
	                    if ("axisX" === this.type ? (e = null !== this.minimum ? this.minimum : this.dataInfo.min, g = null !== this.maximum ? this.maximum : this.dataInfo.max, 0 === g - e && (c = "undefined" === typeof this.options.interval ? 0.4 : this.options.interval, g += c, e -= c), h = Infinity !==
	                            this.dataInfo.minDiff ? this.dataInfo.minDiff : 1 < g - e ? 0.5 * Math.abs(g - e) : 1) : "axisY" === this.type && (e = null !== this.minimum ? this.minimum : this.dataInfo.min, g = null !== this.maximum ? this.maximum : this.dataInfo.max, isFinite(e) || isFinite(g) ? 0 === e && 0 === g ? (g += 9, e = 0) : 0 === g - e ? (c = Math.min(Math.abs(0.01 * Math.abs(g)), 5), g += c, e -= c) : e > g ? (c = Math.min(0.01 * Math.abs(this.getApparentDifference(g, e, null, !0)), 5), 0 <= g ? e = g - c : g = isFinite(e) ? e + c : 0) : (c = Math.min(0.01 * Math.abs(this.getApparentDifference(e, g, null, !0)), 0.05), 0 !== g && (g += c),
	                            0 !== e && (e -= c)) : (g = "undefined" === typeof this.options.interval ? -Infinity : this.options.interval, e = "undefined" !== typeof this.options.interval || isFinite(this.dataInfo.minDiff) ? 0 : Infinity), h = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : 1 < g - e ? 0.5 * Math.abs(g - e) : 1, this.includeZero && (null === this.minimum || isNaN(this.minimum)) && 0 < e && (e = 0), this.includeZero && (null === this.maximum || isNaN(this.maximum)) && 0 > g && (g = 0)), Math.abs(this.getApparentDifference(e, g, null, !0)), "axisX" === this.type && b) {
	                        this.valueType =
	                            "dateTime";
	                        if (null === this.minimum || isNaN(this.minimum)) this.minimum = e - h / 2;
	                        if (null === this.maximum || isNaN(this.maximum)) this.maximum = g + h / 2
	                    } else this.intervalType = this.valueType = "number", null === this.minimum && (this.minimum = "axisX" === this.type ? e - h / 2 : Math.floor(e / this.interval) * this.interval, this.minimum = Math.min(this.minimum, null === this.sessionVariables.viewportMinimum || isNaN(this.sessionVariables.viewportMinimum) ? Infinity : this.sessionVariables.viewportMinimum)), null === this.maximum && (this.maximum = "axisX" ===
	                        this.type ? g + h / 2 : Math.ceil(g / this.interval) * this.interval, this.maximum = Math.max(this.maximum, null === this.sessionVariables.viewportMaximum || isNaN(this.sessionVariables.viewportMaximum) ? -Infinity : this.sessionVariables.viewportMaximum)), 0 === this.maximum && 0 === this.minimum && (0 === this.options.minimum ? this.maximum += 10 : 0 === this.options.maximum && (this.minimum -= 10));
	                y(this.sessionVariables.newViewportMinimum) && (this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum));
	                y(this.sessionVariables.newViewportMaximum) &&
	                    (this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum));
	                this.range = this.viewportMaximum - this.viewportMinimum;
	                this.intervalStartPosition = "axisX" === this.type && b ? this.getLabelStartPoint(new Date(this.viewportMinimum), this.intervalType, this.interval) : Math.floor((this.viewportMinimum + 0.2 * this.interval) / this.interval) * this.interval;
	                this.valueFormatString || (this.valueFormatString = C.generateValueFormatString(this.range, 2))
	            }
	        };
	        C.prototype.calculateLogarithmicAxisParameters = function() {
	            var a = this.chart.layoutManager.getFreeSpace(),
	                f = Math.log(this.logarithmBase),
	                b;
	            "bottom" === this._position || "top" === this._position ? (this.maxWidth = a.width, this.maxHeight = a.height) : (this.maxWidth = a.height, this.maxHeight = a.width);
	            var a = "axisX" === this.type ? 500 > this.maxWidth ? 7 : Math.max(7, Math.floor(this.maxWidth / 100)) : Math.max(Math.floor(this.maxWidth / 50), 3),
	                c, e, g, h;
	            h = 1;
	            if (null === this.viewportMinimum || isNaN(this.viewportMinimum)) this.viewportMinimum = this.minimum;
	            if (null === this.viewportMaximum || isNaN(this.viewportMaximum)) this.viewportMaximum = this.maximum;
	            if (this.scaleBreaks)
	                for (h = 0; h < this.scaleBreaks._appliedBreaks.length; h++)
	                    if ((!y(this.sessionVariables.newViewportMinimum) && this.sessionVariables.newViewportMinimum >= this.scaleBreaks._appliedBreaks[h].startValue || !y(this.options.minimum) && this.options.minimum >= this.scaleBreaks._appliedBreaks[h].startValue || !y(this.options.viewportMinimum) && this.viewportMinimum >= this.scaleBreaks._appliedBreaks[h].startValue) && (!y(this.sessionVariables.newViewportMaximum) && this.sessionVariables.newViewportMaximum <= this.scaleBreaks._appliedBreaks[h].endValue ||
	                            !y(this.options.maximum) && this.options.maximum <= this.scaleBreaks._appliedBreaks[h].endValue || !y(this.options.viewportMaximum) && this.viewportMaximum <= this.scaleBreaks._appliedBreaks[h].endValue)) {
	                        this.scaleBreaks._appliedBreaks.splice(h, 1);
	                        break
	                    }
	            "axisX" === this.type ? (c = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, e = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax, 1 === e / c && (h = Math.pow(this.logarithmBase, "undefined" === typeof this.options.interval ?
	                0.4 : this.options.interval), e *= h, c /= h), g = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : e / c > this.logarithmBase ? e / c * Math.pow(this.logarithmBase, 0.5) : this.logarithmBase) : "axisY" === this.type && (c = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, e = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax, 0 >= c && !isFinite(e) ? (e = "undefined" === typeof this.options.interval ? 0 : this.options.interval, c = 1) : 0 >= c ? c = e : isFinite(e) || (e = c), 1 === c && 1 === e ? (e *= this.logarithmBase -
	                1 / this.logarithmBase, c = 1) : 1 === e / c ? (h = Math.min(e * Math.pow(this.logarithmBase, 0.01), Math.pow(this.logarithmBase, 5)), e *= h, c /= h) : c > e ? (h = Math.min(c / e * Math.pow(this.logarithmBase, 0.01), Math.pow(this.logarithmBase, 5)), 1 <= e ? c = e / h : e = c * h) : (h = Math.min(e / c * Math.pow(this.logarithmBase, 0.01), Math.pow(this.logarithmBase, 0.04)), 1 !== e && (e *= h), 1 !== c && (c /= h)), g = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : e / c > this.logarithmBase ? e / c * Math.pow(this.logarithmBase, 0.5) : this.logarithmBase, this.includeZero && (null ===
	                this.viewportMinimum || isNaN(this.viewportMinimum)) && 1 < c && (c = 1), this.includeZero && (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && 1 > e && (e = 1));
	            h = (isNaN(this.viewportMaximum) || null === this.viewportMaximum ? e : this.viewportMaximum) / (isNaN(this.viewportMinimum) || null === this.viewportMinimum ? c : this.viewportMinimum);
	            linearRange = (isNaN(this.viewportMaximum) || null === this.viewportMaximum ? e : this.viewportMaximum) - (isNaN(this.viewportMinimum) || null === this.viewportMinimum ? c : this.viewportMinimum);
	            this.intervalType =
	                "number";
	            h = Math.pow(this.logarithmBase, C.getNiceNumber(Math.abs(Math.log(h) / f), !1));
	            this.options && 0 < this.options.interval ? this.interval = this.options.interval : (this.interval = C.getNiceExponent(Math.log(h) / f / (a - 1), !0), b = C.getNiceNumber(linearRange / (a - 1), !0));
	            if (null === this.viewportMinimum || isNaN(this.viewportMinimum)) this.viewportMinimum = "axisX" === this.type ? c / Math.sqrt(g) : Math.pow(this.logarithmBase, this.interval * Math.floor(Math.log(c) / f / this.interval));
	            if (null === this.viewportMaximum || isNaN(this.viewportMaximum)) this.viewportMaximum =
	                "axisX" === this.type ? e * Math.sqrt(g) : Math.pow(this.logarithmBase, this.interval * Math.ceil(Math.log(e) / f / this.interval));
	            1 === this.viewportMaximum && 1 === this.viewportMinimum && (1 === this.options.viewportMinimum ? this.viewportMaximum *= this.logarithmBase - 1 / this.logarithmBase : 1 === this.options.viewportMaximum && (this.viewportMinimum /= this.logarithmBase - 1 / this.logarithmBase), this.options && "undefined" === typeof this.options.interval && (this.interval = C.getNiceExponent(Math.ceil(Math.log(h) / f) / (a - 1)), b = C.getNiceNumber((this.viewportMaximum -
	                this.viewportMinimum) / (a - 1), !0)));
	            if (null === this.minimum || null === this.maximum) "axisX" === this.type ? (c = null !== this.minimum ? this.minimum : this.dataInfo.min, e = null !== this.maximum ? this.maximum : this.dataInfo.max, 1 === e / c && (h = Math.pow(this.logarithmBase, "undefined" === typeof this.options.interval ? 0.4 : this.options.interval), e *= h, c /= h), g = Infinity !== this.dataInfo.minDiff ? this.dataInfo.minDiff : e / c > this.logarithmBase ? e / c * Math.pow(this.logarithmBase, 0.5) : this.logarithmBase) : "axisY" === this.type && (c = null !== this.minimum ?
	                this.minimum : this.dataInfo.min, e = null !== this.maximum ? this.maximum : this.dataInfo.max, isFinite(c) || isFinite(e) ? 1 === c && 1 === e ? (e *= this.logarithmBase, c /= this.logarithmBase) : 1 === e / c ? (h = Math.pow(this.logarithmBase, this.interval), e *= h, c /= h) : c > e ? (h = Math.min(0.01 * (c / e), 5), 1 <= e ? c = e / h : e = c * h) : (h = Math.min(e / c * Math.pow(this.logarithmBase, 0.01), Math.pow(this.logarithmBase, 0.04)), 1 !== e && (e *= h), 1 !== c && (c /= h)) : (e = "undefined" === typeof this.options.interval ? 0 : this.options.interval, c = 1), g = Infinity !== this.dataInfo.minDiff ?
	                this.dataInfo.minDiff : e / c > this.logarithmBase ? e / c * Math.pow(this.logarithmBase, 0.5) : this.logarithmBase, this.includeZero && (null === this.minimum || isNaN(this.minimum)) && 1 < c && (c = 1), this.includeZero && (null === this.maximum || isNaN(this.maximum)) && 1 > e && (e = 1)), this.intervalType = "number", null === this.minimum && (this.minimum = "axisX" === this.type ? c / Math.sqrt(g) : Math.pow(this.logarithmBase, this.interval * Math.floor(Math.log(c) / f / this.interval)), this.minimum = Math.min(this.minimum, null === this.sessionVariables.viewportMinimum ||
	                isNaN(this.sessionVariables.viewportMinimum) ? "undefined" === typeof this.sessionVariables.newViewportMinimum ? Infinity : this.sessionVariables.newViewportMinimum : this.sessionVariables.viewportMinimum)), null === this.maximum && (this.maximum = "axisX" === this.type ? e * Math.sqrt(g) : Math.pow(this.logarithmBase, this.interval * Math.ceil(Math.log(e) / f / this.interval)), this.maximum = Math.max(this.maximum, null === this.sessionVariables.viewportMaximum || isNaN(this.sessionVariables.viewportMaximum) ? "undefined" === typeof this.sessionVariables.newViewportMaximum ?
	                0 : this.sessionVariables.newViewportMaximum : this.sessionVariables.viewportMaximum)), 1 === this.maximum && 1 === this.minimum && (1 === this.options.minimum ? this.maximum *= this.logarithmBase - 1 / this.logarithmBase : 1 === this.options.maximum && (this.minimum /= this.logarithmBase - 1 / this.logarithmBase));
	            this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum);
	            this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum);
	            this.viewportMinimum > this.viewportMaximum && (!this.options.viewportMinimum && !this.options.minimum ||
	                this.options.viewportMaximum || this.options.maximum ? this.options.viewportMinimum || this.options.minimum || !this.options.viewportMaximum && !this.options.maximum || (this.viewportMinimum = this.minimum = (this.options.viewportMaximum || this.options.maximum) / Math.pow(this.logarithmBase, 2 * Math.ceil(this.interval))) : this.viewportMaximum = this.maximum = this.options.viewportMinimum || this.options.minimum);
	            c = Math.pow(this.logarithmBase, Math.floor(Math.log(this.viewportMinimum) / (f * this.interval) + 0.2) * this.interval);
	            this.range =
	                this.viewportMaximum / this.viewportMinimum;
	            this.noTicks = a;
	            if (!this.options.interval && this.range < Math.pow(this.logarithmBase, 8 > this.viewportMaximum || 3 > a ? 2 : 3)) {
	                for (f = Math.floor(this.viewportMinimum / b + 0.5) * b; f < this.viewportMinimum;) f += b;
	                this.equidistantInterval = !1;
	                this.intervalStartPosition = f;
	                this.interval = b
	            } else this.options.interval || (b = Math.ceil(this.interval), this.range > this.interval && (this.interval = b, c = Math.pow(this.logarithmBase, Math.floor(Math.log(this.viewportMinimum) / (f * this.interval) + 0.2) * this.interval))),
	                this.equidistantInterval = !0, this.intervalStartPosition = c;
	            if (!this.valueFormatString && (this.valueFormatString = "#,##0.##", 1 > this.viewportMinimum)) {
	                f = Math.floor(Math.abs(Math.log(this.viewportMinimum) / Math.LN10)) + 2;
	                if (isNaN(f) || !isFinite(f)) f = 2;
	                if (2 < f)
	                    for (h = 0; h < f - 2; h++) this.valueFormatString += "#"
	            }
	        };
	        C.generateValueFormatString = function(a, f) {
	            var b = "#,##0.",
	                c = f;
	            1 > a && (c += Math.floor(Math.abs(Math.log(a) / Math.LN10)), isNaN(c) || !isFinite(c)) && (c = f);
	            for (var e = 0; e < c; e++) b += "#";
	            return b
	        };
	        C.getNiceExponent = function(a,
	            f) {
	            var b = Math.floor(Math.log(a) / Math.LN10),
	                c = a / Math.pow(10, b),
	                c = 0 > b ? 1 >= c ? 1 : 5 >= c ? 5 : 10 : Math.max(Math.floor(c), 1);
	            return Number((c * Math.pow(10, b)).toFixed(20))
	        };
	        C.getNiceNumber = function(a, f) {
	            var b = Math.floor(Math.log(a) / Math.LN10),
	                c = a / Math.pow(10, b);
	            return Number(((f ? 1.5 > c ? 1 : 3 > c ? 2 : 7 > c ? 5 : 10 : 1 >= c ? 1 : 2 >= c ? 2 : 5 >= c ? 5 : 10) * Math.pow(10, b)).toFixed(20))
	        };
	        C.prototype.getLabelStartPoint = function() {
	            var a = U[this.intervalType + "Duration"] * this.interval,
	                a = new Date(Math.floor(this.viewportMinimum / a) * a);
	            if ("millisecond" !==
	                this.intervalType)
	                if ("second" === this.intervalType) 0 < a.getMilliseconds() && (a.setSeconds(a.getSeconds() + 1), a.setMilliseconds(0));
	                else if ("minute" === this.intervalType) {
	                if (0 < a.getSeconds() || 0 < a.getMilliseconds()) a.setMinutes(a.getMinutes() + 1), a.setSeconds(0), a.setMilliseconds(0)
	            } else if ("hour" === this.intervalType) {
	                if (0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds()) a.setHours(a.getHours() + 1), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0)
	            } else if ("day" === this.intervalType) {
	                if (0 < a.getHours() ||
	                    0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds()) a.setDate(a.getDate() + 1), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0)
	            } else if ("week" === this.intervalType) {
	                if (0 < a.getDay() || 0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds()) a.setDate(a.getDate() + (7 - a.getDay())), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0)
	            } else if ("month" === this.intervalType) {
	                if (1 < a.getDate() || 0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds()) a.setMonth(a.getMonth() +
	                    1), a.setDate(1), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0)
	            } else "year" === this.intervalType && (0 < a.getMonth() || 1 < a.getDate() || 0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds()) && (a.setFullYear(a.getFullYear() + 1), a.setMonth(0), a.setDate(1), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0));
	            return a
	        };
	        pa(P, X);
	        pa(aa, X);
	        aa.prototype.createUserOptions = function(a) {
	            if ("undefined" !== typeof a || this.options._isPlaceholder) {
	                var f = 0;
	                this.parent.options._isPlaceholder &&
	                    this.parent.createUserOptions();
	                this.options._isPlaceholder || (Da(this.parent[this.optionsName]), f = this.parent.options[this.optionsName].indexOf(this.options));
	                this.options = "undefined" === typeof a ? {} : a;
	                this.parent.options[this.optionsName][f] = this.options
	            }
	        };
	        aa.prototype.render = function(a) {
	            if (0 !== this.spacing || 0 !== this.options.lineThickness && ("undefined" !== typeof this.options.lineThickness || 0 !== this.parent.lineThickness)) {
	                var f = this.ctx,
	                    b = this.ctx.globalAlpha;
	                this.ctx = a || this.ctx;
	                this.ctx.save();
	                this.ctx.beginPath();
	                this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height);
	                this.ctx.clip();
	                var c = this.scaleBreaks.parent.getPixelCoordinatesOnAxis(this.startValue),
	                    e = this.scaleBreaks.parent.getPixelCoordinatesOnAxis(this.endValue);
	                this.ctx.strokeStyle = this.lineColor;
	                this.ctx.fillStyle = this.color;
	                this.ctx.beginPath();
	                this.ctx.globalAlpha = 1;
	                R(this.id);
	                var g, h, l, m, k, r;
	                a = Math.max(this.spacing, 3);
	                var p = Math.max(0, this.lineThickness);
	                this.ctx.lineWidth = p;
	                this.ctx.setLineDash &&
	                    this.ctx.setLineDash(G(this.lineDashType, p));
	                if ("bottom" === this.scaleBreaks.parent._position || "top" === this.scaleBreaks.parent._position)
	                    if (c = 1 === p % 2 ? (c.x << 0) + 0.5 : c.x << 0, h = 1 === p % 2 ? (e.x << 0) + 0.5 : e.x << 0, "top" === this.scaleBreaks.parent._position ? (e = this.chart.plotArea.y1, l = this.chart.plotArea.y2 + p / 2 + 0.5 << 0) : (e = this.chart.plotArea.y2, l = this.chart.plotArea.y1 - p / 2 + 0.5 << 0, a *= -1), this.bounds = {
	                            x1: c - p / 2,
	                            y1: e,
	                            x2: h + p / 2,
	                            y2: l
	                        }, this.ctx.moveTo(c, e), "straight" === this.type || "top" === this.scaleBreaks.parent._position &&
	                        0 >= a || "bottom" === this.scaleBreaks.parent._position && 0 <= a) this.ctx.lineTo(c, l), this.ctx.lineTo(h, l), this.ctx.lineTo(h, e);
	                    else if ("wavy" === this.type) {
	                    m = c;
	                    k = e;
	                    g = 0.5;
	                    r = (l - k) / a / 3;
	                    for (var n = 0; n < r; n++) this.ctx.bezierCurveTo(m + g * a, k + a, m + g * a, k + 2 * a, m, k + 3 * a), k += 3 * a, g *= -1;
	                    this.ctx.bezierCurveTo(m + g * a, k + a, m + g * a, k + 2 * a, m, k + 3 * a);
	                    m = h;
	                    g *= -1;
	                    this.ctx.lineTo(m, k);
	                    for (n = 0; n < r; n++) this.ctx.bezierCurveTo(m + g * a, k - a, m + g * a, k - 2 * a, m, k - 3 * a), k -= 3 * a, g *= -1
	                } else {
	                    if ("zigzag" === this.type) {
	                        g = -1;
	                        k = e + a;
	                        m = c + a;
	                        r = (l - k) / a / 2;
	                        for (n = 0; n < r; n++) this.ctx.lineTo(m,
	                            k), m += 2 * g * a, k += 2 * a, g *= -1;
	                        this.ctx.lineTo(m, k);
	                        m += h - c;
	                        for (n = 0; n < r + 1; n++) this.ctx.lineTo(m, k), m += 2 * g * a, k -= 2 * a, g *= -1;
	                        this.ctx.lineTo(m + g * a, k + a)
	                    }
	                } else if ("left" === this.scaleBreaks.parent._position || "right" === this.scaleBreaks.parent._position)
	                    if (e = 1 === p % 2 ? (e.y << 0) + 0.5 : e.y << 0, l = 1 === p % 2 ? (c.y << 0) + 0.5 : c.y << 0, "left" === this.scaleBreaks.parent._position ? (c = this.chart.plotArea.x1, h = this.chart.plotArea.x2 + p / 2 + 0.5 << 0) : (c = this.chart.plotArea.x2, h = this.chart.plotArea.x1 - p / 2 + 0.5 << 0, a *= -1), this.bounds = {
	                            x1: c,
	                            y1: e - p /
	                                2,
	                            x2: h,
	                            y2: l + p / 2
	                        }, this.ctx.moveTo(c, e), "straight" === this.type || "left" === this.scaleBreaks.parent._position && 0 >= a || "right" === this.scaleBreaks.parent._position && 0 <= a) this.ctx.lineTo(h, e), this.ctx.lineTo(h, l), this.ctx.lineTo(c, l);
	                    else if ("wavy" === this.type) {
	                    m = c;
	                    k = e;
	                    g = 0.5;
	                    r = (h - m) / a / 3;
	                    for (n = 0; n < r; n++) this.ctx.bezierCurveTo(m + a, k + g * a, m + 2 * a, k + g * a, m + 3 * a, k), m += 3 * a, g *= -1;
	                    this.ctx.bezierCurveTo(m + a, k + g * a, m + 2 * a, k + g * a, m + 3 * a, k);
	                    k = l;
	                    g *= -1;
	                    this.ctx.lineTo(m, k);
	                    for (n = 0; n < r; n++) this.ctx.bezierCurveTo(m - a, k + g * a, m - 2 * a,
	                        k + g * a, m - 3 * a, k), m -= 3 * a, g *= -1
	                } else if ("zigzag" === this.type) {
	                    g = 1;
	                    k = e - a;
	                    m = c + a;
	                    r = (h - m) / a / 2;
	                    for (n = 0; n < r; n++) this.ctx.lineTo(m, k), k += 2 * g * a, m += 2 * a, g *= -1;
	                    this.ctx.lineTo(m, k);
	                    k += l - e;
	                    for (n = 0; n < r + 1; n++) this.ctx.lineTo(m, k), k += 2 * g * a, m -= 2 * a, g *= -1;
	                    this.ctx.lineTo(m + a, k + g * a)
	                }
	                0 < p && this.ctx.stroke();
	                this.ctx.closePath();
	                this.ctx.globalAlpha = this.fillOpacity;
	                this.ctx.globalCompositeOperation = "destination-over";
	                this.ctx.fill();
	                this.ctx.restore();
	                this.ctx.globalAlpha = b;
	                this.ctx = f
	            }
	        };
	        pa(ga, X);
	        ga.prototype.createUserOptions =
	            function(a) {
	                if ("undefined" !== typeof a || this.options._isPlaceholder) {
	                    var f = 0;
	                    this.parent.options._isPlaceholder && this.parent.createUserOptions();
	                    this.options._isPlaceholder || (Da(this.parent.stripLines), f = this.parent.options.stripLines.indexOf(this.options));
	                    this.options = "undefined" === typeof a ? {} : a;
	                    this.parent.options.stripLines[f] = this.options
	                }
	            };
	        ga.prototype.render = function() {
	            this.ctx.save();
	            var a = this.parent.getPixelCoordinatesOnAxis(this.value),
	                f = Math.abs("pixel" === this._thicknessType ? this.thickness :
	                    this.parent.conversionParameters.pixelPerUnit * this.thickness);
	            if (0 < f) {
	                var b = null === this.opacity ? 1 : this.opacity;
	                this.ctx.strokeStyle = this.color;
	                this.ctx.beginPath();
	                var c = this.ctx.globalAlpha;
	                this.ctx.globalAlpha = b;
	                R(this.id);
	                var e, g, h, l;
	                this.ctx.lineWidth = f;
	                this.ctx.setLineDash && this.ctx.setLineDash(G(this.lineDashType, f));
	                if ("bottom" === this.parent._position || "top" === this.parent._position) e = g = 1 === this.ctx.lineWidth % 2 ? (a.x << 0) + 0.5 : a.x << 0, h = this.chart.plotArea.y1, l = this.chart.plotArea.y2, this.bounds = {
	                    x1: e - f / 2,
	                    y1: h,
	                    x2: g + f / 2,
	                    y2: l
	                };
	                else if ("left" === this.parent._position || "right" === this.parent._position) h = l = 1 === this.ctx.lineWidth % 2 ? (a.y << 0) + 0.5 : a.y << 0, e = this.chart.plotArea.x1, g = this.chart.plotArea.x2, this.bounds = {
	                    x1: e,
	                    y1: h - f / 2,
	                    x2: g,
	                    y2: l + f / 2
	                };
	                this.ctx.moveTo(e, h);
	                this.ctx.lineTo(g, l);
	                this.ctx.stroke();
	                this.ctx.globalAlpha = c
	            }
	            this.ctx.restore()
	        };
	        pa(ia, X);
	        ia.prototype.render = function(a, f) {
	            var b, c, e, g, h = null,
	                l = h = null,
	                m = "";
	            if (!this.valueFormatString)
	                if ("dateTime" === this.parent.valueType) this.valueFormatString =
	                    this.parent.valueFormatString;
	                else {
	                    var k = 0,
	                        k = "xySwapped" === this.chart.plotInfo.axisPlacement ? 50 < this.parent.range ? 0 : 500 < this.chart.width && 25 > this.parent.range ? 2 : Math.floor(Math.abs(Math.log(this.parent.range) / Math.LN10)) + (5 > this.parent.range ? 2 : 10 > this.parent.range ? 1 : 0) : 50 < this.parent.range ? 0 : Math.floor(Math.abs(Math.log(this.parent.range) / Math.LN10)) + (5 > this.parent.range ? 2 : 10 > this.parent.range ? 1 : 0);
	                    this.valueFormatString = C.generateValueFormatString(this.parent.range, k)
	                }
	            var l = null === this.opacity ? 1 :
	                this.opacity,
	                k = Math.abs("pixel" === this._thicknessType ? this.thickness : this.parent.conversionParameters.pixelPerUnit * this.thickness),
	                r = this.chart.overlaidCanvasCtx,
	                p = r.globalAlpha;
	            r.globalAlpha = l;
	            r.beginPath();
	            r.strokeStyle = this.color;
	            r.lineWidth = k;
	            r.save();
	            this.labelFontSize = y(this.options.labelFontSize) ? this.parent.labelFontSize : this.labelFontSize;
	            if ("left" === this.parent._position || "right" === this.parent._position) this.labelMaxWidth = y(this.options.labelMaxWidth) ? this.parent.bounds.x2 - this.parent.bounds.x1 :
	                this.labelMaxWidth, this.labelMaxHeight = y(this.options.labelWrap) || this.labelWrap ? 3 * this.chart.height : 2 * this.labelFontSize;
	            else if ("top" === this.parent._position || "bottom" === this.parent._position) this.labelMaxWidth = y(this.options.labelMaxWidth) ? 3 * this.chart.width : this.labelMaxWidth, this.labelMaxHeight = y(this.options.labelWrap) || this.labelWrap ? this.parent.bounds.height : 2 * this.labelFontSize;
	            0 < k && r.setLineDash && r.setLineDash(G(this.lineDashType, k));
	            l = new la(r, {
	                x: 0,
	                y: 0,
	                padding: {
	                    top: 2,
	                    right: 3,
	                    bottom: 2,
	                    left: 4
	                },
	                backgroundColor: this.labelBackgroundColor,
	                borderColor: this.labelBorderColor,
	                borderThickness: this.labelBorderThickness,
	                cornerRadius: this.labelCornerRadius,
	                maxWidth: this.labelMaxWidth,
	                maxHeight: this.labelMaxHeight,
	                angle: this.labelAngle,
	                text: m,
	                horizontalAlign: "left",
	                fontSize: this.labelFontSize,
	                fontFamily: this.labelFontFamily,
	                fontWeight: this.labelFontWeight,
	                fontColor: this.labelFontColor,
	                fontStyle: this.labelFontStyle,
	                textBaseline: "middle"
	            });
	            if (this.snapToDataPoint) {
	                var n = 0,
	                    h = [];
	                if ("xySwapped" === this.chart.plotInfo.axisPlacement) {
	                    var d =
	                        null;
	                    if ("bottom" === this.parent._position || "top" === this.parent._position) n = this.parent.dataSeries[0].axisX.convertPixelToValue({
	                        y: f
	                    });
	                    else if ("left" === this.parent._position || "right" === this.parent._position) n = this.parent.convertPixelToValue({
	                        y: f
	                    });
	                    for (var q = 0; q < this.parent.dataSeries.length; q++)(d = this.parent.dataSeries[q].getDataPointAtX(n, !0)) && 0 <= d.index && (d.dataSeries = this.parent.dataSeries[q], null !== d.dataPoint.y && h.push(d));
	                    d = null;
	                    if (0 === h.length) return;
	                    h.sort(function(a, b) {
	                        return a.distance -
	                            b.distance
	                    });
	                    d = Math.abs(a - this.parent.convertValueToPixel(h[0].dataPoint.y));
	                    q = 0;
	                    if ("rangeBar" === h[0].dataSeries.type || "error" === h[0].dataSeries.type)
	                        for (var d = Math.abs(a - this.parent.convertValueToPixel(h[q].dataPoint.y[0])), s = 0, n = 0; n < h.length; n++)
	                            if (h[n].dataPoint.y && h[n].dataPoint.y.length)
	                                for (m = 0; m < h[n].dataPoint.y.length; m++) s = Math.abs(a - this.parent.convertValueToPixel(h[n].dataPoint.y[m])), s < d && (d = s, q = n);
	                            else s = Math.abs(a - this.parent.convertValueToPixel(h[n].dataPoint.y)), s < d && (d = s, q = n);
	                    else if ("stackedBar" ===
	                        h[0].dataSeries.type)
	                        for (var d = Math.abs(a - this.parent.convertValueToPixel(h[0].dataPoint.y)), v = s = 0, n = q = 0; n < h.length; n++)
	                            if (h[n].dataPoint.y && h[n].dataPoint.y.length)
	                                for (m = 0; m < h[n].dataPoint.y.length; m++) s = Math.abs(a - this.parent.convertValueToPixel(h[n].dataPoint.y[m])), s < d && (d = s, q = n);
	                            else v += h[n].dataPoint.y, s = Math.abs(a - this.parent.convertValueToPixel(v)), s < d && (d = s, q = n);
	                    else if ("stackedBar100" === h[0].dataSeries.type)
	                        for (var d = Math.abs(a - this.parent.convertValueToPixel(h[0].dataPoint.y)), u = v = s = 0,
	                                n = 0; n < h.length; n++)
	                            if (h[n].dataPoint.y && h[n].dataPoint.y.length)
	                                for (m = 0; m < h[n].dataPoint.y.length; m++) s = Math.abs(a - this.parent.convertValueToPixel(h[n].dataPoint.y[m])), s < d && (d = s, q = n);
	                            else v += h[n].dataPoint.y, u = h[n].dataPoint.x.getTime ? h[n].dataPoint.x.getTime() : h[n].dataPoint.x, u = 100 * (v / h[n].dataSeries.plotUnit.dataPointYSums[u]), s = Math.abs(a - this.parent.convertValueToPixel(u)), s < d && (d = s, q = n);
	                    else
	                        for (d = Math.abs(a - this.parent.convertValueToPixel(h[0].dataPoint.y)), n = q = s = 0; n < h.length; n++)
	                            if (h[n].dataPoint.y &&
	                                h[n].dataPoint.y.length)
	                                for (m = 0; m < h[n].dataPoint.y.length; m++) s = Math.abs(a - this.parent.convertValueToPixel(h[n].dataPoint.y[m])), s < d && (d = s, q = n);
	                            else s = Math.abs(a - this.parent.convertValueToPixel(h[n].dataPoint.y)), s < d && (d = s, q = n);
	                    m = h[q];
	                    if ("bottom" === this.parent._position || "top" === this.parent._position) {
	                        b = 0;
	                        if ("rangeBar" === this.parent.dataSeries[q].type || "error" === this.parent.dataSeries[q].type) {
	                            d = Math.abs(a - this.parent.convertValueToPixel(m.dataPoint.y[0]));
	                            for (n = s = 0; n < m.dataPoint.y.length; n++) s = Math.abs(a -
	                                this.parent.convertValueToPixel(m.dataPoint.y[n])), s < d && (d = s, b = n);
	                            h = 1 === r.lineWidth % 2 ? (this.parent.convertValueToPixel(m.dataPoint.y[b]) << 0) + 0.5 : this.parent.convertValueToPixel(m.dataPoint.y[b]) << 0;
	                            l.text = this.labelFormatter ? this.labelFormatter({
	                                chart: this.chart,
	                                axis: this.parent.options,
	                                crosshair: this.options,
	                                value: m.dataPoint.y[b]
	                            }) : y(this.options.label) ? W(m.dataPoint.y[b], this.valueFormatString, this.chart._cultureInfo) : this.label
	                        } else if ("stackedBar" === this.parent.dataSeries[q].type) {
	                            d = Math.abs(a -
	                                this.parent.convertValueToPixel(h[0].dataPoint.y));
	                            v = s = 0;
	                            for (n = q; 0 <= n; n--) v += h[n].dataPoint.y, s = Math.abs(a - this.parent.convertValueToPixel(v)), s < d && (d = s, b = n);
	                            h = 1 === r.lineWidth % 2 ? (this.parent.convertValueToPixel(v) << 0) + 0.5 : this.parent.convertValueToPixel(v) << 0;
	                            l.text = this.labelFormatter ? this.labelFormatter({
	                                chart: this.chart,
	                                axis: this.parent.options,
	                                crosshair: this.options,
	                                value: m.dataPoint.y
	                            }) : y(this.options.label) ? W(m.dataPoint.y, this.valueFormatString, this.chart._cultureInfo) : this.label
	                        } else if ("stackedBar100" ===
	                            this.parent.dataSeries[q].type) {
	                            d = Math.abs(a - this.parent.convertValueToPixel(h[0].dataPoint.y));
	                            u = v = s = 0;
	                            for (n = q; 0 <= n; n--) v += h[n].dataPoint.y, u = h[n].dataPoint.x.getTime ? h[n].dataPoint.x.getTime() : h[n].dataPoint.x, u = 100 * (v / h[n].dataSeries.plotUnit.dataPointYSums[u]), s = Math.abs(a - this.parent.convertValueToPixel(u)), s < d && (d = s, b = n);
	                            h = 1 === r.lineWidth % 2 ? (this.parent.convertValueToPixel(u) << 0) + 0.5 : this.parent.convertValueToPixel(u) << 0;
	                            l.text = this.labelFormatter ? this.labelFormatter({
	                                chart: this.chart,
	                                axis: this.parent.options,
	                                crosshair: this.options,
	                                value: u
	                            }) : y(this.options.label) ? W(u, this.valueFormatString, this.chart._cultureInfo) : this.label
	                        } else h = 1 === r.lineWidth % 2 ? (this.parent.convertValueToPixel(m.dataPoint.y) << 0) + 0.5 : this.parent.convertValueToPixel(m.dataPoint.y) << 0, l.text = this.labelFormatter ? this.labelFormatter({
	                            chart: this.chart,
	                            axis: this.parent.options,
	                            crosshair: this.options,
	                            value: m.dataPoint.y
	                        }) : y(this.options.label) ? W(m.dataPoint.y, this.valueFormatString, this.chart._cultureInfo) : this.label;
	                        b = c = h;
	                        e = this.chart.plotArea.y1;
	                        g = this.chart.plotArea.y2;
	                        this.bounds = {
	                            x1: b - k / 2,
	                            y1: e,
	                            x2: c + k / 2,
	                            y2: g
	                        };
	                        l.x = b - l.measureText().width / 2;
	                        l.x + l.width > this.chart.bounds.x2 ? l.x = this.chart.bounds.x2 - l.width : l.x < this.chart.bounds.x1 && (l.x = this.chart.bounds.x1);
	                        l.y = this.parent.lineCoordinates.y2 + l.fontSize / 2 + 2
	                    } else if ("left" === this.parent._position || "right" === this.parent._position) {
	                        e = g = h = 1 === r.lineWidth % 2 ? (this.parent.convertValueToPixel(m.dataPoint.x) << 0) + 0.5 : this.parent.convertValueToPixel(m.dataPoint.x) << 0;
	                        b = this.chart.plotArea.x1;
	                        c = this.chart.plotArea.x2;
	                        this.bounds = {
	                            x1: b,
	                            y1: e - k / 2,
	                            x2: c,
	                            y2: g + k / 2
	                        };
	                        u = !1;
	                        if (this.parent.labels)
	                            for (h = Math.ceil(this.parent.interval), n = 0; n < this.parent.viewportMaximum; n += h)
	                                if (this.parent.labels[n]) u = !0;
	                                else {
	                                    u = !1;
	                                    break
	                                }
	                        if (u) {
	                            if ("axisX" === this.parent.type)
	                                for (n = this.parent.convertPixelToValue({
	                                        y: f
	                                    }), d = null, q = 0; q < this.parent.dataSeries.length; q++)(d = this.parent.dataSeries[q].getDataPointAtX(n, !0)) && 0 <= d.index && (l.text = this.labelFormatter ? this.labelFormatter({
	                                        chart: this.chart,
	                                        axis: this.parent.options,
	                                        crosshair: this.options,
	                                        value: m.dataPoint.x
	                                    }) :
	                                    y(this.options.label) ? d.dataPoint.label : this.label)
	                        } else "dateTime" === this.parent.valueType ? l.text = this.labelFormatter ? this.labelFormatter({
	                            chart: this.chart,
	                            axis: this.parent.options,
	                            crosshair: this.options,
	                            value: m.dataPoint.x
	                        }) : y(this.options.label) ? Ba(m.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label : "number" === this.parent.valueType && (l.text = this.labelFormatter ? this.labelFormatter({
	                                chart: this.chart,
	                                axis: this.parent.options,
	                                crosshair: this.options,
	                                value: m.dataPoint.x
	                            }) : y(this.options.label) ?
	                            W(m.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label);
	                        l.y = g + l.fontSize / 2 - l.measureText().height / 2 + 2;
	                        l.y - l.fontSize / 2 < this.chart.bounds.y1 ? l.y = this.chart.bounds.y1 + l.fontSize / 2 + 2 : l.y + l.measureText().height - l.fontSize / 2 > this.chart.bounds.y2 && (l.y = this.chart.bounds.y2 - l.measureText().height + l.fontSize / 2);
	                        "left" === this.parent._position ? l.x = this.parent.lineCoordinates.x2 - l.measureText().width : "right" === this.parent._position && (l.x = this.parent.lineCoordinates.x2)
	                    }
	                } else if ("bottom" ===
	                    this.parent._position || "top" === this.parent._position) {
	                    n = this.parent.convertPixelToValue({
	                        x: a
	                    });
	                    for (q = 0; q < this.parent.dataSeries.length; q++)(d = this.parent.dataSeries[q].getDataPointAtX(n, !0)) && 0 <= d.index && (d.dataSeries = this.parent.dataSeries[q], null !== d.dataPoint.y && h.push(d));
	                    if (0 === h.length) return;
	                    h.sort(function(a, b) {
	                        return a.distance - b.distance
	                    });
	                    m = h[0];
	                    b = c = h = 1 === r.lineWidth % 2 ? (this.parent.convertValueToPixel(m.dataPoint.x) << 0) + 0.5 : this.parent.convertValueToPixel(m.dataPoint.x) << 0;
	                    e = this.chart.plotArea.y1;
	                    g = this.chart.plotArea.y2;
	                    this.bounds = {
	                        x1: b - k / 2,
	                        y1: e,
	                        x2: c + k / 2,
	                        y2: g
	                    };
	                    u = !1;
	                    if (this.parent.labels)
	                        for (h = Math.ceil(this.parent.interval), n = 0; n < this.parent.viewportMaximum; n += h)
	                            if (this.parent.labels[n]) u = !0;
	                            else {
	                                u = !1;
	                                break
	                            }
	                    if (u) {
	                        if ("axisX" === this.parent.type)
	                            for (n = this.parent.convertPixelToValue({
	                                    x: a
	                                }), d = null, q = 0; q < this.parent.dataSeries.length; q++)(d = this.parent.dataSeries[q].getDataPointAtX(n, !0)) && 0 <= d.index && (l.text = this.labelFormatter ? this.labelFormatter({
	                                chart: this.chart,
	                                axis: this.parent.options,
	                                crosshair: this.options,
	                                value: m.dataPoint.x
	                            }) : y(this.options.label) ? d.dataPoint.label : this.label)
	                    } else "dateTime" === this.parent.valueType ? l.text = this.labelFormatter ? this.labelFormatter({
	                        chart: this.chart,
	                        axis: this.parent.options,
	                        crosshair: this.options,
	                        value: m.dataPoint.x
	                    }) : y(this.options.label) ? Ba(m.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label : "number" === this.parent.valueType && (l.text = this.labelFormatter ? this.labelFormatter({
	                        chart: this.chart,
	                        axis: this.parent.options,
	                        crosshair: this.options,
	                        value: m.dataPoint.x
	                    }) : y(this.options.label) ? W(m.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label);
	                    l.x = b - l.measureText().width / 2;
	                    l.x + l.width > this.chart.bounds.x2 && (l.x = this.chart.bounds.x2 - l.width);
	                    l.x < this.chart.bounds.x1 && (l.x = this.chart.bounds.x1);
	                    "bottom" === this.parent._position ? l.y = this.parent.lineCoordinates.y2 + l.fontSize / 2 + 2 : "top" === this.parent._position && (l.y = this.parent.lineCoordinates.y1 - l.height + l.fontSize / 2 + 2)
	                } else if ("left" === this.parent._position || "right" === this.parent._position) {
	                    !y(this.parent.dataSeries) &&
	                        0 < this.parent.dataSeries.length && (n = this.parent.dataSeries[0].axisX.convertPixelToValue({
	                            x: a
	                        }));
	                    for (q = 0; q < this.parent.dataSeries.length; q++)(d = this.parent.dataSeries[q].getDataPointAtX(n, !0)) && 0 <= d.index && (d.dataSeries = this.parent.dataSeries[q], null !== d.dataPoint.y && h.push(d));
	                    if (0 === h.length) return;
	                    h.sort(function(a, b) {
	                        return a.distance - b.distance
	                    });
	                    q = 0;
	                    if ("rangeColumn" === h[0].dataSeries.type || "rangeArea" === h[0].dataSeries.type || "error" === h[0].dataSeries.type || "rangeSplineArea" === h[0].dataSeries.type ||
	                        "candlestick" === h[0].dataSeries.type || "ohlc" === h[0].dataSeries.type || "boxAndWhisker" === h[0].dataSeries.type)
	                        for (d = Math.abs(f - this.parent.convertValueToPixel(h[0].dataPoint.y[0])), n = s = 0; n < h.length; n++)
	                            if (h[n].dataPoint.y && h[n].dataPoint.y.length)
	                                for (m = 0; m < h[n].dataPoint.y.length; m++) s = Math.abs(f - this.parent.convertValueToPixel(h[n].dataPoint.y[m])), s < d && (d = s, q = n);
	                            else s = Math.abs(f - this.parent.convertValueToPixel(h[n].dataPoint.y)), s < d && (d = s, q = n);
	                    else if ("stackedColumn" === h[0].dataSeries.type || "stackedArea" ===
	                        h[0].dataSeries.type)
	                        for (d = Math.abs(f - this.parent.convertValueToPixel(h[0].dataPoint.y)), n = v = s = 0; n < h.length; n++)
	                            if (h[n].dataPoint.y && h[n].dataPoint.y.length)
	                                for (m = 0; m < h[n].dataPoint.y.length; m++) s = Math.abs(f - this.parent.convertValueToPixel(h[n].dataPoint.y[m])), s < d && (d = s, q = n);
	                            else v += h[n].dataPoint.y, s = Math.abs(f - this.parent.convertValueToPixel(v)), s < d && (d = s, q = n);
	                    else if ("stackedColumn100" === h[0].dataSeries.type || "stackedArea100" === h[0].dataSeries.type)
	                        for (d = Math.abs(f - this.parent.convertValueToPixel(h[0].dataPoint.y)),
	                            n = u = v = s = 0; n < h.length; n++)
	                            if (h[n].dataPoint.y && h[n].dataPoint.y.length)
	                                for (m = 0; m < h[n].dataPoint.y.length; m++) s = Math.abs(f - this.parent.convertValueToPixel(h[n].dataPoint.y[m])), s < d && (d = s, q = n);
	                            else v += h[n].dataPoint.y, u = h[n].dataPoint.x.getTime ? h[n].dataPoint.x.getTime() : h[n].dataPoint.x, u = 100 * (v / h[n].dataSeries.plotUnit.dataPointYSums[u]), s = Math.abs(f - this.parent.convertValueToPixel(u)), s < d && (d = s, q = n);
	                    else
	                        for (d = Math.abs(f - this.parent.convertValueToPixel(h[0].dataPoint.y)), n = s = 0; n < h.length; n++)
	                            if (h[n].dataPoint.y &&
	                                h[n].dataPoint.y.length)
	                                for (m = 0; m < h[n].dataPoint.y.length; m++) s = Math.abs(f - this.parent.convertValueToPixel(h[n].dataPoint.y[m])), s < d && (d = s, q = n);
	                            else s = Math.abs(f - this.parent.convertValueToPixel(h[n].dataPoint.y)), s < d && (d = s, q = n);
	                    m = h[q];
	                    b = 0;
	                    if ("rangeColumn" === this.parent.dataSeries[q].type || "rangeArea" === this.parent.dataSeries[q].type || "error" === this.parent.dataSeries[q].type || "rangeSplineArea" === this.parent.dataSeries[q].type || "candlestick" === this.parent.dataSeries[q].type || "ohlc" === this.parent.dataSeries[q].type ||
	                        "boxAndWhisker" === this.parent.dataSeries[q].type) {
	                        d = Math.abs(f - this.parent.convertValueToPixel(m.dataPoint.y[0]));
	                        for (n = s = 0; n < m.dataPoint.y.length; n++) s = Math.abs(f - this.parent.convertValueToPixel(m.dataPoint.y[n])), s < d && (d = s, b = n);
	                        h = 1 === r.lineWidth % 2 ? (this.parent.convertValueToPixel(m.dataPoint.y[b]) << 0) + 0.5 : this.parent.convertValueToPixel(m.dataPoint.y[b]) << 0;
	                        l.text = this.labelFormatter ? this.labelFormatter({
	                                chart: this.chart,
	                                axis: this.parent.options,
	                                crosshair: this.options,
	                                value: m.dataPoint.y[b]
	                            }) : y(this.options.label) ?
	                            W(m.dataPoint.y[b], this.valueFormatString, this.chart._cultureInfo) : this.label
	                    } else if ("stackedColumn" === this.parent.dataSeries[q].type || "stackedArea" === this.parent.dataSeries[q].type) {
	                        d = Math.abs(f - this.parent.convertValueToPixel(h[0].dataPoint.y));
	                        v = s = 0;
	                        for (n = q; 0 <= n; n--) v += h[n].dataPoint.y, s = Math.abs(f - this.parent.convertValueToPixel(v)), s < d && (d = s, b = n);
	                        h = 1 === r.lineWidth % 2 ? (this.parent.convertValueToPixel(v) << 0) + 0.5 : this.parent.convertValueToPixel(v) << 0;
	                        l.text = this.labelFormatter ? this.labelFormatter({
	                            chart: this.chart,
	                            axis: this.parent.options,
	                            crosshair: this.options,
	                            value: m.dataPoint.y
	                        }) : y(this.options.label) ? W(m.dataPoint.y, this.valueFormatString, this.chart._cultureInfo) : this.label
	                    } else if ("stackedColumn100" === this.parent.dataSeries[q].type || "stackedArea100" === this.parent.dataSeries[q].type) {
	                        d = Math.abs(f - this.parent.convertValueToPixel(h[0].dataPoint.y));
	                        v = s = 0;
	                        for (n = q; 0 <= n; n--) v += h[n].dataPoint.y, u = h[n].dataPoint.x.getTime ? h[n].dataPoint.x.getTime() : h[n].dataPoint.x, u = 100 * (v / h[n].dataSeries.plotUnit.dataPointYSums[u]),
	                            s = Math.abs(f - this.parent.convertValueToPixel(u)), s < d && (d = s, b = n);
	                        h = 1 === r.lineWidth % 2 ? (this.parent.convertValueToPixel(u) << 0) + 0.5 : this.parent.convertValueToPixel(u) << 0;
	                        l.text = this.labelFormatter ? this.labelFormatter({
	                            chart: this.chart,
	                            axis: this.parent.options,
	                            crosshair: this.options,
	                            value: u
	                        }) : y(this.options.label) ? W(u, this.valueFormatString, this.chart._cultureInfo) : this.label
	                    } else "waterfall" === this.parent.dataSeries[q].type ? (h = 1 === r.lineWidth % 2 ? (this.parent.convertValueToPixel(m.dataSeries.dataPointEOs[m.index].cumulativeSum) <<
	                        0) + 0.5 : this.parent.convertValueToPixel(m.dataSeries.dataPointEOs[m.index].cumulativeSum) << 0, l.text = this.labelFormatter ? this.labelFormatter({
	                        chart: this.chart,
	                        axis: this.parent.options,
	                        crosshair: this.options,
	                        value: m.dataSeries.dataPointEOs[m.index].cumulativeSum
	                    }) : y(this.options.label) ? W(m.dataSeries.dataPointEOs[m.index].cumulativeSum, this.valueFormatString, this.chart._cultureInfo) : this.label) : (h = 1 === r.lineWidth % 2 ? (this.parent.convertValueToPixel(m.dataPoint.y) << 0) + 0.5 : this.parent.convertValueToPixel(m.dataPoint.y) <<
	                        0, l.text = this.labelFormatter ? this.labelFormatter({
	                            chart: this.chart,
	                            axis: this.parent.options,
	                            crosshair: this.options,
	                            value: m.dataPoint.y
	                        }) : y(this.options.label) ? W(m.dataPoint.y, this.valueFormatString, this.chart._cultureInfo) : this.label);
	                    e = g = h;
	                    b = this.chart.plotArea.x1;
	                    c = this.chart.plotArea.x2;
	                    this.bounds = {
	                        x1: b,
	                        y1: e - k / 2,
	                        x2: c,
	                        y2: g + k / 2
	                    };
	                    l.y = g + l.fontSize / 2 - l.measureText().height / 2 + 2;
	                    l.y - l.fontSize / 2 < this.chart.bounds.y1 ? l.y = this.chart.bounds.y1 + l.fontSize / 2 + 2 : l.y + l.measureText().height - l.fontSize / 2 > this.chart.bounds.y2 &&
	                        (l.y = this.chart.bounds.y2 - l.measureText().height + l.fontSize / 2);
	                    "left" === this.parent._position ? l.x = this.parent.lineCoordinates.x2 - l.measureText().width : "right" === this.parent._position && (l.x = this.parent.lineCoordinates.x2)
	                }
	                h = null;
	                ("bottom" === this.parent._position || "top" === this.parent._position) && (b >= this.parent.convertValueToPixel(this.parent.viewportMinimum) && c <= this.parent.convertValueToPixel(this.parent.viewportMaximum)) && (0 < k && (r.moveTo(b, e), r.lineTo(c, g), r.stroke()), r.restore(), !y(l.text) && ("number" ===
	                    typeof l.text.valueOf() || 0 < l.text.length) && l.render(!0));
	                ("left" === this.parent._position || "right" === this.parent._position) && (g >= this.parent.convertValueToPixel(this.parent.viewportMaximum) && e <= this.parent.convertValueToPixel(this.parent.viewportMinimum)) && (0 < k && (r.moveTo(b, e), r.lineTo(c, g), r.stroke()), r.restore(), !y(l.text) && ("number" === typeof l.text.valueOf() || 0 < l.text.length) && l.render(!0))
	            } else {
	                if ("bottom" === this.parent._position || "top" === this.parent._position) b = c = h = 1 === r.lineWidth % 2 ? (a << 0) + 0.5 :
	                    a << 0, e = this.chart.plotArea.y1, g = this.chart.plotArea.y2, this.bounds = {
	                        x1: b - k / 2,
	                        y1: e,
	                        x2: c + k / 2,
	                        y2: g
	                    };
	                else if ("left" === this.parent._position || "right" === this.parent._position) e = g = h = 1 === r.lineWidth % 2 ? (f << 0) + 0.5 : f << 0, b = this.chart.plotArea.x1, c = this.chart.plotArea.x2, this.bounds = {
	                    x1: b,
	                    y1: e - k / 2,
	                    x2: c,
	                    y2: g + k / 2
	                };
	                if ("xySwapped" === this.chart.plotInfo.axisPlacement)
	                    if ("left" === this.parent._position || "right" === this.parent._position) {
	                        u = !1;
	                        if (this.parent.labels)
	                            for (h = Math.ceil(this.parent.interval), n = 0; n < this.parent.viewportMaximum; n +=
	                                h)
	                                if (this.parent.labels[n]) u = !0;
	                                else {
	                                    u = !1;
	                                    break
	                                }
	                        if (u) {
	                            if ("axisX" === this.parent.type)
	                                for (n = this.parent.convertPixelToValue({
	                                        y: f
	                                    }), d = null, q = 0; q < this.parent.dataSeries.length; q++)(d = this.parent.dataSeries[q].getDataPointAtX(n, !0)) && 0 <= d.index && (l.text = this.labelFormatter ? this.labelFormatter({
	                                    chart: this.chart,
	                                    axis: this.parent.options,
	                                    crosshair: this.options,
	                                    value: this.parent.convertPixelToValue(a)
	                                }) : y(this.options.label) ? d.dataPoint.label : this.label)
	                        } else "dateTime" === this.parent.valueType ? l.text = this.labelFormatter ?
	                            this.labelFormatter({
	                                chart: this.chart,
	                                axis: this.parent.options,
	                                crosshair: this.options,
	                                value: this.parent.convertPixelToValue(f)
	                            }) : y(this.options.label) ? Ba(this.parent.convertPixelToValue(f), this.valueFormatString, this.chart._cultureInfo) : this.label : "number" === this.parent.valueType && (l.text = this.labelFormatter ? this.labelFormatter({
	                                chart: this.chart,
	                                axis: this.parent.options,
	                                crosshair: this.options,
	                                value: this.parent.convertPixelToValue(f)
	                            }) : y(this.options.label) ? W(this.parent.convertPixelToValue(f), this.valueFormatString,
	                                this.chart._cultureInfo) : this.label);
	                        l.y = f + l.fontSize / 2 - l.measureText().height / 2 + 2;
	                        l.y - l.fontSize / 2 < this.chart.bounds.y1 ? l.y = this.chart.bounds.y1 + l.fontSize / 2 + 2 : l.y + l.measureText().height - l.fontSize / 2 > this.chart.bounds.y2 && (l.y = this.chart.bounds.y2 - l.measureText().height + l.fontSize / 2);
	                        "left" === this.parent._position ? l.x = this.parent.lineCoordinates.x1 - l.measureText().width : "right" === this.parent._position && (l.x = this.parent.lineCoordinates.x2)
	                    } else {
	                        if ("bottom" === this.parent._position || "top" === this.parent._position) l.text =
	                            this.labelFormatter ? this.labelFormatter({
	                                chart: this.chart,
	                                axis: this.parent.options,
	                                crosshair: this.options,
	                                value: this.parent.convertPixelToValue(a)
	                            }) : y(this.options.label) ? W(this.parent.convertPixelToValue(a), this.valueFormatString, this.chart._cultureInfo) : this.label, l.x = b - l.measureText().width / 2, l.x + l.width > this.chart.bounds.x2 && (l.x = this.chart.bounds.x2 - l.width), l.x < this.chart.bounds.x1 && (l.x = this.chart.bounds.x1), "bottom" === this.parent._position && (l.y = this.parent.lineCoordinates.y2 + l.fontSize / 2 +
	                                2), "top" === this.parent._position && (l.y = this.parent.lineCoordinates.y1 - l.height + l.fontSize / 2 + 2)
	                    }
	                else if ("bottom" === this.parent._position || "top" === this.parent._position) {
	                    u = !1;
	                    m = "";
	                    if (this.parent.labels)
	                        for (h = Math.ceil(this.parent.interval), n = 0; n < this.parent.viewportMaximum; n += h)
	                            if (this.parent.labels[n]) u = !0;
	                            else {
	                                u = !1;
	                                break
	                            }
	                    if (u) {
	                        if ("axisX" === this.parent.type)
	                            for (n = this.parent.convertPixelToValue({
	                                    x: a
	                                }), d = null, q = 0; q < this.parent.dataSeries.length; q++)(d = this.parent.dataSeries[q].getDataPointAtX(n, !0)) &&
	                                0 <= d.index && (l.text = this.labelFormatter ? this.labelFormatter({
	                                    chart: this.chart,
	                                    axis: this.parent.options,
	                                    crosshair: this.options,
	                                    value: this.parent.convertPixelToValue(a)
	                                }) : y(this.options.label) ? d.dataPoint.label : this.label)
	                    } else "dateTime" === this.parent.valueType ? l.text = this.labelFormatter ? this.labelFormatter({
	                            chart: this.chart,
	                            axis: this.parent.options,
	                            crosshair: this.options,
	                            value: this.parent.convertPixelToValue(a)
	                        }) : y(this.options.label) ? Ba(this.parent.convertPixelToValue(a), this.valueFormatString, this.chart._cultureInfo) :
	                        this.label : "number" === this.parent.valueType && (l.text = this.labelFormatter ? this.labelFormatter({
	                            chart: this.chart,
	                            axis: this.parent.options,
	                            crosshair: this.options,
	                            value: 0 < this.parent.dataSeries.length ? this.parent.convertPixelToValue(a) : ""
	                        }) : y(this.options.label) ? W(this.parent.convertPixelToValue(a), this.valueFormatString, this.chart._cultureInfo) : this.label);
	                    l.x = b - l.measureText().width / 2;
	                    l.x + l.width > this.chart.bounds.x2 && (l.x = this.chart.bounds.x2 - l.width);
	                    l.x < this.chart.bounds.x1 && (l.x = this.chart.bounds.x1);
	                    "bottom" === this.parent._position ? l.y = this.parent.lineCoordinates.y2 + l.fontSize / 2 + 2 : "top" === this.parent._position && (l.y = this.parent.lineCoordinates.y1 - l.height + l.fontSize / 2 + 2)
	                } else if ("left" === this.parent._position || "right" === this.parent._position) l.text = this.labelFormatter ? this.labelFormatter({
	                        chart: this.chart,
	                        axis: this.parent.options,
	                        crosshair: this.options,
	                        value: this.parent.convertPixelToValue(f)
	                    }) : y(this.options.label) ? W(this.parent.convertPixelToValue(f), this.valueFormatString, this.chart._cultureInfo) :
	                    this.label, l.y = f + l.fontSize / 2 - l.measureText().height / 2 + 2, l.y - l.fontSize / 2 < this.chart.bounds.y1 ? l.y = this.chart.bounds.y1 + l.fontSize / 2 + 2 : l.y + l.measureText().height - l.fontSize / 2 > this.chart.bounds.y2 && (l.y = this.chart.bounds.y2 - l.measureText().height + l.fontSize / 2), "left" === this.parent._position ? l.x = this.parent.lineCoordinates.x2 - l.measureText().width : "right" === this.parent._position && (l.x = this.parent.lineCoordinates.x2);
	                0 < k && (r.moveTo(b, e), r.lineTo(c, g), r.stroke());
	                r.restore();
	                !y(l.text) && ("number" === typeof l.text.valueOf() ||
	                    0 < l.text.length) && l.render(!0)
	            }
	            r.globalAlpha = p
	        };
	        pa(Y, X);
	        Y.prototype._initialize = function() {
	            if (this.enabled) {
	                this.container = document.createElement("div");
	                this.container.setAttribute("class", "canvasjs-chart-tooltip");
	                this.container.style.position = "absolute";
	                this.container.style.height = "auto";
	                this.container.style.boxShadow = "1px 1px 2px 2px rgba(0,0,0,0.1)";
	                this.container.style.zIndex = "1000";
	                this.container.style.pointerEvents = "none";
	                this.container.style.display = "none";
	                var a;
	                a = '<div style=" width: auto;height: auto;min-width: 50px;';
	                a += "line-height: auto;";
	                a += "margin: 0px 0px 0px 0px;";
	                a += "padding: 5px;";
	                a += "font-family: Calibri, Arial, Georgia, serif;";
	                a += "font-weight: normal;";
	                a += "font-style: " + (v ? "italic;" : "normal;");
	                a += "font-size: 14px;";
	                a += "color: #000000;";
	                a += "text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.1);";
	                a += "text-align: left;";
	                a += "border: 2px solid gray;";
	                a += v ? "background: rgba(255,255,255,.9);" : "background: rgb(255,255,255);";
	                a += "text-indent: 0px;";
	                a += "white-space: nowrap;";
	                a += "border-radius: 5px;";
	                a += "-moz-user-select:none;";
	                a += "-khtml-user-select: none;";
	                a += "-webkit-user-select: none;";
	                a += "-ms-user-select: none;";
	                a += "user-select: none;";
	                v || (a += "filter: alpha(opacity = 90);", a += "filter: progid:DXImageTransform.Microsoft.Shadow(Strength=3, Direction=135, Color='#666666');");
	                a += '} "> Sample Tooltip</div>';
	                this.container.innerHTML = a;
	                this.contentDiv = this.container.firstChild;
	                this.container.style.borderRadius = this.contentDiv.style.borderRadius;
	                this.chart._canvasJSContainer.appendChild(this.container)
	            }
	        };
	        Y.prototype.mouseMoveHandler =
	            function(a, f) {
	                this._lastUpdated && 4 > (new Date).getTime() - this._lastUpdated || (this._lastUpdated = (new Date).getTime(), this.chart.resetOverlayedCanvas(), this._updateToolTip(a, f))
	            };
	        Y.prototype._updateToolTip = function(a, f, b) {
	            b = "undefined" === typeof b ? !0 : b;
	            this.container || this._initialize();
	            this.enabled || this.hide();
	            if (!this.chart.disableToolTip) {
	                if ("undefined" === typeof a || "undefined" === typeof f) {
	                    if (isNaN(this._prevX) || isNaN(this._prevY)) return;
	                    a = this._prevX;
	                    f = this._prevY
	                } else this._prevX = a, this._prevY = f;
	                var c = null,
	                    e = null,
	                    g = [],
	                    h = 0;
	                if (this.shared && this.enabled && "none" !== this.chart.plotInfo.axisPlacement) {
	                    if ("xySwapped" === this.chart.plotInfo.axisPlacement) {
	                        var l = [];
	                        if (this.chart.axisX)
	                            for (var m = 0; m < this.chart.axisX.length; m++) {
	                                for (var h = this.chart.axisX[m].convertPixelToValue({
	                                        y: f
	                                    }), k = null, c = 0; c < this.chart.axisX[m].dataSeries.length; c++)(k = this.chart.axisX[m].dataSeries[c].getDataPointAtX(h, b)) && 0 <= k.index && (k.dataSeries = this.chart.axisX[m].dataSeries[c], null !== k.dataPoint.y && l.push(k));
	                                k = null
	                            }
	                        if (this.chart.axisX2)
	                            for (m =
	                                0; m < this.chart.axisX2.length; m++) {
	                                h = this.chart.axisX2[m].convertPixelToValue({
	                                    y: f
	                                });
	                                k = null;
	                                for (c = 0; c < this.chart.axisX2[m].dataSeries.length; c++)(k = this.chart.axisX2[m].dataSeries[c].getDataPointAtX(h, b)) && 0 <= k.index && (k.dataSeries = this.chart.axisX2[m].dataSeries[c], null !== k.dataPoint.y && l.push(k));
	                                k = null
	                            }
	                    } else {
	                        l = [];
	                        if (this.chart.axisX)
	                            for (m = 0; m < this.chart.axisX.length; m++)
	                                for (h = this.chart.axisX[m].convertPixelToValue({
	                                        x: a
	                                    }), k = null, c = 0; c < this.chart.axisX[m].dataSeries.length; c++)(k = this.chart.axisX[m].dataSeries[c].getDataPointAtX(h,
	                                    b)) && 0 <= k.index && (k.dataSeries = this.chart.axisX[m].dataSeries[c], null !== k.dataPoint.y && l.push(k));
	                        if (this.chart.axisX2)
	                            for (m = 0; m < this.chart.axisX2.length; m++)
	                                for (h = this.chart.axisX2[m].convertPixelToValue({
	                                        x: a
	                                    }), k = null, c = 0; c < this.chart.axisX2[m].dataSeries.length; c++)(k = this.chart.axisX2[m].dataSeries[c].getDataPointAtX(h, b)) && 0 <= k.index && (k.dataSeries = this.chart.axisX2[m].dataSeries[c], null !== k.dataPoint.y && l.push(k))
	                    }
	                    if (0 === l.length) return;
	                    l.sort(function(a, b) {
	                        return a.distance - b.distance
	                    });
	                    b = l[0];
	                    for (c = 0; c < l.length; c++) l[c].dataPoint.x.valueOf() === b.dataPoint.x.valueOf() && g.push(l[c]);
	                    l = null
	                } else {
	                    if (k = this.chart.getDataPointAtXY(a, f, b)) this.currentDataPointIndex = k.dataPointIndex, this.currentSeriesIndex = k.dataSeries.index;
	                    else if (v)
	                        if (k = Wa(a, f, this.chart._eventManager.ghostCtx), 0 < k && "undefined" !== typeof this.chart._eventManager.objectMap[k]) {
	                            k = this.chart._eventManager.objectMap[k];
	                            if ("legendItem" === k.objectType) return;
	                            this.currentSeriesIndex = k.dataSeriesIndex;
	                            this.currentDataPointIndex = 0 <=
	                                k.dataPointIndex ? k.dataPointIndex : -1
	                        } else this.currentDataPointIndex = -1;
	                    else this.currentDataPointIndex = -1;
	                    if (0 <= this.currentSeriesIndex) {
	                        e = this.chart.data[this.currentSeriesIndex];
	                        k = {};
	                        if (0 <= this.currentDataPointIndex) c = e.dataPoints[this.currentDataPointIndex], k.dataSeries = e, k.dataPoint = c, k.index = this.currentDataPointIndex, k.distance = Math.abs(c.x - h), "waterfall" === e.type && (k.cumulativeSumYStartValue = e.dataPointEOs[this.currentDataPointIndex].cumulativeSumYStartValue, k.cumulativeSum = e.dataPointEOs[this.currentDataPointIndex].cumulativeSum);
	                        else {
	                            if (!this.enabled || "line" !== e.type && "stepLine" !== e.type && "spline" !== e.type && "area" !== e.type && "stepArea" !== e.type && "splineArea" !== e.type && "stackedArea" !== e.type && "stackedArea100" !== e.type && "rangeArea" !== e.type && "rangeSplineArea" !== e.type && "candlestick" !== e.type && "ohlc" !== e.type && "boxAndWhisker" !== e.type) return;
	                            h = e.axisX.convertPixelToValue({
	                                x: a
	                            });
	                            k = e.getDataPointAtX(h, b);
	                            k.dataSeries = e;
	                            this.currentDataPointIndex = k.index;
	                            c = k.dataPoint
	                        }
	                        if (!y(k.dataPoint.y))
	                            if (k.dataSeries.axisY)
	                                if (0 < k.dataPoint.y.length) {
	                                    for (c =
	                                        b = 0; c < k.dataPoint.y.length; c++) k.dataPoint.y[c] < k.dataSeries.axisY.viewportMinimum ? b-- : k.dataPoint.y[c] > k.dataSeries.axisY.viewportMaximum && b++;
	                                    b < k.dataPoint.y.length && b > -k.dataPoint.y.length && g.push(k)
	                                } else "column" === e.type || "bar" === e.type ? 0 > k.dataPoint.y ? 0 > k.dataSeries.axisY.viewportMinimum && k.dataSeries.axisY.viewportMaximum >= k.dataPoint.y && g.push(k) : k.dataSeries.axisY.viewportMinimum <= k.dataPoint.y && 0 <= k.dataSeries.axisY.viewportMaximum && g.push(k) : "bubble" === e.type ? (b = this.chart._eventManager.objectMap[e.dataPointIds[k.index]].size /
	                                    2, k.dataPoint.y >= k.dataSeries.axisY.viewportMinimum - b && k.dataPoint.y <= k.dataSeries.axisY.viewportMaximum + b && g.push(k)) : "waterfall" === e.type ? (b = 0, k.cumulativeSumYStartValue < k.dataSeries.axisY.viewportMinimum ? b-- : k.cumulativeSumYStartValue > k.dataSeries.axisY.viewportMaximum && b++, k.cumulativeSum < k.dataSeries.axisY.viewportMinimum ? b-- : k.cumulativeSum > k.dataSeries.axisY.viewportMaximum && b++, 2 > b && -2 < b && g.push(k)) : (0 <= k.dataSeries.type.indexOf("100") || "stackedColumn" === e.type || "stackedBar" === e.type || k.dataPoint.y >=
	                                    k.dataSeries.axisY.viewportMinimum && k.dataPoint.y <= k.dataSeries.axisY.viewportMaximum) && g.push(k);
	                        else g.push(k)
	                    }
	                }
	                if (0 < g.length && (this.highlightObjects(g), this.enabled))
	                    if (b = "", b = this.getToolTipInnerHTML({
	                            entries: g
	                        }), null !== b) {
	                        this.contentDiv.innerHTML = b;
	                        b = !1;
	                        "none" === this.container.style.display && (b = !0, this.container.style.display = "block");
	                        try {
	                            this.contentDiv.style.background = this.backgroundColor ? this.backgroundColor : v ? "rgba(255,255,255,.9)" : "rgb(255,255,255)", this.borderColor = "waterfall" === g[0].dataSeries.type ?
	                                this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : g[0].dataPoint.color ? g[0].dataPoint.color : -1 < g[0].dataPoint.y ? g[0].dataSeries.risingColor : g[0].dataSeries.fallingColor : "error" === g[0].dataSeries.type ? this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : g[0].dataSeries.color ? g[0].dataSeries.color :
	                                g[0].dataSeries._colorSet[e.index % g[0].dataSeries._colorSet.length] : this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : g[0].dataPoint.color ? g[0].dataPoint.color : g[0].dataSeries.color ? g[0].dataSeries.color : g[0].dataSeries._colorSet[g[0].index % g[0].dataSeries._colorSet.length], this.contentDiv.style.borderWidth = this.borderThickness || 0 === this.borderThickness ? this.borderThickness + "px" : "2px", this.contentDiv.style.borderRadius =
	                                this.cornerRadius || 0 === this.cornerRadius ? this.cornerRadius + "px" : "5px", this.container.style.borderRadius = this.contentDiv.style.borderRadius, this.contentDiv.style.fontSize = this.fontSize || 0 === this.fontSize ? this.fontSize + "px" : "14px", this.contentDiv.style.color = this.fontColor ? this.fontColor : "#000000", this.contentDiv.style.fontFamily = this.fontFamily ? this.fontFamily : "Calibri, Arial, Georgia, serif;", this.contentDiv.style.fontWeight = this.fontWeight ? this.fontWeight : "normal", this.contentDiv.style.fontStyle =
	                                this.fontStyle ? this.fontStyle : v ? "italic" : "normal"
	                        } catch (q) {}
	                        "pie" === g[0].dataSeries.type || "doughnut" === g[0].dataSeries.type || "funnel" === g[0].dataSeries.type || "pyramid" === g[0].dataSeries.type || "bar" === g[0].dataSeries.type || "rangeBar" === g[0].dataSeries.type || "stackedBar" === g[0].dataSeries.type || "stackedBar100" === g[0].dataSeries.type ? a = a - 10 - this.container.clientWidth : (a = g[0].dataSeries.axisX.convertValueToPixel(g[0].dataPoint.x) - this.container.clientWidth << 0, a -= 10);
	                        0 > a && (a += this.container.clientWidth +
	                            20);
	                        a + this.container.clientWidth > Math.max(this.chart.container.clientWidth, this.chart.width) && (a = Math.max(0, Math.max(this.chart.container.clientWidth, this.chart.width) - this.container.clientWidth));
	                        f = 1 !== g.length || this.shared || "line" !== g[0].dataSeries.type && "stepLine" !== g[0].dataSeries.type && "spline" !== g[0].dataSeries.type && "area" !== g[0].dataSeries.type && "stepArea" !== g[0].dataSeries.type && "splineArea" !== g[0].dataSeries.type ? "bar" === g[0].dataSeries.type || "rangeBar" === g[0].dataSeries.type || "stackedBar" ===
	                            g[0].dataSeries.type || "stackedBar100" === g[0].dataSeries.type ? g[0].dataSeries.axisX.convertValueToPixel(g[0].dataPoint.x) : f : g[0].dataSeries.axisY.convertValueToPixel(g[0].dataPoint.y);
	                        f = -f + 10;
	                        0 < f + this.container.clientHeight + 5 && (f -= f + this.container.clientHeight + 5 - 0);
	                        this.fixMozTransitionDelay(a, f);
	                        !this.animationEnabled || b ? this.disableAnimation() : (this.enableAnimation(), this.container.style.MozTransition = this.mozContainerTransition);
	                        this.container.style.left = a + "px";
	                        this.container.style.bottom = f + "px"
	                    } else this.hide(!1)
	            }
	        };
	        Y.prototype.highlightObjects = function(a) {
	            var f = this.chart.overlaidCanvasCtx;
	            this.chart.resetOverlayedCanvas();
	            f.clearRect(0, 0, this.chart.width, this.chart.height);
	            f.save();
	            var b = this.chart.plotArea,
	                c = 0;
	            f.beginPath();
	            f.rect(b.x1, b.y1, b.x2 - b.x1, b.y2 - b.y1);
	            f.clip();
	            for (b = 0; b < a.length; b++) {
	                var e = a[b];
	                if ((e = this.chart._eventManager.objectMap[e.dataSeries.dataPointIds[e.index]]) && e.objectType && "dataPoint" === e.objectType) {
	                    var c = this.chart.data[e.dataSeriesIndex],
	                        g = c.dataPoints[e.dataPointIndex],
	                        h = e.dataPointIndex;
	                    !1 === g.highlightEnabled || !0 !== c.highlightEnabled && !0 !== g.highlightEnabled || ("line" === c.type || "stepLine" === c.type || "spline" === c.type || "scatter" === c.type || "area" === c.type || "stepArea" === c.type || "splineArea" === c.type || "stackedArea" === c.type || "stackedArea100" === c.type || "rangeArea" === c.type || "rangeSplineArea" === c.type ? (g = c.getMarkerProperties(h, e.x1, e.y1, this.chart.overlaidCanvasCtx), g.size = Math.max(1.5 * g.size << 0, 10), g.borderColor = g.borderColor || "#FFFFFF", g.borderThickness = g.borderThickness || Math.ceil(0.1 *
	                            g.size), ja.drawMarkers([g]), "undefined" !== typeof e.y2 && (g = c.getMarkerProperties(h, e.x1, e.y2, this.chart.overlaidCanvasCtx), g.size = Math.max(1.5 * g.size << 0, 10), g.borderColor = g.borderColor || "#FFFFFF", g.borderThickness = g.borderThickness || Math.ceil(0.1 * g.size), ja.drawMarkers([g]))) : "bubble" === c.type ? (g = c.getMarkerProperties(h, e.x1, e.y1, this.chart.overlaidCanvasCtx), g.size = e.size, g.color = "white", g.borderColor = "white", f.globalAlpha = 0.3, ja.drawMarkers([g]), f.globalAlpha = 1) : "column" === c.type || "stackedColumn" ===
	                        c.type || "stackedColumn100" === c.type || "bar" === c.type || "rangeBar" === c.type || "stackedBar" === c.type || "stackedBar100" === c.type || "rangeColumn" === c.type || "waterfall" === c.type ? V(f, e.x1, e.y1, e.x2, e.y2, "white", 0, null, !1, !1, !1, !1, 0.3) : "pie" === c.type || "doughnut" === c.type ? ra(f, e.center, e.radius, "white", c.type, e.startAngle, e.endAngle, 0.3, e.percentInnerRadius) : "funnel" === c.type || "pyramid" === c.type ? sa(f, e.funnelSection, 0.3, "white") : "candlestick" === c.type ? (f.globalAlpha = 1, f.strokeStyle = e.color, f.lineWidth = 2 * e.borderThickness,
	                            c = 0 === f.lineWidth % 2 ? 0 : 0.5, f.beginPath(), f.moveTo(e.x3 - c, Math.min(e.y2, e.y3)), f.lineTo(e.x3 - c, Math.min(e.y1, e.y4)), f.stroke(), f.beginPath(), f.moveTo(e.x3 - c, Math.max(e.y1, e.y4)), f.lineTo(e.x3 - c, Math.max(e.y2, e.y3)), f.stroke(), V(f, e.x1, Math.min(e.y1, e.y4), e.x2, Math.max(e.y1, e.y4), "transparent", 2 * e.borderThickness, e.color, !1, !1, !1, !1), f.globalAlpha = 1) : "ohlc" === c.type ? (f.globalAlpha = 1, f.strokeStyle = e.color, f.lineWidth = 2 * e.borderThickness, c = 0 === f.lineWidth % 2 ? 0 : 0.5, f.beginPath(), f.moveTo(e.x3 - c, e.y2), f.lineTo(e.x3 -
	                            c, e.y3), f.stroke(), f.beginPath(), f.moveTo(e.x3, e.y1), f.lineTo(e.x1, e.y1), f.stroke(), f.beginPath(), f.moveTo(e.x3, e.y4), f.lineTo(e.x2, e.y4), f.stroke(), f.globalAlpha = 1) : "boxAndWhisker" === c.type ? (f.save(), f.globalAlpha = 1, f.strokeStyle = e.stemColor, f.lineWidth = 2 * e.stemThickness, 0 < e.stemThickness && (f.beginPath(), f.moveTo(e.x3, e.y2 + e.borderThickness / 2), f.lineTo(e.x3, e.y1 + e.whiskerThickness / 2), f.stroke(), f.beginPath(), f.moveTo(e.x3, e.y4 - e.whiskerThickness / 2), f.lineTo(e.x3, e.y3 - e.borderThickness / 2), f.stroke()),
	                            f.beginPath(), V(f, e.x1 - e.borderThickness / 2, Math.max(e.y2 + e.borderThickness / 2, e.y3 + e.borderThickness / 2), e.x2 + e.borderThickness / 2, Math.min(e.y2 - e.borderThickness / 2, e.y3 - e.borderThickness / 2), "transparent", e.borderThickness, e.color, !1, !1, !1, !1), f.globalAlpha = 1, f.strokeStyle = e.whiskerColor, f.lineWidth = 2 * e.whiskerThickness, 0 < e.whiskerThickness && (f.beginPath(), f.moveTo(Math.floor(e.x3 - e.whiskerLength / 2), e.y4), f.lineTo(Math.ceil(e.x3 + e.whiskerLength / 2), e.y4), f.stroke(), f.beginPath(), f.moveTo(Math.floor(e.x3 -
	                                e.whiskerLength / 2), e.y1), f.lineTo(Math.ceil(e.x3 + e.whiskerLength / 2), e.y1), f.stroke()), f.globalAlpha = 1, f.strokeStyle = e.lineColor, f.lineWidth = 2 * e.lineThickness, 0 < e.lineThickness && (f.beginPath(), f.moveTo(e.x1, e.y5), f.lineTo(e.x2, e.y5), f.stroke()), f.restore(), f.globalAlpha = 1) : "error" === c.type && z(f, e.x1, e.y1, e.x2, e.y2, "white", e.whiskerProperties, e.stemProperties, e.isXYSwapped, 0.3))
	                }
	            }
	            f.restore();
	            f.globalAlpha = 1;
	            f.beginPath()
	        };
	        Y.prototype.getToolTipInnerHTML = function(a) {
	            a = a.entries;
	            for (var f = null, b = null,
	                    c = null, e = 0, g = "", h = !0, l = 0; l < a.length; l++)
	                if (a[l].dataSeries.toolTipContent || a[l].dataPoint.toolTipContent) {
	                    h = !1;
	                    break
	                }
	            if (h && (this.content && "function" === typeof this.content || this.contentFormatter)) a = {
	                chart: this.chart,
	                toolTip: this.options,
	                entries: a
	            }, f = this.contentFormatter ? this.contentFormatter(a) : this.content(a);
	            else if (this.shared && "none" !== this.chart.plotInfo.axisPlacement) {
	                for (var m = null, k = "", l = 0; l < a.length; l++) b = a[l].dataSeries, c = a[l].dataPoint, e = a[l].index, g = "", 0 === l && (h && !this.content) && (this.chart.axisX &&
	                    0 < this.chart.axisX.length ? k += "undefined" !== typeof this.chart.axisX[0].labels[c.x] ? this.chart.axisX[0].labels[c.x] : "{x}" : this.chart.axisX2 && 0 < this.chart.axisX2.length && (k += "undefined" !== typeof this.chart.axisX2[0].labels[c.x] ? this.chart.axisX2[0].labels[c.x] : "{x}"), k += "</br>", k = this.chart.replaceKeywordsWithValue(k, c, b, e)), null === c.toolTipContent || "undefined" === typeof c.toolTipContent && null === b.options.toolTipContent || ("line" === b.type || "stepLine" === b.type || "spline" === b.type || "area" === b.type || "stepArea" ===
	                    b.type || "splineArea" === b.type || "column" === b.type || "bar" === b.type || "scatter" === b.type || "stackedColumn" === b.type || "stackedColumn100" === b.type || "stackedBar" === b.type || "stackedBar100" === b.type || "stackedArea" === b.type || "stackedArea100" === b.type || "waterfall" === b.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (g += m != b.axisXIndex ? b.axisX.title ? b.axisX.title + "<br/>" : "X:{axisXIndex}<br/>" : ""), g += c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && "function" !== typeof this.content ?
	                        this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>{name}:</span>&nbsp;&nbsp;{y}", m = b.axisXIndex) : "bubble" === b.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (g += m != b.axisXIndex ? b.axisX.title ? b.axisX.title + "<br/>" : "X:{axisXIndex}<br/>" : ""), g += c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && "function" !== typeof this.content ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>{name}:</span>&nbsp;&nbsp;{y}, &nbsp;&nbsp;{z}") :
	                    "rangeColumn" === b.type || "rangeBar" === b.type || "rangeArea" === b.type || "rangeSplineArea" === b.type || "error" === b.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (g += m != b.axisXIndex ? b.axisX.title ? b.axisX.title + "<br/>" : "X:{axisXIndex}<br/>" : ""), g += c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && "function" !== typeof this.content ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>{name}:</span>&nbsp;&nbsp;{y[0]},&nbsp;{y[1]}") : "candlestick" ===
	                    b.type || "ohlc" === b.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (g += m != b.axisXIndex ? b.axisX.title ? b.axisX.title + "<br/>" : "X:{axisXIndex}<br/>" : ""), g += c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && "function" !== typeof this.content ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>{name}:</span><br/>Open: &nbsp;&nbsp;{y[0]}<br/>High: &nbsp;&nbsp;&nbsp;{y[1]}<br/>Low:&nbsp;&nbsp;&nbsp;{y[2]}<br/>Close: &nbsp;&nbsp;{y[3]}") : "boxAndWhisker" ===
	                    b.type && (this.chart.axisX && 1 < this.chart.axisX.length && (g += m != b.axisXIndex ? b.axisX.title ? b.axisX.title + "<br/>" : "X:{axisXIndex}<br/>" : ""), g += c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && "function" !== typeof this.content ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>{name}:</span><br/>Minimum: &nbsp;&nbsp;{y[0]}<br/>Q1: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[1]}<br/>Q2: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[4]}<br/>Q3: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Maximum: &nbsp;{y[3]}"),
	                    null === f && (f = ""), !0 === this.reversed ? (f = this.chart.replaceKeywordsWithValue(g, c, b, e) + f, l < a.length - 1 && (f = "</br>" + f)) : (f += this.chart.replaceKeywordsWithValue(g, c, b, e), l < a.length - 1 && (f += "</br>")));
	                null !== f && (f = k + f)
	            } else {
	                b = a[0].dataSeries;
	                c = a[0].dataPoint;
	                e = a[0].index;
	                if (null === c.toolTipContent || "undefined" === typeof c.toolTipContent && null === b.options.toolTipContent) return null;
	                "line" === b.type || "stepLine" === b.type || "spline" === b.type || "area" === b.type || "stepArea" === b.type || "splineArea" === b.type || "column" ===
	                    b.type || "bar" === b.type || "scatter" === b.type || "stackedColumn" === b.type || "stackedColumn100" === b.type || "stackedBar" === b.type || "stackedBar100" === b.type || "stackedArea" === b.type || "stackedArea100" === b.type || "waterfall" === b.type ? g = c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && "function" !== typeof this.content ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>" + (c.label ? "{label}" : "{x}") + ":</span>&nbsp;&nbsp;{y}" : "bubble" === b.type ? g = c.toolTipContent ?
	                    c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && "function" !== typeof this.content ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>" + (c.label ? "{label}" : "{x}") + ":</span>&nbsp;&nbsp;{y}, &nbsp;&nbsp;{z}" : "pie" === b.type || "doughnut" === b.type || "funnel" === b.type || "pyramid" === b.type ? g = c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && "function" !== typeof this.content ? this.content : "<span style='\"" + (this.options.fontColor ? "" :
	                        "'color:{color};'") + "\"'>" + (c.name ? "{name}:</span>&nbsp;&nbsp;" : c.label ? "{label}:</span>&nbsp;&nbsp;" : "</span>") + "{y}" : "rangeColumn" === b.type || "rangeBar" === b.type || "rangeArea" === b.type || "rangeSplineArea" === b.type || "error" === b.type ? g = c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && "function" !== typeof this.content ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>" + (c.label ? "{label}" : "{x}") + " :</span>&nbsp;&nbsp;{y[0]}, &nbsp;{y[1]}" :
	                    "candlestick" === b.type || "ohlc" === b.type ? g = c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent : this.content && "function" !== typeof this.content ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>" + (c.label ? "{label}" : "{x}") + "</span><br/>Open: &nbsp;&nbsp;{y[0]}<br/>High: &nbsp;&nbsp;&nbsp;{y[1]}<br/>Low: &nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Close: &nbsp;&nbsp;{y[3]}" : "boxAndWhisker" === b.type && (g = c.toolTipContent ? c.toolTipContent : b.toolTipContent ? b.toolTipContent :
	                        this.content && "function" !== typeof this.content ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>" + (c.label ? "{label}" : "{x}") + "</span><br/>Minimum: &nbsp;&nbsp;{y[0]}<br/>Q1: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[1]}<br/>Q2: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[4]}<br/>Q3: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Maximum: &nbsp;{y[3]}");
	                null === f && (f = "");
	                f += this.chart.replaceKeywordsWithValue(g, c, b, e)
	            }
	            return f
	        };
	        Y.prototype.enableAnimation = function() {
	            if (!this.container.style.WebkitTransition) {
	                var a = this.getContainerTransition(this.containerTransitionDuration);
	                this.container.style.WebkitTransition = a;
	                this.container.style.MsTransition = a;
	                this.container.style.transition = a;
	                this.container.style.MozTransition = this.mozContainerTransition
	            }
	        };
	        Y.prototype.disableAnimation = function() {
	            this.container.style.WebkitTransition && (this.container.style.WebkitTransition =
	                "", this.container.style.MozTransition = "", this.container.style.MsTransition = "", this.container.style.transition = "")
	        };
	        Y.prototype.hide = function(a) {
	            this.container && (this.container.style.display = "none", this.currentSeriesIndex = -1, this._prevY = this._prevX = NaN, ("undefined" === typeof a || a) && this.chart.resetOverlayedCanvas())
	        };
	        Y.prototype.show = function(a, f, b) {
	            this._updateToolTip(a, f, "undefined" === typeof b ? !1 : b)
	        };
	        Y.prototype.fixMozTransitionDelay = function(a, f) {
	            if (20 < this.chart._eventManager.lastObjectId) this.mozContainerTransition =
	                this.getContainerTransition(0);
	            else {
	                var b = parseFloat(this.container.style.left),
	                    b = isNaN(b) ? 0 : b,
	                    c = parseFloat(this.container.style.bottom),
	                    c = isNaN(c) ? 0 : c;
	                10 < Math.sqrt(Math.pow(b - a, 2) + Math.pow(c - f, 2)) ? this.mozContainerTransition = this.getContainerTransition(0.1) : this.mozContainerTransition = this.getContainerTransition(0)
	            }
	        };
	        Y.prototype.getContainerTransition = function(a) {
	            return "left " + a + "s ease-out 0s, bottom " + a + "s ease-out 0s"
	        };
	        fa.prototype.reset = function() {
	            this.lastObjectId = 0;
	            this.objectMap = [];
	            this.rectangularRegionEventSubscriptions = [];
	            this.previousDataPointEventObject = null;
	            this.eventObjects = [];
	            v && (this.ghostCtx.clearRect(0, 0, this.chart.width, this.chart.height), this.ghostCtx.beginPath())
	        };
	        fa.prototype.getNewObjectTrackingId = function() {
	            return ++this.lastObjectId
	        };
	        fa.prototype.mouseEventHandler = function(a) {
	            if ("mousemove" === a.type || "click" === a.type) {
	                var f = [],
	                    b = Oa(a),
	                    c = null;
	                if ((c = this.chart.getObjectAtXY(b.x, b.y, !1)) && "undefined" !== typeof this.objectMap[c])
	                    if (c = this.objectMap[c], "dataPoint" === c.objectType) {
	                        var e = this.chart.data[c.dataSeriesIndex],
	                            g = e.dataPoints[c.dataPointIndex],
	                            h = c.dataPointIndex;
	                        c.eventParameter = {
	                            x: b.x,
	                            y: b.y,
	                            dataPoint: g,
	                            dataSeries: e.options,
	                            dataPointIndex: h,
	                            dataSeriesIndex: e.index,
	                            chart: this.chart
	                        };
	                        c.eventContext = {
	                            context: g,
	                            userContext: g,
	                            mouseover: "mouseover",
	                            mousemove: "mousemove",
	                            mouseout: "mouseout",
	                            click: "click"
	                        };
	                        f.push(c);
	                        c = this.objectMap[e.id];
	                        c.eventParameter = {
	                            x: b.x,
	                            y: b.y,
	                            dataPoint: g,
	                            dataSeries: e.options,
	                            dataPointIndex: h,
	                            dataSeriesIndex: e.index,
	                            chart: this.chart
	                        };
	                        c.eventContext = {
	                            context: e,
	                            userContext: e.options,
	                            mouseover: "mouseover",
	                            mousemove: "mousemove",
	                            mouseout: "mouseout",
	                            click: "click"
	                        };
	                        f.push(this.objectMap[e.id])
	                    } else "legendItem" === c.objectType && (e = this.chart.data[c.dataSeriesIndex], g = null !== c.dataPointIndex ? e.dataPoints[c.dataPointIndex] : null, c.eventParameter = {
	                        x: b.x,
	                        y: b.y,
	                        dataSeries: e.options,
	                        dataPoint: g,
	                        dataPointIndex: c.dataPointIndex,
	                        dataSeriesIndex: c.dataSeriesIndex,
	                        chart: this.chart
	                    }, c.eventContext = {
	                        context: this.chart.legend,
	                        userContext: this.chart.legend.options,
	                        mouseover: "itemmouseover",
	                        mousemove: "itemmousemove",
	                        mouseout: "itemmouseout",
	                        click: "itemclick"
	                    }, f.push(c));
	                e = [];
	                for (b = 0; b < this.mouseoveredObjectMaps.length; b++) {
	                    g = !0;
	                    for (c = 0; c < f.length; c++)
	                        if (f[c].id === this.mouseoveredObjectMaps[b].id) {
	                            g = !1;
	                            break
	                        }
	                    g ? this.fireEvent(this.mouseoveredObjectMaps[b], "mouseout", a) : e.push(this.mouseoveredObjectMaps[b])
	                }
	                this.mouseoveredObjectMaps = e;
	                for (b = 0; b < f.length; b++) {
	                    e = !1;
	                    for (c = 0; c < this.mouseoveredObjectMaps.length; c++)
	                        if (f[b].id === this.mouseoveredObjectMaps[c].id) {
	                            e = !0;
	                            break
	                        }
	                    e || (this.fireEvent(f[b], "mouseover", a), this.mouseoveredObjectMaps.push(f[b]));
	                    "click" === a.type ? this.fireEvent(f[b], "click", a) : "mousemove" === a.type && this.fireEvent(f[b], "mousemove", a)
	                }
	            }
	        };
	        fa.prototype.fireEvent = function(a, f, b) {
	            if (a && f) {
	                var c = a.eventParameter,
	                    e = a.eventContext,
	                    g = a.eventContext.userContext;
	                g && (e && g[e[f]]) && g[e[f]].call(g, c);
	                "mouseout" !== f ? g.cursor && g.cursor !== b.target.style.cursor && (b.target.style.cursor = g.cursor) : (b.target.style.cursor = this.chart._defaultCursor, delete a.eventParameter, delete a.eventContext);
	                "click" === f && ("dataPoint" === a.objectType && this.chart.pieDoughnutClickHandler) &&
	                    this.chart.pieDoughnutClickHandler.call(this.chart.data[a.dataSeriesIndex], c);
	                "click" === f && ("dataPoint" === a.objectType && this.chart.funnelPyramidClickHandler) && this.chart.funnelPyramidClickHandler.call(this.chart.data[a.dataSeriesIndex], c)
	            }
	        };
	        ka.prototype.animate = function(a, f, b, c, e) {
	            var g = this;
	            this.chart.isAnimating = !0;
	            e = e || H.easing.linear;
	            b && this.animations.push({
	                startTime: (new Date).getTime() + (a ? a : 0),
	                duration: f,
	                animationCallback: b,
	                onComplete: c
	            });
	            for (a = []; 0 < this.animations.length;)
	                if (f = this.animations.shift(),
	                    b = (new Date).getTime(), c = 0, f.startTime <= b && (c = e(Math.min(b - f.startTime, f.duration), 0, 1, f.duration), c = Math.min(c, 1), isNaN(c) || !isFinite(c)) && (c = 1), 1 > c && a.push(f), f.animationCallback(c), 1 <= c && f.onComplete) f.onComplete();
	            this.animations = a;
	            0 < this.animations.length ? this.animationRequestId = this.chart.requestAnimFrame.call(window, function() {
	                g.animate.call(g)
	            }) : this.chart.isAnimating = !1
	        };
	        ka.prototype.cancelAllAnimations = function() {
	            this.animations = [];
	            this.animationRequestId && this.chart.cancelRequestAnimFrame.call(window,
	                this.animationRequestId);
	            this.animationRequestId = null;
	            this.chart.isAnimating = !1
	        };
	        var H = {
	                yScaleAnimation: function(a, f) {
	                    if (0 !== a) {
	                        var b = f.dest,
	                            c = f.source.canvas,
	                            e = f.animationBase;
	                        b.drawImage(c, 0, 0, c.width, c.height, 0, e - e * a, b.canvas.width / ha, a * b.canvas.height / ha)
	                    }
	                },
	                xScaleAnimation: function(a, f) {
	                    if (0 !== a) {
	                        var b = f.dest,
	                            c = f.source.canvas,
	                            e = f.animationBase;
	                        b.drawImage(c, 0, 0, c.width, c.height, e - e * a, 0, a * b.canvas.width / ha, b.canvas.height / ha)
	                    }
	                },
	                xClipAnimation: function(a, f) {
	                    if (0 !== a) {
	                        var b = f.dest,
	                            c = f.source.canvas;
	                        b.save();
	                        0 < a && b.drawImage(c, 0, 0, c.width * a, c.height, 0, 0, c.width * a / ha, c.height / ha);
	                        b.restore()
	                    }
	                },
	                fadeInAnimation: function(a, f) {
	                    if (0 !== a) {
	                        var b = f.dest,
	                            c = f.source.canvas;
	                        b.save();
	                        b.globalAlpha = a;
	                        b.drawImage(c, 0, 0, c.width, c.height, 0, 0, b.canvas.width / ha, b.canvas.height / ha);
	                        b.restore()
	                    }
	                },
	                easing: {
	                    linear: function(a, f, b, c) {
	                        return b * a / c + f
	                    },
	                    easeOutQuad: function(a, f, b, c) {
	                        return -b * (a /= c) * (a - 2) + f
	                    },
	                    easeOutQuart: function(a, f, b, c) {
	                        return -b * ((a = a / c - 1) * a * a * a - 1) + f
	                    },
	                    easeInQuad: function(a, f, b, c) {
	                        return b * (a /= c) * a + f
	                    },
	                    easeInQuart: function(a,
	                        f, b, c) {
	                        return b * (a /= c) * a * a * a + f
	                    }
	                }
	            },
	            ja = {
	                drawMarker: function(a, f, b, c, e, g, h, l) {
	                    if (b) {
	                        var m = 1;
	                        b.fillStyle = g ? g : "#000000";
	                        b.strokeStyle = h ? h : "#000000";
	                        b.lineWidth = l ? l : 0;
	                        "circle" === c ? (b.moveTo(a, f), b.beginPath(), b.arc(a, f, e / 2, 0, 2 * Math.PI, !1), g && b.fill(), l && (h ? b.stroke() : (m = b.globalAlpha, b.globalAlpha = 0.15, b.strokeStyle = "black", b.stroke(), b.globalAlpha = m))) : "square" === c ? (b.beginPath(), b.rect(a - e / 2, f - e / 2, e, e), g && b.fill(), l && (h ? b.stroke() : (m = b.globalAlpha, b.globalAlpha = 0.15, b.strokeStyle = "black", b.stroke(), b.globalAlpha =
	                            m))) : "triangle" === c ? (b.beginPath(), b.moveTo(a - e / 2, f + e / 2), b.lineTo(a + e / 2, f + e / 2), b.lineTo(a, f - e / 2), b.closePath(), g && b.fill(), l && (h ? b.stroke() : (m = b.globalAlpha, b.globalAlpha = 0.15, b.strokeStyle = "black", b.stroke(), b.globalAlpha = m)), b.beginPath()) : "cross" === c && (b.strokeStyle = g, b.lineWidth = e / 4, b.beginPath(), b.moveTo(a - e / 2, f - e / 2), b.lineTo(a + e / 2, f + e / 2), b.stroke(), b.moveTo(a + e / 2, f - e / 2), b.lineTo(a - e / 2, f + e / 2), b.stroke())
	                    }
	                },
	                drawMarkers: function(a) {
	                    for (var f = 0; f < a.length; f++) {
	                        var b = a[f];
	                        ja.drawMarker(b.x, b.y, b.ctx,
	                            b.type, b.size, b.color, b.borderColor, b.borderThickness)
	                    }
	                }
	            };
	        return q
	    }();
	    x.Chart.version = "v2.0 GA"
	})();

	/*
	  excanvas is used to support IE678 which do not implement HTML5 Canvas Element. You can safely remove the following excanvas code if you don't need to support older browsers.

	  Copyright 2006 Google Inc. https://code.google.com/p/explorercanvas/
	  Licensed under the Apache License, Version 2.0
	*/
	document.createElement("canvas").getContext || function() {
	    function V() {
	        return this.context_ || (this.context_ = new C(this))
	    }

	    function W(a, b, c) {
	        var g = M.call(arguments, 2);
	        return function() {
	            return a.apply(b, g.concat(M.call(arguments)))
	        }
	    }

	    function N(a) {
	        return String(a).replace(/&/g, "&amp;").replace(/"/g, "&quot;")
	    }

	    function O(a) {
	        a.namespaces.g_vml_ || a.namespaces.add("g_vml_", "urn:schemas-microsoft-com:vml", "#default#VML");
	        a.namespaces.g_o_ || a.namespaces.add("g_o_", "urn:schemas-microsoft-com:office:office", "#default#VML");
	        a.styleSheets.ex_canvas_ || (a = a.createStyleSheet(), a.owningElement.id = "ex_canvas_", a.cssText = "canvas{display:inline-block;overflow:hidden;text-align:left;width:300px;height:150px}")
	    }

	    function X(a) {
	        var b = a.srcElement;
	        switch (a.propertyName) {
	            case "width":
	                b.getContext().clearRect();
	                b.style.width = b.attributes.width.nodeValue + "px";
	                b.firstChild.style.width = b.clientWidth + "px";
	                break;
	            case "height":
	                b.getContext().clearRect(), b.style.height = b.attributes.height.nodeValue + "px", b.firstChild.style.height = b.clientHeight +
	                    "px"
	        }
	    }

	    function Y(a) {
	        a = a.srcElement;
	        a.firstChild && (a.firstChild.style.width = a.clientWidth + "px", a.firstChild.style.height = a.clientHeight + "px")
	    }

	    function D() {
	        return [
	            [1, 0, 0],
	            [0, 1, 0],
	            [0, 0, 1]
	        ]
	    }

	    function t(a, b) {
	        for (var c = D(), g = 0; 3 > g; g++)
	            for (var e = 0; 3 > e; e++) {
	                for (var f = 0, d = 0; 3 > d; d++) f += a[g][d] * b[d][e];
	                c[g][e] = f
	            }
	        return c
	    }

	    function P(a, b) {
	        b.fillStyle = a.fillStyle;
	        b.lineCap = a.lineCap;
	        b.lineJoin = a.lineJoin;
	        b.lineWidth = a.lineWidth;
	        b.miterLimit = a.miterLimit;
	        b.shadowBlur = a.shadowBlur;
	        b.shadowColor = a.shadowColor;
	        b.shadowOffsetX =
	            a.shadowOffsetX;
	        b.shadowOffsetY = a.shadowOffsetY;
	        b.strokeStyle = a.strokeStyle;
	        b.globalAlpha = a.globalAlpha;
	        b.font = a.font;
	        b.textAlign = a.textAlign;
	        b.textBaseline = a.textBaseline;
	        b.arcScaleX_ = a.arcScaleX_;
	        b.arcScaleY_ = a.arcScaleY_;
	        b.lineScale_ = a.lineScale_
	    }

	    function Q(a) {
	        var b = a.indexOf("(", 3),
	            c = a.indexOf(")", b + 1),
	            b = a.substring(b + 1, c).split(",");
	        if (4 != b.length || "a" != a.charAt(3)) b[3] = 1;
	        return b
	    }

	    function E(a, b, c) {
	        return Math.min(c, Math.max(b, a))
	    }

	    function F(a, b, c) {
	        0 > c && c++;
	        1 < c && c--;
	        return 1 > 6 * c ? a + 6 * (b - a) * c :
	            1 > 2 * c ? b : 2 > 3 * c ? a + 6 * (b - a) * (2 / 3 - c) : a
	    }

	    function G(a) {
	        if (a in H) return H[a];
	        var b, c = 1;
	        a = String(a);
	        if ("#" == a.charAt(0)) b = a;
	        else if (/^rgb/.test(a)) {
	            c = Q(a);
	            b = "#";
	            for (var g, e = 0; 3 > e; e++) g = -1 != c[e].indexOf("%") ? Math.floor(255 * (parseFloat(c[e]) / 100)) : +c[e], b += v[E(g, 0, 255)];
	            c = +c[3]
	        } else if (/^hsl/.test(a)) {
	            e = c = Q(a);
	            b = parseFloat(e[0]) / 360 % 360;
	            0 > b && b++;
	            g = E(parseFloat(e[1]) / 100, 0, 1);
	            e = E(parseFloat(e[2]) / 100, 0, 1);
	            if (0 == g) g = e = b = e;
	            else {
	                var f = 0.5 > e ? e * (1 + g) : e + g - e * g,
	                    d = 2 * e - f;
	                g = F(d, f, b + 1 / 3);
	                e = F(d, f, b);
	                b = F(d, f, b - 1 / 3)
	            }
	            b = "#" +
	                v[Math.floor(255 * g)] + v[Math.floor(255 * e)] + v[Math.floor(255 * b)];
	            c = c[3]
	        } else b = Z[a] || a;
	        return H[a] = {
	            color: b,
	            alpha: c
	        }
	    }

	    function C(a) {
	        this.m_ = D();
	        this.mStack_ = [];
	        this.aStack_ = [];
	        this.currentPath_ = [];
	        this.fillStyle = this.strokeStyle = "#000";
	        this.lineWidth = 1;
	        this.lineJoin = "miter";
	        this.lineCap = "butt";
	        this.miterLimit = 1 * q;
	        this.globalAlpha = 1;
	        this.font = "10px sans-serif";
	        this.textAlign = "left";
	        this.textBaseline = "alphabetic";
	        this.canvas = a;
	        var b = "width:" + a.clientWidth + "px;height:" + a.clientHeight + "px;overflow:hidden;position:absolute",
	            c = a.ownerDocument.createElement("div");
	        c.style.cssText = b;
	        a.appendChild(c);
	        b = c.cloneNode(!1);
	        b.style.backgroundColor = "red";
	        b.style.filter = "alpha(opacity=0)";
	        a.appendChild(b);
	        this.element_ = c;
	        this.lineScale_ = this.arcScaleY_ = this.arcScaleX_ = 1
	    }

	    function R(a, b, c, g) {
	        a.currentPath_.push({
	            type: "bezierCurveTo",
	            cp1x: b.x,
	            cp1y: b.y,
	            cp2x: c.x,
	            cp2y: c.y,
	            x: g.x,
	            y: g.y
	        });
	        a.currentX_ = g.x;
	        a.currentY_ = g.y
	    }

	    function S(a, b) {
	        var c = G(a.strokeStyle),
	            g = c.color,
	            c = c.alpha * a.globalAlpha,
	            e = a.lineScale_ * a.lineWidth;
	        1 > e && (c *= e);
	        b.push("<g_vml_:stroke",
	            ' opacity="', c, '"', ' joinstyle="', a.lineJoin, '"', ' miterlimit="', a.miterLimit, '"', ' endcap="', $[a.lineCap] || "square", '"', ' weight="', e, 'px"', ' color="', g, '" />')
	    }

	    function T(a, b, c, g) {
	        var e = a.fillStyle,
	            f = a.arcScaleX_,
	            d = a.arcScaleY_,
	            k = g.x - c.x,
	            n = g.y - c.y;
	        if (e instanceof w) {
	            var h = 0,
	                l = g = 0,
	                u = 0,
	                m = 1;
	            if ("gradient" == e.type_) {
	                h = e.x1_ / f;
	                c = e.y1_ / d;
	                var p = s(a, e.x0_ / f, e.y0_ / d),
	                    h = s(a, h, c),
	                    h = 180 * Math.atan2(h.x - p.x, h.y - p.y) / Math.PI;
	                0 > h && (h += 360);
	                1E-6 > h && (h = 0)
	            } else p = s(a, e.x0_, e.y0_), g = (p.x - c.x) / k, l = (p.y - c.y) / n, k /= f * q,
	                n /= d * q, m = x.max(k, n), u = 2 * e.r0_ / m, m = 2 * e.r1_ / m - u;
	            f = e.colors_;
	            f.sort(function(a, b) {
	                return a.offset - b.offset
	            });
	            d = f.length;
	            p = f[0].color;
	            c = f[d - 1].color;
	            k = f[0].alpha * a.globalAlpha;
	            a = f[d - 1].alpha * a.globalAlpha;
	            for (var n = [], r = 0; r < d; r++) {
	                var t = f[r];
	                n.push(t.offset * m + u + " " + t.color)
	            }
	            b.push('<g_vml_:fill type="', e.type_, '"', ' method="none" focus="100%"', ' color="', p, '"', ' color2="', c, '"', ' colors="', n.join(","), '"', ' opacity="', a, '"', ' g_o_:opacity2="', k, '"', ' angle="', h, '"', ' focusposition="', g, ",", l, '" />')
	        } else e instanceof
	        I ? k && n && b.push("<g_vml_:fill", ' position="', -c.x / k * f * f, ",", -c.y / n * d * d, '"', ' type="tile"', ' src="', e.src_, '" />') : (e = G(a.fillStyle), b.push('<g_vml_:fill color="', e.color, '" opacity="', e.alpha * a.globalAlpha, '" />'))
	    }

	    function s(a, b, c) {
	        a = a.m_;
	        return {
	            x: q * (b * a[0][0] + c * a[1][0] + a[2][0]) - r,
	            y: q * (b * a[0][1] + c * a[1][1] + a[2][1]) - r
	        }
	    }

	    function z(a, b, c) {
	        isFinite(b[0][0]) && (isFinite(b[0][1]) && isFinite(b[1][0]) && isFinite(b[1][1]) && isFinite(b[2][0]) && isFinite(b[2][1])) && (a.m_ = b, c && (a.lineScale_ = aa(ba(b[0][0] * b[1][1] - b[0][1] *
	            b[1][0]))))
	    }

	    function w(a) {
	        this.type_ = a;
	        this.r1_ = this.y1_ = this.x1_ = this.r0_ = this.y0_ = this.x0_ = 0;
	        this.colors_ = []
	    }

	    function I(a, b) {
	        if (!a || 1 != a.nodeType || "IMG" != a.tagName) throw new A("TYPE_MISMATCH_ERR");
	        if ("complete" != a.readyState) throw new A("INVALID_STATE_ERR");
	        switch (b) {
	            case "repeat":
	            case null:
	            case "":
	                this.repetition_ = "repeat";
	                break;
	            case "repeat-x":
	            case "repeat-y":
	            case "no-repeat":
	                this.repetition_ = b;
	                break;
	            default:
	                throw new A("SYNTAX_ERR");
	        }
	        this.src_ = a.src;
	        this.width_ = a.width;
	        this.height_ = a.height
	    }

	    function A(a) {
	        this.code = this[a];
	        this.message = a + ": DOM Exception " + this.code
	    }
	    var x = Math,
	        k = x.round,
	        J = x.sin,
	        K = x.cos,
	        ba = x.abs,
	        aa = x.sqrt,
	        q = 10,
	        r = q / 2;
	    navigator.userAgent.match(/MSIE ([\d.]+)?/);
	    var M = Array.prototype.slice;
	    O(document);
	    var U = {
	        init: function(a) {
	            a = a || document;
	            a.createElement("canvas");
	            a.attachEvent("onreadystatechange", W(this.init_, this, a))
	        },
	        init_: function(a) {
	            a = a.getElementsByTagName("canvas");
	            for (var b = 0; b < a.length; b++) this.initElement(a[b])
	        },
	        initElement: function(a) {
	            if (!a.getContext) {
	                a.getContext =
	                    V;
	                O(a.ownerDocument);
	                a.innerHTML = "";
	                a.attachEvent("onpropertychange", X);
	                a.attachEvent("onresize", Y);
	                var b = a.attributes;
	                b.width && b.width.specified ? a.style.width = b.width.nodeValue + "px" : a.width = a.clientWidth;
	                b.height && b.height.specified ? a.style.height = b.height.nodeValue + "px" : a.height = a.clientHeight
	            }
	            return a
	        }
	    };
	    U.init();
	    for (var v = [], d = 0; 16 > d; d++)
	        for (var B = 0; 16 > B; B++) v[16 * d + B] = d.toString(16) + B.toString(16);
	    var Z = {
	            aliceblue: "#F0F8FF",
	            antiquewhite: "#FAEBD7",
	            aquamarine: "#7FFFD4",
	            azure: "#F0FFFF",
	            beige: "#F5F5DC",
	            bisque: "#FFE4C4",
	            black: "#000000",
	            blanchedalmond: "#FFEBCD",
	            blueviolet: "#8A2BE2",
	            brown: "#A52A2A",
	            burlywood: "#DEB887",
	            cadetblue: "#5F9EA0",
	            chartreuse: "#7FFF00",
	            chocolate: "#D2691E",
	            coral: "#FF7F50",
	            cornflowerblue: "#6495ED",
	            cornsilk: "#FFF8DC",
	            crimson: "#DC143C",
	            cyan: "#00FFFF",
	            darkblue: "#00008B",
	            darkcyan: "#008B8B",
	            darkgoldenrod: "#B8860B",
	            darkgray: "#A9A9A9",
	            darkgreen: "#006400",
	            darkgrey: "#A9A9A9",
	            darkkhaki: "#BDB76B",
	            darkmagenta: "#8B008B",
	            darkolivegreen: "#556B2F",
	            darkorange: "#FF8C00",
	            darkorchid: "#9932CC",
	            darkred: "#8B0000",
	            darksalmon: "#E9967A",
	            darkseagreen: "#8FBC8F",
	            darkslateblue: "#483D8B",
	            darkslategray: "#2F4F4F",
	            darkslategrey: "#2F4F4F",
	            darkturquoise: "#00CED1",
	            darkviolet: "#9400D3",
	            deeppink: "#FF1493",
	            deepskyblue: "#00BFFF",
	            dimgray: "#696969",
	            dimgrey: "#696969",
	            dodgerblue: "#1E90FF",
	            firebrick: "#B22222",
	            floralwhite: "#FFFAF0",
	            forestgreen: "#228B22",
	            gainsboro: "#DCDCDC",
	            ghostwhite: "#F8F8FF",
	            gold: "#FFD700",
	            goldenrod: "#DAA520",
	            grey: "#808080",
	            greenyellow: "#ADFF2F",
	            honeydew: "#F0FFF0",
	            hotpink: "#FF69B4",
	            indianred: "#CD5C5C",
	            indigo: "#4B0082",
	            ivory: "#FFFFF0",
	            khaki: "#F0E68C",
	            lavender: "#E6E6FA",
	            lavenderblush: "#FFF0F5",
	            lawngreen: "#7CFC00",
	            lemonchiffon: "#FFFACD",
	            lightblue: "#ADD8E6",
	            lightcoral: "#F08080",
	            lightcyan: "#E0FFFF",
	            lightgoldenrodyellow: "#FAFAD2",
	            lightgreen: "#90EE90",
	            lightgrey: "#D3D3D3",
	            lightpink: "#FFB6C1",
	            lightsalmon: "#FFA07A",
	            lightseagreen: "#20B2AA",
	            lightskyblue: "#87CEFA",
	            lightslategray: "#778899",
	            lightslategrey: "#778899",
	            lightsteelblue: "#B0C4DE",
	            lightyellow: "#FFFFE0",
	            limegreen: "#32CD32",
	            linen: "#FAF0E6",
	            magenta: "#FF00FF",
	            mediumaquamarine: "#66CDAA",
	            mediumblue: "#0000CD",
	            mediumorchid: "#BA55D3",
	            mediumpurple: "#9370DB",
	            mediumseagreen: "#3CB371",
	            mediumslateblue: "#7B68EE",
	            mediumspringgreen: "#00FA9A",
	            mediumturquoise: "#48D1CC",
	            mediumvioletred: "#C71585",
	            midnightblue: "#191970",
	            mintcream: "#F5FFFA",
	            mistyrose: "#FFE4E1",
	            moccasin: "#FFE4B5",
	            navajowhite: "#FFDEAD",
	            oldlace: "#FDF5E6",
	            olivedrab: "#6B8E23",
	            orange: "#FFA500",
	            orangered: "#FF4500",
	            orchid: "#DA70D6",
	            palegoldenrod: "#EEE8AA",
	            palegreen: "#98FB98",
	            paleturquoise: "#AFEEEE",
	            palevioletred: "#DB7093",
	            papayawhip: "#FFEFD5",
	            peachpuff: "#FFDAB9",
	            peru: "#CD853F",
	            pink: "#FFC0CB",
	            plum: "#DDA0DD",
	            powderblue: "#B0E0E6",
	            rosybrown: "#BC8F8F",
	            royalblue: "#4169E1",
	            saddlebrown: "#8B4513",
	            salmon: "#FA8072",
	            sandybrown: "#F4A460",
	            seagreen: "#2E8B57",
	            seashell: "#FFF5EE",
	            sienna: "#A0522D",
	            skyblue: "#87CEEB",
	            slateblue: "#6A5ACD",
	            slategray: "#708090",
	            slategrey: "#708090",
	            snow: "#FFFAFA",
	            springgreen: "#00FF7F",
	            steelblue: "#4682B4",
	            tan: "#D2B48C",
	            thistle: "#D8BFD8",
	            tomato: "#FF6347",
	            turquoise: "#40E0D0",
	            violet: "#EE82EE",
	            wheat: "#F5DEB3",
	            whitesmoke: "#F5F5F5",
	            yellowgreen: "#9ACD32"
	        },
	        H = {},
	        L = {},
	        $ = {
	            butt: "flat",
	            round: "round"
	        },
	        d = C.prototype;
	    d.clearRect = function() {
	        this.textMeasureEl_ && (this.textMeasureEl_.removeNode(!0), this.textMeasureEl_ = null);
	        this.element_.innerHTML = ""
	    };
	    d.beginPath = function() {
	        this.currentPath_ = []
	    };
	    d.moveTo = function(a, b) {
	        var c = s(this, a, b);
	        this.currentPath_.push({
	            type: "moveTo",
	            x: c.x,
	            y: c.y
	        });
	        this.currentX_ = c.x;
	        this.currentY_ = c.y
	    };
	    d.lineTo = function(a, b) {
	        var c = s(this, a, b);
	        this.currentPath_.push({
	            type: "lineTo",
	            x: c.x,
	            y: c.y
	        });
	        this.currentX_ = c.x;
	        this.currentY_ = c.y
	    };
	    d.bezierCurveTo =
	        function(a, b, c, g, e, f) {
	            e = s(this, e, f);
	            a = s(this, a, b);
	            c = s(this, c, g);
	            R(this, a, c, e)
	        };
	    d.quadraticCurveTo = function(a, b, c, g) {
	        a = s(this, a, b);
	        c = s(this, c, g);
	        g = {
	            x: this.currentX_ + 2 / 3 * (a.x - this.currentX_),
	            y: this.currentY_ + 2 / 3 * (a.y - this.currentY_)
	        };
	        R(this, g, {
	            x: g.x + (c.x - this.currentX_) / 3,
	            y: g.y + (c.y - this.currentY_) / 3
	        }, c)
	    };
	    d.arc = function(a, b, c, g, e, f) {
	        c *= q;
	        var d = f ? "at" : "wa",
	            k = a + K(g) * c - r,
	            n = b + J(g) * c - r;
	        g = a + K(e) * c - r;
	        e = b + J(e) * c - r;
	        k != g || f || (k += 0.125);
	        a = s(this, a, b);
	        k = s(this, k, n);
	        g = s(this, g, e);
	        this.currentPath_.push({
	            type: d,
	            x: a.x,
	            y: a.y,
	            radius: c,
	            xStart: k.x,
	            yStart: k.y,
	            xEnd: g.x,
	            yEnd: g.y
	        })
	    };
	    d.rect = function(a, b, c, g) {
	        this.moveTo(a, b);
	        this.lineTo(a + c, b);
	        this.lineTo(a + c, b + g);
	        this.lineTo(a, b + g);
	        this.closePath()
	    };
	    d.strokeRect = function(a, b, c, g) {
	        var e = this.currentPath_;
	        this.beginPath();
	        this.moveTo(a, b);
	        this.lineTo(a + c, b);
	        this.lineTo(a + c, b + g);
	        this.lineTo(a, b + g);
	        this.closePath();
	        this.stroke();
	        this.currentPath_ = e
	    };
	    d.fillRect = function(a, b, c, g) {
	        var e = this.currentPath_;
	        this.beginPath();
	        this.moveTo(a, b);
	        this.lineTo(a + c, b);
	        this.lineTo(a +
	            c, b + g);
	        this.lineTo(a, b + g);
	        this.closePath();
	        this.fill();
	        this.currentPath_ = e
	    };
	    d.createLinearGradient = function(a, b, c, g) {
	        var e = new w("gradient");
	        e.x0_ = a;
	        e.y0_ = b;
	        e.x1_ = c;
	        e.y1_ = g;
	        return e
	    };
	    d.createRadialGradient = function(a, b, c, g, e, f) {
	        var d = new w("gradientradial");
	        d.x0_ = a;
	        d.y0_ = b;
	        d.r0_ = c;
	        d.x1_ = g;
	        d.y1_ = e;
	        d.r1_ = f;
	        return d
	    };
	    d.drawImage = function(a, b) {
	        var c, g, e, d, r, y, n, h;
	        e = a.runtimeStyle.width;
	        d = a.runtimeStyle.height;
	        a.runtimeStyle.width = "auto";
	        a.runtimeStyle.height = "auto";
	        var l = a.width,
	            u = a.height;
	        a.runtimeStyle.width =
	            e;
	        a.runtimeStyle.height = d;
	        if (3 == arguments.length) c = arguments[1], g = arguments[2], r = y = 0, n = e = l, h = d = u;
	        else if (5 == arguments.length) c = arguments[1], g = arguments[2], e = arguments[3], d = arguments[4], r = y = 0, n = l, h = u;
	        else if (9 == arguments.length) r = arguments[1], y = arguments[2], n = arguments[3], h = arguments[4], c = arguments[5], g = arguments[6], e = arguments[7], d = arguments[8];
	        else throw Error("Invalid number of arguments");
	        var m = s(this, c, g),
	            p = [];
	        p.push(" <g_vml_:group", ' coordsize="', 10 * q, ",", 10 * q, '"', ' coordorigin="0,0"', ' style="width:',
	            10, "px;height:", 10, "px;position:absolute;");
	        if (1 != this.m_[0][0] || this.m_[0][1] || 1 != this.m_[1][1] || this.m_[1][0]) {
	            var t = [];
	            t.push("M11=", this.m_[0][0], ",", "M12=", this.m_[1][0], ",", "M21=", this.m_[0][1], ",", "M22=", this.m_[1][1], ",", "Dx=", k(m.x / q), ",", "Dy=", k(m.y / q), "");
	            var v = s(this, c + e, g),
	                w = s(this, c, g + d);
	            c = s(this, c + e, g + d);
	            m.x = x.max(m.x, v.x, w.x, c.x);
	            m.y = x.max(m.y, v.y, w.y, c.y);
	            p.push("padding:0 ", k(m.x / q), "px ", k(m.y / q), "px 0;filter:progid:DXImageTransform.Microsoft.Matrix(", t.join(""), ", sizingmethod='clip');")
	        } else p.push("top:",
	            k(m.y / q), "px;left:", k(m.x / q), "px;");
	        p.push(' ">', '<g_vml_:image src="', a.src, '"', ' style="width:', q * e, "px;", " height:", q * d, 'px"', ' cropleft="', r / l, '"', ' croptop="', y / u, '"', ' cropright="', (l - r - n) / l, '"', ' cropbottom="', (u - y - h) / u, '"', " />", "</g_vml_:group>");
	        this.element_.insertAdjacentHTML("BeforeEnd", p.join(""))
	    };
	    d.stroke = function(a) {
	        var b = [];
	        b.push("<g_vml_:shape", ' filled="', !!a, '"', ' style="position:absolute;width:', 10, "px;height:", 10, 'px;"', ' coordorigin="0,0"', ' coordsize="', 10 * q, ",", 10 * q, '"',
	            ' stroked="', !a, '"', ' path="');
	        for (var c = {
	                x: null,
	                y: null
	            }, d = {
	                x: null,
	                y: null
	            }, e = 0; e < this.currentPath_.length; e++) {
	            var f = this.currentPath_[e];
	            switch (f.type) {
	                case "moveTo":
	                    b.push(" m ", k(f.x), ",", k(f.y));
	                    break;
	                case "lineTo":
	                    b.push(" l ", k(f.x), ",", k(f.y));
	                    break;
	                case "close":
	                    b.push(" x ");
	                    f = null;
	                    break;
	                case "bezierCurveTo":
	                    b.push(" c ", k(f.cp1x), ",", k(f.cp1y), ",", k(f.cp2x), ",", k(f.cp2y), ",", k(f.x), ",", k(f.y));
	                    break;
	                case "at":
	                case "wa":
	                    b.push(" ", f.type, " ", k(f.x - this.arcScaleX_ * f.radius), ",", k(f.y - this.arcScaleY_ *
	                        f.radius), " ", k(f.x + this.arcScaleX_ * f.radius), ",", k(f.y + this.arcScaleY_ * f.radius), " ", k(f.xStart), ",", k(f.yStart), " ", k(f.xEnd), ",", k(f.yEnd))
	            }
	            if (f) {
	                if (null == c.x || f.x < c.x) c.x = f.x;
	                if (null == d.x || f.x > d.x) d.x = f.x;
	                if (null == c.y || f.y < c.y) c.y = f.y;
	                if (null == d.y || f.y > d.y) d.y = f.y
	            }
	        }
	        b.push(' ">');
	        a ? T(this, b, c, d) : S(this, b);
	        b.push("</g_vml_:shape>");
	        this.element_.insertAdjacentHTML("beforeEnd", b.join(""))
	    };
	    d.fill = function() {
	        this.stroke(!0)
	    };
	    d.closePath = function() {
	        this.currentPath_.push({
	            type: "close"
	        })
	    };
	    d.save = function() {
	        var a = {};
	        P(this, a);
	        this.aStack_.push(a);
	        this.mStack_.push(this.m_);
	        this.m_ = t(D(), this.m_)
	    };
	    d.restore = function() {
	        this.aStack_.length && (P(this.aStack_.pop(), this), this.m_ = this.mStack_.pop())
	    };
	    d.translate = function(a, b) {
	        z(this, t([
	            [1, 0, 0],
	            [0, 1, 0],
	            [a, b, 1]
	        ], this.m_), !1)
	    };
	    d.rotate = function(a) {
	        var b = K(a);
	        a = J(a);
	        z(this, t([
	            [b, a, 0],
	            [-a, b, 0],
	            [0, 0, 1]
	        ], this.m_), !1)
	    };
	    d.scale = function(a, b) {
	        this.arcScaleX_ *= a;
	        this.arcScaleY_ *= b;
	        z(this, t([
	            [a, 0, 0],
	            [0, b, 0],
	            [0, 0, 1]
	        ], this.m_), !0)
	    };
	    d.transform = function(a, b, c, d, e, f) {
	        z(this, t([
	            [a,
	                b, 0
	            ],
	            [c, d, 0],
	            [e, f, 1]
	        ], this.m_), !0)
	    };
	    d.setTransform = function(a, b, c, d, e, f) {
	        z(this, [
	            [a, b, 0],
	            [c, d, 0],
	            [e, f, 1]
	        ], !0)
	    };
	    d.drawText_ = function(a, b, c, d, e) {
	        var f = this.m_;
	        d = 0;
	        var r = 1E3,
	            t = 0,
	            n = [],
	            h;
	        h = this.font;
	        if (L[h]) h = L[h];
	        else {
	            var l = document.createElement("div").style;
	            try {
	                l.font = h
	            } catch (u) {}
	            h = L[h] = {
	                style: l.fontStyle || "normal",
	                variant: l.fontVariant || "normal",
	                weight: l.fontWeight || "normal",
	                size: l.fontSize || 10,
	                family: l.fontFamily || "sans-serif"
	            }
	        }
	        var l = h,
	            m = this.element_;
	        h = {};
	        for (var p in l) h[p] = l[p];
	        p = parseFloat(m.currentStyle.fontSize);
	        m = parseFloat(l.size);
	        "number" == typeof l.size ? h.size = l.size : -1 != l.size.indexOf("px") ? h.size = m : -1 != l.size.indexOf("em") ? h.size = p * m : -1 != l.size.indexOf("%") ? h.size = p / 100 * m : -1 != l.size.indexOf("pt") ? h.size = m / 0.75 : h.size = p;
	        h.size *= 0.981;
	        p = h.style + " " + h.variant + " " + h.weight + " " + h.size + "px " + h.family;
	        m = this.element_.currentStyle;
	        l = this.textAlign.toLowerCase();
	        switch (l) {
	            case "left":
	            case "center":
	            case "right":
	                break;
	            case "end":
	                l = "ltr" == m.direction ? "right" : "left";
	                break;
	            case "start":
	                l = "rtl" == m.direction ? "right" :
	                    "left";
	                break;
	            default:
	                l = "left"
	        }
	        switch (this.textBaseline) {
	            case "hanging":
	            case "top":
	                t = h.size / 1.75;
	                break;
	            case "middle":
	                break;
	            default:
	            case null:
	            case "alphabetic":
	            case "ideographic":
	            case "bottom":
	                t = -h.size / 2.25
	        }
	        switch (l) {
	            case "right":
	                d = 1E3;
	                r = 0.05;
	                break;
	            case "center":
	                d = r = 500
	        }
	        b = s(this, b + 0, c + t);
	        n.push('<g_vml_:line from="', -d, ' 0" to="', r, ' 0.05" ', ' coordsize="100 100" coordorigin="0 0"', ' filled="', !e, '" stroked="', !!e, '" style="position:absolute;width:1px;height:1px;">');
	        e ? S(this, n) : T(this, n, {
	            x: -d,
	            y: 0
	        }, {
	            x: r,
	            y: h.size
	        });
	        e = f[0][0].toFixed(3) + "," + f[1][0].toFixed(3) + "," + f[0][1].toFixed(3) + "," + f[1][1].toFixed(3) + ",0,0";
	        b = k(b.x / q) + "," + k(b.y / q);
	        n.push('<g_vml_:skew on="t" matrix="', e, '" ', ' offset="', b, '" origin="', d, ' 0" />', '<g_vml_:path textpathok="true" />', '<g_vml_:textpath on="true" string="', N(a), '" style="v-text-align:', l, ";font:", N(p), '" /></g_vml_:line>');
	        this.element_.insertAdjacentHTML("beforeEnd", n.join(""))
	    };
	    d.fillText = function(a, b, c, d) {
	        this.drawText_(a, b, c, d, !1)
	    };
	    d.strokeText = function(a,
	        b, c, d) {
	        this.drawText_(a, b, c, d, !0)
	    };
	    d.measureText = function(a) {
	        this.textMeasureEl_ || (this.element_.insertAdjacentHTML("beforeEnd", '<span style="position:absolute;top:-20000px;left:0;padding:0;margin:0;border:none;white-space:pre;"></span>'), this.textMeasureEl_ = this.element_.lastChild);
	        var b = this.element_.ownerDocument;
	        this.textMeasureEl_.innerHTML = "";
	        this.textMeasureEl_.style.font = this.font;
	        this.textMeasureEl_.appendChild(b.createTextNode(a));
	        return {
	            width: this.textMeasureEl_.offsetWidth
	        }
	    };
	    d.clip = function() {};
	    d.arcTo = function() {};
	    d.createPattern = function(a, b) {
	        return new I(a, b)
	    };
	    w.prototype.addColorStop = function(a, b) {
	        b = G(b);
	        this.colors_.push({
	            offset: a,
	            color: b.color,
	            alpha: b.alpha
	        })
	    };
	    d = A.prototype = Error();
	    d.INDEX_SIZE_ERR = 1;
	    d.DOMSTRING_SIZE_ERR = 2;
	    d.HIERARCHY_REQUEST_ERR = 3;
	    d.WRONG_DOCUMENT_ERR = 4;
	    d.INVALID_CHARACTER_ERR = 5;
	    d.NO_DATA_ALLOWED_ERR = 6;
	    d.NO_MODIFICATION_ALLOWED_ERR = 7;
	    d.NOT_FOUND_ERR = 8;
	    d.NOT_SUPPORTED_ERR = 9;
	    d.INUSE_ATTRIBUTE_ERR = 10;
	    d.INVALID_STATE_ERR = 11;
	    d.SYNTAX_ERR = 12;
	    d.INVALID_MODIFICATION_ERR =
	        13;
	    d.NAMESPACE_ERR = 14;
	    d.INVALID_ACCESS_ERR = 15;
	    d.VALIDATION_ERR = 16;
	    d.TYPE_MISMATCH_ERR = 17;
	    G_vmlCanvasManager = U;
	    CanvasRenderingContext2D = C;
	    CanvasGradient = w;
	    CanvasPattern = I;
	    DOMException = A
	}();

/***/ }),
/* 16 */
/***/ (function(module, exports) {

	jQuery(document).ready(function ($) {
	    //set animation timing
	    var animationDelay = 2500,
	        //loading bar effect
	        barAnimationDelay = 3800,
	        barWaiting = barAnimationDelay - 3000, //3000 is the duration of the transition on the loading bar - set in the scss/css file
	        //letters effect
	        lettersDelay = 50,
	        //type effect
	        typeLettersDelay = 200,
	        selectionDuration = 300,
	        typeAnimationDelay = selectionDuration + 800,
	        //clip effect 
	        revealDuration = 600,
	        revealAnimationDelay = 1500;

	    initHeadline();


	    function initHeadline() {
	        //insert <i> element for each letter of a changing word
	        singleLetters($('.cd-headline.letters').find('b'));
	        //initialise headline animation
	        animateHeadline($('.cd-headline'));
	    }

	    function singleLetters($words) {
	        $words.each(function () {
	            var word = $(this),
	                letters = word.text().split(''),
	                selected = word.hasClass('is-visible');
	            for (i in letters) {
	                if (word.parents('.rotate-2').length > 0) letters[i] = '<em>' + letters[i] + '</em>';
	                letters[i] = (selected) ? '<i class="in">' + letters[i] + '</i>' : '<i>' + letters[i] + '</i>';
	            }
	            var newLetters = letters.join('');
	            word.html(newLetters).css('opacity', 1);
	        });
	    }

	    function animateHeadline($headlines) {
	        var duration = animationDelay;
	        $headlines.each(function () {
	            var headline = $(this);

	            if (headline.hasClass('loading-bar')) {
	                duration = barAnimationDelay;
	                setTimeout(function () {
	                    headline.find('.cd-words-wrapper').addClass('is-loading')
	                }, barWaiting);
	            } else if (headline.hasClass('clip')) {
	                var spanWrapper = headline.find('.cd-words-wrapper'),
	                    newWidth = spanWrapper.width() + 10;
	                spanWrapper.css('width', newWidth);
	            } else if (!headline.hasClass('type')) {
	                //assign to .cd-words-wrapper the width of its longest word
	                var words = headline.find('.cd-words-wrapper b'),
	                    width = 0;
	                words.each(function () {
	                    var wordWidth = $(this).width();
	                    if (wordWidth > width) width = wordWidth;
	                });
	                headline.find('.cd-words-wrapper').css('width', width);
	            }
	            //trigger animation
	            setTimeout(function () {
	                hideWord(headline.find('.is-visible').eq(0))
	            }, duration);
	        });
	    }

	    function hideWord($word) {
	        var nextWord = takeNext($word);

	        if ($word.parents('.cd-headline').hasClass('type')) {
	            var parentSpan = $word.parent('.cd-words-wrapper');
	            parentSpan.addClass('selected').removeClass('waiting');
	            setTimeout(function () {
	                parentSpan.removeClass('selected');
	                $word.removeClass('is-visible').addClass('is-hidden').children('i').removeClass('in').addClass('out');
	            }, selectionDuration);
	            setTimeout(function () {
	                showWord(nextWord, typeLettersDelay)
	            }, typeAnimationDelay);

	        } else if ($word.parents('.cd-headline').hasClass('letters')) {
	            var bool = ($word.children('i').length >= nextWord.children('i').length) ? true : false;
	            hideLetter($word.find('i').eq(0), $word, bool, lettersDelay);
	            showLetter(nextWord.find('i').eq(0), nextWord, bool, lettersDelay);

	        } else if ($word.parents('.cd-headline').hasClass('clip')) {
	            $word.parents('.cd-words-wrapper').animate({width: '2px'}, revealDuration, function () {
	                switchWord($word, nextWord);
	                showWord(nextWord);
	            });

	        } else if ($word.parents('.cd-headline').hasClass('loading-bar')) {
	            $word.parents('.cd-words-wrapper').removeClass('is-loading');
	            switchWord($word, nextWord);
	            setTimeout(function () {
	                hideWord(nextWord)
	            }, barAnimationDelay);
	            setTimeout(function () {
	                $word.parents('.cd-words-wrapper').addClass('is-loading')
	            }, barWaiting);

	        } else {
	            switchWord($word, nextWord);
	            setTimeout(function () {
	                hideWord(nextWord)
	            }, animationDelay);
	        }
	    }

	    function showWord($word, $duration) {
	        if ($word.parents('.cd-headline').hasClass('type')) {
	            showLetter($word.find('i').eq(0), $word, false, $duration);
	            $word.addClass('is-visible').removeClass('is-hidden');

	        } else if ($word.parents('.cd-headline').hasClass('clip')) {
	            $word.parents('.cd-words-wrapper').animate({'width': $word.width() + 10}, revealDuration, function () {
	                setTimeout(function () {
	                    hideWord($word)
	                }, revealAnimationDelay);
	            });
	        }
	    }

	    function hideLetter($letter, $word, $bool, $duration) {
	        $letter.removeClass('in').addClass('out');

	        if (!$letter.is(':last-child')) {
	            setTimeout(function () {
	                hideLetter($letter.next(), $word, $bool, $duration);
	            }, $duration);
	        } else if ($bool) {
	            setTimeout(function () {
	                hideWord(takeNext($word))
	            }, animationDelay);
	        }

	        if ($letter.is(':last-child') && $('html').hasClass('no-csstransitions')) {
	            var nextWord = takeNext($word);
	            switchWord($word, nextWord);
	        }
	    }

	    function showLetter($letter, $word, $bool, $duration) {
	        $letter.addClass('in').removeClass('out');

	        if (!$letter.is(':last-child')) {
	            setTimeout(function () {
	                showLetter($letter.next(), $word, $bool, $duration);
	            }, $duration);
	        } else {
	            if ($word.parents('.cd-headline').hasClass('type')) {
	                setTimeout(function () {
	                    $word.parents('.cd-words-wrapper').addClass('waiting');
	                }, 200);
	            }
	            if (!$bool) {
	                setTimeout(function () {
	                    hideWord($word)
	                }, animationDelay)
	            }
	        }
	    }

	    function takeNext($word) {
	        return (!$word.is(':last-child')) ? $word.next() : $word.parent().children().eq(0);
	    }

	    function takePrev($word) {
	        return (!$word.is(':first-child')) ? $word.prev() : $word.parent().children().last();
	    }

	    function switchWord($oldWord, $newWord) {
	        $oldWord.removeClass('is-visible').addClass('is-hidden');
	        $newWord.removeClass('is-hidden').addClass('is-visible');
	    }
	});

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(18);

	jQuery(function ($) {
	    "use strict";
	    var xv_ww = $(window).width(),
	        xv_slideshow = true;

	    menuInit();

	    // Check If Counter In Viewport
	    $(window).on('load resize', function () {
	        menuInit();
	    });

	    function menuInit() {
	        xv_ww = $(window).width();
	        if ($('.nav-offcanvas').length) {
	            $('.paper-nav-toggle').removeClass('dl-trigger');
	        }

	        if (($('.nav-offcanvas').length && xv_ww <= 1030) || $('.nav-offcanvas-desktop').length) {
	            $('body').addClass('sidebar-collapse');
	            $('.dl-menu').addClass("dl-menuopen");
	            $('.paper-nav-toggle').removeClass('dl-trigger');
	            $('.nav-offcanvas .paper_menu').addClass('main-sidebar shadow1 fixed offcanvas');
	        } else {
	            $('.nav-offcanvas .paper_menu').removeClass('main-sidebar shadow1 fixed offcanvas');
	        }


	        if (xv_ww <= 1030 || $('.mini-nav').length) {
	            $('.responsive-menu').removeClass('xv-menuwrapper').addClass('dl-menuwrapper');
	            $('.user-avatar').removeClass('pull-right');
	            $('.lg-submenu').addClass("dl-submenu");
	        } else {
	            $('.responsive-menu').removeClass('dl-menuwrapper').addClass('xv-menuwrapper');
	            $('.lg-submenu').removeClass("dl-submenu");
	            $('.user-avatar').addClass('pull-right');
	        }
	    }
	    $('#dl-menu').dlmenu({
	        animationClasses: {
	            classin: 'dl-animate-in-2',
	            classout: 'dl-animate-out-2'
	        }
	    });
	});

/***/ }),
/* 18 */
/***/ (function(module, exports) {

	/**
	 * jquery.dlmenu.js v1.0.1
	 * http://www.codrops.com
	 */
	;(function ($, window, undefined) {

	    'use strict';

	    // global
	    var Modernizr = window.Modernizr, $body = $('body');

	    $.DLMenu = function (options, element) {
	        this.$el = $(element);
	        this._init(options);
	    };

	    // the options
	    $.DLMenu.defaults = {
	        // classes for the animation effects
	        animationClasses: {classin: 'dl-animate-in-1', classout: 'dl-animate-out-1'},
	        // callback: click a link that has a sub menu
	        // el is the link element (li); name is the level name
	        onLevelClick: function (el, name) {
	            return false;
	        },
	        // callback: click a link that does not have a sub menu
	        // el is the link element (li); ev is the event obj
	        onLinkClick: function (el, ev) {
	            return false;
	        }
	    };

	    $.DLMenu.prototype = {
	        _init: function (options) {

	            // options
	            this.options = $.extend(true, {}, $.DLMenu.defaults, options);
	            // cache some elements and initialize some variables
	            this._config();

	            var animEndEventNames = {
	                    'WebkitAnimation': 'webkitAnimationEnd',
	                    'OAnimation': 'oAnimationEnd',
	                    'msAnimation': 'MSAnimationEnd',
	                    'animation': 'animationend'
	                },
	                transEndEventNames = {
	                    'WebkitTransition': 'webkitTransitionEnd',
	                    'MozTransition': 'transitionend',
	                    'OTransition': 'oTransitionEnd',
	                    'msTransition': 'MSTransitionEnd',
	                    'transition': 'transitionend'
	                };
	            // animation end event name
	            this.animEndEventName = animEndEventNames[Modernizr.prefixed('animation')] + '.dlmenu';
	            // transition end event name
	            this.transEndEventName = transEndEventNames[Modernizr.prefixed('transition')] + '.dlmenu',
	                // support for css animations and css transitions
	                this.supportAnimations = Modernizr.cssanimations,
	                this.supportTransitions = Modernizr.csstransitions;

	            this._initEvents();

	        },
	        _config: function () {
	            this.open = false;
	            this.$trigger = $('.dl-trigger');
	            this.$menu = this.$el.children('ul.dl-menu');
	            this.$menuitems = this.$menu.find('li:not(.dl-back)');
	            this.$el.find('ul.dl-submenu,ul.lg-submenu').prepend('<li class="dl-back"><a href="#">back</a></li>');
	            this.$back = this.$menu.find('li.dl-back');
	        },
	        _initEvents: function () {

	            var self = this;

	            this.$trigger.on('click.dlmenu', function () {

	                if (self.open) {
	                    self._closeMenu();
	                }
	                else {
	                    self._openMenu();
	                }
	                return false;

	            });

	            this.$menuitems.on('click.dlmenu', function (event) {

	                if (!$(this).find('a').slice(0, 1).data('toggle')) {

	                    event.stopPropagation();
	                }

	                var $item = $(this),
	                    $submenu = $item.children('ul.dl-submenu');

	                if ($submenu.length > 0) {

	                    var $flyin = $submenu.clone().css('opacity', 0).insertAfter(self.$menu),
	                        onAnimationEndFn = function () {
	                            self.$menu.off(self.animEndEventName).removeClass(self.options.animationClasses.classout).addClass('dl-subview');
	                            $item.addClass('dl-subviewopen').parents('.dl-subviewopen:first').removeClass('dl-subviewopen').addClass('dl-subview');
	                            $flyin.remove();
	                        };

	                    setTimeout(function () {
	                        $flyin.addClass(self.options.animationClasses.classin);
	                        self.$menu.addClass(self.options.animationClasses.classout);
	                        if (self.supportAnimations) {
	                            self.$menu.on(self.animEndEventName, onAnimationEndFn);
	                        }
	                        else {
	                            onAnimationEndFn.call();
	                        }

	                        self.options.onLevelClick($item, $item.children('a:first').text());
	                    });

	                    return false;

	                }
	                else {
	                    self.options.onLinkClick($item, event);
	                }

	            });

	            this.$back.on('click.dlmenu', function (event) {

	                var $this = $(this),
	                    $submenu = $this.parents('ul.dl-submenu:first'),
	                    $item = $submenu.parent(),

	                    $flyin = $submenu.clone().insertAfter(self.$menu);

	                var onAnimationEndFn = function () {
	                    self.$menu.off(self.animEndEventName).removeClass(self.options.animationClasses.classin);
	                    $flyin.remove();
	                };

	                setTimeout(function () {
	                    $flyin.addClass(self.options.animationClasses.classout);
	                    self.$menu.addClass(self.options.animationClasses.classin);
	                    if (self.supportAnimations) {
	                        self.$menu.on(self.animEndEventName, onAnimationEndFn);
	                    }
	                    else {
	                        onAnimationEndFn.call();
	                    }

	                    $item.removeClass('dl-subviewopen');

	                    var $subview = $this.parents('.dl-subview:first');
	                    if ($subview.is('li')) {
	                        $subview.addClass('dl-subviewopen');
	                    }
	                    $subview.removeClass('dl-subview');
	                });

	                return false;

	            });

	        },
	        closeMenu: function () {
	            if (this.open) {
	                this._closeMenu();

	            }
	        },
	        _closeMenu: function () {
	            var self = this,
	                onTransitionEndFn = function () {
	                    self.$menu.off(self.transEndEventName);
	                    self._resetMenu();
	                };

	            this.$menu.removeClass('dl-menuopen');
	            this.$menu.addClass('dl-menu-toggle');
	            this.$trigger.removeClass('dl-active');

	            if (this.supportTransitions) {
	                this.$menu.on(this.transEndEventName, onTransitionEndFn);
	            }
	            else {
	                onTransitionEndFn.call();
	            }

	            this.open = false;
	        },
	        openMenu: function () {
	            if (!this.open) {
	                this._openMenu();
	            }
	        },
	        _openMenu: function () {
	            var self = this;
	            // clicking somewhere else makes the menu close
	            $body.off('click').on('click.dlmenu', function () {
	                self._closeMenu();
	            });
	            this.$menu.addClass('dl-menuopen dl-menu-toggle').on(this.transEndEventName, function () {
	                $(this).removeClass('dl-menu-toggle');
	            });
	            this.$trigger.addClass('dl-active');
	            this.open = true;
	        },
	        // resets the menu to its original state (first level of options)
	        _resetMenu: function () {
	            this.$menu.removeClass('dl-subview');
	            this.$menuitems.removeClass('dl-subview dl-subviewopen');
	        }
	    };

	    var logError = function (message) {
	        if (window.console) {
	            window.console.error(message);
	        }
	    };

	    $.fn.dlmenu = function (options) {
	        if (typeof options === 'string') {
	            var args = Array.prototype.slice.call(arguments, 1);
	            this.each(function () {
	                var instance = $.data(this, 'dlmenu');
	                if (!instance) {
	                    logError("cannot call methods on dlmenu prior to initialization; " +
	                        "attempted to call method '" + options + "'");
	                    return;
	                }
	                if (!$.isFunction(instance[options]) || options.charAt(0) === "_") {
	                    logError("no such method '" + options + "' for dlmenu instance");
	                    return;
	                }
	                instance[options].apply(instance, args);
	            });
	        }
	        else {
	            this.each(function () {
	                var instance = $.data(this, 'dlmenu');
	                if (instance) {
	                    instance._init();
	                }
	                else {
	                    instance = $.data(this, 'dlmenu', new $.DLMenu(options, this));
	                }
	            });
	        }
	        return this;
	    };

	})(jQuery, window);

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(20);
	jQuery(function ($) {
	    "use strict";
	    lightSlider();
	});
	var lightSlider = function () {
	    var clientSlider = $('#clientSlider').lightSlider({
	        adaptiveHeight: true,
	        item: 5,
	        slideMargin: 0,
	        auto: true,
	        loop: false,
	        pauseOnHover: true,
	    });

	    var light = $(".lightSlider");
	    light.each(function () {
	        var $this = $(this);
	        $this.lightSlider({
	            verticalHeight: $this.data('vertical-height'),
	            autoWidth: $this.data('auto-width'),
	            slideWidth: $this.data('slide-width'),
	            centerSlide: $this.data('center-slide'),
	            gallery: $this.data('gallery'),
	            thumbItem: $this.data('thumbs'),
	            thumbMargin: $this.data('margin'),
	            item: $this.data('item'),
	            loop: $this.data('loop'),
	            mode: $this.data('mode'),
	            adaptiveHeight: $this.data('adaptive-height'),
	            speed: $this.data('speed'),
	            auto: $this.data('auto'),
	            pause: $this.data('pause'),
	            pauseOnHover: $this.data('pause-on-hover'),
	            pager: $this.data('pager'),
	            slideMargin: $this.data('slide-margin'),
	            vThumbWidth: 80,
	            currentPagerPosition: $this.data('position'),
	            controls: $this.data('controls'),
	            prevHtml: '<span class="icon-left-arrow"></span>',
	            nextHtml: '<span class="icon-right-arrow"></span>',
	            responsive: [
	                {
	                    breakpoint: 1024,
	                    settings: {
	                        item: $this.data('item-lg'),
	                        slideMove: 1,
	                        slideMargin: 6,
	                    }
	                },
	                {
	                    breakpoint: 768,
	                    settings: {
	                        item: $this.data('item-md'),
	                        slideMove: 1,
	                        slideMargin: 6,
	                    }
	                },
	                {
	                    breakpoint: 480,
	                    settings: {
	                        item: $this.data('item-sm'),
	                        slideMove: 1
	                    }
	                }
	            ],
	            onSliderLoad: function (el) {
	                if ($this.data('start')) {
	                    $this.goToSlide($this.data('start'));
	                }
	                $this.addClass('showSlider');


	                el.find('.lslide .animated').addClass("go");
	            },

	            onBeforeNextSlide: function (el) {
	                el.find('.lslide .animated').removeClass("go");
	            },
	            onAfterSlide: function (el) {
	                el.find('.lslide .animated').addClass("go");
	            }
	        });
	    });

	};

/***/ }),
/* 20 */
/***/ (function(module, exports) {

	/*! lightslider - v1.1.6 - 2016-10-25
	* https://github.com/sachinchoolur/lightslider
	* Copyright (c) 2016 Sachin N; Licensed MIT */
	(function ($, undefined) {
	    'use strict';
	    var defaults = {
	        item: 3,
	        autoWidth: false,
	        slideMove: 1,
	        slideMargin: 10,
	        addClass: '',
	        mode: 'slide',
	        useCSS: true,
	        cssEasing: 'ease', //'cubic-bezier(0.25, 0, 0.25, 1)',
	        easing: 'linear', //'for jquery animation',//
	        speed: 400, //ms'
	        auto: false,
	        pauseOnHover: false,
	        loop: false,
	        slideEndAnimation: true,
	        pause: 2000,
	        keyPress: false,
	        controls: true,
	        prevHtml: '',
	        nextHtml: '',
	        rtl: false,
	        adaptiveHeight: false,
	        vertical: false,
	        verticalHeight: 500,
	        vThumbWidth: 100,
	        thumbItem: 10,
	        pager: true,
	        gallery: false,
	        galleryMargin: 5,
	        thumbMargin: 5,
	        currentPagerPosition: 'middle',
	        enableTouch: true,
	        enableDrag: true,
	        freeMove: true,
	        swipeThreshold: 40,
	        responsive: [],
	        /* jshint ignore:start */
	        onBeforeStart: function ($el) {},
	        onSliderLoad: function ($el) {},
	        onBeforeSlide: function ($el, scene) {},
	        onAfterSlide: function ($el, scene) {},
	        onBeforeNextSlide: function ($el, scene) {},
	        onBeforePrevSlide: function ($el, scene) {}
	        /* jshint ignore:end */
	    };
	    $.fn.lightSlider = function (options) {
	        if (this.length === 0) {
	            return this;
	        }

	        if (this.length > 1) {
	            this.each(function () {
	                $(this).lightSlider(options);
	            });
	            return this;
	        }

	        var plugin = {},
	            settings = $.extend(true, {}, defaults, options),
	            settingsTemp = {},
	            $el = this;
	        plugin.$el = this;

	        if (settings.mode === 'fade') {
	            settings.vertical = false;
	        }
	        var $children = $el.children(),
	            windowW = $(window).width(),
	            breakpoint = null,
	            resposiveObj = null,
	            length = 0,
	            w = 0,
	            on = false,
	            elSize = 0,
	            $slide = '',
	            scene = 0,
	            property = (settings.vertical === true) ? 'height' : 'width',
	            gutter = (settings.vertical === true) ? 'margin-bottom' : 'margin-right',
	            slideValue = 0,
	            pagerWidth = 0,
	            slideWidth = 0,
	            thumbWidth = 0,
	            interval = null,
	            isTouch = ('ontouchstart' in document.documentElement);
	        var refresh = {};

	        refresh.chbreakpoint = function () {
	            windowW = $(window).width();
	            if (settings.responsive.length) {
	                var item;
	                if (settings.autoWidth === false) {
	                    item = settings.item;
	                }
	                if (windowW < settings.responsive[0].breakpoint) {
	                    for (var i = 0; i < settings.responsive.length; i++) {
	                        if (windowW < settings.responsive[i].breakpoint) {
	                            breakpoint = settings.responsive[i].breakpoint;
	                            resposiveObj = settings.responsive[i];
	                        }
	                    }
	                }
	                if (typeof resposiveObj !== 'undefined' && resposiveObj !== null) {
	                    for (var j in resposiveObj.settings) {
	                        if (resposiveObj.settings.hasOwnProperty(j)) {
	                            if (typeof settingsTemp[j] === 'undefined' || settingsTemp[j] === null) {
	                                settingsTemp[j] = settings[j];
	                            }
	                            settings[j] = resposiveObj.settings[j];
	                        }
	                    }
	                }
	                if (!$.isEmptyObject(settingsTemp) && windowW > settings.responsive[0].breakpoint) {
	                    for (var k in settingsTemp) {
	                        if (settingsTemp.hasOwnProperty(k)) {
	                            settings[k] = settingsTemp[k];
	                        }
	                    }
	                }
	                if (settings.autoWidth === false) {
	                    if (slideValue > 0 && slideWidth > 0) {
	                        if (item !== settings.item) {
	                            scene = Math.round(slideValue / ((slideWidth + settings.slideMargin) * settings.slideMove));
	                        }
	                    }
	                }
	            }
	        };

	        refresh.calSW = function () {
	            if (settings.autoWidth === false) {
	                slideWidth = (elSize - ((settings.item * (settings.slideMargin)) - settings.slideMargin)) / settings.item;
	            }
	        };

	        refresh.calWidth = function (cln) {
	            var ln = cln === true ? $slide.find('.lslide').length : $children.length;
	            if (settings.autoWidth === false) {
	                w = ln * (slideWidth + settings.slideMargin);
	            } else {
	                w = 0;
	                for (var i = 0; i < ln; i++) {
	                    w += (parseInt($children.eq(i).width()) + settings.slideMargin);
	                }
	            }
	            return w;
	        };
	        plugin = {
	            doCss: function () {
	                var support = function () {
	                    var transition = ['transition', 'MozTransition', 'WebkitTransition', 'OTransition', 'msTransition', 'KhtmlTransition'];
	                    var root = document.documentElement;
	                    for (var i = 0; i < transition.length; i++) {
	                        if (transition[i] in root.style) {
	                            return true;
	                        }
	                    }
	                };
	                if (settings.useCSS && support()) {
	                    return true;
	                }
	                return false;
	            },
	            keyPress: function () {
	                if (settings.keyPress) {
	                    $(document).on('keyup.lightslider', function (e) {
	                        if (!$(':focus').is('input, textarea')) {
	                            if (e.preventDefault) {
	                                e.preventDefault();
	                            } else {
	                                e.returnValue = false;
	                            }
	                            if (e.keyCode === 37) {
	                                $el.goToPrevSlide();
	                            } else if (e.keyCode === 39) {
	                                $el.goToNextSlide();
	                            }
	                        }
	                    });
	                }
	            },
	            controls: function () {
	                if (settings.controls) {
	                    $el.after('<div class="lSAction"><a class="lSPrev">' + settings.prevHtml + '</a><a class="lSNext">' + settings.nextHtml + '</a></div>');
	                    if (!settings.autoWidth) {
	                        if (length <= settings.item) {
	                            $slide.find('.lSAction').hide();
	                        }
	                    } else {
	                        if (refresh.calWidth(false) < elSize) {
	                            $slide.find('.lSAction').hide();
	                        }
	                    }
	                    $slide.find('.lSAction a').on('click', function (e) {
	                        if (e.preventDefault) {
	                            e.preventDefault();
	                        } else {
	                            e.returnValue = false;
	                        }
	                        if ($(this).attr('class') === 'lSPrev') {
	                            $el.goToPrevSlide();
	                        } else {
	                            $el.goToNextSlide();
	                        }
	                        return false;
	                    });
	                }
	            },
	            initialStyle: function () {
	                var $this = this;
	                if (settings.mode === 'fade') {
	                    settings.autoWidth = false;
	                    settings.slideEndAnimation = false;
	                }
	                if (settings.auto) {
	                    settings.slideEndAnimation = false;
	                }
	                if (settings.autoWidth) {
	                    settings.slideMove = 1;
	                    settings.item = 1;
	                }
	                if (settings.loop) {
	                    settings.slideMove = 1;
	                    settings.freeMove = false;
	                }
	                settings.onBeforeStart.call(this, $el);
	                refresh.chbreakpoint();
	                $el.addClass('lightSlider').wrap('<div class="lSSlideOuter ' + settings.addClass + '"><div class="lSSlideWrapper"></div></div>');
	                $slide = $el.parent('.lSSlideWrapper');
	                if (settings.rtl === true) {
	                    $slide.parent().addClass('lSrtl');
	                }
	                if (settings.vertical) {
	                    $slide.parent().addClass('vertical');
	                    elSize = settings.verticalHeight;
	                    $slide.css('height', elSize + 'px');
	                } else {
	                    elSize = $el.outerWidth();
	                }
	                $children.addClass('lslide');
	                if (settings.loop === true && settings.mode === 'slide') {
	                    refresh.calSW();
	                    refresh.clone = function () {
	                        if (refresh.calWidth(true) > elSize) {
	                            /**/
	                            var tWr = 0,
	                                tI = 0;
	                            for (var k = 0; k < $children.length; k++) {
	                                tWr += (parseInt($el.find('.lslide').eq(k).width()) + settings.slideMargin);
	                                tI++;
	                                if (tWr >= (elSize + settings.slideMargin)) {
	                                    break;
	                                }
	                            }
	                            var tItem = settings.autoWidth === true ? tI : settings.item;

	                            /**/
	                            if (tItem < $el.find('.clone.left').length) {
	                                for (var i = 0; i < $el.find('.clone.left').length - tItem; i++) {
	                                    $children.eq(i).remove();
	                                }
	                            }
	                            if (tItem < $el.find('.clone.right').length) {
	                                for (var j = $children.length - 1; j > ($children.length - 1 - $el.find('.clone.right').length); j--) {
	                                    scene--;
	                                    $children.eq(j).remove();
	                                }
	                            }
	                            /**/
	                            for (var n = $el.find('.clone.right').length; n < tItem; n++) {
	                                $el.find('.lslide').eq(n).clone().removeClass('lslide').addClass('clone right').appendTo($el);
	                                scene++;
	                            }
	                            for (var m = $el.find('.lslide').length - $el.find('.clone.left').length; m > ($el.find('.lslide').length - tItem); m--) {
	                                $el.find('.lslide').eq(m - 1).clone().removeClass('lslide').addClass('clone left').prependTo($el);
	                            }
	                            $children = $el.children();
	                        } else {
	                            if ($children.hasClass('clone')) {
	                                $el.find('.clone').remove();
	                                $this.move($el, 0);
	                            }
	                        }
	                    };
	                    refresh.clone();
	                }
	                refresh.sSW = function () {
	                    length = $children.length;
	                    if (settings.rtl === true && settings.vertical === false) {
	                        gutter = 'margin-left';
	                    }
	                    if (settings.autoWidth === false) {
	                        $children.css(property, slideWidth + 'px');
	                    }
	                    $children.css(gutter, settings.slideMargin + 'px');
	                    w = refresh.calWidth(false);
	                    $el.css(property, w + 'px');
	                    if (settings.loop === true && settings.mode === 'slide') {
	                        if (on === false) {
	                            scene = $el.find('.clone.left').length;
	                        }
	                    }
	                };
	                refresh.calL = function () {
	                    $children = $el.children();
	                    length = $children.length;
	                };
	                if (this.doCss()) {
	                    $slide.addClass('usingCss');
	                }
	                refresh.calL();
	                if (settings.mode === 'slide') {
	                    refresh.calSW();
	                    refresh.sSW();
	                    if (settings.loop === true) {
	                        slideValue = $this.slideValue();
	                        this.move($el, slideValue);
	                    }
	                    if (settings.vertical === false) {
	                        this.setHeight($el, false);
	                    }

	                } else {
	                    this.setHeight($el, true);
	                    $el.addClass('lSFade');
	                    if (!this.doCss()) {
	                        $children.fadeOut(0);
	                        $children.eq(scene).fadeIn(0);
	                    }
	                }
	                if (settings.loop === true && settings.mode === 'slide') {
	                    $children.eq(scene).addClass('active');
	                } else {
	                    $children.first().addClass('active');
	                }
	            },
	            pager: function () {
	                var $this = this;
	                refresh.createPager = function () {
	                    thumbWidth = (elSize - ((settings.thumbItem * (settings.thumbMargin)) - settings.thumbMargin)) / settings.thumbItem;
	                    var $children = $slide.find('.lslide');
	                    var length = $slide.find('.lslide').length;
	                    var i = 0,
	                        pagers = '',
	                        v = 0;
	                    for (i = 0; i < length; i++) {
	                        if (settings.mode === 'slide') {
	                            // calculate scene * slide value
	                            if (!settings.autoWidth) {
	                                v = i * ((slideWidth + settings.slideMargin) * settings.slideMove);
	                            } else {
	                                v += ((parseInt($children.eq(i).width()) + settings.slideMargin) * settings.slideMove);
	                            }
	                        }
	                        var thumb = $children.eq(i * settings.slideMove).attr('data-thumb');
	                        if (settings.gallery === true) {
	                            pagers += '<li style="width:100%;' + property + ':' + thumbWidth + 'px;' + gutter + ':' + settings.thumbMargin + 'px"><a href="#"><img src="' + thumb + '" /></a></li>';
	                        } else {
	                            pagers += '<li><a href="#">' + (i + 1) + '</a></li>';
	                        }
	                        if (settings.mode === 'slide') {
	                            if ((v) >= w - elSize - settings.slideMargin) {
	                                i = i + 1;
	                                var minPgr = 2;
	                                if (settings.autoWidth) {
	                                    pagers += '<li><a href="#">' + (i + 1) + '</a></li>';
	                                    minPgr = 1;
	                                }
	                                if (i < minPgr) {
	                                    pagers = null;
	                                    $slide.parent().addClass('noPager');
	                                } else {
	                                    $slide.parent().removeClass('noPager');
	                                }
	                                break;
	                            }
	                        }
	                    }
	                    var $cSouter = $slide.parent();
	                    $cSouter.find('.lSPager').html(pagers); 
	                    if (settings.gallery === true) {
	                        if (settings.vertical === true) {
	                            // set Gallery thumbnail width
	                            $cSouter.find('.lSPager').css('width', settings.vThumbWidth + 'px');
	                        }
	                        pagerWidth = (i * (settings.thumbMargin + thumbWidth)) + 0.5;
	                        $cSouter.find('.lSPager').css({
	                            property: pagerWidth + 'px',
	                            'transition-duration': settings.speed + 'ms'
	                        });
	                        if (settings.vertical === true) {
	                            $slide.parent().css('padding-right', (settings.vThumbWidth + settings.galleryMargin) + 'px');
	                        }
	                        $cSouter.find('.lSPager').css(property, pagerWidth + 'px');
	                    }
	                    var $pager = $cSouter.find('.lSPager').find('li');
	                    $pager.first().addClass('active');
	                    $pager.on('click', function () {
	                        if (settings.loop === true && settings.mode === 'slide') {
	                            scene = scene + ($pager.index(this) - $cSouter.find('.lSPager').find('li.active').index());
	                        } else {
	                            scene = $pager.index(this);
	                        }
	                        $el.mode(false);
	                        if (settings.gallery === true) {
	                            $this.slideThumb();
	                        }
	                        return false;
	                    });
	                };
	                if (settings.pager) {
	                    var cl = 'lSpg';
	                    if (settings.gallery) {
	                        cl = 'lSGallery';
	                    }
	                    $slide.after('<ul class="lSPager ' + cl + '"></ul>');
	                    var gMargin = (settings.vertical) ? 'margin-left' : 'margin-top';
	                    $slide.parent().find('.lSPager').css(gMargin, settings.galleryMargin + 'px');
	                    refresh.createPager();
	                }

	                setTimeout(function () {
	                    refresh.init();
	                }, 0);
	            },
	            setHeight: function (ob, fade) {
	                var obj = null,
	                    $this = this;
	                if (settings.loop) {
	                    obj = ob.children('.lslide ').first();
	                } else {
	                    obj = ob.children().first();
	                }
	                var setCss = function () {
	                    var tH = obj.outerHeight(),
	                        tP = 0,
	                        tHT = tH;
	                    if (fade) {
	                        tH = 0;
	                        tP = ((tHT) * 100) / elSize;
	                    }
	                    ob.css({
	                        'height': tH + 'px',
	                        'padding-bottom': tP + '%'
	                    });
	                };
	                setCss();
	                if (obj.find('img').length) {
	                    if ( obj.find('img')[0].complete) {
	                        setCss();
	                        if (!interval) {
	                            $this.auto();
	                        }   
	                    }else{
	                        obj.find('img').on('load', function () {
	                            setTimeout(function () {
	                                setCss();
	                                if (!interval) {
	                                    $this.auto();
	                                }
	                            }, 100);
	                        });
	                    }
	                }else{
	                    if (!interval) {
	                        $this.auto();
	                    }
	                }
	            },
	            active: function (ob, t) {
	                if (this.doCss() && settings.mode === 'fade') {
	                    $slide.addClass('on');
	                }
	                var sc = 0;
	                if (scene * settings.slideMove < length) {
	                    ob.removeClass('active');
	                    if (!this.doCss() && settings.mode === 'fade' && t === false) {
	                        ob.fadeOut(settings.speed);
	                    }
	                    if (t === true) {
	                        sc = scene;
	                    } else {
	                        sc = scene * settings.slideMove;
	                    }
	                    //t === true ? sc = scene : sc = scene * settings.slideMove;
	                    var l, nl;
	                    if (t === true) {
	                        l = ob.length;
	                        nl = l - 1;
	                        if (sc + 1 >= l) {
	                            sc = nl;
	                        }
	                    }
	                    if (settings.loop === true && settings.mode === 'slide') {
	                        //t === true ? sc = scene - $el.find('.clone.left').length : sc = scene * settings.slideMove;
	                        if (t === true) {
	                            sc = scene - $el.find('.clone.left').length;
	                        } else {
	                            sc = scene * settings.slideMove;
	                        }
	                        if (t === true) {
	                            l = ob.length;
	                            nl = l - 1;
	                            if (sc + 1 === l) {
	                                sc = nl;
	                            } else if (sc + 1 > l) {
	                                sc = 0;
	                            }
	                        }
	                    }

	                    if (!this.doCss() && settings.mode === 'fade' && t === false) {
	                        ob.eq(sc).fadeIn(settings.speed);
	                    }
	                    ob.eq(sc).addClass('active');
	                } else {
	                    ob.removeClass('active');
	                    ob.eq(ob.length - 1).addClass('active');
	                    if (!this.doCss() && settings.mode === 'fade' && t === false) {
	                        ob.fadeOut(settings.speed);
	                        ob.eq(sc).fadeIn(settings.speed);
	                    }
	                }
	            },
	            move: function (ob, v) {
	                if (settings.rtl === true) {
	                    v = -v;
	                }
	                if (this.doCss()) {
	                    if (settings.vertical === true) {
	                        ob.css({
	                            'transform': 'translate3d(0px, ' + (-v) + 'px, 0px)',
	                            '-webkit-transform': 'translate3d(0px, ' + (-v) + 'px, 0px)'
	                        });
	                    } else {
	                        ob.css({
	                            'transform': 'translate3d(' + (-v) + 'px, 0px, 0px)',
	                            '-webkit-transform': 'translate3d(' + (-v) + 'px, 0px, 0px)',
	                        });
	                    }
	                } else {
	                    if (settings.vertical === true) {
	                        ob.css('position', 'relative').animate({
	                            top: -v + 'px'
	                        }, settings.speed, settings.easing);
	                    } else {
	                        ob.css('position', 'relative').animate({
	                            left: -v + 'px'
	                        }, settings.speed, settings.easing);
	                    }
	                }
	                var $thumb = $slide.parent().find('.lSPager').find('li');
	                this.active($thumb, true);
	            },
	            fade: function () {
	                this.active($children, false);
	                var $thumb = $slide.parent().find('.lSPager').find('li');
	                this.active($thumb, true);
	            },
	            slide: function () {
	                var $this = this;
	                refresh.calSlide = function () {
	                    if (w > elSize) {
	                        slideValue = $this.slideValue();
	                        $this.active($children, false);
	                        if ((slideValue) > w - elSize - settings.slideMargin) {
	                            slideValue = w - elSize - settings.slideMargin;
	                        } else if (slideValue < 0) {
	                            slideValue = 0;
	                        }
	                        $this.move($el, slideValue);
	                        if (settings.loop === true && settings.mode === 'slide') {
	                            if (scene >= (length - ($el.find('.clone.left').length / settings.slideMove))) {
	                                $this.resetSlide($el.find('.clone.left').length);
	                            }
	                            if (scene === 0) {
	                                $this.resetSlide($slide.find('.lslide').length);
	                            }
	                        }
	                    }
	                };
	                refresh.calSlide();
	            },
	            resetSlide: function (s) {
	                var $this = this;
	                $slide.find('.lSAction a').addClass('disabled');
	                setTimeout(function () {
	                    scene = s;
	                    $slide.css('transition-duration', '0ms');
	                    slideValue = $this.slideValue();
	                    $this.active($children, false);
	                    plugin.move($el, slideValue);
	                    setTimeout(function () {
	                        $slide.css('transition-duration', settings.speed + 'ms');
	                        $slide.find('.lSAction a').removeClass('disabled');
	                    }, 50);
	                }, settings.speed + 100);
	            },
	            slideValue: function () {
	                var _sV = 0;
	                if (settings.autoWidth === false) {
	                    _sV = scene * ((slideWidth + settings.slideMargin) * settings.slideMove);
	                } else {
	                    _sV = 0;
	                    for (var i = 0; i < scene; i++) {
	                        _sV += (parseInt($children.eq(i).width()) + settings.slideMargin);
	                    }
	                }
	                return _sV;
	            },
	            slideThumb: function () {
	                var position;
	                switch (settings.currentPagerPosition) {
	                case 'left':
	                    position = 0;
	                    break;
	                case 'middle':
	                    position = (elSize / 2) - (thumbWidth / 2);
	                    break;
	                case 'right':
	                    position = elSize - thumbWidth;
	                }
	                var sc = scene - $el.find('.clone.left').length;
	                var $pager = $slide.parent().find('.lSPager');
	                if (settings.mode === 'slide' && settings.loop === true) {
	                    if (sc >= $pager.children().length) {
	                        sc = 0;
	                    } else if (sc < 0) {
	                        sc = $pager.children().length;
	                    }
	                }
	                var thumbSlide = sc * ((thumbWidth + settings.thumbMargin)) - (position);
	                if ((thumbSlide + elSize) > pagerWidth) {
	                    thumbSlide = pagerWidth - elSize - settings.thumbMargin;
	                }
	                if (thumbSlide < 0) {
	                    thumbSlide = 0;
	                }
	                this.move($pager, thumbSlide);
	            },
	            auto: function () {
	                if (settings.auto) {
	                    clearInterval(interval);
	                    interval = setInterval(function () {
	                        $el.goToNextSlide();
	                    }, settings.pause);
	                }
	            },
	            pauseOnHover: function(){
	                var $this = this;
	                if (settings.auto && settings.pauseOnHover) {
	                    $slide.on('mouseenter', function(){
	                        $(this).addClass('ls-hover');
	                        $el.pause();
	                        settings.auto = true;
	                    });
	                    $slide.on('mouseleave',function(){
	                        $(this).removeClass('ls-hover');
	                        if (!$slide.find('.lightSlider').hasClass('lsGrabbing')) {
	                            $this.auto();
	                        }
	                    });
	                }
	            },
	            touchMove: function (endCoords, startCoords) {
	                $slide.css('transition-duration', '0ms');
	                if (settings.mode === 'slide') {
	                    var distance = endCoords - startCoords;
	                    var swipeVal = slideValue - distance;
	                    if ((swipeVal) >= w - elSize - settings.slideMargin) {
	                        if (settings.freeMove === false) {
	                            swipeVal = w - elSize - settings.slideMargin;
	                        } else {
	                            var swipeValT = w - elSize - settings.slideMargin;
	                            swipeVal = swipeValT + ((swipeVal - swipeValT) / 5);

	                        }
	                    } else if (swipeVal < 0) {
	                        if (settings.freeMove === false) {
	                            swipeVal = 0;
	                        } else {
	                            swipeVal = swipeVal / 5;
	                        }
	                    }
	                    this.move($el, swipeVal);
	                }
	            },

	            touchEnd: function (distance) {
	                $slide.css('transition-duration', settings.speed + 'ms');
	                if (settings.mode === 'slide') {
	                    var mxVal = false;
	                    var _next = true;
	                    slideValue = slideValue - distance;
	                    if ((slideValue) > w - elSize - settings.slideMargin) {
	                        slideValue = w - elSize - settings.slideMargin;
	                        if (settings.autoWidth === false) {
	                            mxVal = true;
	                        }
	                    } else if (slideValue < 0) {
	                        slideValue = 0;
	                    }
	                    var gC = function (next) {
	                        var ad = 0;
	                        if (!mxVal) {
	                            if (next) {
	                                ad = 1;
	                            }
	                        }
	                        if (!settings.autoWidth) {
	                            var num = slideValue / ((slideWidth + settings.slideMargin) * settings.slideMove);
	                            scene = parseInt(num) + ad;
	                            if (slideValue >= (w - elSize - settings.slideMargin)) {
	                                if (num % 1 !== 0) {
	                                    scene++;
	                                }
	                            }
	                        } else {
	                            var tW = 0;
	                            for (var i = 0; i < $children.length; i++) {
	                                tW += (parseInt($children.eq(i).width()) + settings.slideMargin);
	                                scene = i + ad;
	                                if (tW >= slideValue) {
	                                    break;
	                                }
	                            }
	                        }
	                    };
	                    if (distance >= settings.swipeThreshold) {
	                        gC(false);
	                        _next = false;
	                    } else if (distance <= -settings.swipeThreshold) {
	                        gC(true);
	                        _next = false;
	                    }
	                    $el.mode(_next);
	                    this.slideThumb();
	                } else {
	                    if (distance >= settings.swipeThreshold) {
	                        $el.goToPrevSlide();
	                    } else if (distance <= -settings.swipeThreshold) {
	                        $el.goToNextSlide();
	                    }
	                }
	            },



	            enableDrag: function () {
	                var $this = this;
	                if (!isTouch) {
	                    var startCoords = 0,
	                        endCoords = 0,
	                        isDraging = false;
	                    $slide.find('.lightSlider').addClass('lsGrab');
	                    $slide.on('mousedown', function (e) {
	                        if (w < elSize) {
	                            if (w !== 0) {
	                                return false;
	                            }
	                        }
	                        if ($(e.target).attr('class') !== ('lSPrev') && $(e.target).attr('class') !== ('lSNext')) {
	                            startCoords = (settings.vertical === true) ? e.pageY : e.pageX;
	                            isDraging = true;
	                            if (e.preventDefault) {
	                                e.preventDefault();
	                            } else {
	                                e.returnValue = false;
	                            }
	                            // ** Fix for webkit cursor issue https://code.google.com/p/chromium/issues/detail?id=26723
	                            $slide.scrollLeft += 1;
	                            $slide.scrollLeft -= 1;
	                            // *
	                            $slide.find('.lightSlider').removeClass('lsGrab').addClass('lsGrabbing');
	                            clearInterval(interval);
	                        }
	                    });
	                    $(window).on('mousemove', function (e) {
	                        if (isDraging) {
	                            endCoords = (settings.vertical === true) ? e.pageY : e.pageX;
	                            $this.touchMove(endCoords, startCoords);
	                        }
	                    });
	                    $(window).on('mouseup', function (e) {
	                        if (isDraging) {
	                            $slide.find('.lightSlider').removeClass('lsGrabbing').addClass('lsGrab');
	                            isDraging = false;
	                            endCoords = (settings.vertical === true) ? e.pageY : e.pageX;
	                            var distance = endCoords - startCoords;
	                            if (Math.abs(distance) >= settings.swipeThreshold) {
	                                $(window).on('click.ls', function (e) {
	                                    if (e.preventDefault) {
	                                        e.preventDefault();
	                                    } else {
	                                        e.returnValue = false;
	                                    }
	                                    e.stopImmediatePropagation();
	                                    e.stopPropagation();
	                                    $(window).off('click.ls');
	                                });
	                            }

	                            $this.touchEnd(distance);

	                        }
	                    });
	                }
	            },




	            enableTouch: function () {
	                var $this = this;
	                if (isTouch) {
	                    var startCoords = {},
	                        endCoords = {};
	                    $slide.on('touchstart', function (e) {
	                        endCoords = e.originalEvent.targetTouches[0];
	                        startCoords.pageX = e.originalEvent.targetTouches[0].pageX;
	                        startCoords.pageY = e.originalEvent.targetTouches[0].pageY;
	                        clearInterval(interval);
	                    });
	                    $slide.on('touchmove', function (e) {
	                        if (w < elSize) {
	                            if (w !== 0) {
	                                return false;
	                            }
	                        }
	                        var orig = e.originalEvent;
	                        endCoords = orig.targetTouches[0];
	                        var xMovement = Math.abs(endCoords.pageX - startCoords.pageX);
	                        var yMovement = Math.abs(endCoords.pageY - startCoords.pageY);
	                        if (settings.vertical === true) {
	                            if ((yMovement * 3) > xMovement) {
	                                e.preventDefault();
	                            }
	                            $this.touchMove(endCoords.pageY, startCoords.pageY);
	                        } else {
	                            if ((xMovement * 3) > yMovement) {
	                                e.preventDefault();
	                            }
	                            $this.touchMove(endCoords.pageX, startCoords.pageX);
	                        }

	                    });
	                    $slide.on('touchend', function () {
	                        if (w < elSize) {
	                            if (w !== 0) {
	                                return false;
	                            }
	                        }
	                        var distance;
	                        if (settings.vertical === true) {
	                            distance = endCoords.pageY - startCoords.pageY;
	                        } else {
	                            distance = endCoords.pageX - startCoords.pageX;
	                        }
	                        $this.touchEnd(distance);
	                    });
	                }
	            },
	            build: function () {
	                var $this = this;
	                $this.initialStyle();
	                if (this.doCss()) {

	                    if (settings.enableTouch === true) {
	                        $this.enableTouch();
	                    }
	                    if (settings.enableDrag === true) {
	                        $this.enableDrag();
	                    }
	                }

	                $(window).on('focus', function(){
	                    $this.auto();
	                });
	                
	                $(window).on('blur', function(){
	                    clearInterval(interval);
	                });

	                $this.pager();
	                $this.pauseOnHover();
	                $this.controls();
	                $this.keyPress();
	            }
	        };
	        plugin.build();
	        refresh.init = function () {
	            refresh.chbreakpoint();
	            if (settings.vertical === true) {
	                if (settings.item > 1) {
	                    elSize = settings.verticalHeight;
	                } else {
	                    elSize = $children.outerHeight();
	                }
	                $slide.css('height', elSize + 'px');
	            } else {
	                elSize = $slide.outerWidth();
	            }
	            if (settings.loop === true && settings.mode === 'slide') {
	                refresh.clone();
	            }
	            refresh.calL();
	            if (settings.mode === 'slide') {
	                $el.removeClass('lSSlide');
	            }
	            if (settings.mode === 'slide') {
	                refresh.calSW();
	                refresh.sSW();
	            }
	            setTimeout(function () {
	                if (settings.mode === 'slide') {
	                    $el.addClass('lSSlide');
	                }
	            }, 1000);
	            if (settings.pager) {
	                refresh.createPager();
	            }
	            if (settings.adaptiveHeight === true && settings.vertical === false) {
	                $el.css('height', $children.eq(scene).outerHeight(true));
	            }
	            if (settings.adaptiveHeight === false) {
	                if (settings.mode === 'slide') {
	                    if (settings.vertical === false) {
	                        plugin.setHeight($el, false);
	                    }else{
	                        plugin.auto();
	                    }
	                } else {
	                    plugin.setHeight($el, true);
	                }
	            }
	            if (settings.gallery === true) {
	                plugin.slideThumb();
	            }
	            if (settings.mode === 'slide') {
	                plugin.slide();
	            }
	            if (settings.autoWidth === false) {
	                if ($children.length <= settings.item) {
	                    $slide.find('.lSAction').hide();
	                } else {
	                    $slide.find('.lSAction').show();
	                }
	            } else {
	                if ((refresh.calWidth(false) < elSize) && (w !== 0)) {
	                    $slide.find('.lSAction').hide();
	                } else {
	                    $slide.find('.lSAction').show();
	                }
	            }
	        };
	        $el.goToPrevSlide = function () {
	            if (scene > 0) {
	                settings.onBeforePrevSlide.call(this, $el, scene);
	                scene--;
	                $el.mode(false);
	                if (settings.gallery === true) {
	                    plugin.slideThumb();
	                }
	            } else {
	                if (settings.loop === true) {
	                    settings.onBeforePrevSlide.call(this, $el, scene);
	                    if (settings.mode === 'fade') {
	                        var l = (length - 1);
	                        scene = parseInt(l / settings.slideMove);
	                    }
	                    $el.mode(false);
	                    if (settings.gallery === true) {
	                        plugin.slideThumb();
	                    }
	                } else if (settings.slideEndAnimation === true) {
	                    $el.addClass('leftEnd');
	                    setTimeout(function () {
	                        $el.removeClass('leftEnd');
	                    }, 400);
	                }
	            }
	        };
	        $el.goToNextSlide = function () {
	            var nextI = true;
	            if (settings.mode === 'slide') {
	                var _slideValue = plugin.slideValue();
	                nextI = _slideValue < w - elSize - settings.slideMargin;
	            }
	            if (((scene * settings.slideMove) < length - settings.slideMove) && nextI) {
	                settings.onBeforeNextSlide.call(this, $el, scene);
	                scene++;
	                $el.mode(false);
	                if (settings.gallery === true) {
	                    plugin.slideThumb();
	                }
	            } else {
	                if (settings.loop === true) {
	                    settings.onBeforeNextSlide.call(this, $el, scene);
	                    scene = 0;
	                    $el.mode(false);
	                    if (settings.gallery === true) {
	                        plugin.slideThumb();
	                    }
	                } else if (settings.slideEndAnimation === true) {
	                    $el.addClass('rightEnd');
	                    setTimeout(function () {
	                        $el.removeClass('rightEnd');
	                    }, 400);
	                }
	            }
	        };
	        $el.mode = function (_touch) {
	            if (settings.adaptiveHeight === true && settings.vertical === false) {
	                $el.css('height', $children.eq(scene).outerHeight(true));
	            }
	            if (on === false) {
	                if (settings.mode === 'slide') {
	                    if (plugin.doCss()) {
	                        $el.addClass('lSSlide');
	                        if (settings.speed !== '') {
	                            $slide.css('transition-duration', settings.speed + 'ms');
	                        }
	                        if (settings.cssEasing !== '') {
	                            $slide.css('transition-timing-function', settings.cssEasing);
	                        }
	                    }
	                } else {
	                    if (plugin.doCss()) {
	                        if (settings.speed !== '') {
	                            $el.css('transition-duration', settings.speed + 'ms');
	                        }
	                        if (settings.cssEasing !== '') {
	                            $el.css('transition-timing-function', settings.cssEasing);
	                        }
	                    }
	                }
	            }
	            if (!_touch) {
	                settings.onBeforeSlide.call(this, $el, scene);
	            }
	            if (settings.mode === 'slide') {
	                plugin.slide();
	            } else {
	                plugin.fade();
	            }
	            if (!$slide.hasClass('ls-hover')) {
	                plugin.auto();
	            }
	            setTimeout(function () {
	                if (!_touch) {
	                    settings.onAfterSlide.call(this, $el, scene);
	                }
	            }, settings.speed);
	            on = true;
	        };
	        $el.play = function () {
	            $el.goToNextSlide();
	            settings.auto = true;
	            plugin.auto();
	        };
	        $el.pause = function () {
	            settings.auto = false;
	            clearInterval(interval);
	        };
	        $el.refresh = function () {
	            refresh.init();
	        };
	        $el.getCurrentSlideCount = function () {
	            var sc = scene;
	            if (settings.loop) {
	                var ln = $slide.find('.lslide').length,
	                    cl = $el.find('.clone.left').length;
	                if (scene <= cl - 1) {
	                    sc = ln + (scene - cl);
	                } else if (scene >= (ln + cl)) {
	                    sc = scene - ln - cl;
	                } else {
	                    sc = scene - cl;
	                }
	            }
	            return sc + 1;
	        }; 
	        $el.getTotalSlideCount = function () {
	            return $slide.find('.lslide').length;
	        };
	        $el.goToSlide = function (s) {
	            if (settings.loop) {
	                scene = (s + $el.find('.clone.left').length - 1);
	            } else {
	                scene = s;
	            }
	            $el.mode(false);
	            if (settings.gallery === true) {
	                plugin.slideThumb();
	            }
	        };
	        $el.destroy = function () {
	            if ($el.lightSlider) {
	                $el.goToPrevSlide = function(){};
	                $el.goToNextSlide = function(){};
	                $el.mode = function(){};
	                $el.play = function(){};
	                $el.pause = function(){};
	                $el.refresh = function(){};
	                $el.getCurrentSlideCount = function(){};
	                $el.getTotalSlideCount = function(){};
	                $el.goToSlide = function(){}; 
	                $el.lightSlider = null;
	                refresh = {
	                    init : function(){}
	                };
	                $el.parent().parent().find('.lSAction, .lSPager').remove();
	                $el.removeClass('lightSlider lSFade lSSlide lsGrab lsGrabbing leftEnd right').removeAttr('style').unwrap().unwrap();
	                $el.children().removeAttr('style');
	                $children.removeClass('lslide active');
	                $el.find('.clone').remove();
	                $children = null;
	                interval = null;
	                on = false;
	                scene = 0;
	            }

	        };
	        setTimeout(function () {
	            settings.onSliderLoad.call(this, $el);
	        }, 10);
	        $(window).on('resize orientationchange', function (e) {
	            setTimeout(function () {
	                if (e.preventDefault) {
	                    e.preventDefault();
	                } else {
	                    e.returnValue = false;
	                }
	                refresh.init();
	            }, 200);
	        });
	        return this;
	    };
	}(jQuery));


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(22);
	__webpack_require__(29);

	jQuery(function ($) {
	    "use strict";

	    initMasonary();


	});


	var initfilter = function ($masonryContainer, $ele) {
	    var $filterElement = $('.project-filter li, .filter li');
	    $filterElement.removeClass("active");
	    $ele.addClass("active");

	    if ($('.masonry-container .animated').length > 0) {
	        $('.masonry-container .animated').addClass("go");
	    }

	    var selector = $ele.attr('data-filter');
	    $masonryContainer.isotope({
	        filter: selector,
	        animationOptions: {
	            duration: 750,
	            easing: 'linear',
	            queue: false
	        }
	    });
	    return false;

	};
	function initMasonary() {

	    var $masonryContainer = $('.masonry-container');
	    var $filterElement = $('.project-filter li, .filter li');

	    if ($('#filter-items').length) {
	        $('.filter li').on('click', function () {
	            console.log('scroll now');
	            $('html, body').animate({
	                scrollTop: $('#filter-items').offset().top - 0
	            }, 1500, function () {
	            });
	            return false;
	        });
	    }


	    $masonryContainer.waitForImages(function () {
	        $('.masonry-container').show();
	        $('.masonry-container').masonry({
	            itemSelector: '.masonry-post'
	        });

	    });

	    $(window).on('load', function () {
	        var $ele = $('.project-filter .active');
	        initfilter($masonryContainer, $ele);
	    });


	    $filterElement.click(function () {
	        $filterElement.removeClass("active");
	        var $ele = $(this).addClass("active");

	        initfilter($masonryContainer, $ele, $filterElement);
	    });
	}

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Masonry v4.2.0
	 * Cascading grid layout library
	 * http://masonry.desandro.com
	 * MIT License
	 * by David DeSandro
	 */

	( function( window, factory ) {
	  // universal module definition
	  /* jshint strict: false */ /*globals define, module, require */
	  if ( true ) {
	    // AMD
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(23),
	        __webpack_require__(25)
	      ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if ( typeof module == 'object' && module.exports ) {
	    // CommonJS
	    module.exports = factory(
	      require('outlayer'),
	      require('get-size')
	    );
	  } else {
	    // browser global
	    window.Masonry = factory(
	      window.Outlayer,
	      window.getSize
	    );
	  }

	}( window, function factory( Outlayer, getSize ) {

	'use strict';

	// -------------------------- masonryDefinition -------------------------- //

	  // create an Outlayer layout class
	  var Masonry = Outlayer.create('masonry');
	  // isFitWidth -> fitWidth
	  Masonry.compatOptions.fitWidth = 'isFitWidth';

	  var proto = Masonry.prototype;

	  proto._resetLayout = function() {
	    this.getSize();
	    this._getMeasurement( 'columnWidth', 'outerWidth' );
	    this._getMeasurement( 'gutter', 'outerWidth' );
	    this.measureColumns();

	    // reset column Y
	    this.colYs = [];
	    for ( var i=0; i < this.cols; i++ ) {
	      this.colYs.push( 0 );
	    }

	    this.maxY = 0;
	    this.horizontalColIndex = 0;
	  };

	  proto.measureColumns = function() {
	    this.getContainerWidth();
	    // if columnWidth is 0, default to outerWidth of first item
	    if ( !this.columnWidth ) {
	      var firstItem = this.items[0];
	      var firstItemElem = firstItem && firstItem.element;
	      // columnWidth fall back to item of first element
	      this.columnWidth = firstItemElem && getSize( firstItemElem ).outerWidth ||
	        // if first elem has no width, default to size of container
	        this.containerWidth;
	    }

	    var columnWidth = this.columnWidth += this.gutter;

	    // calculate columns
	    var containerWidth = this.containerWidth + this.gutter;
	    var cols = containerWidth / columnWidth;
	    // fix rounding errors, typically with gutters
	    var excess = columnWidth - containerWidth % columnWidth;
	    // if overshoot is less than a pixel, round up, otherwise floor it
	    var mathMethod = excess && excess < 1 ? 'round' : 'floor';
	    cols = Math[ mathMethod ]( cols );
	    this.cols = Math.max( cols, 1 );
	  };

	  proto.getContainerWidth = function() {
	    // container is parent if fit width
	    var isFitWidth = this._getOption('fitWidth');
	    var container = isFitWidth ? this.element.parentNode : this.element;
	    // check that this.size and size are there
	    // IE8 triggers resize on body size change, so they might not be
	    var size = getSize( container );
	    this.containerWidth = size && size.innerWidth;
	  };

	  proto._getItemLayoutPosition = function( item ) {
	    item.getSize();
	    // how many columns does this brick span
	    var remainder = item.size.outerWidth % this.columnWidth;
	    var mathMethod = remainder && remainder < 1 ? 'round' : 'ceil';
	    // round if off by 1 pixel, otherwise use ceil
	    var colSpan = Math[ mathMethod ]( item.size.outerWidth / this.columnWidth );
	    colSpan = Math.min( colSpan, this.cols );
	    // use horizontal or top column position
	    var colPosMethod = this.options.horizontalOrder ?
	      '_getHorizontalColPosition' : '_getTopColPosition';
	    var colPosition = this[ colPosMethod ]( colSpan, item );
	    // position the brick
	    var position = {
	      x: this.columnWidth * colPosition.col,
	      y: colPosition.y
	    };
	    // apply setHeight to necessary columns
	    var setHeight = colPosition.y + item.size.outerHeight;
	    var setMax = colSpan + colPosition.col;
	    for ( var i = colPosition.col; i < setMax; i++ ) {
	      this.colYs[i] = setHeight;
	    }

	    return position;
	  };

	  proto._getTopColPosition = function( colSpan ) {
	    var colGroup = this._getTopColGroup( colSpan );
	    // get the minimum Y value from the columns
	    var minimumY = Math.min.apply( Math, colGroup );

	    return {
	      col: colGroup.indexOf( minimumY ),
	      y: minimumY,
	    };
	  };

	  /**
	   * @param {Number} colSpan - number of columns the element spans
	   * @returns {Array} colGroup
	   */
	  proto._getTopColGroup = function( colSpan ) {
	    if ( colSpan < 2 ) {
	      // if brick spans only one column, use all the column Ys
	      return this.colYs;
	    }

	    var colGroup = [];
	    // how many different places could this brick fit horizontally
	    var groupCount = this.cols + 1 - colSpan;
	    // for each group potential horizontal position
	    for ( var i = 0; i < groupCount; i++ ) {
	      colGroup[i] = this._getColGroupY( i, colSpan );
	    }
	    return colGroup;
	  };

	  proto._getColGroupY = function( col, colSpan ) {
	    if ( colSpan < 2 ) {
	      return this.colYs[ col ];
	    }
	    // make an array of colY values for that one group
	    var groupColYs = this.colYs.slice( col, col + colSpan );
	    // and get the max value of the array
	    return Math.max.apply( Math, groupColYs );
	  };

	  // get column position based on horizontal index. #873
	  proto._getHorizontalColPosition = function( colSpan, item ) {
	    var col = this.horizontalColIndex % this.cols;
	    var isOver = colSpan > 1 && col + colSpan > this.cols;
	    // shift to next row if item can't fit on current row
	    col = isOver ? 0 : col;
	    // don't let zero-size items take up space
	    var hasSize = item.size.outerWidth && item.size.outerHeight;
	    this.horizontalColIndex = hasSize ? col + colSpan : this.horizontalColIndex;

	    return {
	      col: col,
	      y: this._getColGroupY( col, colSpan ),
	    };
	  };

	  proto._manageStamp = function( stamp ) {
	    var stampSize = getSize( stamp );
	    var offset = this._getElementOffset( stamp );
	    // get the columns that this stamp affects
	    var isOriginLeft = this._getOption('originLeft');
	    var firstX = isOriginLeft ? offset.left : offset.right;
	    var lastX = firstX + stampSize.outerWidth;
	    var firstCol = Math.floor( firstX / this.columnWidth );
	    firstCol = Math.max( 0, firstCol );
	    var lastCol = Math.floor( lastX / this.columnWidth );
	    // lastCol should not go over if multiple of columnWidth #425
	    lastCol -= lastX % this.columnWidth ? 0 : 1;
	    lastCol = Math.min( this.cols - 1, lastCol );
	    // set colYs to bottom of the stamp

	    var isOriginTop = this._getOption('originTop');
	    var stampMaxY = ( isOriginTop ? offset.top : offset.bottom ) +
	      stampSize.outerHeight;
	    for ( var i = firstCol; i <= lastCol; i++ ) {
	      this.colYs[i] = Math.max( stampMaxY, this.colYs[i] );
	    }
	  };

	  proto._getContainerSize = function() {
	    this.maxY = Math.max.apply( Math, this.colYs );
	    var size = {
	      height: this.maxY
	    };

	    if ( this._getOption('fitWidth') ) {
	      size.width = this._getContainerFitWidth();
	    }

	    return size;
	  };

	  proto._getContainerFitWidth = function() {
	    var unusedCols = 0;
	    // count unused columns
	    var i = this.cols;
	    while ( --i ) {
	      if ( this.colYs[i] !== 0 ) {
	        break;
	      }
	      unusedCols++;
	    }
	    // fit container to columns that have been used
	    return ( this.cols - unusedCols ) * this.columnWidth - this.gutter;
	  };

	  proto.needsResizeLayout = function() {
	    var previousWidth = this.containerWidth;
	    this.getContainerWidth();
	    return previousWidth != this.containerWidth;
	  };

	  return Masonry;

	}));


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Outlayer v2.1.1
	 * the brains and guts of a layout library
	 * MIT license
	 */

	( function( window, factory ) {
	  'use strict';
	  // universal module definition
	  /* jshint strict: false */ /* globals define, module, require */
	  if ( true ) {
	    // AMD - RequireJS
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(24),
	        __webpack_require__(25),
	        __webpack_require__(26),
	        __webpack_require__(28)
	      ], __WEBPACK_AMD_DEFINE_RESULT__ = function( EvEmitter, getSize, utils, Item ) {
	        return factory( window, EvEmitter, getSize, utils, Item);
	      }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if ( typeof module == 'object' && module.exports ) {
	    // CommonJS - Browserify, Webpack
	    module.exports = factory(
	      window,
	      require('ev-emitter'),
	      require('get-size'),
	      require('fizzy-ui-utils'),
	      require('./item')
	    );
	  } else {
	    // browser global
	    window.Outlayer = factory(
	      window,
	      window.EvEmitter,
	      window.getSize,
	      window.fizzyUIUtils,
	      window.Outlayer.Item
	    );
	  }

	}( window, function factory( window, EvEmitter, getSize, utils, Item ) {
	'use strict';

	// ----- vars ----- //

	var console = window.console;
	var jQuery = window.jQuery;
	var noop = function() {};

	// -------------------------- Outlayer -------------------------- //

	// globally unique identifiers
	var GUID = 0;
	// internal store of all Outlayer intances
	var instances = {};


	/**
	 * @param {Element, String} element
	 * @param {Object} options
	 * @constructor
	 */
	function Outlayer( element, options ) {
	  var queryElement = utils.getQueryElement( element );
	  if ( !queryElement ) {
	    if ( console ) {
	      console.error( 'Bad element for ' + this.constructor.namespace +
	        ': ' + ( queryElement || element ) );
	    }
	    return;
	  }
	  this.element = queryElement;
	  // add jQuery
	  if ( jQuery ) {
	    this.$element = jQuery( this.element );
	  }

	  // options
	  this.options = utils.extend( {}, this.constructor.defaults );
	  this.option( options );

	  // add id for Outlayer.getFromElement
	  var id = ++GUID;
	  this.element.outlayerGUID = id; // expando
	  instances[ id ] = this; // associate via id

	  // kick it off
	  this._create();

	  var isInitLayout = this._getOption('initLayout');
	  if ( isInitLayout ) {
	    this.layout();
	  }
	}

	// settings are for internal use only
	Outlayer.namespace = 'outlayer';
	Outlayer.Item = Item;

	// default options
	Outlayer.defaults = {
	  containerStyle: {
	    position: 'relative'
	  },
	  initLayout: true,
	  originLeft: true,
	  originTop: true,
	  resize: true,
	  resizeContainer: true,
	  // item options
	  transitionDuration: '0.4s',
	  hiddenStyle: {
	    opacity: 0,
	    transform: 'scale(0.001)'
	  },
	  visibleStyle: {
	    opacity: 1,
	    transform: 'scale(1)'
	  }
	};

	var proto = Outlayer.prototype;
	// inherit EvEmitter
	utils.extend( proto, EvEmitter.prototype );

	/**
	 * set options
	 * @param {Object} opts
	 */
	proto.option = function( opts ) {
	  utils.extend( this.options, opts );
	};

	/**
	 * get backwards compatible option value, check old name
	 */
	proto._getOption = function( option ) {
	  var oldOption = this.constructor.compatOptions[ option ];
	  return oldOption && this.options[ oldOption ] !== undefined ?
	    this.options[ oldOption ] : this.options[ option ];
	};

	Outlayer.compatOptions = {
	  // currentName: oldName
	  initLayout: 'isInitLayout',
	  horizontal: 'isHorizontal',
	  layoutInstant: 'isLayoutInstant',
	  originLeft: 'isOriginLeft',
	  originTop: 'isOriginTop',
	  resize: 'isResizeBound',
	  resizeContainer: 'isResizingContainer'
	};

	proto._create = function() {
	  // get items from children
	  this.reloadItems();
	  // elements that affect layout, but are not laid out
	  this.stamps = [];
	  this.stamp( this.options.stamp );
	  // set container style
	  utils.extend( this.element.style, this.options.containerStyle );

	  // bind resize method
	  var canBindResize = this._getOption('resize');
	  if ( canBindResize ) {
	    this.bindResize();
	  }
	};

	// goes through all children again and gets bricks in proper order
	proto.reloadItems = function() {
	  // collection of item elements
	  this.items = this._itemize( this.element.children );
	};


	/**
	 * turn elements into Outlayer.Items to be used in layout
	 * @param {Array or NodeList or HTMLElement} elems
	 * @returns {Array} items - collection of new Outlayer Items
	 */
	proto._itemize = function( elems ) {

	  var itemElems = this._filterFindItemElements( elems );
	  var Item = this.constructor.Item;

	  // create new Outlayer Items for collection
	  var items = [];
	  for ( var i=0; i < itemElems.length; i++ ) {
	    var elem = itemElems[i];
	    var item = new Item( elem, this );
	    items.push( item );
	  }

	  return items;
	};

	/**
	 * get item elements to be used in layout
	 * @param {Array or NodeList or HTMLElement} elems
	 * @returns {Array} items - item elements
	 */
	proto._filterFindItemElements = function( elems ) {
	  return utils.filterFindElements( elems, this.options.itemSelector );
	};

	/**
	 * getter method for getting item elements
	 * @returns {Array} elems - collection of item elements
	 */
	proto.getItemElements = function() {
	  return this.items.map( function( item ) {
	    return item.element;
	  });
	};

	// ----- init & layout ----- //

	/**
	 * lays out all items
	 */
	proto.layout = function() {
	  this._resetLayout();
	  this._manageStamps();

	  // don't animate first layout
	  var layoutInstant = this._getOption('layoutInstant');
	  var isInstant = layoutInstant !== undefined ?
	    layoutInstant : !this._isLayoutInited;
	  this.layoutItems( this.items, isInstant );

	  // flag for initalized
	  this._isLayoutInited = true;
	};

	// _init is alias for layout
	proto._init = proto.layout;

	/**
	 * logic before any new layout
	 */
	proto._resetLayout = function() {
	  this.getSize();
	};


	proto.getSize = function() {
	  this.size = getSize( this.element );
	};

	/**
	 * get measurement from option, for columnWidth, rowHeight, gutter
	 * if option is String -> get element from selector string, & get size of element
	 * if option is Element -> get size of element
	 * else use option as a number
	 *
	 * @param {String} measurement
	 * @param {String} size - width or height
	 * @private
	 */
	proto._getMeasurement = function( measurement, size ) {
	  var option = this.options[ measurement ];
	  var elem;
	  if ( !option ) {
	    // default to 0
	    this[ measurement ] = 0;
	  } else {
	    // use option as an element
	    if ( typeof option == 'string' ) {
	      elem = this.element.querySelector( option );
	    } else if ( option instanceof HTMLElement ) {
	      elem = option;
	    }
	    // use size of element, if element
	    this[ measurement ] = elem ? getSize( elem )[ size ] : option;
	  }
	};

	/**
	 * layout a collection of item elements
	 * @api public
	 */
	proto.layoutItems = function( items, isInstant ) {
	  items = this._getItemsForLayout( items );

	  this._layoutItems( items, isInstant );

	  this._postLayout();
	};

	/**
	 * get the items to be laid out
	 * you may want to skip over some items
	 * @param {Array} items
	 * @returns {Array} items
	 */
	proto._getItemsForLayout = function( items ) {
	  return items.filter( function( item ) {
	    return !item.isIgnored;
	  });
	};

	/**
	 * layout items
	 * @param {Array} items
	 * @param {Boolean} isInstant
	 */
	proto._layoutItems = function( items, isInstant ) {
	  this._emitCompleteOnItems( 'layout', items );

	  if ( !items || !items.length ) {
	    // no items, emit event with empty array
	    return;
	  }

	  var queue = [];

	  items.forEach( function( item ) {
	    // get x/y object from method
	    var position = this._getItemLayoutPosition( item );
	    // enqueue
	    position.item = item;
	    position.isInstant = isInstant || item.isLayoutInstant;
	    queue.push( position );
	  }, this );

	  this._processLayoutQueue( queue );
	};

	/**
	 * get item layout position
	 * @param {Outlayer.Item} item
	 * @returns {Object} x and y position
	 */
	proto._getItemLayoutPosition = function( /* item */ ) {
	  return {
	    x: 0,
	    y: 0
	  };
	};

	/**
	 * iterate over array and position each item
	 * Reason being - separating this logic prevents 'layout invalidation'
	 * thx @paul_irish
	 * @param {Array} queue
	 */
	proto._processLayoutQueue = function( queue ) {
	  this.updateStagger();
	  queue.forEach( function( obj, i ) {
	    this._positionItem( obj.item, obj.x, obj.y, obj.isInstant, i );
	  }, this );
	};

	// set stagger from option in milliseconds number
	proto.updateStagger = function() {
	  var stagger = this.options.stagger;
	  if ( stagger === null || stagger === undefined ) {
	    this.stagger = 0;
	    return;
	  }
	  this.stagger = getMilliseconds( stagger );
	  return this.stagger;
	};

	/**
	 * Sets position of item in DOM
	 * @param {Outlayer.Item} item
	 * @param {Number} x - horizontal position
	 * @param {Number} y - vertical position
	 * @param {Boolean} isInstant - disables transitions
	 */
	proto._positionItem = function( item, x, y, isInstant, i ) {
	  if ( isInstant ) {
	    // if not transition, just set CSS
	    item.goTo( x, y );
	  } else {
	    item.stagger( i * this.stagger );
	    item.moveTo( x, y );
	  }
	};

	/**
	 * Any logic you want to do after each layout,
	 * i.e. size the container
	 */
	proto._postLayout = function() {
	  this.resizeContainer();
	};

	proto.resizeContainer = function() {
	  var isResizingContainer = this._getOption('resizeContainer');
	  if ( !isResizingContainer ) {
	    return;
	  }
	  var size = this._getContainerSize();
	  if ( size ) {
	    this._setContainerMeasure( size.width, true );
	    this._setContainerMeasure( size.height, false );
	  }
	};

	/**
	 * Sets width or height of container if returned
	 * @returns {Object} size
	 *   @param {Number} width
	 *   @param {Number} height
	 */
	proto._getContainerSize = noop;

	/**
	 * @param {Number} measure - size of width or height
	 * @param {Boolean} isWidth
	 */
	proto._setContainerMeasure = function( measure, isWidth ) {
	  if ( measure === undefined ) {
	    return;
	  }

	  var elemSize = this.size;
	  // add padding and border width if border box
	  if ( elemSize.isBorderBox ) {
	    measure += isWidth ? elemSize.paddingLeft + elemSize.paddingRight +
	      elemSize.borderLeftWidth + elemSize.borderRightWidth :
	      elemSize.paddingBottom + elemSize.paddingTop +
	      elemSize.borderTopWidth + elemSize.borderBottomWidth;
	  }

	  measure = Math.max( measure, 0 );
	  this.element.style[ isWidth ? 'width' : 'height' ] = measure + 'px';
	};

	/**
	 * emit eventComplete on a collection of items events
	 * @param {String} eventName
	 * @param {Array} items - Outlayer.Items
	 */
	proto._emitCompleteOnItems = function( eventName, items ) {
	  var _this = this;
	  function onComplete() {
	    _this.dispatchEvent( eventName + 'Complete', null, [ items ] );
	  }

	  var count = items.length;
	  if ( !items || !count ) {
	    onComplete();
	    return;
	  }

	  var doneCount = 0;
	  function tick() {
	    doneCount++;
	    if ( doneCount == count ) {
	      onComplete();
	    }
	  }

	  // bind callback
	  items.forEach( function( item ) {
	    item.once( eventName, tick );
	  });
	};

	/**
	 * emits events via EvEmitter and jQuery events
	 * @param {String} type - name of event
	 * @param {Event} event - original event
	 * @param {Array} args - extra arguments
	 */
	proto.dispatchEvent = function( type, event, args ) {
	  // add original event to arguments
	  var emitArgs = event ? [ event ].concat( args ) : args;
	  this.emitEvent( type, emitArgs );

	  if ( jQuery ) {
	    // set this.$element
	    this.$element = this.$element || jQuery( this.element );
	    if ( event ) {
	      // create jQuery event
	      var $event = jQuery.Event( event );
	      $event.type = type;
	      this.$element.trigger( $event, args );
	    } else {
	      // just trigger with type if no event available
	      this.$element.trigger( type, args );
	    }
	  }
	};

	// -------------------------- ignore & stamps -------------------------- //


	/**
	 * keep item in collection, but do not lay it out
	 * ignored items do not get skipped in layout
	 * @param {Element} elem
	 */
	proto.ignore = function( elem ) {
	  var item = this.getItem( elem );
	  if ( item ) {
	    item.isIgnored = true;
	  }
	};

	/**
	 * return item to layout collection
	 * @param {Element} elem
	 */
	proto.unignore = function( elem ) {
	  var item = this.getItem( elem );
	  if ( item ) {
	    delete item.isIgnored;
	  }
	};

	/**
	 * adds elements to stamps
	 * @param {NodeList, Array, Element, or String} elems
	 */
	proto.stamp = function( elems ) {
	  elems = this._find( elems );
	  if ( !elems ) {
	    return;
	  }

	  this.stamps = this.stamps.concat( elems );
	  // ignore
	  elems.forEach( this.ignore, this );
	};

	/**
	 * removes elements to stamps
	 * @param {NodeList, Array, or Element} elems
	 */
	proto.unstamp = function( elems ) {
	  elems = this._find( elems );
	  if ( !elems ){
	    return;
	  }

	  elems.forEach( function( elem ) {
	    // filter out removed stamp elements
	    utils.removeFrom( this.stamps, elem );
	    this.unignore( elem );
	  }, this );
	};

	/**
	 * finds child elements
	 * @param {NodeList, Array, Element, or String} elems
	 * @returns {Array} elems
	 */
	proto._find = function( elems ) {
	  if ( !elems ) {
	    return;
	  }
	  // if string, use argument as selector string
	  if ( typeof elems == 'string' ) {
	    elems = this.element.querySelectorAll( elems );
	  }
	  elems = utils.makeArray( elems );
	  return elems;
	};

	proto._manageStamps = function() {
	  if ( !this.stamps || !this.stamps.length ) {
	    return;
	  }

	  this._getBoundingRect();

	  this.stamps.forEach( this._manageStamp, this );
	};

	// update boundingLeft / Top
	proto._getBoundingRect = function() {
	  // get bounding rect for container element
	  var boundingRect = this.element.getBoundingClientRect();
	  var size = this.size;
	  this._boundingRect = {
	    left: boundingRect.left + size.paddingLeft + size.borderLeftWidth,
	    top: boundingRect.top + size.paddingTop + size.borderTopWidth,
	    right: boundingRect.right - ( size.paddingRight + size.borderRightWidth ),
	    bottom: boundingRect.bottom - ( size.paddingBottom + size.borderBottomWidth )
	  };
	};

	/**
	 * @param {Element} stamp
	**/
	proto._manageStamp = noop;

	/**
	 * get x/y position of element relative to container element
	 * @param {Element} elem
	 * @returns {Object} offset - has left, top, right, bottom
	 */
	proto._getElementOffset = function( elem ) {
	  var boundingRect = elem.getBoundingClientRect();
	  var thisRect = this._boundingRect;
	  var size = getSize( elem );
	  var offset = {
	    left: boundingRect.left - thisRect.left - size.marginLeft,
	    top: boundingRect.top - thisRect.top - size.marginTop,
	    right: thisRect.right - boundingRect.right - size.marginRight,
	    bottom: thisRect.bottom - boundingRect.bottom - size.marginBottom
	  };
	  return offset;
	};

	// -------------------------- resize -------------------------- //

	// enable event handlers for listeners
	// i.e. resize -> onresize
	proto.handleEvent = utils.handleEvent;

	/**
	 * Bind layout to window resizing
	 */
	proto.bindResize = function() {
	  window.addEventListener( 'resize', this );
	  this.isResizeBound = true;
	};

	/**
	 * Unbind layout to window resizing
	 */
	proto.unbindResize = function() {
	  window.removeEventListener( 'resize', this );
	  this.isResizeBound = false;
	};

	proto.onresize = function() {
	  this.resize();
	};

	utils.debounceMethod( Outlayer, 'onresize', 100 );

	proto.resize = function() {
	  // don't trigger if size did not change
	  // or if resize was unbound. See #9
	  if ( !this.isResizeBound || !this.needsResizeLayout() ) {
	    return;
	  }

	  this.layout();
	};

	/**
	 * check if layout is needed post layout
	 * @returns Boolean
	 */
	proto.needsResizeLayout = function() {
	  var size = getSize( this.element );
	  // check that this.size and size are there
	  // IE8 triggers resize on body size change, so they might not be
	  var hasSizes = this.size && size;
	  return hasSizes && size.innerWidth !== this.size.innerWidth;
	};

	// -------------------------- methods -------------------------- //

	/**
	 * add items to Outlayer instance
	 * @param {Array or NodeList or Element} elems
	 * @returns {Array} items - Outlayer.Items
	**/
	proto.addItems = function( elems ) {
	  var items = this._itemize( elems );
	  // add items to collection
	  if ( items.length ) {
	    this.items = this.items.concat( items );
	  }
	  return items;
	};

	/**
	 * Layout newly-appended item elements
	 * @param {Array or NodeList or Element} elems
	 */
	proto.appended = function( elems ) {
	  var items = this.addItems( elems );
	  if ( !items.length ) {
	    return;
	  }
	  // layout and reveal just the new items
	  this.layoutItems( items, true );
	  this.reveal( items );
	};

	/**
	 * Layout prepended elements
	 * @param {Array or NodeList or Element} elems
	 */
	proto.prepended = function( elems ) {
	  var items = this._itemize( elems );
	  if ( !items.length ) {
	    return;
	  }
	  // add items to beginning of collection
	  var previousItems = this.items.slice(0);
	  this.items = items.concat( previousItems );
	  // start new layout
	  this._resetLayout();
	  this._manageStamps();
	  // layout new stuff without transition
	  this.layoutItems( items, true );
	  this.reveal( items );
	  // layout previous items
	  this.layoutItems( previousItems );
	};

	/**
	 * reveal a collection of items
	 * @param {Array of Outlayer.Items} items
	 */
	proto.reveal = function( items ) {
	  this._emitCompleteOnItems( 'reveal', items );
	  if ( !items || !items.length ) {
	    return;
	  }
	  var stagger = this.updateStagger();
	  items.forEach( function( item, i ) {
	    item.stagger( i * stagger );
	    item.reveal();
	  });
	};

	/**
	 * hide a collection of items
	 * @param {Array of Outlayer.Items} items
	 */
	proto.hide = function( items ) {
	  this._emitCompleteOnItems( 'hide', items );
	  if ( !items || !items.length ) {
	    return;
	  }
	  var stagger = this.updateStagger();
	  items.forEach( function( item, i ) {
	    item.stagger( i * stagger );
	    item.hide();
	  });
	};

	/**
	 * reveal item elements
	 * @param {Array}, {Element}, {NodeList} items
	 */
	proto.revealItemElements = function( elems ) {
	  var items = this.getItems( elems );
	  this.reveal( items );
	};

	/**
	 * hide item elements
	 * @param {Array}, {Element}, {NodeList} items
	 */
	proto.hideItemElements = function( elems ) {
	  var items = this.getItems( elems );
	  this.hide( items );
	};

	/**
	 * get Outlayer.Item, given an Element
	 * @param {Element} elem
	 * @param {Function} callback
	 * @returns {Outlayer.Item} item
	 */
	proto.getItem = function( elem ) {
	  // loop through items to get the one that matches
	  for ( var i=0; i < this.items.length; i++ ) {
	    var item = this.items[i];
	    if ( item.element == elem ) {
	      // return item
	      return item;
	    }
	  }
	};

	/**
	 * get collection of Outlayer.Items, given Elements
	 * @param {Array} elems
	 * @returns {Array} items - Outlayer.Items
	 */
	proto.getItems = function( elems ) {
	  elems = utils.makeArray( elems );
	  var items = [];
	  elems.forEach( function( elem ) {
	    var item = this.getItem( elem );
	    if ( item ) {
	      items.push( item );
	    }
	  }, this );

	  return items;
	};

	/**
	 * remove element(s) from instance and DOM
	 * @param {Array or NodeList or Element} elems
	 */
	proto.remove = function( elems ) {
	  var removeItems = this.getItems( elems );

	  this._emitCompleteOnItems( 'remove', removeItems );

	  // bail if no items to remove
	  if ( !removeItems || !removeItems.length ) {
	    return;
	  }

	  removeItems.forEach( function( item ) {
	    item.remove();
	    // remove item from collection
	    utils.removeFrom( this.items, item );
	  }, this );
	};

	// ----- destroy ----- //

	// remove and disable Outlayer instance
	proto.destroy = function() {
	  // clean up dynamic styles
	  var style = this.element.style;
	  style.height = '';
	  style.position = '';
	  style.width = '';
	  // destroy items
	  this.items.forEach( function( item ) {
	    item.destroy();
	  });

	  this.unbindResize();

	  var id = this.element.outlayerGUID;
	  delete instances[ id ]; // remove reference to instance by id
	  delete this.element.outlayerGUID;
	  // remove data for jQuery
	  if ( jQuery ) {
	    jQuery.removeData( this.element, this.constructor.namespace );
	  }

	};

	// -------------------------- data -------------------------- //

	/**
	 * get Outlayer instance from element
	 * @param {Element} elem
	 * @returns {Outlayer}
	 */
	Outlayer.data = function( elem ) {
	  elem = utils.getQueryElement( elem );
	  var id = elem && elem.outlayerGUID;
	  return id && instances[ id ];
	};


	// -------------------------- create Outlayer class -------------------------- //

	/**
	 * create a layout class
	 * @param {String} namespace
	 */
	Outlayer.create = function( namespace, options ) {
	  // sub-class Outlayer
	  var Layout = subclass( Outlayer );
	  // apply new options and compatOptions
	  Layout.defaults = utils.extend( {}, Outlayer.defaults );
	  utils.extend( Layout.defaults, options );
	  Layout.compatOptions = utils.extend( {}, Outlayer.compatOptions  );

	  Layout.namespace = namespace;

	  Layout.data = Outlayer.data;

	  // sub-class Item
	  Layout.Item = subclass( Item );

	  // -------------------------- declarative -------------------------- //

	  utils.htmlInit( Layout, namespace );

	  // -------------------------- jQuery bridge -------------------------- //

	  // make into jQuery plugin
	  if ( jQuery && jQuery.bridget ) {
	    jQuery.bridget( namespace, Layout );
	  }

	  return Layout;
	};

	function subclass( Parent ) {
	  function SubClass() {
	    Parent.apply( this, arguments );
	  }

	  SubClass.prototype = Object.create( Parent.prototype );
	  SubClass.prototype.constructor = SubClass;

	  return SubClass;
	}

	// ----- helpers ----- //

	// how many milliseconds are in each unit
	var msUnits = {
	  ms: 1,
	  s: 1000
	};

	// munge time-like parameter into millisecond number
	// '0.4s' -> 40
	function getMilliseconds( time ) {
	  if ( typeof time == 'number' ) {
	    return time;
	  }
	  var matches = time.match( /(^\d*\.?\d*)(\w*)/ );
	  var num = matches && matches[1];
	  var unit = matches && matches[2];
	  if ( !num.length ) {
	    return 0;
	  }
	  num = parseFloat( num );
	  var mult = msUnits[ unit ] || 1;
	  return num * mult;
	}

	// ----- fin ----- //

	// back in global
	Outlayer.Item = Item;

	return Outlayer;

	}));


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * EvEmitter v1.1.0
	 * Lil' event emitter
	 * MIT License
	 */

	/* jshint unused: true, undef: true, strict: true */

	( function( global, factory ) {
	  // universal module definition
	  /* jshint strict: false */ /* globals define, module, window */
	  if ( true ) {
	    // AMD - RequireJS
	    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if ( typeof module == 'object' && module.exports ) {
	    // CommonJS - Browserify, Webpack
	    module.exports = factory();
	  } else {
	    // Browser globals
	    global.EvEmitter = factory();
	  }

	}( typeof window != 'undefined' ? window : this, function() {

	"use strict";

	function EvEmitter() {}

	var proto = EvEmitter.prototype;

	proto.on = function( eventName, listener ) {
	  if ( !eventName || !listener ) {
	    return;
	  }
	  // set events hash
	  var events = this._events = this._events || {};
	  // set listeners array
	  var listeners = events[ eventName ] = events[ eventName ] || [];
	  // only add once
	  if ( listeners.indexOf( listener ) == -1 ) {
	    listeners.push( listener );
	  }

	  return this;
	};

	proto.once = function( eventName, listener ) {
	  if ( !eventName || !listener ) {
	    return;
	  }
	  // add event
	  this.on( eventName, listener );
	  // set once flag
	  // set onceEvents hash
	  var onceEvents = this._onceEvents = this._onceEvents || {};
	  // set onceListeners object
	  var onceListeners = onceEvents[ eventName ] = onceEvents[ eventName ] || {};
	  // set flag
	  onceListeners[ listener ] = true;

	  return this;
	};

	proto.off = function( eventName, listener ) {
	  var listeners = this._events && this._events[ eventName ];
	  if ( !listeners || !listeners.length ) {
	    return;
	  }
	  var index = listeners.indexOf( listener );
	  if ( index != -1 ) {
	    listeners.splice( index, 1 );
	  }

	  return this;
	};

	proto.emitEvent = function( eventName, args ) {
	  var listeners = this._events && this._events[ eventName ];
	  if ( !listeners || !listeners.length ) {
	    return;
	  }
	  // copy over to avoid interference if .off() in listener
	  listeners = listeners.slice(0);
	  args = args || [];
	  // once stuff
	  var onceListeners = this._onceEvents && this._onceEvents[ eventName ];

	  for ( var i=0; i < listeners.length; i++ ) {
	    var listener = listeners[i]
	    var isOnce = onceListeners && onceListeners[ listener ];
	    if ( isOnce ) {
	      // remove listener
	      // remove before trigger to prevent recursion
	      this.off( eventName, listener );
	      // unset once flag
	      delete onceListeners[ listener ];
	    }
	    // trigger listener
	    listener.apply( this, args );
	  }

	  return this;
	};

	proto.allOff = function() {
	  delete this._events;
	  delete this._onceEvents;
	};

	return EvEmitter;

	}));


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * getSize v2.0.2
	 * measure size of elements
	 * MIT license
	 */

	/*jshint browser: true, strict: true, undef: true, unused: true */
	/*global define: false, module: false, console: false */

	( function( window, factory ) {
	  'use strict';

	  if ( true ) {
	    // AMD
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return factory();
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if ( typeof module == 'object' && module.exports ) {
	    // CommonJS
	    module.exports = factory();
	  } else {
	    // browser global
	    window.getSize = factory();
	  }

	})( window, function factory() {
	'use strict';

	// -------------------------- helpers -------------------------- //

	// get a number from a string, not a percentage
	function getStyleSize( value ) {
	  var num = parseFloat( value );
	  // not a percent like '100%', and a number
	  var isValid = value.indexOf('%') == -1 && !isNaN( num );
	  return isValid && num;
	}

	function noop() {}

	var logError = typeof console == 'undefined' ? noop :
	  function( message ) {
	    console.error( message );
	  };

	// -------------------------- measurements -------------------------- //

	var measurements = [
	  'paddingLeft',
	  'paddingRight',
	  'paddingTop',
	  'paddingBottom',
	  'marginLeft',
	  'marginRight',
	  'marginTop',
	  'marginBottom',
	  'borderLeftWidth',
	  'borderRightWidth',
	  'borderTopWidth',
	  'borderBottomWidth'
	];

	var measurementsLength = measurements.length;

	function getZeroSize() {
	  var size = {
	    width: 0,
	    height: 0,
	    innerWidth: 0,
	    innerHeight: 0,
	    outerWidth: 0,
	    outerHeight: 0
	  };
	  for ( var i=0; i < measurementsLength; i++ ) {
	    var measurement = measurements[i];
	    size[ measurement ] = 0;
	  }
	  return size;
	}

	// -------------------------- getStyle -------------------------- //

	/**
	 * getStyle, get style of element, check for Firefox bug
	 * https://bugzilla.mozilla.org/show_bug.cgi?id=548397
	 */
	function getStyle( elem ) {
	  var style = getComputedStyle( elem );
	  if ( !style ) {
	    logError( 'Style returned ' + style +
	      '. Are you running this code in a hidden iframe on Firefox? ' +
	      'See http://bit.ly/getsizebug1' );
	  }
	  return style;
	}

	// -------------------------- setup -------------------------- //

	var isSetup = false;

	var isBoxSizeOuter;

	/**
	 * setup
	 * check isBoxSizerOuter
	 * do on first getSize() rather than on page load for Firefox bug
	 */
	function setup() {
	  // setup once
	  if ( isSetup ) {
	    return;
	  }
	  isSetup = true;

	  // -------------------------- box sizing -------------------------- //

	  /**
	   * WebKit measures the outer-width on style.width on border-box elems
	   * IE & Firefox<29 measures the inner-width
	   */
	  var div = document.createElement('div');
	  div.style.width = '200px';
	  div.style.padding = '1px 2px 3px 4px';
	  div.style.borderStyle = 'solid';
	  div.style.borderWidth = '1px 2px 3px 4px';
	  div.style.boxSizing = 'border-box';

	  var body = document.body || document.documentElement;
	  body.appendChild( div );
	  var style = getStyle( div );

	  getSize.isBoxSizeOuter = isBoxSizeOuter = getStyleSize( style.width ) == 200;
	  body.removeChild( div );

	}

	// -------------------------- getSize -------------------------- //

	function getSize( elem ) {
	  setup();

	  // use querySeletor if elem is string
	  if ( typeof elem == 'string' ) {
	    elem = document.querySelector( elem );
	  }

	  // do not proceed on non-objects
	  if ( !elem || typeof elem != 'object' || !elem.nodeType ) {
	    return;
	  }

	  var style = getStyle( elem );

	  // if hidden, everything is 0
	  if ( style.display == 'none' ) {
	    return getZeroSize();
	  }

	  var size = {};
	  size.width = elem.offsetWidth;
	  size.height = elem.offsetHeight;

	  var isBorderBox = size.isBorderBox = style.boxSizing == 'border-box';

	  // get all measurements
	  for ( var i=0; i < measurementsLength; i++ ) {
	    var measurement = measurements[i];
	    var value = style[ measurement ];
	    var num = parseFloat( value );
	    // any 'auto', 'medium' value will be 0
	    size[ measurement ] = !isNaN( num ) ? num : 0;
	  }

	  var paddingWidth = size.paddingLeft + size.paddingRight;
	  var paddingHeight = size.paddingTop + size.paddingBottom;
	  var marginWidth = size.marginLeft + size.marginRight;
	  var marginHeight = size.marginTop + size.marginBottom;
	  var borderWidth = size.borderLeftWidth + size.borderRightWidth;
	  var borderHeight = size.borderTopWidth + size.borderBottomWidth;

	  var isBorderBoxSizeOuter = isBorderBox && isBoxSizeOuter;

	  // overwrite width and height if we can get it from style
	  var styleWidth = getStyleSize( style.width );
	  if ( styleWidth !== false ) {
	    size.width = styleWidth +
	      // add padding and border unless it's already including it
	      ( isBorderBoxSizeOuter ? 0 : paddingWidth + borderWidth );
	  }

	  var styleHeight = getStyleSize( style.height );
	  if ( styleHeight !== false ) {
	    size.height = styleHeight +
	      // add padding and border unless it's already including it
	      ( isBorderBoxSizeOuter ? 0 : paddingHeight + borderHeight );
	  }

	  size.innerWidth = size.width - ( paddingWidth + borderWidth );
	  size.innerHeight = size.height - ( paddingHeight + borderHeight );

	  size.outerWidth = size.width + marginWidth;
	  size.outerHeight = size.height + marginHeight;

	  return size;
	}

	return getSize;

	});


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Fizzy UI utils v2.0.5
	 * MIT license
	 */

	/*jshint browser: true, undef: true, unused: true, strict: true */

	( function( window, factory ) {
	  // universal module definition
	  /*jshint strict: false */ /*globals define, module, require */

	  if ( true ) {
	    // AMD
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	      __webpack_require__(27)
	    ], __WEBPACK_AMD_DEFINE_RESULT__ = function( matchesSelector ) {
	      return factory( window, matchesSelector );
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if ( typeof module == 'object' && module.exports ) {
	    // CommonJS
	    module.exports = factory(
	      window,
	      require('desandro-matches-selector')
	    );
	  } else {
	    // browser global
	    window.fizzyUIUtils = factory(
	      window,
	      window.matchesSelector
	    );
	  }

	}( window, function factory( window, matchesSelector ) {

	'use strict';

	var utils = {};

	// ----- extend ----- //

	// extends objects
	utils.extend = function( a, b ) {
	  for ( var prop in b ) {
	    a[ prop ] = b[ prop ];
	  }
	  return a;
	};

	// ----- modulo ----- //

	utils.modulo = function( num, div ) {
	  return ( ( num % div ) + div ) % div;
	};

	// ----- makeArray ----- //

	// turn element or nodeList into an array
	utils.makeArray = function( obj ) {
	  var ary = [];
	  if ( Array.isArray( obj ) ) {
	    // use object if already an array
	    ary = obj;
	  } else if ( obj && typeof obj == 'object' &&
	    typeof obj.length == 'number' ) {
	    // convert nodeList to array
	    for ( var i=0; i < obj.length; i++ ) {
	      ary.push( obj[i] );
	    }
	  } else {
	    // array of single index
	    ary.push( obj );
	  }
	  return ary;
	};

	// ----- removeFrom ----- //

	utils.removeFrom = function( ary, obj ) {
	  var index = ary.indexOf( obj );
	  if ( index != -1 ) {
	    ary.splice( index, 1 );
	  }
	};

	// ----- getParent ----- //

	utils.getParent = function( elem, selector ) {
	  while ( elem.parentNode && elem != document.body ) {
	    elem = elem.parentNode;
	    if ( matchesSelector( elem, selector ) ) {
	      return elem;
	    }
	  }
	};

	// ----- getQueryElement ----- //

	// use element as selector string
	utils.getQueryElement = function( elem ) {
	  if ( typeof elem == 'string' ) {
	    return document.querySelector( elem );
	  }
	  return elem;
	};

	// ----- handleEvent ----- //

	// enable .ontype to trigger from .addEventListener( elem, 'type' )
	utils.handleEvent = function( event ) {
	  var method = 'on' + event.type;
	  if ( this[ method ] ) {
	    this[ method ]( event );
	  }
	};

	// ----- filterFindElements ----- //

	utils.filterFindElements = function( elems, selector ) {
	  // make array of elems
	  elems = utils.makeArray( elems );
	  var ffElems = [];

	  elems.forEach( function( elem ) {
	    // check that elem is an actual element
	    if ( !( elem instanceof HTMLElement ) ) {
	      return;
	    }
	    // add elem if no selector
	    if ( !selector ) {
	      ffElems.push( elem );
	      return;
	    }
	    // filter & find items if we have a selector
	    // filter
	    if ( matchesSelector( elem, selector ) ) {
	      ffElems.push( elem );
	    }
	    // find children
	    var childElems = elem.querySelectorAll( selector );
	    // concat childElems to filterFound array
	    for ( var i=0; i < childElems.length; i++ ) {
	      ffElems.push( childElems[i] );
	    }
	  });

	  return ffElems;
	};

	// ----- debounceMethod ----- //

	utils.debounceMethod = function( _class, methodName, threshold ) {
	  // original method
	  var method = _class.prototype[ methodName ];
	  var timeoutName = methodName + 'Timeout';

	  _class.prototype[ methodName ] = function() {
	    var timeout = this[ timeoutName ];
	    if ( timeout ) {
	      clearTimeout( timeout );
	    }
	    var args = arguments;

	    var _this = this;
	    this[ timeoutName ] = setTimeout( function() {
	      method.apply( _this, args );
	      delete _this[ timeoutName ];
	    }, threshold || 100 );
	  };
	};

	// ----- docReady ----- //

	utils.docReady = function( callback ) {
	  var readyState = document.readyState;
	  if ( readyState == 'complete' || readyState == 'interactive' ) {
	    // do async to allow for other scripts to run. metafizzy/flickity#441
	    setTimeout( callback );
	  } else {
	    document.addEventListener( 'DOMContentLoaded', callback );
	  }
	};

	// ----- htmlInit ----- //

	// http://jamesroberts.name/blog/2010/02/22/string-functions-for-javascript-trim-to-camel-case-to-dashed-and-to-underscore/
	utils.toDashed = function( str ) {
	  return str.replace( /(.)([A-Z])/g, function( match, $1, $2 ) {
	    return $1 + '-' + $2;
	  }).toLowerCase();
	};

	var console = window.console;
	/**
	 * allow user to initialize classes via [data-namespace] or .js-namespace class
	 * htmlInit( Widget, 'widgetName' )
	 * options are parsed from data-namespace-options
	 */
	utils.htmlInit = function( WidgetClass, namespace ) {
	  utils.docReady( function() {
	    var dashedNamespace = utils.toDashed( namespace );
	    var dataAttr = 'data-' + dashedNamespace;
	    var dataAttrElems = document.querySelectorAll( '[' + dataAttr + ']' );
	    var jsDashElems = document.querySelectorAll( '.js-' + dashedNamespace );
	    var elems = utils.makeArray( dataAttrElems )
	      .concat( utils.makeArray( jsDashElems ) );
	    var dataOptionsAttr = dataAttr + '-options';
	    var jQuery = window.jQuery;

	    elems.forEach( function( elem ) {
	      var attr = elem.getAttribute( dataAttr ) ||
	        elem.getAttribute( dataOptionsAttr );
	      var options;
	      try {
	        options = attr && JSON.parse( attr );
	      } catch ( error ) {
	        // log error, do not initialize
	        if ( console ) {
	          console.error( 'Error parsing ' + dataAttr + ' on ' + elem.className +
	          ': ' + error );
	        }
	        return;
	      }
	      // initialize
	      var instance = new WidgetClass( elem, options );
	      // make available via $().data('namespace')
	      if ( jQuery ) {
	        jQuery.data( elem, namespace, instance );
	      }
	    });

	  });
	};

	// -----  ----- //

	return utils;

	}));


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * matchesSelector v2.0.2
	 * matchesSelector( element, '.selector' )
	 * MIT license
	 */

	/*jshint browser: true, strict: true, undef: true, unused: true */

	( function( window, factory ) {
	  /*global define: false, module: false */
	  'use strict';
	  // universal module definition
	  if ( true ) {
	    // AMD
	    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if ( typeof module == 'object' && module.exports ) {
	    // CommonJS
	    module.exports = factory();
	  } else {
	    // browser global
	    window.matchesSelector = factory();
	  }

	}( window, function factory() {
	  'use strict';

	  var matchesMethod = ( function() {
	    var ElemProto = window.Element.prototype;
	    // check for the standard method name first
	    if ( ElemProto.matches ) {
	      return 'matches';
	    }
	    // check un-prefixed
	    if ( ElemProto.matchesSelector ) {
	      return 'matchesSelector';
	    }
	    // check vendor prefixes
	    var prefixes = [ 'webkit', 'moz', 'ms', 'o' ];

	    for ( var i=0; i < prefixes.length; i++ ) {
	      var prefix = prefixes[i];
	      var method = prefix + 'MatchesSelector';
	      if ( ElemProto[ method ] ) {
	        return method;
	      }
	    }
	  })();

	  return function matchesSelector( elem, selector ) {
	    return elem[ matchesMethod ]( selector );
	  };

	}));


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Outlayer Item
	 */

	( function( window, factory ) {
	  // universal module definition
	  /* jshint strict: false */ /* globals define, module, require */
	  if ( true ) {
	    // AMD - RequireJS
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
	        __webpack_require__(24),
	        __webpack_require__(25)
	      ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if ( typeof module == 'object' && module.exports ) {
	    // CommonJS - Browserify, Webpack
	    module.exports = factory(
	      require('ev-emitter'),
	      require('get-size')
	    );
	  } else {
	    // browser global
	    window.Outlayer = {};
	    window.Outlayer.Item = factory(
	      window.EvEmitter,
	      window.getSize
	    );
	  }

	}( window, function factory( EvEmitter, getSize ) {
	'use strict';

	// ----- helpers ----- //

	function isEmptyObj( obj ) {
	  for ( var prop in obj ) {
	    return false;
	  }
	  prop = null;
	  return true;
	}

	// -------------------------- CSS3 support -------------------------- //


	var docElemStyle = document.documentElement.style;

	var transitionProperty = typeof docElemStyle.transition == 'string' ?
	  'transition' : 'WebkitTransition';
	var transformProperty = typeof docElemStyle.transform == 'string' ?
	  'transform' : 'WebkitTransform';

	var transitionEndEvent = {
	  WebkitTransition: 'webkitTransitionEnd',
	  transition: 'transitionend'
	}[ transitionProperty ];

	// cache all vendor properties that could have vendor prefix
	var vendorProperties = {
	  transform: transformProperty,
	  transition: transitionProperty,
	  transitionDuration: transitionProperty + 'Duration',
	  transitionProperty: transitionProperty + 'Property',
	  transitionDelay: transitionProperty + 'Delay'
	};

	// -------------------------- Item -------------------------- //

	function Item( element, layout ) {
	  if ( !element ) {
	    return;
	  }

	  this.element = element;
	  // parent layout class, i.e. Masonry, Isotope, or Packery
	  this.layout = layout;
	  this.position = {
	    x: 0,
	    y: 0
	  };

	  this._create();
	}

	// inherit EvEmitter
	var proto = Item.prototype = Object.create( EvEmitter.prototype );
	proto.constructor = Item;

	proto._create = function() {
	  // transition objects
	  this._transn = {
	    ingProperties: {},
	    clean: {},
	    onEnd: {}
	  };

	  this.css({
	    position: 'absolute'
	  });
	};

	// trigger specified handler for event type
	proto.handleEvent = function( event ) {
	  var method = 'on' + event.type;
	  if ( this[ method ] ) {
	    this[ method ]( event );
	  }
	};

	proto.getSize = function() {
	  this.size = getSize( this.element );
	};

	/**
	 * apply CSS styles to element
	 * @param {Object} style
	 */
	proto.css = function( style ) {
	  var elemStyle = this.element.style;

	  for ( var prop in style ) {
	    // use vendor property if available
	    var supportedProp = vendorProperties[ prop ] || prop;
	    elemStyle[ supportedProp ] = style[ prop ];
	  }
	};

	 // measure position, and sets it
	proto.getPosition = function() {
	  var style = getComputedStyle( this.element );
	  var isOriginLeft = this.layout._getOption('originLeft');
	  var isOriginTop = this.layout._getOption('originTop');
	  var xValue = style[ isOriginLeft ? 'left' : 'right' ];
	  var yValue = style[ isOriginTop ? 'top' : 'bottom' ];
	  var x = parseFloat( xValue );
	  var y = parseFloat( yValue );
	  // convert percent to pixels
	  var layoutSize = this.layout.size;
	  if ( xValue.indexOf('%') != -1 ) {
	    x = ( x / 100 ) * layoutSize.width;
	  }
	  if ( yValue.indexOf('%') != -1 ) {
	    y = ( y / 100 ) * layoutSize.height;
	  }
	  // clean up 'auto' or other non-integer values
	  x = isNaN( x ) ? 0 : x;
	  y = isNaN( y ) ? 0 : y;
	  // remove padding from measurement
	  x -= isOriginLeft ? layoutSize.paddingLeft : layoutSize.paddingRight;
	  y -= isOriginTop ? layoutSize.paddingTop : layoutSize.paddingBottom;

	  this.position.x = x;
	  this.position.y = y;
	};

	// set settled position, apply padding
	proto.layoutPosition = function() {
	  var layoutSize = this.layout.size;
	  var style = {};
	  var isOriginLeft = this.layout._getOption('originLeft');
	  var isOriginTop = this.layout._getOption('originTop');

	  // x
	  var xPadding = isOriginLeft ? 'paddingLeft' : 'paddingRight';
	  var xProperty = isOriginLeft ? 'left' : 'right';
	  var xResetProperty = isOriginLeft ? 'right' : 'left';

	  var x = this.position.x + layoutSize[ xPadding ];
	  // set in percentage or pixels
	  style[ xProperty ] = this.getXValue( x );
	  // reset other property
	  style[ xResetProperty ] = '';

	  // y
	  var yPadding = isOriginTop ? 'paddingTop' : 'paddingBottom';
	  var yProperty = isOriginTop ? 'top' : 'bottom';
	  var yResetProperty = isOriginTop ? 'bottom' : 'top';

	  var y = this.position.y + layoutSize[ yPadding ];
	  // set in percentage or pixels
	  style[ yProperty ] = this.getYValue( y );
	  // reset other property
	  style[ yResetProperty ] = '';

	  this.css( style );
	  this.emitEvent( 'layout', [ this ] );
	};

	proto.getXValue = function( x ) {
	  var isHorizontal = this.layout._getOption('horizontal');
	  return this.layout.options.percentPosition && !isHorizontal ?
	    ( ( x / this.layout.size.width ) * 100 ) + '%' : x + 'px';
	};

	proto.getYValue = function( y ) {
	  var isHorizontal = this.layout._getOption('horizontal');
	  return this.layout.options.percentPosition && isHorizontal ?
	    ( ( y / this.layout.size.height ) * 100 ) + '%' : y + 'px';
	};

	proto._transitionTo = function( x, y ) {
	  this.getPosition();
	  // get current x & y from top/left
	  var curX = this.position.x;
	  var curY = this.position.y;

	  var didNotMove = x == this.position.x && y == this.position.y;

	  // save end position
	  this.setPosition( x, y );

	  // if did not move and not transitioning, just go to layout
	  if ( didNotMove && !this.isTransitioning ) {
	    this.layoutPosition();
	    return;
	  }

	  var transX = x - curX;
	  var transY = y - curY;
	  var transitionStyle = {};
	  transitionStyle.transform = this.getTranslate( transX, transY );

	  this.transition({
	    to: transitionStyle,
	    onTransitionEnd: {
	      transform: this.layoutPosition
	    },
	    isCleaning: true
	  });
	};

	proto.getTranslate = function( x, y ) {
	  // flip cooridinates if origin on right or bottom
	  var isOriginLeft = this.layout._getOption('originLeft');
	  var isOriginTop = this.layout._getOption('originTop');
	  x = isOriginLeft ? x : -x;
	  y = isOriginTop ? y : -y;
	  return 'translate3d(' + x + 'px, ' + y + 'px, 0)';
	};

	// non transition + transform support
	proto.goTo = function( x, y ) {
	  this.setPosition( x, y );
	  this.layoutPosition();
	};

	proto.moveTo = proto._transitionTo;

	proto.setPosition = function( x, y ) {
	  this.position.x = parseFloat( x );
	  this.position.y = parseFloat( y );
	};

	// ----- transition ----- //

	/**
	 * @param {Object} style - CSS
	 * @param {Function} onTransitionEnd
	 */

	// non transition, just trigger callback
	proto._nonTransition = function( args ) {
	  this.css( args.to );
	  if ( args.isCleaning ) {
	    this._removeStyles( args.to );
	  }
	  for ( var prop in args.onTransitionEnd ) {
	    args.onTransitionEnd[ prop ].call( this );
	  }
	};

	/**
	 * proper transition
	 * @param {Object} args - arguments
	 *   @param {Object} to - style to transition to
	 *   @param {Object} from - style to start transition from
	 *   @param {Boolean} isCleaning - removes transition styles after transition
	 *   @param {Function} onTransitionEnd - callback
	 */
	proto.transition = function( args ) {
	  // redirect to nonTransition if no transition duration
	  if ( !parseFloat( this.layout.options.transitionDuration ) ) {
	    this._nonTransition( args );
	    return;
	  }

	  var _transition = this._transn;
	  // keep track of onTransitionEnd callback by css property
	  for ( var prop in args.onTransitionEnd ) {
	    _transition.onEnd[ prop ] = args.onTransitionEnd[ prop ];
	  }
	  // keep track of properties that are transitioning
	  for ( prop in args.to ) {
	    _transition.ingProperties[ prop ] = true;
	    // keep track of properties to clean up when transition is done
	    if ( args.isCleaning ) {
	      _transition.clean[ prop ] = true;
	    }
	  }

	  // set from styles
	  if ( args.from ) {
	    this.css( args.from );
	    // force redraw. http://blog.alexmaccaw.com/css-transitions
	    var h = this.element.offsetHeight;
	    // hack for JSHint to hush about unused var
	    h = null;
	  }
	  // enable transition
	  this.enableTransition( args.to );
	  // set styles that are transitioning
	  this.css( args.to );

	  this.isTransitioning = true;

	};

	// dash before all cap letters, including first for
	// WebkitTransform => -webkit-transform
	function toDashedAll( str ) {
	  return str.replace( /([A-Z])/g, function( $1 ) {
	    return '-' + $1.toLowerCase();
	  });
	}

	var transitionProps = 'opacity,' + toDashedAll( transformProperty );

	proto.enableTransition = function(/* style */) {
	  // HACK changing transitionProperty during a transition
	  // will cause transition to jump
	  if ( this.isTransitioning ) {
	    return;
	  }

	  // make `transition: foo, bar, baz` from style object
	  // HACK un-comment this when enableTransition can work
	  // while a transition is happening
	  // var transitionValues = [];
	  // for ( var prop in style ) {
	  //   // dash-ify camelCased properties like WebkitTransition
	  //   prop = vendorProperties[ prop ] || prop;
	  //   transitionValues.push( toDashedAll( prop ) );
	  // }
	  // munge number to millisecond, to match stagger
	  var duration = this.layout.options.transitionDuration;
	  duration = typeof duration == 'number' ? duration + 'ms' : duration;
	  // enable transition styles
	  this.css({
	    transitionProperty: transitionProps,
	    transitionDuration: duration,
	    transitionDelay: this.staggerDelay || 0
	  });
	  // listen for transition end event
	  this.element.addEventListener( transitionEndEvent, this, false );
	};

	// ----- events ----- //

	proto.onwebkitTransitionEnd = function( event ) {
	  this.ontransitionend( event );
	};

	proto.onotransitionend = function( event ) {
	  this.ontransitionend( event );
	};

	// properties that I munge to make my life easier
	var dashedVendorProperties = {
	  '-webkit-transform': 'transform'
	};

	proto.ontransitionend = function( event ) {
	  // disregard bubbled events from children
	  if ( event.target !== this.element ) {
	    return;
	  }
	  var _transition = this._transn;
	  // get property name of transitioned property, convert to prefix-free
	  var propertyName = dashedVendorProperties[ event.propertyName ] || event.propertyName;

	  // remove property that has completed transitioning
	  delete _transition.ingProperties[ propertyName ];
	  // check if any properties are still transitioning
	  if ( isEmptyObj( _transition.ingProperties ) ) {
	    // all properties have completed transitioning
	    this.disableTransition();
	  }
	  // clean style
	  if ( propertyName in _transition.clean ) {
	    // clean up style
	    this.element.style[ event.propertyName ] = '';
	    delete _transition.clean[ propertyName ];
	  }
	  // trigger onTransitionEnd callback
	  if ( propertyName in _transition.onEnd ) {
	    var onTransitionEnd = _transition.onEnd[ propertyName ];
	    onTransitionEnd.call( this );
	    delete _transition.onEnd[ propertyName ];
	  }

	  this.emitEvent( 'transitionEnd', [ this ] );
	};

	proto.disableTransition = function() {
	  this.removeTransitionStyles();
	  this.element.removeEventListener( transitionEndEvent, this, false );
	  this.isTransitioning = false;
	};

	/**
	 * removes style property from element
	 * @param {Object} style
	**/
	proto._removeStyles = function( style ) {
	  // clean up transition styles
	  var cleanStyle = {};
	  for ( var prop in style ) {
	    cleanStyle[ prop ] = '';
	  }
	  this.css( cleanStyle );
	};

	var cleanTransitionStyle = {
	  transitionProperty: '',
	  transitionDuration: '',
	  transitionDelay: ''
	};

	proto.removeTransitionStyles = function() {
	  // remove transition
	  this.css( cleanTransitionStyle );
	};

	// ----- stagger ----- //

	proto.stagger = function( delay ) {
	  delay = isNaN( delay ) ? 0 : delay;
	  this.staggerDelay = delay + 'ms';
	};

	// ----- show/hide/remove ----- //

	// remove element from DOM
	proto.removeElem = function() {
	  this.element.parentNode.removeChild( this.element );
	  // remove display: none
	  this.css({ display: '' });
	  this.emitEvent( 'remove', [ this ] );
	};

	proto.remove = function() {
	  // just remove element if no transition support or no transition
	  if ( !transitionProperty || !parseFloat( this.layout.options.transitionDuration ) ) {
	    this.removeElem();
	    return;
	  }

	  // start transition
	  this.once( 'transitionEnd', function() {
	    this.removeElem();
	  });
	  this.hide();
	};

	proto.reveal = function() {
	  delete this.isHidden;
	  // remove display: none
	  this.css({ display: '' });

	  var options = this.layout.options;

	  var onTransitionEnd = {};
	  var transitionEndProperty = this.getHideRevealTransitionEndProperty('visibleStyle');
	  onTransitionEnd[ transitionEndProperty ] = this.onRevealTransitionEnd;

	  this.transition({
	    from: options.hiddenStyle,
	    to: options.visibleStyle,
	    isCleaning: true,
	    onTransitionEnd: onTransitionEnd
	  });
	};

	proto.onRevealTransitionEnd = function() {
	  // check if still visible
	  // during transition, item may have been hidden
	  if ( !this.isHidden ) {
	    this.emitEvent('reveal');
	  }
	};

	/**
	 * get style property use for hide/reveal transition end
	 * @param {String} styleProperty - hiddenStyle/visibleStyle
	 * @returns {String}
	 */
	proto.getHideRevealTransitionEndProperty = function( styleProperty ) {
	  var optionStyle = this.layout.options[ styleProperty ];
	  // use opacity
	  if ( optionStyle.opacity ) {
	    return 'opacity';
	  }
	  // get first property
	  for ( var prop in optionStyle ) {
	    return prop;
	  }
	};

	proto.hide = function() {
	  // set flag
	  this.isHidden = true;
	  // remove display: none
	  this.css({ display: '' });

	  var options = this.layout.options;

	  var onTransitionEnd = {};
	  var transitionEndProperty = this.getHideRevealTransitionEndProperty('hiddenStyle');
	  onTransitionEnd[ transitionEndProperty ] = this.onHideTransitionEnd;

	  this.transition({
	    from: options.visibleStyle,
	    to: options.hiddenStyle,
	    // keep hidden stuff hidden
	    isCleaning: true,
	    onTransitionEnd: onTransitionEnd
	  });
	};

	proto.onHideTransitionEnd = function() {
	  // check if still hidden
	  // during transition, item may have been un-hidden
	  if ( this.isHidden ) {
	    this.css({ display: 'none' });
	    this.emitEvent('hide');
	  }
	};

	proto.destroy = function() {
	  this.css({
	    position: '',
	    left: '',
	    right: '',
	    top: '',
	    bottom: '',
	    transition: '',
	    transform: ''
	  });
	};

	return Item;

	}));


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_1__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_LOCAL_MODULE_2__;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_3__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_LOCAL_MODULE_4__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_5__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_LOCAL_MODULE_6__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_7__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_8__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_9__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_10__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_11__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_LOCAL_MODULE_12__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Isotope PACKAGED v3.0.3
	 *
	 * Licensed GPLv3 for open source use
	 * or Isotope Commercial License for commercial use
	 *
	 * http://isotope.metafizzy.co
	 * Copyright 2017 Metafizzy
	 */

	!function(t,e){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(3)], __WEBPACK_AMD_DEFINE_RESULT__ = function(i){return e(t,i)}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):"object"==typeof module&&module.exports?module.exports=e(t,require("jquery")):t.jQueryBridget=e(t,t.jQuery)}(window,function(t,e){"use strict";function i(i,s,a){function u(t,e,n){var o,s="$()."+i+'("'+e+'")';return t.each(function(t,u){var h=a.data(u,i);if(!h)return void r(i+" not initialized. Cannot call methods, i.e. "+s);var d=h[e];if(!d||"_"==e.charAt(0))return void r(s+" is not a valid method");var l=d.apply(h,n);o=void 0===o?l:o}),void 0!==o?o:t}function h(t,e){t.each(function(t,n){var o=a.data(n,i);o?(o.option(e),o._init()):(o=new s(n,e),a.data(n,i,o))})}a=a||e||t.jQuery,a&&(s.prototype.option||(s.prototype.option=function(t){a.isPlainObject(t)&&(this.options=a.extend(!0,this.options,t))}),a.fn[i]=function(t){if("string"==typeof t){var e=o.call(arguments,1);return u(this,t,e)}return h(this,t),this},n(a))}function n(t){!t||t&&t.bridget||(t.bridget=i)}var o=Array.prototype.slice,s=t.console,r="undefined"==typeof s?function(){}:function(t){s.error(t)};return n(e||t.jQuery),i}),function(t,e){ true?!(__WEBPACK_AMD_DEFINE_FACTORY__ = (e), __WEBPACK_LOCAL_MODULE_1__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__)):"object"==typeof module&&module.exports?module.exports=e():t.EvEmitter=e()}("undefined"!=typeof window?window:this,function(){function t(){}var e=t.prototype;return e.on=function(t,e){if(t&&e){var i=this._events=this._events||{},n=i[t]=i[t]||[];return n.indexOf(e)==-1&&n.push(e),this}},e.once=function(t,e){if(t&&e){this.on(t,e);var i=this._onceEvents=this._onceEvents||{},n=i[t]=i[t]||{};return n[e]=!0,this}},e.off=function(t,e){var i=this._events&&this._events[t];if(i&&i.length){var n=i.indexOf(e);return n!=-1&&i.splice(n,1),this}},e.emitEvent=function(t,e){var i=this._events&&this._events[t];if(i&&i.length){var n=0,o=i[n];e=e||[];for(var s=this._onceEvents&&this._onceEvents[t];o;){var r=s&&s[o];r&&(this.off(t,o),delete s[o]),o.apply(this,e),n+=r?0:1,o=i[n]}return this}},t}),function(t,e){"use strict"; true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_LOCAL_MODULE_2__ = (function(){return e()}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__))):"object"==typeof module&&module.exports?module.exports=e():t.getSize=e()}(window,function(){"use strict";function t(t){var e=parseFloat(t),i=t.indexOf("%")==-1&&!isNaN(e);return i&&e}function e(){}function i(){for(var t={width:0,height:0,innerWidth:0,innerHeight:0,outerWidth:0,outerHeight:0},e=0;e<h;e++){var i=u[e];t[i]=0}return t}function n(t){var e=getComputedStyle(t);return e||a("Style returned "+e+". Are you running this code in a hidden iframe on Firefox? See http://bit.ly/getsizebug1"),e}function o(){if(!d){d=!0;var e=document.createElement("div");e.style.width="200px",e.style.padding="1px 2px 3px 4px",e.style.borderStyle="solid",e.style.borderWidth="1px 2px 3px 4px",e.style.boxSizing="border-box";var i=document.body||document.documentElement;i.appendChild(e);var o=n(e);s.isBoxSizeOuter=r=200==t(o.width),i.removeChild(e)}}function s(e){if(o(),"string"==typeof e&&(e=document.querySelector(e)),e&&"object"==typeof e&&e.nodeType){var s=n(e);if("none"==s.display)return i();var a={};a.width=e.offsetWidth,a.height=e.offsetHeight;for(var d=a.isBorderBox="border-box"==s.boxSizing,l=0;l<h;l++){var f=u[l],m=s[f],c=parseFloat(m);a[f]=isNaN(c)?0:c}var p=a.paddingLeft+a.paddingRight,y=a.paddingTop+a.paddingBottom,g=a.marginLeft+a.marginRight,v=a.marginTop+a.marginBottom,_=a.borderLeftWidth+a.borderRightWidth,I=a.borderTopWidth+a.borderBottomWidth,z=d&&r,S=t(s.width);S!==!1&&(a.width=S+(z?0:p+_));var x=t(s.height);return x!==!1&&(a.height=x+(z?0:y+I)),a.innerWidth=a.width-(p+_),a.innerHeight=a.height-(y+I),a.outerWidth=a.width+g,a.outerHeight=a.height+v,a}}var r,a="undefined"==typeof console?e:function(t){console.error(t)},u=["paddingLeft","paddingRight","paddingTop","paddingBottom","marginLeft","marginRight","marginTop","marginBottom","borderLeftWidth","borderRightWidth","borderTopWidth","borderBottomWidth"],h=u.length,d=!1;return s}),function(t,e){"use strict"; true?!(__WEBPACK_AMD_DEFINE_FACTORY__ = (e), __WEBPACK_LOCAL_MODULE_3__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__)):"object"==typeof module&&module.exports?module.exports=e():t.matchesSelector=e()}(window,function(){"use strict";var t=function(){var t=window.Element.prototype;if(t.matches)return"matches";if(t.matchesSelector)return"matchesSelector";for(var e=["webkit","moz","ms","o"],i=0;i<e.length;i++){var n=e[i],o=n+"MatchesSelector";if(t[o])return o}}();return function(e,i){return e[t](i)}}),function(t,e){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_3__], __WEBPACK_LOCAL_MODULE_4__ = (function(i){return e(t,i)}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__))):"object"==typeof module&&module.exports?module.exports=e(t,require("desandro-matches-selector")):t.fizzyUIUtils=e(t,t.matchesSelector)}(window,function(t,e){var i={};i.extend=function(t,e){for(var i in e)t[i]=e[i];return t},i.modulo=function(t,e){return(t%e+e)%e},i.makeArray=function(t){var e=[];if(Array.isArray(t))e=t;else if(t&&"object"==typeof t&&"number"==typeof t.length)for(var i=0;i<t.length;i++)e.push(t[i]);else e.push(t);return e},i.removeFrom=function(t,e){var i=t.indexOf(e);i!=-1&&t.splice(i,1)},i.getParent=function(t,i){for(;t!=document.body;)if(t=t.parentNode,e(t,i))return t},i.getQueryElement=function(t){return"string"==typeof t?document.querySelector(t):t},i.handleEvent=function(t){var e="on"+t.type;this[e]&&this[e](t)},i.filterFindElements=function(t,n){t=i.makeArray(t);var o=[];return t.forEach(function(t){if(t instanceof HTMLElement){if(!n)return void o.push(t);e(t,n)&&o.push(t);for(var i=t.querySelectorAll(n),s=0;s<i.length;s++)o.push(i[s])}}),o},i.debounceMethod=function(t,e,i){var n=t.prototype[e],o=e+"Timeout";t.prototype[e]=function(){var t=this[o];t&&clearTimeout(t);var e=arguments,s=this;this[o]=setTimeout(function(){n.apply(s,e),delete s[o]},i||100)}},i.docReady=function(t){var e=document.readyState;"complete"==e||"interactive"==e?setTimeout(t):document.addEventListener("DOMContentLoaded",t)},i.toDashed=function(t){return t.replace(/(.)([A-Z])/g,function(t,e,i){return e+"-"+i}).toLowerCase()};var n=t.console;return i.htmlInit=function(e,o){i.docReady(function(){var s=i.toDashed(o),r="data-"+s,a=document.querySelectorAll("["+r+"]"),u=document.querySelectorAll(".js-"+s),h=i.makeArray(a).concat(i.makeArray(u)),d=r+"-options",l=t.jQuery;h.forEach(function(t){var i,s=t.getAttribute(r)||t.getAttribute(d);try{i=s&&JSON.parse(s)}catch(a){return void(n&&n.error("Error parsing "+r+" on "+t.className+": "+a))}var u=new e(t,i);l&&l.data(t,o,u)})})},i}),function(t,e){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_1__,__WEBPACK_LOCAL_MODULE_2__], __WEBPACK_AMD_DEFINE_FACTORY__ = (e), __WEBPACK_LOCAL_MODULE_5__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__)):"object"==typeof module&&module.exports?module.exports=e(require("ev-emitter"),require("get-size")):(t.Outlayer={},t.Outlayer.Item=e(t.EvEmitter,t.getSize))}(window,function(t,e){"use strict";function i(t){for(var e in t)return!1;return e=null,!0}function n(t,e){t&&(this.element=t,this.layout=e,this.position={x:0,y:0},this._create())}function o(t){return t.replace(/([A-Z])/g,function(t){return"-"+t.toLowerCase()})}var s=document.documentElement.style,r="string"==typeof s.transition?"transition":"WebkitTransition",a="string"==typeof s.transform?"transform":"WebkitTransform",u={WebkitTransition:"webkitTransitionEnd",transition:"transitionend"}[r],h={transform:a,transition:r,transitionDuration:r+"Duration",transitionProperty:r+"Property",transitionDelay:r+"Delay"},d=n.prototype=Object.create(t.prototype);d.constructor=n,d._create=function(){this._transn={ingProperties:{},clean:{},onEnd:{}},this.css({position:"absolute"})},d.handleEvent=function(t){var e="on"+t.type;this[e]&&this[e](t)},d.getSize=function(){this.size=e(this.element)},d.css=function(t){var e=this.element.style;for(var i in t){var n=h[i]||i;e[n]=t[i]}},d.getPosition=function(){var t=getComputedStyle(this.element),e=this.layout._getOption("originLeft"),i=this.layout._getOption("originTop"),n=t[e?"left":"right"],o=t[i?"top":"bottom"],s=this.layout.size,r=n.indexOf("%")!=-1?parseFloat(n)/100*s.width:parseInt(n,10),a=o.indexOf("%")!=-1?parseFloat(o)/100*s.height:parseInt(o,10);r=isNaN(r)?0:r,a=isNaN(a)?0:a,r-=e?s.paddingLeft:s.paddingRight,a-=i?s.paddingTop:s.paddingBottom,this.position.x=r,this.position.y=a},d.layoutPosition=function(){var t=this.layout.size,e={},i=this.layout._getOption("originLeft"),n=this.layout._getOption("originTop"),o=i?"paddingLeft":"paddingRight",s=i?"left":"right",r=i?"right":"left",a=this.position.x+t[o];e[s]=this.getXValue(a),e[r]="";var u=n?"paddingTop":"paddingBottom",h=n?"top":"bottom",d=n?"bottom":"top",l=this.position.y+t[u];e[h]=this.getYValue(l),e[d]="",this.css(e),this.emitEvent("layout",[this])},d.getXValue=function(t){var e=this.layout._getOption("horizontal");return this.layout.options.percentPosition&&!e?t/this.layout.size.width*100+"%":t+"px"},d.getYValue=function(t){var e=this.layout._getOption("horizontal");return this.layout.options.percentPosition&&e?t/this.layout.size.height*100+"%":t+"px"},d._transitionTo=function(t,e){this.getPosition();var i=this.position.x,n=this.position.y,o=parseInt(t,10),s=parseInt(e,10),r=o===this.position.x&&s===this.position.y;if(this.setPosition(t,e),r&&!this.isTransitioning)return void this.layoutPosition();var a=t-i,u=e-n,h={};h.transform=this.getTranslate(a,u),this.transition({to:h,onTransitionEnd:{transform:this.layoutPosition},isCleaning:!0})},d.getTranslate=function(t,e){var i=this.layout._getOption("originLeft"),n=this.layout._getOption("originTop");return t=i?t:-t,e=n?e:-e,"translate3d("+t+"px, "+e+"px, 0)"},d.goTo=function(t,e){this.setPosition(t,e),this.layoutPosition()},d.moveTo=d._transitionTo,d.setPosition=function(t,e){this.position.x=parseInt(t,10),this.position.y=parseInt(e,10)},d._nonTransition=function(t){this.css(t.to),t.isCleaning&&this._removeStyles(t.to);for(var e in t.onTransitionEnd)t.onTransitionEnd[e].call(this)},d.transition=function(t){if(!parseFloat(this.layout.options.transitionDuration))return void this._nonTransition(t);var e=this._transn;for(var i in t.onTransitionEnd)e.onEnd[i]=t.onTransitionEnd[i];for(i in t.to)e.ingProperties[i]=!0,t.isCleaning&&(e.clean[i]=!0);if(t.from){this.css(t.from);var n=this.element.offsetHeight;n=null}this.enableTransition(t.to),this.css(t.to),this.isTransitioning=!0};var l="opacity,"+o(a);d.enableTransition=function(){if(!this.isTransitioning){var t=this.layout.options.transitionDuration;t="number"==typeof t?t+"ms":t,this.css({transitionProperty:l,transitionDuration:t,transitionDelay:this.staggerDelay||0}),this.element.addEventListener(u,this,!1)}},d.onwebkitTransitionEnd=function(t){this.ontransitionend(t)},d.onotransitionend=function(t){this.ontransitionend(t)};var f={"-webkit-transform":"transform"};d.ontransitionend=function(t){if(t.target===this.element){var e=this._transn,n=f[t.propertyName]||t.propertyName;if(delete e.ingProperties[n],i(e.ingProperties)&&this.disableTransition(),n in e.clean&&(this.element.style[t.propertyName]="",delete e.clean[n]),n in e.onEnd){var o=e.onEnd[n];o.call(this),delete e.onEnd[n]}this.emitEvent("transitionEnd",[this])}},d.disableTransition=function(){this.removeTransitionStyles(),this.element.removeEventListener(u,this,!1),this.isTransitioning=!1},d._removeStyles=function(t){var e={};for(var i in t)e[i]="";this.css(e)};var m={transitionProperty:"",transitionDuration:"",transitionDelay:""};return d.removeTransitionStyles=function(){this.css(m)},d.stagger=function(t){t=isNaN(t)?0:t,this.staggerDelay=t+"ms"},d.removeElem=function(){this.element.parentNode.removeChild(this.element),this.css({display:""}),this.emitEvent("remove",[this])},d.remove=function(){return r&&parseFloat(this.layout.options.transitionDuration)?(this.once("transitionEnd",function(){this.removeElem()}),void this.hide()):void this.removeElem()},d.reveal=function(){delete this.isHidden,this.css({display:""});var t=this.layout.options,e={},i=this.getHideRevealTransitionEndProperty("visibleStyle");e[i]=this.onRevealTransitionEnd,this.transition({from:t.hiddenStyle,to:t.visibleStyle,isCleaning:!0,onTransitionEnd:e})},d.onRevealTransitionEnd=function(){this.isHidden||this.emitEvent("reveal")},d.getHideRevealTransitionEndProperty=function(t){var e=this.layout.options[t];if(e.opacity)return"opacity";for(var i in e)return i},d.hide=function(){this.isHidden=!0,this.css({display:""});var t=this.layout.options,e={},i=this.getHideRevealTransitionEndProperty("hiddenStyle");e[i]=this.onHideTransitionEnd,this.transition({from:t.visibleStyle,to:t.hiddenStyle,isCleaning:!0,onTransitionEnd:e})},d.onHideTransitionEnd=function(){this.isHidden&&(this.css({display:"none"}),this.emitEvent("hide"))},d.destroy=function(){this.css({position:"",left:"",right:"",top:"",bottom:"",transition:"",transform:""})},n}),function(t,e){"use strict"; true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_1__,__WEBPACK_LOCAL_MODULE_2__,__WEBPACK_LOCAL_MODULE_4__,__WEBPACK_LOCAL_MODULE_5__], __WEBPACK_LOCAL_MODULE_6__ = (function(i,n,o,s){return e(t,i,n,o,s)}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__))):"object"==typeof module&&module.exports?module.exports=e(t,require("ev-emitter"),require("get-size"),require("fizzy-ui-utils"),require("./item")):t.Outlayer=e(t,t.EvEmitter,t.getSize,t.fizzyUIUtils,t.Outlayer.Item)}(window,function(t,e,i,n,o){"use strict";function s(t,e){var i=n.getQueryElement(t);if(!i)return void(u&&u.error("Bad element for "+this.constructor.namespace+": "+(i||t)));this.element=i,h&&(this.$element=h(this.element)),this.options=n.extend({},this.constructor.defaults),this.option(e);var o=++l;this.element.outlayerGUID=o,f[o]=this,this._create();var s=this._getOption("initLayout");s&&this.layout()}function r(t){function e(){t.apply(this,arguments)}return e.prototype=Object.create(t.prototype),e.prototype.constructor=e,e}function a(t){if("number"==typeof t)return t;var e=t.match(/(^\d*\.?\d*)(\w*)/),i=e&&e[1],n=e&&e[2];if(!i.length)return 0;i=parseFloat(i);var o=c[n]||1;return i*o}var u=t.console,h=t.jQuery,d=function(){},l=0,f={};s.namespace="outlayer",s.Item=o,s.defaults={containerStyle:{position:"relative"},initLayout:!0,originLeft:!0,originTop:!0,resize:!0,resizeContainer:!0,transitionDuration:"0.4s",hiddenStyle:{opacity:0,transform:"scale(0.001)"},visibleStyle:{opacity:1,transform:"scale(1)"}};var m=s.prototype;n.extend(m,e.prototype),m.option=function(t){n.extend(this.options,t)},m._getOption=function(t){var e=this.constructor.compatOptions[t];return e&&void 0!==this.options[e]?this.options[e]:this.options[t]},s.compatOptions={initLayout:"isInitLayout",horizontal:"isHorizontal",layoutInstant:"isLayoutInstant",originLeft:"isOriginLeft",originTop:"isOriginTop",resize:"isResizeBound",resizeContainer:"isResizingContainer"},m._create=function(){this.reloadItems(),this.stamps=[],this.stamp(this.options.stamp),n.extend(this.element.style,this.options.containerStyle);var t=this._getOption("resize");t&&this.bindResize()},m.reloadItems=function(){this.items=this._itemize(this.element.children)},m._itemize=function(t){for(var e=this._filterFindItemElements(t),i=this.constructor.Item,n=[],o=0;o<e.length;o++){var s=e[o],r=new i(s,this);n.push(r)}return n},m._filterFindItemElements=function(t){return n.filterFindElements(t,this.options.itemSelector)},m.getItemElements=function(){return this.items.map(function(t){return t.element})},m.layout=function(){this._resetLayout(),this._manageStamps();var t=this._getOption("layoutInstant"),e=void 0!==t?t:!this._isLayoutInited;this.layoutItems(this.items,e),this._isLayoutInited=!0},m._init=m.layout,m._resetLayout=function(){this.getSize()},m.getSize=function(){this.size=i(this.element)},m._getMeasurement=function(t,e){var n,o=this.options[t];o?("string"==typeof o?n=this.element.querySelector(o):o instanceof HTMLElement&&(n=o),this[t]=n?i(n)[e]:o):this[t]=0},m.layoutItems=function(t,e){t=this._getItemsForLayout(t),this._layoutItems(t,e),this._postLayout()},m._getItemsForLayout=function(t){return t.filter(function(t){return!t.isIgnored})},m._layoutItems=function(t,e){if(this._emitCompleteOnItems("layout",t),t&&t.length){var i=[];t.forEach(function(t){var n=this._getItemLayoutPosition(t);n.item=t,n.isInstant=e||t.isLayoutInstant,i.push(n)},this),this._processLayoutQueue(i)}},m._getItemLayoutPosition=function(){return{x:0,y:0}},m._processLayoutQueue=function(t){this.updateStagger(),t.forEach(function(t,e){this._positionItem(t.item,t.x,t.y,t.isInstant,e)},this)},m.updateStagger=function(){var t=this.options.stagger;return null===t||void 0===t?void(this.stagger=0):(this.stagger=a(t),this.stagger)},m._positionItem=function(t,e,i,n,o){n?t.goTo(e,i):(t.stagger(o*this.stagger),t.moveTo(e,i))},m._postLayout=function(){this.resizeContainer()},m.resizeContainer=function(){var t=this._getOption("resizeContainer");if(t){var e=this._getContainerSize();e&&(this._setContainerMeasure(e.width,!0),this._setContainerMeasure(e.height,!1))}},m._getContainerSize=d,m._setContainerMeasure=function(t,e){if(void 0!==t){var i=this.size;i.isBorderBox&&(t+=e?i.paddingLeft+i.paddingRight+i.borderLeftWidth+i.borderRightWidth:i.paddingBottom+i.paddingTop+i.borderTopWidth+i.borderBottomWidth),t=Math.max(t,0),this.element.style[e?"width":"height"]=t+"px"}},m._emitCompleteOnItems=function(t,e){function i(){o.dispatchEvent(t+"Complete",null,[e])}function n(){r++,r==s&&i()}var o=this,s=e.length;if(!e||!s)return void i();var r=0;e.forEach(function(e){e.once(t,n)})},m.dispatchEvent=function(t,e,i){var n=e?[e].concat(i):i;if(this.emitEvent(t,n),h)if(this.$element=this.$element||h(this.element),e){var o=h.Event(e);o.type=t,this.$element.trigger(o,i)}else this.$element.trigger(t,i)},m.ignore=function(t){var e=this.getItem(t);e&&(e.isIgnored=!0)},m.unignore=function(t){var e=this.getItem(t);e&&delete e.isIgnored},m.stamp=function(t){t=this._find(t),t&&(this.stamps=this.stamps.concat(t),t.forEach(this.ignore,this))},m.unstamp=function(t){t=this._find(t),t&&t.forEach(function(t){n.removeFrom(this.stamps,t),this.unignore(t)},this)},m._find=function(t){if(t)return"string"==typeof t&&(t=this.element.querySelectorAll(t)),t=n.makeArray(t)},m._manageStamps=function(){this.stamps&&this.stamps.length&&(this._getBoundingRect(),this.stamps.forEach(this._manageStamp,this))},m._getBoundingRect=function(){var t=this.element.getBoundingClientRect(),e=this.size;this._boundingRect={left:t.left+e.paddingLeft+e.borderLeftWidth,top:t.top+e.paddingTop+e.borderTopWidth,right:t.right-(e.paddingRight+e.borderRightWidth),bottom:t.bottom-(e.paddingBottom+e.borderBottomWidth)}},m._manageStamp=d,m._getElementOffset=function(t){var e=t.getBoundingClientRect(),n=this._boundingRect,o=i(t),s={left:e.left-n.left-o.marginLeft,top:e.top-n.top-o.marginTop,right:n.right-e.right-o.marginRight,bottom:n.bottom-e.bottom-o.marginBottom};return s},m.handleEvent=n.handleEvent,m.bindResize=function(){t.addEventListener("resize",this),this.isResizeBound=!0},m.unbindResize=function(){t.removeEventListener("resize",this),this.isResizeBound=!1},m.onresize=function(){this.resize()},n.debounceMethod(s,"onresize",100),m.resize=function(){this.isResizeBound&&this.needsResizeLayout()&&this.layout()},m.needsResizeLayout=function(){var t=i(this.element),e=this.size&&t;return e&&t.innerWidth!==this.size.innerWidth},m.addItems=function(t){var e=this._itemize(t);return e.length&&(this.items=this.items.concat(e)),e},m.appended=function(t){var e=this.addItems(t);e.length&&(this.layoutItems(e,!0),this.reveal(e))},m.prepended=function(t){var e=this._itemize(t);if(e.length){var i=this.items.slice(0);this.items=e.concat(i),this._resetLayout(),this._manageStamps(),this.layoutItems(e,!0),this.reveal(e),this.layoutItems(i)}},m.reveal=function(t){if(this._emitCompleteOnItems("reveal",t),t&&t.length){var e=this.updateStagger();t.forEach(function(t,i){t.stagger(i*e),t.reveal()})}},m.hide=function(t){if(this._emitCompleteOnItems("hide",t),t&&t.length){var e=this.updateStagger();t.forEach(function(t,i){t.stagger(i*e),t.hide()})}},m.revealItemElements=function(t){var e=this.getItems(t);this.reveal(e)},m.hideItemElements=function(t){var e=this.getItems(t);this.hide(e)},m.getItem=function(t){for(var e=0;e<this.items.length;e++){var i=this.items[e];if(i.element==t)return i}},m.getItems=function(t){t=n.makeArray(t);var e=[];return t.forEach(function(t){var i=this.getItem(t);i&&e.push(i)},this),e},m.remove=function(t){var e=this.getItems(t);this._emitCompleteOnItems("remove",e),e&&e.length&&e.forEach(function(t){t.remove(),n.removeFrom(this.items,t)},this)},m.destroy=function(){var t=this.element.style;t.height="",t.position="",t.width="",this.items.forEach(function(t){t.destroy()}),this.unbindResize();var e=this.element.outlayerGUID;delete f[e],delete this.element.outlayerGUID,h&&h.removeData(this.element,this.constructor.namespace)},s.data=function(t){t=n.getQueryElement(t);var e=t&&t.outlayerGUID;return e&&f[e]},s.create=function(t,e){var i=r(s);return i.defaults=n.extend({},s.defaults),n.extend(i.defaults,e),i.compatOptions=n.extend({},s.compatOptions),i.namespace=t,i.data=s.data,i.Item=r(o),n.htmlInit(i,t),h&&h.bridget&&h.bridget(t,i),i};var c={ms:1,s:1e3};return s.Item=o,s}),function(t,e){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_6__], __WEBPACK_AMD_DEFINE_FACTORY__ = (e), __WEBPACK_LOCAL_MODULE_7__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__)):"object"==typeof module&&module.exports?module.exports=e(require("outlayer")):(t.Isotope=t.Isotope||{},t.Isotope.Item=e(t.Outlayer))}(window,function(t){"use strict";function e(){t.Item.apply(this,arguments)}var i=e.prototype=Object.create(t.Item.prototype),n=i._create;i._create=function(){this.id=this.layout.itemGUID++,n.call(this),this.sortData={}},i.updateSortData=function(){if(!this.isIgnored){this.sortData.id=this.id,this.sortData["original-order"]=this.id,this.sortData.random=Math.random();var t=this.layout.options.getSortData,e=this.layout._sorters;for(var i in t){var n=e[i];this.sortData[i]=n(this.element,this)}}};var o=i.destroy;return i.destroy=function(){o.apply(this,arguments),this.css({display:""})},e}),function(t,e){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_2__,__WEBPACK_LOCAL_MODULE_6__], __WEBPACK_AMD_DEFINE_FACTORY__ = (e), __WEBPACK_LOCAL_MODULE_8__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__)):"object"==typeof module&&module.exports?module.exports=e(require("get-size"),require("outlayer")):(t.Isotope=t.Isotope||{},t.Isotope.LayoutMode=e(t.getSize,t.Outlayer))}(window,function(t,e){"use strict";function i(t){this.isotope=t,t&&(this.options=t.options[this.namespace],this.element=t.element,this.items=t.filteredItems,this.size=t.size)}var n=i.prototype,o=["_resetLayout","_getItemLayoutPosition","_manageStamp","_getContainerSize","_getElementOffset","needsResizeLayout","_getOption"];return o.forEach(function(t){n[t]=function(){return e.prototype[t].apply(this.isotope,arguments)}}),n.needsVerticalResizeLayout=function(){var e=t(this.isotope.element),i=this.isotope.size&&e;return i&&e.innerHeight!=this.isotope.size.innerHeight},n._getMeasurement=function(){this.isotope._getMeasurement.apply(this,arguments)},n.getColumnWidth=function(){this.getSegmentSize("column","Width")},n.getRowHeight=function(){this.getSegmentSize("row","Height")},n.getSegmentSize=function(t,e){var i=t+e,n="outer"+e;if(this._getMeasurement(i,n),!this[i]){var o=this.getFirstItemSize();this[i]=o&&o[n]||this.isotope.size["inner"+e]}},n.getFirstItemSize=function(){var e=this.isotope.filteredItems[0];return e&&e.element&&t(e.element)},n.layout=function(){this.isotope.layout.apply(this.isotope,arguments)},n.getSize=function(){this.isotope.getSize(),this.size=this.isotope.size},i.modes={},i.create=function(t,e){function o(){i.apply(this,arguments)}return o.prototype=Object.create(n),o.prototype.constructor=o,e&&(o.options=e),o.prototype.namespace=t,i.modes[t]=o,o},i}),function(t,e){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_6__,__WEBPACK_LOCAL_MODULE_2__], __WEBPACK_AMD_DEFINE_FACTORY__ = (e), __WEBPACK_LOCAL_MODULE_9__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__)):"object"==typeof module&&module.exports?module.exports=e(require("outlayer"),require("get-size")):t.Masonry=e(t.Outlayer,t.getSize)}(window,function(t,e){var i=t.create("masonry");return i.compatOptions.fitWidth="isFitWidth",i.prototype._resetLayout=function(){this.getSize(),this._getMeasurement("columnWidth","outerWidth"),this._getMeasurement("gutter","outerWidth"),this.measureColumns(),this.colYs=[];for(var t=0;t<this.cols;t++)this.colYs.push(0);this.maxY=0},i.prototype.measureColumns=function(){if(this.getContainerWidth(),!this.columnWidth){var t=this.items[0],i=t&&t.element;this.columnWidth=i&&e(i).outerWidth||this.containerWidth}var n=this.columnWidth+=this.gutter,o=this.containerWidth+this.gutter,s=o/n,r=n-o%n,a=r&&r<1?"round":"floor";s=Math[a](s),this.cols=Math.max(s,1)},i.prototype.getContainerWidth=function(){var t=this._getOption("fitWidth"),i=t?this.element.parentNode:this.element,n=e(i);this.containerWidth=n&&n.innerWidth},i.prototype._getItemLayoutPosition=function(t){t.getSize();var e=t.size.outerWidth%this.columnWidth,i=e&&e<1?"round":"ceil",n=Math[i](t.size.outerWidth/this.columnWidth);n=Math.min(n,this.cols);for(var o=this._getColGroup(n),s=Math.min.apply(Math,o),r=o.indexOf(s),a={x:this.columnWidth*r,y:s},u=s+t.size.outerHeight,h=this.cols+1-o.length,d=0;d<h;d++)this.colYs[r+d]=u;return a},i.prototype._getColGroup=function(t){if(t<2)return this.colYs;for(var e=[],i=this.cols+1-t,n=0;n<i;n++){var o=this.colYs.slice(n,n+t);e[n]=Math.max.apply(Math,o)}return e},i.prototype._manageStamp=function(t){var i=e(t),n=this._getElementOffset(t),o=this._getOption("originLeft"),s=o?n.left:n.right,r=s+i.outerWidth,a=Math.floor(s/this.columnWidth);a=Math.max(0,a);var u=Math.floor(r/this.columnWidth);u-=r%this.columnWidth?0:1,u=Math.min(this.cols-1,u);for(var h=this._getOption("originTop"),d=(h?n.top:n.bottom)+i.outerHeight,l=a;l<=u;l++)this.colYs[l]=Math.max(d,this.colYs[l])},i.prototype._getContainerSize=function(){this.maxY=Math.max.apply(Math,this.colYs);var t={height:this.maxY};return this._getOption("fitWidth")&&(t.width=this._getContainerFitWidth()),t},i.prototype._getContainerFitWidth=function(){for(var t=0,e=this.cols;--e&&0===this.colYs[e];)t++;return(this.cols-t)*this.columnWidth-this.gutter},i.prototype.needsResizeLayout=function(){var t=this.containerWidth;return this.getContainerWidth(),t!=this.containerWidth},i}),function(t,e){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_8__,__WEBPACK_LOCAL_MODULE_9__], __WEBPACK_AMD_DEFINE_FACTORY__ = (e), __WEBPACK_LOCAL_MODULE_10__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__)):"object"==typeof module&&module.exports?module.exports=e(require("../layout-mode"),require("masonry-layout")):e(t.Isotope.LayoutMode,t.Masonry)}(window,function(t,e){"use strict";var i=t.create("masonry"),n=i.prototype,o={_getElementOffset:!0,layout:!0,_getMeasurement:!0};for(var s in e.prototype)o[s]||(n[s]=e.prototype[s]);var r=n.measureColumns;n.measureColumns=function(){this.items=this.isotope.filteredItems,r.call(this)};var a=n._getOption;return n._getOption=function(t){return"fitWidth"==t?void 0!==this.options.isFitWidth?this.options.isFitWidth:this.options.fitWidth:a.apply(this.isotope,arguments)},i}),function(t,e){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_8__], __WEBPACK_AMD_DEFINE_FACTORY__ = (e), __WEBPACK_LOCAL_MODULE_11__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__)):"object"==typeof exports?module.exports=e(require("../layout-mode")):e(t.Isotope.LayoutMode)}(window,function(t){"use strict";var e=t.create("fitRows"),i=e.prototype;return i._resetLayout=function(){this.x=0,this.y=0,this.maxY=0,this._getMeasurement("gutter","outerWidth")},i._getItemLayoutPosition=function(t){t.getSize();var e=t.size.outerWidth+this.gutter,i=this.isotope.size.innerWidth+this.gutter;0!==this.x&&e+this.x>i&&(this.x=0,this.y=this.maxY);var n={x:this.x,y:this.y};return this.maxY=Math.max(this.maxY,this.y+t.size.outerHeight),this.x+=e,n},i._getContainerSize=function(){return{height:this.maxY}},e}),function(t,e){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_8__], __WEBPACK_AMD_DEFINE_FACTORY__ = (e), __WEBPACK_LOCAL_MODULE_12__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__)):"object"==typeof module&&module.exports?module.exports=e(require("../layout-mode")):e(t.Isotope.LayoutMode)}(window,function(t){"use strict";var e=t.create("vertical",{horizontalAlignment:0}),i=e.prototype;return i._resetLayout=function(){this.y=0},i._getItemLayoutPosition=function(t){t.getSize();var e=(this.isotope.size.innerWidth-t.size.outerWidth)*this.options.horizontalAlignment,i=this.y;return this.y+=t.size.outerHeight,{x:e,y:i}},i._getContainerSize=function(){return{height:this.y}},e}),function(t,e){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_6__,__WEBPACK_LOCAL_MODULE_2__,__WEBPACK_LOCAL_MODULE_3__,__WEBPACK_LOCAL_MODULE_4__,__WEBPACK_LOCAL_MODULE_7__,__WEBPACK_LOCAL_MODULE_8__,__WEBPACK_LOCAL_MODULE_10__,__WEBPACK_LOCAL_MODULE_11__,__WEBPACK_LOCAL_MODULE_12__], __WEBPACK_AMD_DEFINE_RESULT__ = function(i,n,o,s,r,a){return e(t,i,n,o,s,r,a)}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):"object"==typeof module&&module.exports?module.exports=e(t,require("outlayer"),require("get-size"),require("desandro-matches-selector"),require("fizzy-ui-utils"),require("isotope/js/item"),require("isotope/js/layout-mode"),require("isotope/js/layout-modes/masonry"),require("isotope/js/layout-modes/fit-rows"),require("isotope/js/layout-modes/vertical")):t.Isotope=e(t,t.Outlayer,t.getSize,t.matchesSelector,t.fizzyUIUtils,t.Isotope.Item,t.Isotope.LayoutMode)}(window,function(t,e,i,n,o,s,r){function a(t,e){return function(i,n){for(var o=0;o<t.length;o++){var s=t[o],r=i.sortData[s],a=n.sortData[s];if(r>a||r<a){var u=void 0!==e[s]?e[s]:e,h=u?1:-1;return(r>a?1:-1)*h}}return 0}}var u=t.jQuery,h=String.prototype.trim?function(t){return t.trim()}:function(t){return t.replace(/^\s+|\s+$/g,"")},d=e.create("isotope",{layoutMode:"masonry",isJQueryFiltering:!0,sortAscending:!0});d.Item=s,d.LayoutMode=r;var l=d.prototype;l._create=function(){this.itemGUID=0,this._sorters={},this._getSorters(),e.prototype._create.call(this),this.modes={},this.filteredItems=this.items,this.sortHistory=["original-order"];for(var t in r.modes)this._initLayoutMode(t)},l.reloadItems=function(){this.itemGUID=0,e.prototype.reloadItems.call(this)},l._itemize=function(){for(var t=e.prototype._itemize.apply(this,arguments),i=0;i<t.length;i++){var n=t[i];n.id=this.itemGUID++}return this._updateItemsSortData(t),t},l._initLayoutMode=function(t){var e=r.modes[t],i=this.options[t]||{};this.options[t]=e.options?o.extend(e.options,i):i,this.modes[t]=new e(this)},l.layout=function(){return!this._isLayoutInited&&this._getOption("initLayout")?void this.arrange():void this._layout()},l._layout=function(){var t=this._getIsInstant();this._resetLayout(),this._manageStamps(),this.layoutItems(this.filteredItems,t),this._isLayoutInited=!0},l.arrange=function(t){this.option(t),this._getIsInstant();var e=this._filter(this.items);this.filteredItems=e.matches,this._bindArrangeComplete(),this._isInstant?this._noTransition(this._hideReveal,[e]):this._hideReveal(e),this._sort(),this._layout()},l._init=l.arrange,l._hideReveal=function(t){this.reveal(t.needReveal),this.hide(t.needHide)},l._getIsInstant=function(){var t=this._getOption("layoutInstant"),e=void 0!==t?t:!this._isLayoutInited;return this._isInstant=e,e},l._bindArrangeComplete=function(){function t(){e&&i&&n&&o.dispatchEvent("arrangeComplete",null,[o.filteredItems])}var e,i,n,o=this;this.once("layoutComplete",function(){e=!0,t()}),this.once("hideComplete",function(){i=!0,t()}),this.once("revealComplete",function(){n=!0,t()})},l._filter=function(t){var e=this.options.filter;e=e||"*";for(var i=[],n=[],o=[],s=this._getFilterTest(e),r=0;r<t.length;r++){var a=t[r];if(!a.isIgnored){var u=s(a);u&&i.push(a),u&&a.isHidden?n.push(a):u||a.isHidden||o.push(a)}}return{matches:i,needReveal:n,needHide:o}},l._getFilterTest=function(t){return u&&this.options.isJQueryFiltering?function(e){return u(e.element).is(t)}:"function"==typeof t?function(e){return t(e.element)}:function(e){return n(e.element,t)}},l.updateSortData=function(t){var e;t?(t=o.makeArray(t),e=this.getItems(t)):e=this.items,this._getSorters(),this._updateItemsSortData(e)},l._getSorters=function(){var t=this.options.getSortData;for(var e in t){var i=t[e];this._sorters[e]=f(i)}},l._updateItemsSortData=function(t){for(var e=t&&t.length,i=0;e&&i<e;i++){var n=t[i];n.updateSortData()}};var f=function(){function t(t){if("string"!=typeof t)return t;var i=h(t).split(" "),n=i[0],o=n.match(/^\[(.+)\]$/),s=o&&o[1],r=e(s,n),a=d.sortDataParsers[i[1]];
	    return t=a?function(t){return t&&a(r(t))}:function(t){return t&&r(t)}}function e(t,e){return t?function(e){return e.getAttribute(t)}:function(t){var i=t.querySelector(e);return i&&i.textContent}}return t}();d.sortDataParsers={parseInt:function(t){return parseInt(t,10)},parseFloat:function(t){return parseFloat(t)}},l._sort=function(){if(this.options.sortBy){var t=o.makeArray(this.options.sortBy);this._getIsSameSortBy(t)||(this.sortHistory=t.concat(this.sortHistory));var e=a(this.sortHistory,this.options.sortAscending);this.filteredItems.sort(e)}},l._getIsSameSortBy=function(t){for(var e=0;e<t.length;e++)if(t[e]!=this.sortHistory[e])return!1;return!0},l._mode=function(){var t=this.options.layoutMode,e=this.modes[t];if(!e)throw new Error("No layout mode: "+t);return e.options=this.options[t],e},l._resetLayout=function(){e.prototype._resetLayout.call(this),this._mode()._resetLayout()},l._getItemLayoutPosition=function(t){return this._mode()._getItemLayoutPosition(t)},l._manageStamp=function(t){this._mode()._manageStamp(t)},l._getContainerSize=function(){return this._mode()._getContainerSize()},l.needsResizeLayout=function(){return this._mode().needsResizeLayout()},l.appended=function(t){var e=this.addItems(t);if(e.length){var i=this._filterRevealAdded(e);this.filteredItems=this.filteredItems.concat(i)}},l.prepended=function(t){var e=this._itemize(t);if(e.length){this._resetLayout(),this._manageStamps();var i=this._filterRevealAdded(e);this.layoutItems(this.filteredItems),this.filteredItems=i.concat(this.filteredItems),this.items=e.concat(this.items)}},l._filterRevealAdded=function(t){var e=this._filter(t);return this.hide(e.needHide),this.reveal(e.matches),this.layoutItems(e.matches,!0),e.matches},l.insert=function(t){var e=this.addItems(t);if(e.length){var i,n,o=e.length;for(i=0;i<o;i++)n=e[i],this.element.appendChild(n.element);var s=this._filter(e).matches;for(i=0;i<o;i++)e[i].isLayoutInstant=!0;for(this.arrange(),i=0;i<o;i++)delete e[i].isLayoutInstant;this.reveal(s)}};var m=l.remove;return l.remove=function(t){t=o.makeArray(t);var e=this.getItems(t);m.call(this,t);for(var i=e&&e.length,n=0;i&&n<i;n++){var s=e[n];o.removeFrom(this.filteredItems,s)}},l.shuffle=function(){for(var t=0;t<this.items.length;t++){var e=this.items[t];e.sortData.random=Math.random()}this.options.sortBy="random",this._sort(),this._layout()},l._noTransition=function(t,e){var i=this.options.transitionDuration;this.options.transitionDuration=0;var n=t.apply(this,e);return this.options.transitionDuration=i,n},l.getFilteredItemElements=function(){return this.filteredItems.map(function(t){return t.element})},d});

/***/ }),
/* 30 */
/***/ (function(module, exports) {

	jQuery(function ($) {
	    "use strict";
	    /*=======================================
	     Hero Section
	     =======================================*/
	    if ($('section.hero-header').length > 0) {
	        var $mainnav = $('.mainnav').height();
	        $('section.hero-header').height($(window).height());
	        // Window Resize
	        $(window).resize(function () {
	            $('section.hero-header').height($(window).height());
	        });
	    }
	    /*=======================================
	     Cut Section
	     =======================================*/
	    if ($('.cut').length > 0) {
	        $('.cut').each(function () {
	            if ($(this).hasClass('cut-top'))
	                $(this).css('border-right-width', $(this).parent().width() + "px");
	            else if ($(this).hasClass('cut-bottom'))
	                $(this).css('border-left-width', $(this).parent().width() + "px");
	        });

	    }
	});

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	/* PaperPanel
	 *
	 * @type Object
	 * @description $.PaperPanel is the main object for the template's app.
	 *              It's used for implementing functions and options related
	 *              to the template. Keeping everything wrapped in an object
	 *              prevents conflict with other plugins and is a better
	 *              way to organize our code.
	 */

	__webpack_require__(32);

	$.PaperPanel = {};

	/* --------------------
	 * - PaperPanel Options -
	 * --------------------
	 * Modify these options to suit your implementation
	 */
	$.PaperPanel.options = {

	    animationSpeed: 500,
	    //Sidebar push menu toggle button selector
	    sidebarToggleSelector: "[data-toggle='offcanvas']",
	    //Activate sidebar push menu
	    sidebarPushMenu: true,
	    navbarMenuSlimscrollWidth: "3px",
	    sidebarSlimScroll: true,
	    controlSidebarOptions: {
	        //Which button should trigger the open/close event
	        toggleBtnSelector: "[data-toggle='control-sidebar']",
	        //The sidebar selector
	        selector: ".control-sidebar",
	        //Enable slide over content
	        slide: true
	    },

	    //The standard screen sizes that bootstrap uses.
	    //If you change these in the variables.less file, change
	    //them here too.
	    screenSizes: {
	        xs: 480,
	        sm: 768,
	        md: 1025,
	        lg: 1200
	    }
	};

	/* ------------------
	 * - Implementation -
	 * ------------------
	 * The next block of code implements PaperPanel's
	 * functions and plugins as specified by the
	 * options above.
	 */
	$(function () {
	    "use strict";

	    //Fix for IE page transitions
	    $("body").removeClass("hold-transition");

	    //Extend options if external options exist
	    if (typeof PaperPanelOptions !== "undefined") {
	        $.extend(true,
	            $.PaperPanel.options,
	            PaperPanelOptions);
	    }

	    //Easy access to options
	    var o = $.PaperPanel.options;

	    //Set up the object
	    _init();

	    //Activate the layout maker
	    $.PaperPanel.layout.activate();

	    //Enable sidebar tree view controls
	    $.PaperPanel.tree('.sidebar');

	    //Enable control sidebar
	    if (o.enableControlSidebar) {
	        $.PaperPanel.controlSidebar.activate();
	    }

	    //Activate sidebar push menu
	    if (o.sidebarPushMenu) {
	        $.PaperPanel.pushMenu.activate(o.sidebarToggleSelector);
	    }
	    /*
	     * INITIALIZE BUTTON TOGGLE
	     * ------------------------
	     */
	    $(document).click(function (e) {
	        // var targetbox = $('.offcanvas');
	        var targetbox = $('.paper-nav-toggle');
	        if (!targetbox.is(e.target) && targetbox.has(e.target).length === 0) {
	            if ($("body").hasClass('sidebar-open')) {
	                $("body").removeClass('sidebar-open').addClass('sidebar-collapse').trigger('collapsed.pushMenu');
	            }
	        }
	    });


	    $('.btn-group[data-toggle="btn-toggle"]').each(function () {
	        var group = $(this);
	        $(this).find(".btn").on('click', function (e) {
	            group.find(".btn.active").removeClass("active");
	            $(this).addClass("active");
	            e.preventDefault();
	        });

	    });
	});

	/* ----------------------------------
	 * - Initialize the PaperPanel Object -
	 * ----------------------------------
	 * All PaperPanel functions are implemented below.
	 */
	function _init() {
	    'use strict';
	    /* Layout
	     * ======
	     * Fixes the layout height in case min-height fails.
	     *
	     * @type Object
	     * @usage $.PaperPanel.layout.activate()
	     *        $.PaperPanel.layout.fix()
	     *        $.PaperPanel.layout.fixSidebar()
	     */

	    var slimScroll = $(".slimScroll");

	    if(slimScroll.length){
	        slimScroll.each(function () {
	            var $this = $(this);
	            var attrData =$this.data();
	            $this.slimscroll({
	                height: attrData.height ? attrData.height+'px' : ($(window).height()) + "px",
	                color: attrData.color ? attrData.color : "rgba(0,0,0,0.95)",
	                size:  attrData.size ? attrData.size +'px' : "5px"
	            });
	        });
	    }


	    $.PaperPanel.layout = {
	        activate: function () {
	            var _this = this;
	            _this.fix();
	            _this.fixSidebar();
	            $(window, ".wrapper").resize(function () {
	                _this.fix();
	                _this.fixSidebar();
	            });
	        },
	        fix: function () {
	            //Get window height and the wrapper height
	            var neg = $('.main-header').outerHeight() + $('.main-footer').outerHeight();
	            var window_height = $(window).height();
	            var sidebar_height = $(".sidebar").height();
	            //Set the min-height of the content and sidebar based on the
	            //the height of the document.
	            if ($("body").hasClass("fixed")) {
	                $(".content-wrapper, .right-side").css('min-height', window_height - $('.main-footer').outerHeight());
	            } else {
	                var postSetWidth;
	                if (window_height >= sidebar_height) {
	                    $(".content-wrapper, .right-side").css('min-height', window_height - neg);
	                    postSetWidth = window_height - neg;
	                } else {
	                    $(".content-wrapper, .right-side").css('min-height', sidebar_height);
	                    postSetWidth = sidebar_height;
	                }

	                //Fix for the control sidebar height
	                var controlSidebar = $($.PaperPanel.options.controlSidebarOptions.selector);
	                if (typeof controlSidebar !== "undefined") {
	                    if (controlSidebar.height() > postSetWidth)
	                        $(".content-wrapper, .right-side").css('min-height', controlSidebar.height());
	                }

	            }
	        },
	        fixSidebar: function () {
	            //Make sure the body tag has the .fixed class
	            if (!$(".main-sidebar").hasClass("fixed")) {
	                if (typeof $.fn.slimScroll != 'undefined') {
	                    $(".sidebar").slimScroll({destroy: true}).height("auto");

	                }
	                return;
	            } else if (typeof $.fn.slimScroll == 'undefined' && window.console) {
	                window.console.error("Error: the fixed layout requires the slimscroll plugin!");
	            }
	            //Enable slimscroll for fixed layout
	            if ($.PaperPanel.options.sidebarSlimScroll) {
	                if (typeof $.fn.slimScroll != 'undefined') {
	                    //Destroy if it exists
	                    $(".sidebar").slimScroll({destroy: true}).height("auto");
	                    //Add slimscroll

	                    $(".sidebar").slimscroll({
	                        height: ($(window).height()) + "px",
	                        color: "rgba(0,0,0,0.3)",
	                        size: "5px"
	                    });
	                }
	            }
	        }
	    };


	    /* PushMenu()
	     * ==========
	     * Adds the push menu functionality to the sidebar.
	     *
	     * @type Function
	     * @usage: $.PaperPanel.pushMenu("[data-toggle='offcanvas']")
	     */
	    $.PaperPanel.pushMenu = {
	        activate: function (toggleBtn) {
	            //Get the screen sizes
	            var screenSizes = $.PaperPanel.options.screenSizes;

	            //Enable sidebar toggle
	            $(document).on('click', toggleBtn, function (e) {
	                e.preventDefault();
	                e.stopPropagation();
	                //Enable sidebar push menu
	                if ($(window).width() > (screenSizes.md - 1)) {
	                    if ($("body").hasClass('sidebar-collapse')) {
	                        $("body").removeClass('sidebar-collapse').trigger('expanded.pushMenu');
	                        if ($('.nav-offcanvas-desktop').length) {
	                            $("body").addClass('sidebar-open').trigger('expanded.pushMenu');
	                        }

	                    } else {
	                        $("body").addClass('sidebar-collapse').trigger('collapsed.pushMenu');
	                    }
	                }
	                //Handle sidebar push menu for small screens
	                else {
	                    if ($("body").hasClass('sidebar-open')) {
	                        $("body").removeClass('sidebar-open').removeClass('sidebar-collapse').trigger('collapsed.pushMenu');
	                    } else {
	                        $("body").addClass('sidebar-open').trigger('expanded.pushMenu');
	                    }
	                }
	            });

	            $(".content-wrapper").click(function () {
	                //Enable hide menu when clicking on the content-wrapper on small screens
	                if ($(window).width() <= (screenSizes.md - 1) && $("body").hasClass("sidebar-open")) {
	                    $("body").removeClass('sidebar-open');
	                }
	            });


	        },
	        expandOnHover: function () {
	            var _this = this;
	            var screenWidth = $.PaperPanel.options.screenSizes.sm - 1;
	            //Expand sidebar on hover
	            $('.main-sidebar').hover(function () {
	                if ($('body').hasClass('sidebar-mini') &&
	                    $("body").hasClass('sidebar-collapse') &&
	                    $(window).width() > screenWidth) {
	                    _this.expand();
	                }
	            }, function () {
	                if ($('body').hasClass('sidebar-mini') &&
	                    $('body').hasClass('sidebar-expanded-on-hover') &&
	                    $(window).width() > screenWidth) {
	                    _this.collapse();
	                }
	            });
	        },
	        expand: function () {
	            $("body").removeClass('sidebar-collapse').addClass('sidebar-expanded-on-hover');
	        },
	        collapse: function () {
	            if ($('body').hasClass('sidebar-expanded-on-hover')) {
	                $('body').removeClass('sidebar-expanded-on-hover').addClass('sidebar-collapse');
	            }
	        }
	    };

	    /* Tree()
	     * ======
	     * Converts the sidebar into a multilevel
	     * tree view menu.
	     *
	     * @type Function
	     * @Usage: $.PaperPanel.tree('.sidebar')
	     */
	    $.PaperPanel.tree = function (menu) {
	        var _this = this;
	        var animationSpeed = $.PaperPanel.options.animationSpeed;
	        $(document).on('click', menu + ' li a', function (e) {
	            //Get the clicked link and the next element
	            var $this = $(this);
	            var checkElement = $this.next();

	            //Check if the next element is a menu and is visible
	            if ((checkElement.is('.treeview-menu')) && (checkElement.is(':visible')) && (!$('body').hasClass('sidebar-collapse'))) {
	                //Close the menu
	                checkElement.slideUp(animationSpeed, function () {
	                    checkElement.removeClass('menu-open');
	                    //Fix the layout in case the sidebar stretches over the height of the window
	                    //_this.layout.fix();
	                });
	                checkElement.parent("li").removeClass("active");
	            }
	            //If the menu is not visible
	            else if ((checkElement.is('.treeview-menu')) && (!checkElement.is(':visible'))) {
	                //Get the parent menu
	                var parent = $this.parents('ul').first();
	                //Close all open menus within the parent
	                var ul = parent.find('ul:visible').slideUp(animationSpeed);
	                //Remove the menu-open class from the parent
	                ul.removeClass('menu-open');
	                //Get the parent li
	                var parent_li = $this.parent("li");

	                //Open the target menu and add the menu-open class
	                checkElement.slideDown(animationSpeed, function () {
	                    //Add the class active to the parent li
	                    checkElement.addClass('menu-open');
	                    parent.find('li.active').removeClass('active');
	                    parent_li.addClass('active');
	                    //Fix the layout in case the sidebar stretches over the height of the window
	                    _this.layout.fix();
	                });
	            }
	            //if this isn't a link, prevent the page from being redirected
	            if (checkElement.is('.treeview-menu')) {
	                e.preventDefault();
	            }
	        });
	    };
	}

/***/ }),
/* 32 */
/***/ (function(module, exports) {

	/*! Copyright (c) 2011 Piotr Rochala (http://rocha.la)
	 * Dual licensed under the MIT (http://www.opensource.org/licenses/mit-license.php)
	 * and GPL (http://www.opensource.org/licenses/gpl-license.php) licenses.
	 *
	 * Version: 1.3.8
	 *
	 */
	(function ($) {

	    $.fn.extend({
	        slimScroll: function (options) {

	            var defaults = {

	                // width in pixels of the visible scroll area
	                width: 'auto',

	                // height in pixels of the visible scroll area
	                height: '250px',

	                // width in pixels of the scrollbar and rail
	                size: '7px',

	                // scrollbar color, accepts any hex/color value
	                color: '#000',

	                // scrollbar position - left/right
	                position: 'right',

	                // distance in pixels between the side edge and the scrollbar
	                distance: '1px',

	                // default scroll position on load - top / bottom / $('selector')
	                start: 'top',

	                // sets scrollbar opacity
	                opacity: .4,

	                // enables always-on mode for the scrollbar
	                alwaysVisible: false,

	                // check if we should hide the scrollbar when user is hovering over
	                disableFadeOut: false,

	                // sets visibility of the rail
	                railVisible: false,

	                // sets rail color
	                railColor: '#333',

	                // sets rail opacity
	                railOpacity: .2,

	                // whether  we should use jQuery UI Draggable to enable bar dragging
	                railDraggable: true,

	                // defautlt CSS class of the slimscroll rail
	                railClass: 'slimScrollRail',

	                // defautlt CSS class of the slimscroll bar
	                barClass: 'slimScrollBar',

	                // defautlt CSS class of the slimscroll wrapper
	                wrapperClass: 'slimScrollDiv',

	                // check if mousewheel should scroll the window if we reach top/bottom
	                allowPageScroll: false,

	                // scroll amount applied to each mouse wheel step
	                wheelStep: 20,

	                // scroll amount applied when user is using gestures
	                touchScrollStep: 200,

	                // sets border radius
	                borderRadius: '7px',

	                // sets border radius of the rail
	                railBorderRadius: '7px'
	            };

	            var o = $.extend(defaults, options);

	            // do it for every element that matches selector
	            this.each(function () {

	                var isOverPanel, isOverBar, isDragg, queueHide, touchDif,
	                    barHeight, percentScroll, lastScroll,
	                    divS = '<div></div>',
	                    minBarHeight = 30,
	                    releaseScroll = false;

	                // used in event handlers and for better minification
	                var me = $(this);

	                // ensure we are not binding it again
	                if (me.parent().hasClass(o.wrapperClass)) {
	                    // start from last bar position
	                    var offset = me.scrollTop();

	                    // find bar and rail
	                    bar = me.siblings('.' + o.barClass);
	                    rail = me.siblings('.' + o.railClass);

	                    getBarHeight();

	                    // check if we should scroll existing instance
	                    if ($.isPlainObject(options)) {
	                        // Pass height: auto to an existing slimscroll object to force a resize after contents have changed
	                        if ('height' in options && options.height == 'auto') {
	                            me.parent().css('height', 'auto');
	                            me.css('height', 'auto');
	                            var height = me.parent().parent().height();
	                            me.parent().css('height', height);
	                            me.css('height', height);
	                        } else if ('height' in options) {
	                            var h = options.height;
	                            me.parent().css('height', h);
	                            me.css('height', h);
	                        }

	                        if ('scrollTo' in options) {
	                            // jump to a static point
	                            offset = parseInt(o.scrollTo);
	                        }
	                        else if ('scrollBy' in options) {
	                            // jump by value pixels
	                            offset += parseInt(o.scrollBy);
	                        }
	                        else if ('destroy' in options) {
	                            // remove slimscroll elements
	                            bar.remove();
	                            rail.remove();
	                            me.unwrap();
	                            return;
	                        }

	                        // scroll content by the given offset
	                        scrollContent(offset, false, true);
	                    }

	                    return;
	                }
	                else if ($.isPlainObject(options)) {
	                    if ('destroy' in options) {
	                        return;
	                    }
	                }

	                // optionally set height to the parent's height
	                o.height = (o.height == 'auto') ? me.parent().height() : o.height;

	                // wrap content
	                var wrapper = $(divS)
	                    .addClass(o.wrapperClass)
	                    .css({
	                        position: 'relative',
	                        overflow: 'hidden',
	                        width: o.width,
	                        height: o.height
	                    });

	                // update style for the div
	                me.css({
	                    overflow: 'hidden',
	                    width: o.width,
	                    height: o.height
	                });

	                // create scrollbar rail
	                var rail = $(divS)
	                    .addClass(o.railClass)
	                    .css({
	                        width: o.size,
	                        height: '100%',
	                        position: 'absolute',
	                        top: 0,
	                        display: (o.alwaysVisible && o.railVisible) ? 'block' : 'none',
	                        'border-radius': o.railBorderRadius,
	                        background: o.railColor,
	                        opacity: o.railOpacity,
	                        zIndex: 90
	                    });

	                // create scrollbar
	                var bar = $(divS)
	                    .addClass(o.barClass)
	                    .css({
	                        background: o.color,
	                        width: o.size,
	                        position: 'absolute',
	                        top: 0,
	                        opacity: o.opacity,
	                        display: o.alwaysVisible ? 'block' : 'none',
	                        'border-radius': o.borderRadius,
	                        BorderRadius: o.borderRadius,
	                        MozBorderRadius: o.borderRadius,
	                        WebkitBorderRadius: o.borderRadius,
	                        zIndex: 99
	                    });

	                // set position
	                var posCss = (o.position == 'right') ? {right: o.distance} : {left: o.distance};
	                rail.css(posCss);
	                bar.css(posCss);

	                // wrap it
	                me.wrap(wrapper);

	                // append to parent div
	                me.parent().append(bar);
	                me.parent().append(rail);

	                // make it draggable and no longer dependent on the jqueryUI
	                if (o.railDraggable) {
	                    bar.bind("mousedown", function (e) {
	                        var $doc = $(document);
	                        isDragg = true;
	                        t = parseFloat(bar.css('top'));
	                        pageY = e.pageY;

	                        $doc.bind("mousemove.slimscroll", function (e) {
	                            currTop = t + e.pageY - pageY;
	                            bar.css('top', currTop);
	                            scrollContent(0, bar.position().top, false);// scroll content
	                        });

	                        $doc.bind("mouseup.slimscroll", function (e) {
	                            isDragg = false;
	                            hideBar();
	                            $doc.unbind('.slimscroll');
	                        });
	                        return false;
	                    }).bind("selectstart.slimscroll", function (e) {
	                        e.stopPropagation();
	                        e.preventDefault();
	                        return false;
	                    });
	                }

	                // on rail over
	                rail.hover(function () {
	                    showBar();
	                }, function () {
	                    hideBar();
	                });

	                // on bar over
	                bar.hover(function () {
	                    isOverBar = true;
	                }, function () {
	                    isOverBar = false;
	                });

	                // show on parent mouseover
	                me.hover(function () {
	                    isOverPanel = true;
	                    showBar();
	                    hideBar();
	                }, function () {
	                    isOverPanel = false;
	                    hideBar();
	                });

	                // support for mobile
	                me.bind('touchstart', function (e, b) {
	                    if (e.originalEvent.touches.length) {
	                        // record where touch started
	                        touchDif = e.originalEvent.touches[0].pageY;
	                    }
	                });

	                me.bind('touchmove', function (e) {
	                    // prevent scrolling the page if necessary
	                    if (!releaseScroll) {
	                        e.originalEvent.preventDefault();
	                    }
	                    if (e.originalEvent.touches.length) {
	                        // see how far user swiped
	                        var diff = (touchDif - e.originalEvent.touches[0].pageY) / o.touchScrollStep;
	                        // scroll content
	                        scrollContent(diff, true);
	                        touchDif = e.originalEvent.touches[0].pageY;
	                    }
	                });

	                // set up initial height
	                getBarHeight();

	                // check start position
	                if (o.start === 'bottom') {
	                    // scroll content to bottom
	                    bar.css({top: me.outerHeight() - bar.outerHeight()});
	                    scrollContent(0, true);
	                }
	                else if (o.start !== 'top') {
	                    // assume jQuery selector
	                    scrollContent($(o.start).position().top, null, true);

	                    // make sure bar stays hidden
	                    if (!o.alwaysVisible) {
	                        bar.hide();
	                    }
	                }

	                // attach scroll events
	                attachWheel(this);

	                function _onWheel(e) {
	                    // use mouse wheel only when mouse is over
	                    if (!isOverPanel) {
	                        return;
	                    }

	                    var e = e || window.event;

	                    var delta = 0;
	                    if (e.wheelDelta) {
	                        delta = -e.wheelDelta / 120;
	                    }
	                    if (e.detail) {
	                        delta = e.detail / 3;
	                    }

	                    var target = e.target || e.srcTarget || e.srcElement;
	                    if ($(target).closest('.' + o.wrapperClass).is(me.parent())) {
	                        // scroll content
	                        scrollContent(delta, true);
	                    }

	                    // stop window scroll
	                    if (e.preventDefault && !releaseScroll) {
	                        e.preventDefault();
	                    }
	                    if (!releaseScroll) {
	                        e.returnValue = false;
	                    }
	                }

	                function scrollContent(y, isWheel, isJump) {
	                    releaseScroll = false;
	                    var delta = y;
	                    var maxTop = me.outerHeight() - bar.outerHeight();

	                    if (isWheel) {
	                        // move bar with mouse wheel
	                        delta = parseInt(bar.css('top')) + y * parseInt(o.wheelStep) / 100 * bar.outerHeight();

	                        // move bar, make sure it doesn't go out
	                        delta = Math.min(Math.max(delta, 0), maxTop);

	                        // if scrolling down, make sure a fractional change to the
	                        // scroll position isn't rounded away when the scrollbar's CSS is set
	                        // this flooring of delta would happened automatically when
	                        // bar.css is set below, but we floor here for clarity
	                        delta = (y > 0) ? Math.ceil(delta) : Math.floor(delta);

	                        // scroll the scrollbar
	                        bar.css({top: delta + 'px'});
	                    }

	                    // calculate actual scroll amount
	                    percentScroll = parseInt(bar.css('top')) / (me.outerHeight() - bar.outerHeight());
	                    delta = percentScroll * (me[0].scrollHeight - me.outerHeight());

	                    if (isJump) {
	                        delta = y;
	                        var offsetTop = delta / me[0].scrollHeight * me.outerHeight();
	                        offsetTop = Math.min(Math.max(offsetTop, 0), maxTop);
	                        bar.css({top: offsetTop + 'px'});
	                    }

	                    // scroll content
	                    me.scrollTop(delta);

	                    // fire scrolling event
	                    me.trigger('slimscrolling', ~~delta);

	                    // ensure bar is visible
	                    showBar();

	                    // trigger hide when scroll is stopped
	                    hideBar();
	                }

	                function attachWheel(target) {
	                    if (window.addEventListener) {
	                        target.addEventListener('DOMMouseScroll', _onWheel, false);
	                        target.addEventListener('mousewheel', _onWheel, false);
	                    }
	                    else {
	                        document.attachEvent("onmousewheel", _onWheel)
	                    }
	                }

	                function getBarHeight() {
	                    // calculate scrollbar height and make sure it is not too small
	                    barHeight = Math.max((me.outerHeight() / me[0].scrollHeight) * me.outerHeight(), minBarHeight);
	                    bar.css({height: barHeight + 'px'});

	                    // hide scrollbar if content is not long enough
	                    var display = barHeight == me.outerHeight() ? 'none' : 'block';
	                    bar.css({display: display});
	                }

	                function showBar() {
	                    // recalculate bar height
	                    getBarHeight();
	                    clearTimeout(queueHide);

	                    // when bar reached top or bottom
	                    if (percentScroll == ~~percentScroll) {
	                        //release wheel
	                        releaseScroll = o.allowPageScroll;

	                        // publish approporiate event
	                        if (lastScroll != percentScroll) {
	                            var msg = (~~percentScroll == 0) ? 'top' : 'bottom';
	                            me.trigger('slimscroll', msg);
	                        }
	                    }
	                    else {
	                        releaseScroll = false;
	                    }
	                    lastScroll = percentScroll;

	                    // show only when required
	                    if (barHeight >= me.outerHeight()) {
	                        //allow window scroll
	                        releaseScroll = true;
	                        return;
	                    }
	                    bar.stop(true, true).fadeIn('fast');
	                    if (o.railVisible) {
	                        rail.stop(true, true).fadeIn('fast');
	                    }
	                }

	                function hideBar() {
	                    // only hide when options allow it
	                    if (!o.alwaysVisible) {
	                        queueHide = setTimeout(function () {
	                            if (!(o.disableFadeOut && isOverPanel) && !isOverBar && !isDragg) {
	                                bar.fadeOut('slow');
	                                rail.fadeOut('slow');
	                            }
	                        }, 1000);
	                    }
	                }

	            });

	            // maintain chainability
	            return this;
	        }
	    });

	    $.fn.extend({
	        slimscroll: $.fn.slimScroll
	    });

	})(jQuery);


/***/ }),
/* 33 */
/***/ (function(module, exports) {

	jQuery(function ($) {
	    "use strict";
	    var type,
	        w3c,
	        start,
	        webkit,
	        opacity,
	        banner_overlay = '.overlay',
	        color_start,
	        color_end,
	        orientation;


	    var overlay = $(banner_overlay);

	    overlay.each(function () {
	        var $this = $(this),
	            color_start = $this.data('start'),
	            color_end = $this.data('end'),
	            orientation = $this.data('orientation'),
	            opacity = $this.data('opacity');

	        apply_gradient($this, color_start, color_end, orientation, opacity);

	    });


	    function apply_gradient(ele, color_start, color_end, orientation, opacity) {

	        switch (orientation) {
	            case 'tobottomright':
	                type = "linear";
	                w3c = "to bottom right";
	                start = "top left";
	                webkit = "left top, right bottom";
	                break;
	            case 'tobottom'        :
	                type = "linear";
	                w3c = "to bottom";
	                start = "top";
	                webkit = "left top, left bottom";
	                break;
	            case 'tobottomleft'    :
	                type = "linear";
	                w3c = "to bottom left";
	                start = "top right";
	                webkit = "right top, left bottom";
	                break;
	            case 'toright'        :
	                type = "linear";
	                w3c = "to right";
	                start = "left";
	                webkit = "left top, right top";
	                break;
	            case 'toleft'        :
	                type = "linear";
	                w3c = "to left";
	                start = "right";
	                webkit = "right top, left top";
	                break;
	            case 'totopright'    :
	                type = "linear";
	                w3c = "to top right";
	                start = "bottom left";
	                webkit = "left bottom, right top";
	                break;
	            case 'totop'        :
	                type = "linear";
	                w3c = "to top";
	                start = "bottom";
	                webkit = "left bottom, left top";
	                break;
	            case 'totopleft'    :
	                type = "linear";
	                w3c = "to top left";
	                start = "bottom right";
	                webkit = "right bottom, left top";
	                break;
	            case 'circulartopleft'        :
	                type = "radial";
	                w3c = "circle farthest-side at left top";
	                start = "left top, circle farthest-side";
	                webkit = "left top, 0, left top, 973";
	                break;
	            case 'circulartopcenter'    :
	                type = "radial";
	                w3c = "circle farthest-side at center top";
	                start = "center top, circle farthest-side";
	                webkit = "center top, 0, center top, 487";
	                break;
	            case 'circulartopright'        :
	                type = "radial";
	                w3c = "circle farthest-side at right top";
	                start = "right top, circle farthest-side";
	                webkit = "right top, 0, right top, 973";
	                break;
	            case 'circularmiddleleft'    :
	                type = "radial";
	                w3c = "circle farthest-side at left center";
	                start = "left center, circle farthest-side";
	                webkit = "left center, 0, left center, 973";
	                break;
	            case 'circularmiddlecenter'    :
	                type = "radial";
	                w3c = "circle farthest-side at center";
	                start = "center, circle farthest-side";
	                webkit = "center center, 0, center center, 487";
	                break;
	            case 'circularmiddleright'    :
	                type = "radial";
	                w3c = "circle farthest-side at right center";
	                start = "right center, circle farthest-side";
	                webkit = "right center, 0, right center";
	                break;
	            case 'circularbottomleft'    :
	                type = "radial";
	                w3c = "circle farthest-side at left bottom";
	                start = "left bottom, circle farthest-side";
	                webkit = "left bottom, 0, left bottom, 973";
	                break;
	            case 'circularbottomcenter'    :
	                type = "radial";
	                w3c = "circle farthest-side at center bottom";
	                start = "center bottom, circle farthest-side";
	                webkit = "center bottom, 0, center bottom, 487";
	                break;
	            case 'circularbottomright'    :
	                type = "radial";
	                w3c = "circle farthest-side at right bottom";
	                start = "right bottom, circle farthest-side";
	                webkit = "right bottom, 0, right bottom, 973";
	                break;
	            case 'ellipsetopleft'        :
	                type = "radial";
	                w3c = "ellipse farthest-side at left top";
	                start = "left top, ellipse farthest-side";
	                webkit = "left top, 0, left top, 973";
	                break;
	            case 'ellipsetopcenter'        :
	                type = "radial";
	                w3c = "ellipse farthest-side at center top";
	                start = "center top, ellipse farthest-side";
	                webkit = "center top, 0, center top, 487";
	                break;
	            case 'ellipsetopright'        :
	                type = "radial";
	                w3c = "ellipse farthest-side at right top";
	                start = "right top, ellipse farthest-side";
	                webkit = "right top, 0, right top, 973";
	                break;
	            case 'ellipsemiddleleft'    :
	                type = "radial";
	                w3c = "ellipse farthest-side at left center";
	                start = "left center, ellipse farthest-side";
	                webkit = "left center, 0, left center, 973";
	                break;
	            case 'ellipsemiddlecenter'    :
	                type = "radial";
	                w3c = "ellipse farthest-side at center";
	                start = "center, ellipse farthest-side";
	                webkit = "center center, 0, center center, 487";
	                break;
	            case 'ellipsemiddleright'    :
	                type = "radial";
	                w3c = "ellipse farthest-side at right center";
	                start = "right center, ellipse farthest-side";
	                webkit = "right center, 0, right center";
	                break;
	            case 'ellipsebottomleft'    :
	                type = "radial";
	                w3c = "ellipse farthest-side at left bottom";
	                start = "left bottom, ellipse farthest-side";
	                webkit = "left bottom, 0, left bottom, 973";
	                break;
	            case 'ellipsebottomcenter'    :
	                type = "radial";
	                w3c = "ellipse farthest-side at center bottom";
	                start = "center bottom, ellipse farthest-side";
	                webkit = "center bottom, 0, center bottom, 487";
	                break;
	            case 'ellipsebottomright'    :
	                type = "radial";
	                w3c = "ellipse farthest-side at right bottom";
	                start = "right bottom, ellipse farthest-side";
	                webkit = "right bottom, 0, right bottom, 973";
	                break;

	            default:
	                type = "linear";
	                w3c = "to right";
	                start = "left";
	                webkit = "left top, right top";
	                break;
	        }

	        if (color_end) {
	            jQuery(ele).css({'background': color_start, 'opacity': opacity});
	            jQuery(ele).css({
	                'background': '-moz-' + type + '-gradient(' + start + ', ' + color_start + ' 0%, ' + color_end + ' 100%)',
	                'opacity': opacity
	            });
	            jQuery(ele).css({
	                'background': '-webkit-gradient(' + type + ', ' + webkit + ', color-stop(0, ' + color_start + '), color-stop(1, ' + color_end + '))',
	                'opacity': opacity
	            });
	            jQuery(ele).css({
	                'background': '-webkit-' + type + '-gradient(' + start + ', ' + color_start + ' 0%, ' + color_end + ' 100%)',
	                'opacity': opacity
	            });
	            jQuery(ele).css({
	                'background': '-o-' + type + '-gradient(' + start + ', ' + color_start + ' 0%, ' + color_end + ' 100%)',
	                'opacity': opacity
	            });
	            jQuery(ele).css({
	                'background': '-ms-' + type + '-gradient(' + start + ', ' + color_start + ' 0%, ' + color_end + ' 100%)',
	                'opacity': opacity
	            });
	            jQuery(ele).css({
	                'background': '' + type + '-gradient(' + w3c + ', ' + color_start + ' 0%, ' + color_end + ' 100%)',
	                'opacity': opacity
	            });
	            jQuery(ele).css({
	                'background': 'filter: progid:DXImageTransform.Microsoft.gradient( startColorstr=\'' + color_start + '\', endColorstr=\'' + color_end + '\',GradientType=1 )',
	                'opacity': opacity
	            });
	        }

	        else {
	            jQuery(ele).css({'background': color_start, 'opacity': opacity});
	        }
	    }

	});


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(35);

	jQuery(function ($) {
	    "use strict";

	    var counter = $('.counter');

	    counter.each(function () {
	        var $this = $(this);
	        var eventDate = $this.data('date');
	        var targetDate = new Date(eventDate),
	            finished = false,
	            availiableExamples = {
	                set15daysFromNow: 15 * 24 * 60 * 60 * 1000,
	                set5minFromNow: 5 * 60 * 1000,
	                set1minFromNow: 1 * 60 * 1000
	            };

	        function callback(event) {
	            var $this = $(this);
	            switch (event.type) {
	                case "seconds":
	                case "minutes":
	                case "hours":
	                case "days":
	                case "weeks":
	                case "daysLeft":
	                    $this.find('div span.' + event.type).html(event.value);
	                    if (finished) {
	                        $this.fadeTo(0, 1);
	                        finished = false;
	                    }

	                    break;
	                case "finished":
	                    $this.fadeTo('slow', .5);
	                    finished = true;
	                    break;
	            }
	        }

	        $this.countdown(targetDate.valueOf(), callback);

	    });
	});

/***/ }),
/* 35 */
/***/ (function(module, exports) {

	/*
	 * jQuery The Final Countdown plugin v1.0.0 beta
	 * http://github.com/hilios/jquery.countdown
	 *
	 * Copyright (c) 2011 Edson Hilios
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining
	 * a copy of this software and associated documentation files (the
	 * "Software"), to deal in the Software without restriction, including
	 * without limitation the rights to use, copy, modify, merge, publish,
	 * distribute, sublicense, and/or sell copies of the Software, and to
	 * permit persons to whom the Software is furnished to do so, subject to
	 * the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be
	 * included in all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
	 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
	 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	 */
	(function($) {
	  
	  $.fn.countdown = function(toDate, callback) {
	    var handlers = ['seconds', 'minutes', 'hours', 'days', 'weeks', 'daysLeft'];
	    
	    function delegate(scope, method) {
	      return function() { return method.call(scope) }
	    }
	    
	    return this.each(function() {
	      // Convert
	      if(!(toDate instanceof Date)) {
	        if(String(toDate).match(/^[0-9]*$/)) {
	          toDate = new Date(toDate);
	        } else if( toDate.match(/([0-9]{1,2})\/([0-9]{1,2})\/([0-9]{2,4})\s([0-9]{1,2})\:([0-9]{2})\:([0-9]{2})/) ||
	            toDate.match(/([0-9]{2,4})\/([0-9]{1,2})\/([0-9]{1,2})\s([0-9]{1,2})\:([0-9]{2})\:([0-9]{2})/)
	            ) {
	          toDate = new Date(toDate);
	        } else if(toDate.match(/([0-9]{1,2})\/([0-9]{1,2})\/([0-9]{2,4})/) || 
	                  toDate.match(/([0-9]{2,4})\/([0-9]{1,2})\/([0-9]{1,2})/)
	                  ) {
	          toDate = new Date(toDate)
	        } else {
	          throw new Error("Doesn't seen to be a valid date object or string")
	        }
	      }
	      
	      var $this = $(this),
	          values = {},
	          lasting = {},
	          interval = $this.data('countdownInterval'),
	          currentDate = new Date(),
	          secondsLeft = Math.floor((toDate.valueOf() - currentDate.valueOf()) / 1000);
	      
	      function triggerEvents() {
	        secondsLeft--;
	        if(secondsLeft < 0) {
	          secondsLeft = 0;
	        }
	        lasting = {
	          seconds : secondsLeft % 60,
	          minutes : Math.floor(secondsLeft / 60) % 60,
	          hours   : Math.floor(secondsLeft / 60 / 60) % 24,
	          days    : Math.floor(secondsLeft / 60 / 60 / 24),
	          weeks   : Math.floor(secondsLeft / 60 / 60 / 24 / 7),
	          daysLeft: Math.floor(secondsLeft / 60 / 60 / 24) % 7
	        }
	        for(var i=0; i<handlers.length; i++) {
	          var eventName = handlers[i];
	          if(values[eventName] != lasting[eventName]) {
	            values[eventName] = lasting[eventName];
	            dispatchEvent(eventName);
	          }
	        }
	        if(secondsLeft == 0) { 
	          stop();
	          dispatchEvent('finished');
	        }
	      }
	      triggerEvents();
	      
	      function dispatchEvent(eventName) {
	        var event = $.Event(eventName);
	        event.date  = new Date(new Date().valueOf() + secondsLeft);
	        event.value = values[eventName] || "0";
	        event.toDate = toDate;
	        event.lasting = lasting;
	        switch(eventName) {
	          case "seconds":
	          case "minutes":
	          case "hours":
	            event.value = event.value < 10 ? '0'+event.value.toString() : event.value.toString();
	            break;
	          default:
	            if(event.value) {
	              event.value = event.value.toString();
	            }
	            break;
	        }
	        callback.call($this, event);
	      }
	      
	      $this.bind('remove', function() {
	        stop(); // If the selector is removed clear the interval for memory sake!
	        dispatchEvent('removed');
	      });
	      
	      function stop() {
	        clearInterval(interval);
	      }

	      function start() {
	        $this.data('countdownInterval', setInterval(delegate($this, triggerEvents), 1000));
	        interval = $this.data('countdownInterval');
	      }
	      
	      if(interval) stop();
	      start();
	    });
	  }
	  // Wrap the remove method to trigger an event when called
	  var removeEvent = new $.Event('remove'),
	      removeFunction = $.fn.remove;
	  $.fn.remove = function() {
	    $(this).trigger(removeEvent);
	    return removeFunction.apply(this, arguments);
	  }
	})(jQuery);

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(35);

	jQuery(function ($) {
	    "use strict";

	    // Initialize Counters
	    $('.sc-counter').each(function () {
	        $(this).data('value', $(this).text()).text(0);
	    });

	    counterStart();

	    // Check If Counter In Viewport
	    $(window).on('load resize scroll', function () {
	        counterStart();
	    });

	    function counterStart() {
	        $('.sc-counter').each(function () {

	            /* Counter Elements */
	            var counter = $(this);

	            /* Counter Variables */
	            var counter_value = counter.data('value');

	            var counter_animated = counter.hasClass('counter-animated');

	            /* Animate If In Viewport */
	            if (isElementInViewport(counter) && !counter_animated) {

	                counter.addClass('counter-animated');
	                $({startVal: 0}).animate({startVal: counter_value},
	                    {
	                        duration: 3000,
	                        easing: 'swing',
	                        step: function () {
	                            counter.text(getNumberWithCommas(Math.ceil(this.startVal)));
	                        }
	                    }
	                );

	            }
	        });
	    }

	});


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(38);
	jQuery(function ($) {
	    "use strict";
	    var Charts = {
	        _HYPHY_REGEX: /-([a-z])/g,
	        _cleanAttr: function (t) {
	            delete t.chart, delete t.datasets, delete t.datasetsOptions, delete t.labels, delete t.options
	        },
	         doughnut: function (element) {
	            var attrData = $.extend({}, $(element).data()),
	                data = attrData.dataset ? eval(attrData.dataset) : {},
	                dataOptions = attrData.datasetOptions ? eval("(" + attrData.datasetOptions + ")") : {},
	                labels = attrData.labels ? eval(attrData.labels) : {},
	                options = attrData.options ? eval("(" + attrData.options + ")") : {};

	            Charts._cleanAttr(attrData);
	            var datasets = $.extend({
	                    data: data,
	                    borderWidth: 2,
	                    hoverBorderColor: "transparent"
	                }, dataOptions),
	                options = $.extend({
	                    cutoutPercentage: 80,
	                    legend: {
	                        display: !1
	                    },
	                    animation: {
	                        animateRotate: !1,
	                        duration: 0
	                    }
	                }, options);
	            new Chart(element.getContext("2d"), {
	                type: "doughnut",
	                data: {
	                    datasets: [datasets],
	                    labels: labels
	                },
	                options: options
	            })
	        },
	        "spark-line": function (element) {
	            var attrData = $.extend({}, $(element).data()),
	                data = attrData.dataset ? eval(attrData.dataset) : [],
	                datasetOptions = attrData.datasetOptions ? eval(attrData.datasetOptions) : [],
	                labels = attrData.labels ? eval(attrData.labels) : {},
	                options = attrData.options ? eval("(" + attrData.options + ")") : {},
	                data = {
	                    labels: labels,
	                    datasets: data.map(function (t, a) {
	                        return $.extend({
	                            data: t,
	                            fill: !0,
	                            backgroundColor: "rgba(255,255,255,.3)",
	                            borderColor: "#fff",
	                            pointBorderColor: "#fff",
	                            lineTension: .25,
	                            pointRadius: 0
	                        }, datasetOptions[a])
	                    })
	                };
	            Charts._cleanAttr(attrData);
	            var options = $.extend({
	                animation: {
	                    duration: 0
	                },
	                legend: {
	                    display: !1
	                },
	                scales: {
	                    xAxes: [{
	                        display: !1
	                    }],
	                    yAxes: [{
	                        display: !1
	                    }]
	                },
	                tooltips: {
	                    enabled: !1
	                }
	            }, options);
	            new Chart(element.getContext("2d"), {
	                type: "bar",
	                data: data,
	                options: options
	            })
	        },
	         line: function (element) {
	            var attrData = $.extend({}, $(element).data()),
	                data = attrData.dataset ? eval(attrData.dataset) : [],
	                datasetOptions = attrData.datasetOptions ? eval(attrData.datasetOptions) : [],
	                labels = attrData.labels ? eval(attrData.labels) : {},
	                options = attrData.options ? eval("(" + attrData.options + ")") : {},
	                isDark = !!attrData.dark,
	                data = {
	                    labels: labels,
	                    datasets: data.map(function (t, a) {
	                        return $.extend({
	                            data: t,
	                            fill: !0,
	                            backgroundColor: isDark ? "rgba(28,168,221,.03)" : "rgba(66,165,245,.2)",
	                            borderColor: "#42a5f5",
	                            pointBorderColor: "#fff",
	                            lineTension: .25,
	                            pointRadius: 0,
	                            pointHoverRadius: 0,
	                            pointHitRadius: 20
	                        }, datasetOptions[a])
	                    })
	                };
	            Charts._cleanAttr(attrData);
	            var options = $.extend({
	                maintainAspectRatio: !1,
	                animation: {
	                    duration: 0
	                },
	                legend: {
	                    display: !1
	                },
	                scales: {
	                    yAxes: [{
	                        gridLines: {
	                            color: isDark ? "rgba(255,255,255,.05)" : "rgba(0,0,0,.05)",
	                            zeroLineColor: isDark ? "rgba(255,255,255,.05)" : "rgba(0,0,0,.05)",
	                            drawBorder: !1
	                        },
	                        ticks: {
	                            beginAtZero: !1,
	                            fixedStepSize: 1e3,
	                            fontColor: isDark ? "#a2a2a2" : "rgba(0,0,0,.4)",
	                            fontSize: 14
	                        }
	                    }],
	                    xAxes: [{
	                        gridLines: {
	                            display: !1
	                        },
	                        ticks: {
	                            fontColor: isDark ? "#a2a2a2" : "rgba(0,0,0,.4)",
	                            fontSize: 14
	                        }
	                    }]
	                },
	                tooltips: {
	                    enabled: !0,
	                    bodyFontSize: 14,
	                    callbacks: {
	                        title: function () {
	                            return ""
	                        },
	                        labelColor: function () {
	                            return {
	                                backgroundColor: "#42a5f5",
	                                borderColor: "#42a5f5"
	                            }
	                        }
	                    }
	                }
	            }, options);
	            new Chart(element.getContext("2d"), {
	                type: "line",
	                data: data,
	                options: options
	            })
	        },
	         bar: function (element) {
	            var attrData = $.extend({}, $(element).data()),
	                data = attrData.dataset ? eval(attrData.dataset) : [],
	                datasetOptions = attrData.datasetOptions ? eval(attrData.datasetOptions) : [],
	                labels = attrData.labels ? eval(attrData.labels) : {},
	                options = attrData.options ? eval("(" + attrData.options + ")") : {},
	                isDark = !!attrData.dark,
	                data = {
	                    labels: labels,
	                    datasets: data.map(function (t, a) {
	                        return $.extend({
	                            data: t,
	                            fill: !0,
	                            backgroundColor: a % 2 ? "#42a5f5" : "#1bc98e",
	                            borderColor: "transparent"
	                        }, datasetOptions[a])
	                    })
	                };
	            Charts._cleanAttr(attrData);
	            var options = $.extend({
	                maintainAspectRatio: !1,
	                animation: {
	                    duration: 0
	                },
	                legend: {
	                    display: !1
	                },
	                scales: {
	                    yAxes: [{
	                        gridLines: {
	                            color: isDark ? "rgba(255,255,255,.05)" : "rgba(0,0,0,.05)",
	                            zeroLineColor: isDark ? "rgba(255,255,255,.05)" : "rgba(0,0,0,.05)",
	                            drawBorder: !1
	                        },
	                        ticks: {
	                            fixedStepSize: 25,
	                            fontColor: isDark ? "#a2a2a2" : "rgba(0,0,0,.4)",
	                            fontSize: 14
	                        }
	                    }],
	                    xAxes: [{
	                        gridLines: {
	                            display: !1
	                        },
	                        ticks: {
	                            fontColor: isDark ? "#a2a2a2" : "rgba(0,0,0,.4)",
	                            fontSize: 14
	                        }
	                    }]
	                },
	                tooltips: {
	                    enabled: !0,
	                    bodyFontSize: 14
	                }
	            }, options);
	            new Chart(element.getContext("2d"), {
	                type: "bar",
	                data: data,
	                options: options
	            })
	        },
	         pie: function (element) {
	            var attrData = $.extend({}, $(element).data()),
	                data = attrData.dataset ? eval(attrData.dataset) : [],
	                datasetOptions = attrData.datasetOptions ? eval(attrData.datasetOptions) : [],
	                labels = attrData.labels ? eval(attrData.labels) : {},
	                options = attrData.options ? eval("(" + attrData.options + ")") : {},
	                isDark = !!attrData.dark,
	                data = {
	                    labels: labels,
	                    datasets: data.map(function (t, a) {
	                        return $.extend({
	                            data: t,
	                            fill: !0,
	                            backgroundColor: a % 2 ? "#42a5f5" : "#1bc98e",
	                            borderColor: "transparent"
	                        }, datasetOptions[a])
	                    })
	                };
	            Charts._cleanAttr(attrData);
	            var options = $.extend({
	                maintainAspectRatio: !1,
	                animation: {
	                    duration: 0
	                },
	                legend: {
	                    display: !1
	                },
	                scales: {
	                    yAxes: [{
	                        gridLines: {
	                            color: isDark ? "rgba(255,255,255,.05)" : "rgba(0,0,0,.05)",
	                            zeroLineColor: isDark ? "rgba(255,255,255,.05)" : "rgba(0,0,0,.05)",
	                            drawBorder: !1
	                        },
	                        ticks: {
	                            fixedStepSize: 25,
	                            fontColor: isDark ? "#a2a2a2" : "rgba(0,0,0,.4)",
	                            fontSize: 14
	                        }
	                    }],
	                    xAxes: [{
	                        gridLines: {
	                            display: !1
	                        },
	                        ticks: {
	                            fontColor: isDark ? "#a2a2a2" : "rgba(0,0,0,.4)",
	                            fontSize: 14
	                        }
	                    }]
	                },
	                tooltips: {
	                    enabled: !0,
	                    bodyFontSize: 14
	                }
	            }, options);
	            new Chart(element.getContext("2d"), {
	                type: "pie",
	                data: data,
	                options: options
	            })
	        },
	         radar: function (element) {
	            var attrData = $.extend({}, $(element).data()),
	                data = attrData.dataset ? eval(attrData.dataset) : [],
	                datasetOptions = attrData.datasetOptions ? eval(attrData.datasetOptions) : [],
	                labels = attrData.labels ? eval(attrData.labels) : {},
	                options = attrData.options ? eval("(" + attrData.options + ")") : {},
	                isDark = !!attrData.dark,
	                data = {
	                    labels: labels,
	                    datasets: data.map(function (t, a) {
	                        return $.extend({
	                            data: t,
	                            fill: !0,
	                            backgroundColor: a % 2 ? "#42a5f5" : "#1bc98e",
	                            borderColor: "transparent"
	                        }, datasetOptions[a])
	                    })
	                };
	            Charts._cleanAttr(attrData);
	            var options = $.extend({
	                maintainAspectRatio: !1,
	                animation: {
	                    duration: 0
	                },
	                legend: {
	                    display: !1
	                },
	                scales: {
	                    yAxes: [{
	                        gridLines: {
	                            color: isDark ? "rgba(255,255,255,.05)" : "rgba(0,0,0,.05)",
	                            zeroLineColor: isDark ? "rgba(255,255,255,.05)" : "rgba(0,0,0,.05)",
	                            drawBorder: !1
	                        },
	                        ticks: {
	                            fixedStepSize: 25,
	                            fontColor: isDark ? "#a2a2a2" : "rgba(0,0,0,.4)",
	                            fontSize: 14
	                        }
	                    }],
	                    xAxes: [{
	                        gridLines: {
	                            display: !1
	                        },
	                        ticks: {
	                            fontColor: isDark ? "#a2a2a2" : "rgba(0,0,0,.4)",
	                            fontSize: 14
	                        }
	                    }]
	                },
	                tooltips: {
	                    enabled: !0,
	                    bodyFontSize: 14
	                }
	            }, options);
	            new Chart(element.getContext("2d"), {
	                type: "radar",
	                data: data,
	                options: options
	            })
	        }
	    };

	    $("[data-chart]").each(function () {
	        $(this).is(":visible")
	        && !$(this).hasClass("js-chart-drawn")
	        && (Charts[$(this).attr("data-chart")](this), $(this).addClass("js-chart-drawn"))
	    })

	});

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * @namespace Chart
	 */
	var Chart = __webpack_require__(39)();

	Chart.helpers = __webpack_require__(41);

	// @todo dispatch these helpers into appropriated helpers/helpers.* file and write unit tests!
	__webpack_require__(46)(Chart);

	Chart.defaults = __webpack_require__(40);
	Chart.Element = __webpack_require__(52);
	Chart.elements = __webpack_require__(53);
	Chart.Interaction = __webpack_require__(58);
	Chart.platform = __webpack_require__(59);

	__webpack_require__(62)(Chart);
	__webpack_require__(63)(Chart);
	__webpack_require__(64)(Chart);
	__webpack_require__(65)(Chart);
	__webpack_require__(66)(Chart);
	__webpack_require__(67)(Chart);
	__webpack_require__(68)(Chart);
	__webpack_require__(70)(Chart);

	__webpack_require__(71)(Chart);
	__webpack_require__(72)(Chart);
	__webpack_require__(73)(Chart);
	__webpack_require__(74)(Chart);
	__webpack_require__(75)(Chart);
	__webpack_require__(76)(Chart);

	// Controllers must be loaded after elements
	// See Chart.core.datasetController.dataElementType
	__webpack_require__(195)(Chart);
	__webpack_require__(196)(Chart);
	__webpack_require__(197)(Chart);
	__webpack_require__(198)(Chart);
	__webpack_require__(199)(Chart);
	__webpack_require__(200)(Chart);
	__webpack_require__(201)(Chart);

	__webpack_require__(202)(Chart);
	__webpack_require__(203)(Chart);
	__webpack_require__(204)(Chart);
	__webpack_require__(205)(Chart);
	__webpack_require__(206)(Chart);
	__webpack_require__(207)(Chart);
	__webpack_require__(208)(Chart);

	// Loading built-it plugins
	var plugins = [];

	plugins.push(
		__webpack_require__(209)(Chart),
		__webpack_require__(210)(Chart),
		__webpack_require__(211)(Chart)
	);

	Chart.plugins.register(plugins);

	Chart.platform.initialize();

	module.exports = Chart;
	if (typeof window !== 'undefined') {
		window.Chart = Chart;
	}

	// DEPRECATIONS

	/**
	 * Provided for backward compatibility, use Chart.helpers.canvas instead.
	 * @namespace Chart.canvasHelpers
	 * @deprecated since version 2.6.0
	 * @todo remove at version 3
	 * @private
	 */
	Chart.canvasHelpers = Chart.helpers.canvas;


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var defaults = __webpack_require__(40);

	defaults._set('global', {
		responsive: true,
		responsiveAnimationDuration: 0,
		maintainAspectRatio: true,
		events: ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'],
		hover: {
			onHover: null,
			mode: 'nearest',
			intersect: true,
			animationDuration: 400
		},
		onClick: null,
		defaultColor: 'rgba(0,0,0,0.1)',
		defaultFontColor: '#666',
		defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
		defaultFontSize: 12,
		defaultFontStyle: 'normal',
		showLines: true,

		// Element defaults defined in element extensions
		elements: {},

		// Layout options such as padding
		layout: {
			padding: {
				top: 0,
				right: 0,
				bottom: 0,
				left: 0
			}
		}
	});

	module.exports = function() {

		// Occupy the global variable of Chart, and create a simple base class
		var Chart = function(item, config) {
			this.construct(item, config);
			return this;
		};

		Chart.Chart = Chart;

		return Chart;
	};


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var helpers = __webpack_require__(41);

	module.exports = {
		/**
		 * @private
		 */
		_set: function(scope, values) {
			return helpers.merge(this[scope] || (this[scope] = {}), values);
		}
	};


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(42);
	module.exports.easing = __webpack_require__(43);
	module.exports.canvas = __webpack_require__(44);
	module.exports.options = __webpack_require__(45);


/***/ }),
/* 42 */
/***/ (function(module, exports) {

	'use strict';

	/**
	 * @namespace Chart.helpers
	 */
	var helpers = {
		/**
		 * An empty function that can be used, for example, for optional callback.
		 */
		noop: function() {},

		/**
		 * Returns a unique id, sequentially generated from a global variable.
		 * @returns {Number}
		 * @function
		 */
		uid: (function() {
			var id = 0;
			return function() {
				return id++;
			};
		}()),

		/**
		 * Returns true if `value` is neither null nor undefined, else returns false.
		 * @param {*} value - The value to test.
		 * @returns {Boolean}
		 * @since 2.7.0
		 */
		isNullOrUndef: function(value) {
			return value === null || typeof value === 'undefined';
		},

		/**
		 * Returns true if `value` is an array, else returns false.
		 * @param {*} value - The value to test.
		 * @returns {Boolean}
		 * @function
		 */
		isArray: Array.isArray ? Array.isArray : function(value) {
			return Object.prototype.toString.call(value) === '[object Array]';
		},

		/**
		 * Returns true if `value` is an object (excluding null), else returns false.
		 * @param {*} value - The value to test.
		 * @returns {Boolean}
		 * @since 2.7.0
		 */
		isObject: function(value) {
			return value !== null && Object.prototype.toString.call(value) === '[object Object]';
		},

		/**
		 * Returns `value` if defined, else returns `defaultValue`.
		 * @param {*} value - The value to return if defined.
		 * @param {*} defaultValue - The value to return if `value` is undefined.
		 * @returns {*}
		 */
		valueOrDefault: function(value, defaultValue) {
			return typeof value === 'undefined' ? defaultValue : value;
		},

		/**
		 * Returns value at the given `index` in array if defined, else returns `defaultValue`.
		 * @param {Array} value - The array to lookup for value at `index`.
		 * @param {Number} index - The index in `value` to lookup for value.
		 * @param {*} defaultValue - The value to return if `value[index]` is undefined.
		 * @returns {*}
		 */
		valueAtIndexOrDefault: function(value, index, defaultValue) {
			return helpers.valueOrDefault(helpers.isArray(value) ? value[index] : value, defaultValue);
		},

		/**
		 * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the
		 * value returned by `fn`. If `fn` is not a function, this method returns undefined.
		 * @param {Function} fn - The function to call.
		 * @param {Array|undefined|null} args - The arguments with which `fn` should be called.
		 * @param {Object} [thisArg] - The value of `this` provided for the call to `fn`.
		 * @returns {*}
		 */
		callback: function(fn, args, thisArg) {
			if (fn && typeof fn.call === 'function') {
				return fn.apply(thisArg, args);
			}
		},

		/**
		 * Note(SB) for performance sake, this method should only be used when loopable type
		 * is unknown or in none intensive code (not called often and small loopable). Else
		 * it's preferable to use a regular for() loop and save extra function calls.
		 * @param {Object|Array} loopable - The object or array to be iterated.
		 * @param {Function} fn - The function to call for each item.
		 * @param {Object} [thisArg] - The value of `this` provided for the call to `fn`.
		 * @param {Boolean} [reverse] - If true, iterates backward on the loopable.
		 */
		each: function(loopable, fn, thisArg, reverse) {
			var i, len, keys;
			if (helpers.isArray(loopable)) {
				len = loopable.length;
				if (reverse) {
					for (i = len - 1; i >= 0; i--) {
						fn.call(thisArg, loopable[i], i);
					}
				} else {
					for (i = 0; i < len; i++) {
						fn.call(thisArg, loopable[i], i);
					}
				}
			} else if (helpers.isObject(loopable)) {
				keys = Object.keys(loopable);
				len = keys.length;
				for (i = 0; i < len; i++) {
					fn.call(thisArg, loopable[keys[i]], keys[i]);
				}
			}
		},

		/**
		 * Returns true if the `a0` and `a1` arrays have the same content, else returns false.
		 * @see http://stackoverflow.com/a/14853974
		 * @param {Array} a0 - The array to compare
		 * @param {Array} a1 - The array to compare
		 * @returns {Boolean}
		 */
		arrayEquals: function(a0, a1) {
			var i, ilen, v0, v1;

			if (!a0 || !a1 || a0.length !== a1.length) {
				return false;
			}

			for (i = 0, ilen = a0.length; i < ilen; ++i) {
				v0 = a0[i];
				v1 = a1[i];

				if (v0 instanceof Array && v1 instanceof Array) {
					if (!helpers.arrayEquals(v0, v1)) {
						return false;
					}
				} else if (v0 !== v1) {
					// NOTE: two different object instances will never be equal: {x:20} != {x:20}
					return false;
				}
			}

			return true;
		},

		/**
		 * Returns a deep copy of `source` without keeping references on objects and arrays.
		 * @param {*} source - The value to clone.
		 * @returns {*}
		 */
		clone: function(source) {
			if (helpers.isArray(source)) {
				return source.map(helpers.clone);
			}

			if (helpers.isObject(source)) {
				var target = {};
				var keys = Object.keys(source);
				var klen = keys.length;
				var k = 0;

				for (; k < klen; ++k) {
					target[keys[k]] = helpers.clone(source[keys[k]]);
				}

				return target;
			}

			return source;
		},

		/**
		 * The default merger when Chart.helpers.merge is called without merger option.
		 * Note(SB): this method is also used by configMerge and scaleMerge as fallback.
		 * @private
		 */
		_merger: function(key, target, source, options) {
			var tval = target[key];
			var sval = source[key];

			if (helpers.isObject(tval) && helpers.isObject(sval)) {
				helpers.merge(tval, sval, options);
			} else {
				target[key] = helpers.clone(sval);
			}
		},

		/**
		 * Merges source[key] in target[key] only if target[key] is undefined.
		 * @private
		 */
		_mergerIf: function(key, target, source) {
			var tval = target[key];
			var sval = source[key];

			if (helpers.isObject(tval) && helpers.isObject(sval)) {
				helpers.mergeIf(tval, sval);
			} else if (!target.hasOwnProperty(key)) {
				target[key] = helpers.clone(sval);
			}
		},

		/**
		 * Recursively deep copies `source` properties into `target` with the given `options`.
		 * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
		 * @param {Object} target - The target object in which all sources are merged into.
		 * @param {Object|Array(Object)} source - Object(s) to merge into `target`.
		 * @param {Object} [options] - Merging options:
		 * @param {Function} [options.merger] - The merge method (key, target, source, options)
		 * @returns {Object} The `target` object.
		 */
		merge: function(target, source, options) {
			var sources = helpers.isArray(source) ? source : [source];
			var ilen = sources.length;
			var merge, i, keys, klen, k;

			if (!helpers.isObject(target)) {
				return target;
			}

			options = options || {};
			merge = options.merger || helpers._merger;

			for (i = 0; i < ilen; ++i) {
				source = sources[i];
				if (!helpers.isObject(source)) {
					continue;
				}

				keys = Object.keys(source);
				for (k = 0, klen = keys.length; k < klen; ++k) {
					merge(keys[k], target, source, options);
				}
			}

			return target;
		},

		/**
		 * Recursively deep copies `source` properties into `target` *only* if not defined in target.
		 * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
		 * @param {Object} target - The target object in which all sources are merged into.
		 * @param {Object|Array(Object)} source - Object(s) to merge into `target`.
		 * @returns {Object} The `target` object.
		 */
		mergeIf: function(target, source) {
			return helpers.merge(target, source, {merger: helpers._mergerIf});
		},

		/**
		 * Applies the contents of two or more objects together into the first object.
		 * @param {Object} target - The target object in which all objects are merged into.
		 * @param {Object} arg1 - Object containing additional properties to merge in target.
		 * @param {Object} argN - Additional objects containing properties to merge in target.
		 * @returns {Object} The `target` object.
		 */
		extend: function(target) {
			var setFn = function(value, key) {
				target[key] = value;
			};
			for (var i = 1, ilen = arguments.length; i < ilen; ++i) {
				helpers.each(arguments[i], setFn);
			}
			return target;
		},

		/**
		 * Basic javascript inheritance based on the model created in Backbone.js
		 */
		inherits: function(extensions) {
			var me = this;
			var ChartElement = (extensions && extensions.hasOwnProperty('constructor')) ? extensions.constructor : function() {
				return me.apply(this, arguments);
			};

			var Surrogate = function() {
				this.constructor = ChartElement;
			};

			Surrogate.prototype = me.prototype;
			ChartElement.prototype = new Surrogate();
			ChartElement.extend = helpers.inherits;

			if (extensions) {
				helpers.extend(ChartElement.prototype, extensions);
			}

			ChartElement.__super__ = me.prototype;
			return ChartElement;
		}
	};

	module.exports = helpers;

	// DEPRECATIONS

	/**
	 * Provided for backward compatibility, use Chart.helpers.callback instead.
	 * @function Chart.helpers.callCallback
	 * @deprecated since version 2.6.0
	 * @todo remove at version 3
	 * @private
	 */
	helpers.callCallback = helpers.callback;

	/**
	 * Provided for backward compatibility, use Array.prototype.indexOf instead.
	 * Array.prototype.indexOf compatibility: Chrome, Opera, Safari, FF1.5+, IE9+
	 * @function Chart.helpers.indexOf
	 * @deprecated since version 2.7.0
	 * @todo remove at version 3
	 * @private
	 */
	helpers.indexOf = function(array, item, fromIndex) {
		return Array.prototype.indexOf.call(array, item, fromIndex);
	};

	/**
	 * Provided for backward compatibility, use Chart.helpers.valueOrDefault instead.
	 * @function Chart.helpers.getValueOrDefault
	 * @deprecated since version 2.7.0
	 * @todo remove at version 3
	 * @private
	 */
	helpers.getValueOrDefault = helpers.valueOrDefault;

	/**
	 * Provided for backward compatibility, use Chart.helpers.valueAtIndexOrDefault instead.
	 * @function Chart.helpers.getValueAtIndexOrDefault
	 * @deprecated since version 2.7.0
	 * @todo remove at version 3
	 * @private
	 */
	helpers.getValueAtIndexOrDefault = helpers.valueAtIndexOrDefault;


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var helpers = __webpack_require__(42);

	/**
	 * Easing functions adapted from Robert Penner's easing equations.
	 * @namespace Chart.helpers.easingEffects
	 * @see http://www.robertpenner.com/easing/
	 */
	var effects = {
		linear: function(t) {
			return t;
		},

		easeInQuad: function(t) {
			return t * t;
		},

		easeOutQuad: function(t) {
			return -t * (t - 2);
		},

		easeInOutQuad: function(t) {
			if ((t /= 0.5) < 1) {
				return 0.5 * t * t;
			}
			return -0.5 * ((--t) * (t - 2) - 1);
		},

		easeInCubic: function(t) {
			return t * t * t;
		},

		easeOutCubic: function(t) {
			return (t = t - 1) * t * t + 1;
		},

		easeInOutCubic: function(t) {
			if ((t /= 0.5) < 1) {
				return 0.5 * t * t * t;
			}
			return 0.5 * ((t -= 2) * t * t + 2);
		},

		easeInQuart: function(t) {
			return t * t * t * t;
		},

		easeOutQuart: function(t) {
			return -((t = t - 1) * t * t * t - 1);
		},

		easeInOutQuart: function(t) {
			if ((t /= 0.5) < 1) {
				return 0.5 * t * t * t * t;
			}
			return -0.5 * ((t -= 2) * t * t * t - 2);
		},

		easeInQuint: function(t) {
			return t * t * t * t * t;
		},

		easeOutQuint: function(t) {
			return (t = t - 1) * t * t * t * t + 1;
		},

		easeInOutQuint: function(t) {
			if ((t /= 0.5) < 1) {
				return 0.5 * t * t * t * t * t;
			}
			return 0.5 * ((t -= 2) * t * t * t * t + 2);
		},

		easeInSine: function(t) {
			return -Math.cos(t * (Math.PI / 2)) + 1;
		},

		easeOutSine: function(t) {
			return Math.sin(t * (Math.PI / 2));
		},

		easeInOutSine: function(t) {
			return -0.5 * (Math.cos(Math.PI * t) - 1);
		},

		easeInExpo: function(t) {
			return (t === 0) ? 0 : Math.pow(2, 10 * (t - 1));
		},

		easeOutExpo: function(t) {
			return (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1;
		},

		easeInOutExpo: function(t) {
			if (t === 0) {
				return 0;
			}
			if (t === 1) {
				return 1;
			}
			if ((t /= 0.5) < 1) {
				return 0.5 * Math.pow(2, 10 * (t - 1));
			}
			return 0.5 * (-Math.pow(2, -10 * --t) + 2);
		},

		easeInCirc: function(t) {
			if (t >= 1) {
				return t;
			}
			return -(Math.sqrt(1 - t * t) - 1);
		},

		easeOutCirc: function(t) {
			return Math.sqrt(1 - (t = t - 1) * t);
		},

		easeInOutCirc: function(t) {
			if ((t /= 0.5) < 1) {
				return -0.5 * (Math.sqrt(1 - t * t) - 1);
			}
			return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
		},

		easeInElastic: function(t) {
			var s = 1.70158;
			var p = 0;
			var a = 1;
			if (t === 0) {
				return 0;
			}
			if (t === 1) {
				return 1;
			}
			if (!p) {
				p = 0.3;
			}
			if (a < 1) {
				a = 1;
				s = p / 4;
			} else {
				s = p / (2 * Math.PI) * Math.asin(1 / a);
			}
			return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
		},

		easeOutElastic: function(t) {
			var s = 1.70158;
			var p = 0;
			var a = 1;
			if (t === 0) {
				return 0;
			}
			if (t === 1) {
				return 1;
			}
			if (!p) {
				p = 0.3;
			}
			if (a < 1) {
				a = 1;
				s = p / 4;
			} else {
				s = p / (2 * Math.PI) * Math.asin(1 / a);
			}
			return a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;
		},

		easeInOutElastic: function(t) {
			var s = 1.70158;
			var p = 0;
			var a = 1;
			if (t === 0) {
				return 0;
			}
			if ((t /= 0.5) === 2) {
				return 1;
			}
			if (!p) {
				p = 0.45;
			}
			if (a < 1) {
				a = 1;
				s = p / 4;
			} else {
				s = p / (2 * Math.PI) * Math.asin(1 / a);
			}
			if (t < 1) {
				return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
			}
			return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * 0.5 + 1;
		},
		easeInBack: function(t) {
			var s = 1.70158;
			return t * t * ((s + 1) * t - s);
		},

		easeOutBack: function(t) {
			var s = 1.70158;
			return (t = t - 1) * t * ((s + 1) * t + s) + 1;
		},

		easeInOutBack: function(t) {
			var s = 1.70158;
			if ((t /= 0.5) < 1) {
				return 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));
			}
			return 0.5 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);
		},

		easeInBounce: function(t) {
			return 1 - effects.easeOutBounce(1 - t);
		},

		easeOutBounce: function(t) {
			if (t < (1 / 2.75)) {
				return 7.5625 * t * t;
			}
			if (t < (2 / 2.75)) {
				return 7.5625 * (t -= (1.5 / 2.75)) * t + 0.75;
			}
			if (t < (2.5 / 2.75)) {
				return 7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375;
			}
			return 7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375;
		},

		easeInOutBounce: function(t) {
			if (t < 0.5) {
				return effects.easeInBounce(t * 2) * 0.5;
			}
			return effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;
		}
	};

	module.exports = {
		effects: effects
	};

	// DEPRECATIONS

	/**
	 * Provided for backward compatibility, use Chart.helpers.easing.effects instead.
	 * @function Chart.helpers.easingEffects
	 * @deprecated since version 2.7.0
	 * @todo remove at version 3
	 * @private
	 */
	helpers.easingEffects = effects;


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var helpers = __webpack_require__(42);

	/**
	 * @namespace Chart.helpers.canvas
	 */
	var exports = module.exports = {
		/**
		 * Clears the entire canvas associated to the given `chart`.
		 * @param {Chart} chart - The chart for which to clear the canvas.
		 */
		clear: function(chart) {
			chart.ctx.clearRect(0, 0, chart.width, chart.height);
		},

		/**
		 * Creates a "path" for a rectangle with rounded corners at position (x, y) with a
		 * given size (width, height) and the same `radius` for all corners.
		 * @param {CanvasRenderingContext2D} ctx - The canvas 2D Context.
		 * @param {Number} x - The x axis of the coordinate for the rectangle starting point.
		 * @param {Number} y - The y axis of the coordinate for the rectangle starting point.
		 * @param {Number} width - The rectangle's width.
		 * @param {Number} height - The rectangle's height.
		 * @param {Number} radius - The rounded amount (in pixels) for the four corners.
		 * @todo handle `radius` as top-left, top-right, bottom-right, bottom-left array/object?
		 */
		roundedRect: function(ctx, x, y, width, height, radius) {
			if (radius) {
				var rx = Math.min(radius, width / 2);
				var ry = Math.min(radius, height / 2);

				ctx.moveTo(x + rx, y);
				ctx.lineTo(x + width - rx, y);
				ctx.quadraticCurveTo(x + width, y, x + width, y + ry);
				ctx.lineTo(x + width, y + height - ry);
				ctx.quadraticCurveTo(x + width, y + height, x + width - rx, y + height);
				ctx.lineTo(x + rx, y + height);
				ctx.quadraticCurveTo(x, y + height, x, y + height - ry);
				ctx.lineTo(x, y + ry);
				ctx.quadraticCurveTo(x, y, x + rx, y);
			} else {
				ctx.rect(x, y, width, height);
			}
		},

		drawPoint: function(ctx, style, radius, x, y) {
			var type, edgeLength, xOffset, yOffset, height, size;

			if (style && typeof style === 'object') {
				type = style.toString();
				if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {
					ctx.drawImage(style, x - style.width / 2, y - style.height / 2, style.width, style.height);
					return;
				}
			}

			if (isNaN(radius) || radius <= 0) {
				return;
			}

			switch (style) {
			// Default includes circle
			default:
				ctx.beginPath();
				ctx.arc(x, y, radius, 0, Math.PI * 2);
				ctx.closePath();
				ctx.fill();
				break;
			case 'triangle':
				ctx.beginPath();
				edgeLength = 3 * radius / Math.sqrt(3);
				height = edgeLength * Math.sqrt(3) / 2;
				ctx.moveTo(x - edgeLength / 2, y + height / 3);
				ctx.lineTo(x + edgeLength / 2, y + height / 3);
				ctx.lineTo(x, y - 2 * height / 3);
				ctx.closePath();
				ctx.fill();
				break;
			case 'rect':
				size = 1 / Math.SQRT2 * radius;
				ctx.beginPath();
				ctx.fillRect(x - size, y - size, 2 * size, 2 * size);
				ctx.strokeRect(x - size, y - size, 2 * size, 2 * size);
				break;
			case 'rectRounded':
				var offset = radius / Math.SQRT2;
				var leftX = x - offset;
				var topY = y - offset;
				var sideSize = Math.SQRT2 * radius;
				ctx.beginPath();
				this.roundedRect(ctx, leftX, topY, sideSize, sideSize, radius / 2);
				ctx.closePath();
				ctx.fill();
				break;
			case 'rectRot':
				size = 1 / Math.SQRT2 * radius;
				ctx.beginPath();
				ctx.moveTo(x - size, y);
				ctx.lineTo(x, y + size);
				ctx.lineTo(x + size, y);
				ctx.lineTo(x, y - size);
				ctx.closePath();
				ctx.fill();
				break;
			case 'cross':
				ctx.beginPath();
				ctx.moveTo(x, y + radius);
				ctx.lineTo(x, y - radius);
				ctx.moveTo(x - radius, y);
				ctx.lineTo(x + radius, y);
				ctx.closePath();
				break;
			case 'crossRot':
				ctx.beginPath();
				xOffset = Math.cos(Math.PI / 4) * radius;
				yOffset = Math.sin(Math.PI / 4) * radius;
				ctx.moveTo(x - xOffset, y - yOffset);
				ctx.lineTo(x + xOffset, y + yOffset);
				ctx.moveTo(x - xOffset, y + yOffset);
				ctx.lineTo(x + xOffset, y - yOffset);
				ctx.closePath();
				break;
			case 'star':
				ctx.beginPath();
				ctx.moveTo(x, y + radius);
				ctx.lineTo(x, y - radius);
				ctx.moveTo(x - radius, y);
				ctx.lineTo(x + radius, y);
				xOffset = Math.cos(Math.PI / 4) * radius;
				yOffset = Math.sin(Math.PI / 4) * radius;
				ctx.moveTo(x - xOffset, y - yOffset);
				ctx.lineTo(x + xOffset, y + yOffset);
				ctx.moveTo(x - xOffset, y + yOffset);
				ctx.lineTo(x + xOffset, y - yOffset);
				ctx.closePath();
				break;
			case 'line':
				ctx.beginPath();
				ctx.moveTo(x - radius, y);
				ctx.lineTo(x + radius, y);
				ctx.closePath();
				break;
			case 'dash':
				ctx.beginPath();
				ctx.moveTo(x, y);
				ctx.lineTo(x + radius, y);
				ctx.closePath();
				break;
			}

			ctx.stroke();
		},

		clipArea: function(ctx, area) {
			ctx.save();
			ctx.beginPath();
			ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
			ctx.clip();
		},

		unclipArea: function(ctx) {
			ctx.restore();
		},

		lineTo: function(ctx, previous, target, flip) {
			if (target.steppedLine) {
				if ((target.steppedLine === 'after' && !flip) || (target.steppedLine !== 'after' && flip)) {
					ctx.lineTo(previous.x, target.y);
				} else {
					ctx.lineTo(target.x, previous.y);
				}
				ctx.lineTo(target.x, target.y);
				return;
			}

			if (!target.tension) {
				ctx.lineTo(target.x, target.y);
				return;
			}

			ctx.bezierCurveTo(
				flip ? previous.controlPointPreviousX : previous.controlPointNextX,
				flip ? previous.controlPointPreviousY : previous.controlPointNextY,
				flip ? target.controlPointNextX : target.controlPointPreviousX,
				flip ? target.controlPointNextY : target.controlPointPreviousY,
				target.x,
				target.y);
		}
	};

	// DEPRECATIONS

	/**
	 * Provided for backward compatibility, use Chart.helpers.canvas.clear instead.
	 * @namespace Chart.helpers.clear
	 * @deprecated since version 2.7.0
	 * @todo remove at version 3
	 * @private
	 */
	helpers.clear = exports.clear;

	/**
	 * Provided for backward compatibility, use Chart.helpers.canvas.roundedRect instead.
	 * @namespace Chart.helpers.drawRoundedRectangle
	 * @deprecated since version 2.7.0
	 * @todo remove at version 3
	 * @private
	 */
	helpers.drawRoundedRectangle = function(ctx) {
		ctx.beginPath();
		exports.roundedRect.apply(exports, arguments);
		ctx.closePath();
	};


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var helpers = __webpack_require__(42);

	/**
	 * @alias Chart.helpers.options
	 * @namespace
	 */
	module.exports = {
		/**
		 * Converts the given line height `value` in pixels for a specific font `size`.
		 * @param {Number|String} value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').
		 * @param {Number} size - The font size (in pixels) used to resolve relative `value`.
		 * @returns {Number} The effective line height in pixels (size * 1.2 if value is invalid).
		 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height
		 * @since 2.7.0
		 */
		toLineHeight: function(value, size) {
			var matches = ('' + value).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
			if (!matches || matches[1] === 'normal') {
				return size * 1.2;
			}

			value = +matches[2];

			switch (matches[3]) {
			case 'px':
				return value;
			case '%':
				value /= 100;
				break;
			default:
				break;
			}

			return size * value;
		},

		/**
		 * Converts the given value into a padding object with pre-computed width/height.
		 * @param {Number|Object} value - If a number, set the value to all TRBL component,
		 *  else, if and object, use defined properties and sets undefined ones to 0.
		 * @returns {Object} The padding values (top, right, bottom, left, width, height)
		 * @since 2.7.0
		 */
		toPadding: function(value) {
			var t, r, b, l;

			if (helpers.isObject(value)) {
				t = +value.top || 0;
				r = +value.right || 0;
				b = +value.bottom || 0;
				l = +value.left || 0;
			} else {
				t = r = b = l = +value || 0;
			}

			return {
				top: t,
				right: r,
				bottom: b,
				left: l,
				height: t + b,
				width: l + r
			};
		},

		/**
		 * Evaluates the given `inputs` sequentially and returns the first defined value.
		 * @param {Array[]} inputs - An array of values, falling back to the last value.
		 * @param {Object} [context] - If defined and the current value is a function, the value
		 * is called with `context` as first argument and the result becomes the new input.
		 * @param {Number} [index] - If defined and the current value is an array, the value
		 * at `index` become the new input.
		 * @since 2.7.0
		 */
		resolve: function(inputs, context, index) {
			var i, ilen, value;

			for (i = 0, ilen = inputs.length; i < ilen; ++i) {
				value = inputs[i];
				if (value === undefined) {
					continue;
				}
				if (context !== undefined && typeof value === 'function') {
					value = value(context);
				}
				if (index !== undefined && helpers.isArray(value)) {
					value = value[index];
				}
				if (value !== undefined) {
					return value;
				}
			}
		}
	};


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	/* global window: false */
	/* global document: false */
	'use strict';

	var color = __webpack_require__(47);
	var defaults = __webpack_require__(40);
	var helpers = __webpack_require__(41);

	module.exports = function(Chart) {

		// -- Basic js utility methods

		helpers.configMerge = function(/* objects ... */) {
			return helpers.merge(helpers.clone(arguments[0]), [].slice.call(arguments, 1), {
				merger: function(key, target, source, options) {
					var tval = target[key] || {};
					var sval = source[key];

					if (key === 'scales') {
						// scale config merging is complex. Add our own function here for that
						target[key] = helpers.scaleMerge(tval, sval);
					} else if (key === 'scale') {
						// used in polar area & radar charts since there is only one scale
						target[key] = helpers.merge(tval, [Chart.scaleService.getScaleDefaults(sval.type), sval]);
					} else {
						helpers._merger(key, target, source, options);
					}
				}
			});
		};

		helpers.scaleMerge = function(/* objects ... */) {
			return helpers.merge(helpers.clone(arguments[0]), [].slice.call(arguments, 1), {
				merger: function(key, target, source, options) {
					if (key === 'xAxes' || key === 'yAxes') {
						var slen = source[key].length;
						var i, type, scale;

						if (!target[key]) {
							target[key] = [];
						}

						for (i = 0; i < slen; ++i) {
							scale = source[key][i];
							type = helpers.valueOrDefault(scale.type, key === 'xAxes' ? 'category' : 'linear');

							if (i >= target[key].length) {
								target[key].push({});
							}

							if (!target[key][i].type || (scale.type && scale.type !== target[key][i].type)) {
								// new/untyped scale or type changed: let's apply the new defaults
								// then merge source scale to correctly overwrite the defaults.
								helpers.merge(target[key][i], [Chart.scaleService.getScaleDefaults(type), scale]);
							} else {
								// scales type are the same
								helpers.merge(target[key][i], scale);
							}
						}
					} else {
						helpers._merger(key, target, source, options);
					}
				}
			});
		};

		helpers.where = function(collection, filterCallback) {
			if (helpers.isArray(collection) && Array.prototype.filter) {
				return collection.filter(filterCallback);
			}
			var filtered = [];

			helpers.each(collection, function(item) {
				if (filterCallback(item)) {
					filtered.push(item);
				}
			});

			return filtered;
		};
		helpers.findIndex = Array.prototype.findIndex ?
			function(array, callback, scope) {
				return array.findIndex(callback, scope);
			} :
			function(array, callback, scope) {
				scope = scope === undefined ? array : scope;
				for (var i = 0, ilen = array.length; i < ilen; ++i) {
					if (callback.call(scope, array[i], i, array)) {
						return i;
					}
				}
				return -1;
			};
		helpers.findNextWhere = function(arrayToSearch, filterCallback, startIndex) {
			// Default to start of the array
			if (helpers.isNullOrUndef(startIndex)) {
				startIndex = -1;
			}
			for (var i = startIndex + 1; i < arrayToSearch.length; i++) {
				var currentItem = arrayToSearch[i];
				if (filterCallback(currentItem)) {
					return currentItem;
				}
			}
		};
		helpers.findPreviousWhere = function(arrayToSearch, filterCallback, startIndex) {
			// Default to end of the array
			if (helpers.isNullOrUndef(startIndex)) {
				startIndex = arrayToSearch.length;
			}
			for (var i = startIndex - 1; i >= 0; i--) {
				var currentItem = arrayToSearch[i];
				if (filterCallback(currentItem)) {
					return currentItem;
				}
			}
		};

		// -- Math methods
		helpers.isNumber = function(n) {
			return !isNaN(parseFloat(n)) && isFinite(n);
		};
		helpers.almostEquals = function(x, y, epsilon) {
			return Math.abs(x - y) < epsilon;
		};
		helpers.almostWhole = function(x, epsilon) {
			var rounded = Math.round(x);
			return (((rounded - epsilon) < x) && ((rounded + epsilon) > x));
		};
		helpers.max = function(array) {
			return array.reduce(function(max, value) {
				if (!isNaN(value)) {
					return Math.max(max, value);
				}
				return max;
			}, Number.NEGATIVE_INFINITY);
		};
		helpers.min = function(array) {
			return array.reduce(function(min, value) {
				if (!isNaN(value)) {
					return Math.min(min, value);
				}
				return min;
			}, Number.POSITIVE_INFINITY);
		};
		helpers.sign = Math.sign ?
			function(x) {
				return Math.sign(x);
			} :
			function(x) {
				x = +x; // convert to a number
				if (x === 0 || isNaN(x)) {
					return x;
				}
				return x > 0 ? 1 : -1;
			};
		helpers.log10 = Math.log10 ?
			function(x) {
				return Math.log10(x);
			} :
			function(x) {
				return Math.log(x) / Math.LN10;
			};
		helpers.toRadians = function(degrees) {
			return degrees * (Math.PI / 180);
		};
		helpers.toDegrees = function(radians) {
			return radians * (180 / Math.PI);
		};
		// Gets the angle from vertical upright to the point about a centre.
		helpers.getAngleFromPoint = function(centrePoint, anglePoint) {
			var distanceFromXCenter = anglePoint.x - centrePoint.x;
			var distanceFromYCenter = anglePoint.y - centrePoint.y;
			var radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);

			var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);

			if (angle < (-0.5 * Math.PI)) {
				angle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]
			}

			return {
				angle: angle,
				distance: radialDistanceFromCenter
			};
		};
		helpers.distanceBetweenPoints = function(pt1, pt2) {
			return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
		};
		helpers.aliasPixel = function(pixelWidth) {
			return (pixelWidth % 2 === 0) ? 0 : 0.5;
		};
		helpers.splineCurve = function(firstPoint, middlePoint, afterPoint, t) {
			// Props to Rob Spencer at scaled innovation for his post on splining between points
			// http://scaledinnovation.com/analytics/splines/aboutSplines.html

			// This function must also respect "skipped" points

			var previous = firstPoint.skip ? middlePoint : firstPoint;
			var current = middlePoint;
			var next = afterPoint.skip ? middlePoint : afterPoint;

			var d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));
			var d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));

			var s01 = d01 / (d01 + d12);
			var s12 = d12 / (d01 + d12);

			// If all points are the same, s01 & s02 will be inf
			s01 = isNaN(s01) ? 0 : s01;
			s12 = isNaN(s12) ? 0 : s12;

			var fa = t * s01; // scaling factor for triangle Ta
			var fb = t * s12;

			return {
				previous: {
					x: current.x - fa * (next.x - previous.x),
					y: current.y - fa * (next.y - previous.y)
				},
				next: {
					x: current.x + fb * (next.x - previous.x),
					y: current.y + fb * (next.y - previous.y)
				}
			};
		};
		helpers.EPSILON = Number.EPSILON || 1e-14;
		helpers.splineCurveMonotone = function(points) {
			// This function calculates Bézier control points in a similar way than |splineCurve|,
			// but preserves monotonicity of the provided data and ensures no local extremums are added
			// between the dataset discrete points due to the interpolation.
			// See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation

			var pointsWithTangents = (points || []).map(function(point) {
				return {
					model: point._model,
					deltaK: 0,
					mK: 0
				};
			});

			// Calculate slopes (deltaK) and initialize tangents (mK)
			var pointsLen = pointsWithTangents.length;
			var i, pointBefore, pointCurrent, pointAfter;
			for (i = 0; i < pointsLen; ++i) {
				pointCurrent = pointsWithTangents[i];
				if (pointCurrent.model.skip) {
					continue;
				}

				pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
				pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
				if (pointAfter && !pointAfter.model.skip) {
					var slopeDeltaX = (pointAfter.model.x - pointCurrent.model.x);

					// In the case of two points that appear at the same x pixel, slopeDeltaX is 0
					pointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;
				}

				if (!pointBefore || pointBefore.model.skip) {
					pointCurrent.mK = pointCurrent.deltaK;
				} else if (!pointAfter || pointAfter.model.skip) {
					pointCurrent.mK = pointBefore.deltaK;
				} else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {
					pointCurrent.mK = 0;
				} else {
					pointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;
				}
			}

			// Adjust tangents to ensure monotonic properties
			var alphaK, betaK, tauK, squaredMagnitude;
			for (i = 0; i < pointsLen - 1; ++i) {
				pointCurrent = pointsWithTangents[i];
				pointAfter = pointsWithTangents[i + 1];
				if (pointCurrent.model.skip || pointAfter.model.skip) {
					continue;
				}

				if (helpers.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {
					pointCurrent.mK = pointAfter.mK = 0;
					continue;
				}

				alphaK = pointCurrent.mK / pointCurrent.deltaK;
				betaK = pointAfter.mK / pointCurrent.deltaK;
				squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
				if (squaredMagnitude <= 9) {
					continue;
				}

				tauK = 3 / Math.sqrt(squaredMagnitude);
				pointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;
				pointAfter.mK = betaK * tauK * pointCurrent.deltaK;
			}

			// Compute control points
			var deltaX;
			for (i = 0; i < pointsLen; ++i) {
				pointCurrent = pointsWithTangents[i];
				if (pointCurrent.model.skip) {
					continue;
				}

				pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
				pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
				if (pointBefore && !pointBefore.model.skip) {
					deltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;
					pointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;
					pointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;
				}
				if (pointAfter && !pointAfter.model.skip) {
					deltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;
					pointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;
					pointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;
				}
			}
		};
		helpers.nextItem = function(collection, index, loop) {
			if (loop) {
				return index >= collection.length - 1 ? collection[0] : collection[index + 1];
			}
			return index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];
		};
		helpers.previousItem = function(collection, index, loop) {
			if (loop) {
				return index <= 0 ? collection[collection.length - 1] : collection[index - 1];
			}
			return index <= 0 ? collection[0] : collection[index - 1];
		};
		// Implementation of the nice number algorithm used in determining where axis labels will go
		helpers.niceNum = function(range, round) {
			var exponent = Math.floor(helpers.log10(range));
			var fraction = range / Math.pow(10, exponent);
			var niceFraction;

			if (round) {
				if (fraction < 1.5) {
					niceFraction = 1;
				} else if (fraction < 3) {
					niceFraction = 2;
				} else if (fraction < 7) {
					niceFraction = 5;
				} else {
					niceFraction = 10;
				}
			} else if (fraction <= 1.0) {
				niceFraction = 1;
			} else if (fraction <= 2) {
				niceFraction = 2;
			} else if (fraction <= 5) {
				niceFraction = 5;
			} else {
				niceFraction = 10;
			}

			return niceFraction * Math.pow(10, exponent);
		};
		// Request animation polyfill - http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/
		helpers.requestAnimFrame = (function() {
			if (typeof window === 'undefined') {
				return function(callback) {
					callback();
				};
			}
			return window.requestAnimationFrame ||
				window.webkitRequestAnimationFrame ||
				window.mozRequestAnimationFrame ||
				window.oRequestAnimationFrame ||
				window.msRequestAnimationFrame ||
				function(callback) {
					return window.setTimeout(callback, 1000 / 60);
				};
		}());
		// -- DOM methods
		helpers.getRelativePosition = function(evt, chart) {
			var mouseX, mouseY;
			var e = evt.originalEvent || evt;
			var canvas = evt.currentTarget || evt.srcElement;
			var boundingRect = canvas.getBoundingClientRect();

			var touches = e.touches;
			if (touches && touches.length > 0) {
				mouseX = touches[0].clientX;
				mouseY = touches[0].clientY;

			} else {
				mouseX = e.clientX;
				mouseY = e.clientY;
			}

			// Scale mouse coordinates into canvas coordinates
			// by following the pattern laid out by 'jerryj' in the comments of
			// http://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/
			var paddingLeft = parseFloat(helpers.getStyle(canvas, 'padding-left'));
			var paddingTop = parseFloat(helpers.getStyle(canvas, 'padding-top'));
			var paddingRight = parseFloat(helpers.getStyle(canvas, 'padding-right'));
			var paddingBottom = parseFloat(helpers.getStyle(canvas, 'padding-bottom'));
			var width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;
			var height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;

			// We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However
			// the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here
			mouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / (width) * canvas.width / chart.currentDevicePixelRatio);
			mouseY = Math.round((mouseY - boundingRect.top - paddingTop) / (height) * canvas.height / chart.currentDevicePixelRatio);

			return {
				x: mouseX,
				y: mouseY
			};

		};

		// Private helper function to convert max-width/max-height values that may be percentages into a number
		function parseMaxStyle(styleValue, node, parentProperty) {
			var valueInPixels;
			if (typeof styleValue === 'string') {
				valueInPixels = parseInt(styleValue, 10);

				if (styleValue.indexOf('%') !== -1) {
					// percentage * size in dimension
					valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
				}
			} else {
				valueInPixels = styleValue;
			}

			return valueInPixels;
		}

		/**
		 * Returns if the given value contains an effective constraint.
		 * @private
		 */
		function isConstrainedValue(value) {
			return value !== undefined && value !== null && value !== 'none';
		}

		// Private helper to get a constraint dimension
		// @param domNode : the node to check the constraint on
		// @param maxStyle : the style that defines the maximum for the direction we are using (maxWidth / maxHeight)
		// @param percentageProperty : property of parent to use when calculating width as a percentage
		// @see http://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser
		function getConstraintDimension(domNode, maxStyle, percentageProperty) {
			var view = document.defaultView;
			var parentNode = domNode.parentNode;
			var constrainedNode = view.getComputedStyle(domNode)[maxStyle];
			var constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];
			var hasCNode = isConstrainedValue(constrainedNode);
			var hasCContainer = isConstrainedValue(constrainedContainer);
			var infinity = Number.POSITIVE_INFINITY;

			if (hasCNode || hasCContainer) {
				return Math.min(
					hasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity,
					hasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);
			}

			return 'none';
		}
		// returns Number or undefined if no constraint
		helpers.getConstraintWidth = function(domNode) {
			return getConstraintDimension(domNode, 'max-width', 'clientWidth');
		};
		// returns Number or undefined if no constraint
		helpers.getConstraintHeight = function(domNode) {
			return getConstraintDimension(domNode, 'max-height', 'clientHeight');
		};
		helpers.getMaximumWidth = function(domNode) {
			var container = domNode.parentNode;
			if (!container) {
				return domNode.clientWidth;
			}

			var paddingLeft = parseInt(helpers.getStyle(container, 'padding-left'), 10);
			var paddingRight = parseInt(helpers.getStyle(container, 'padding-right'), 10);
			var w = container.clientWidth - paddingLeft - paddingRight;
			var cw = helpers.getConstraintWidth(domNode);
			return isNaN(cw) ? w : Math.min(w, cw);
		};
		helpers.getMaximumHeight = function(domNode) {
			var container = domNode.parentNode;
			if (!container) {
				return domNode.clientHeight;
			}

			var paddingTop = parseInt(helpers.getStyle(container, 'padding-top'), 10);
			var paddingBottom = parseInt(helpers.getStyle(container, 'padding-bottom'), 10);
			var h = container.clientHeight - paddingTop - paddingBottom;
			var ch = helpers.getConstraintHeight(domNode);
			return isNaN(ch) ? h : Math.min(h, ch);
		};
		helpers.getStyle = function(el, property) {
			return el.currentStyle ?
				el.currentStyle[property] :
				document.defaultView.getComputedStyle(el, null).getPropertyValue(property);
		};
		helpers.retinaScale = function(chart, forceRatio) {
			var pixelRatio = chart.currentDevicePixelRatio = forceRatio || window.devicePixelRatio || 1;
			if (pixelRatio === 1) {
				return;
			}

			var canvas = chart.canvas;
			var height = chart.height;
			var width = chart.width;

			canvas.height = height * pixelRatio;
			canvas.width = width * pixelRatio;
			chart.ctx.scale(pixelRatio, pixelRatio);

			// If no style has been set on the canvas, the render size is used as display size,
			// making the chart visually bigger, so let's enforce it to the "correct" values.
			// See https://github.com/chartjs/Chart.js/issues/3575
			canvas.style.height = height + 'px';
			canvas.style.width = width + 'px';
		};
		// -- Canvas methods
		helpers.fontString = function(pixelSize, fontStyle, fontFamily) {
			return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;
		};
		helpers.longestText = function(ctx, font, arrayOfThings, cache) {
			cache = cache || {};
			var data = cache.data = cache.data || {};
			var gc = cache.garbageCollect = cache.garbageCollect || [];

			if (cache.font !== font) {
				data = cache.data = {};
				gc = cache.garbageCollect = [];
				cache.font = font;
			}

			ctx.font = font;
			var longest = 0;
			helpers.each(arrayOfThings, function(thing) {
				// Undefined strings and arrays should not be measured
				if (thing !== undefined && thing !== null && helpers.isArray(thing) !== true) {
					longest = helpers.measureText(ctx, data, gc, longest, thing);
				} else if (helpers.isArray(thing)) {
					// if it is an array lets measure each element
					// to do maybe simplify this function a bit so we can do this more recursively?
					helpers.each(thing, function(nestedThing) {
						// Undefined strings and arrays should not be measured
						if (nestedThing !== undefined && nestedThing !== null && !helpers.isArray(nestedThing)) {
							longest = helpers.measureText(ctx, data, gc, longest, nestedThing);
						}
					});
				}
			});

			var gcLen = gc.length / 2;
			if (gcLen > arrayOfThings.length) {
				for (var i = 0; i < gcLen; i++) {
					delete data[gc[i]];
				}
				gc.splice(0, gcLen);
			}
			return longest;
		};
		helpers.measureText = function(ctx, data, gc, longest, string) {
			var textWidth = data[string];
			if (!textWidth) {
				textWidth = data[string] = ctx.measureText(string).width;
				gc.push(string);
			}
			if (textWidth > longest) {
				longest = textWidth;
			}
			return longest;
		};
		helpers.numberOfLabelLines = function(arrayOfThings) {
			var numberOfLines = 1;
			helpers.each(arrayOfThings, function(thing) {
				if (helpers.isArray(thing)) {
					if (thing.length > numberOfLines) {
						numberOfLines = thing.length;
					}
				}
			});
			return numberOfLines;
		};

		helpers.color = !color ?
			function(value) {
				console.error('Color.js not found!');
				return value;
			} :
			function(value) {
				/* global CanvasGradient */
				if (value instanceof CanvasGradient) {
					value = defaults.global.defaultColor;
				}

				return color(value);
			};

		helpers.getHoverColor = function(colorValue) {
			/* global CanvasPattern */
			return (colorValue instanceof CanvasPattern) ?
				colorValue :
				helpers.color(colorValue).saturate(0.5).darken(0.1).rgbString();
		};
	};


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	/* MIT license */
	var convert = __webpack_require__(48);
	var string = __webpack_require__(50);

	var Color = function (obj) {
		if (obj instanceof Color) {
			return obj;
		}
		if (!(this instanceof Color)) {
			return new Color(obj);
		}

		this.valid = false;
		this.values = {
			rgb: [0, 0, 0],
			hsl: [0, 0, 0],
			hsv: [0, 0, 0],
			hwb: [0, 0, 0],
			cmyk: [0, 0, 0, 0],
			alpha: 1
		};

		// parse Color() argument
		var vals;
		if (typeof obj === 'string') {
			vals = string.getRgba(obj);
			if (vals) {
				this.setValues('rgb', vals);
			} else if (vals = string.getHsla(obj)) {
				this.setValues('hsl', vals);
			} else if (vals = string.getHwb(obj)) {
				this.setValues('hwb', vals);
			}
		} else if (typeof obj === 'object') {
			vals = obj;
			if (vals.r !== undefined || vals.red !== undefined) {
				this.setValues('rgb', vals);
			} else if (vals.l !== undefined || vals.lightness !== undefined) {
				this.setValues('hsl', vals);
			} else if (vals.v !== undefined || vals.value !== undefined) {
				this.setValues('hsv', vals);
			} else if (vals.w !== undefined || vals.whiteness !== undefined) {
				this.setValues('hwb', vals);
			} else if (vals.c !== undefined || vals.cyan !== undefined) {
				this.setValues('cmyk', vals);
			}
		}
	};

	Color.prototype = {
		isValid: function () {
			return this.valid;
		},
		rgb: function () {
			return this.setSpace('rgb', arguments);
		},
		hsl: function () {
			return this.setSpace('hsl', arguments);
		},
		hsv: function () {
			return this.setSpace('hsv', arguments);
		},
		hwb: function () {
			return this.setSpace('hwb', arguments);
		},
		cmyk: function () {
			return this.setSpace('cmyk', arguments);
		},

		rgbArray: function () {
			return this.values.rgb;
		},
		hslArray: function () {
			return this.values.hsl;
		},
		hsvArray: function () {
			return this.values.hsv;
		},
		hwbArray: function () {
			var values = this.values;
			if (values.alpha !== 1) {
				return values.hwb.concat([values.alpha]);
			}
			return values.hwb;
		},
		cmykArray: function () {
			return this.values.cmyk;
		},
		rgbaArray: function () {
			var values = this.values;
			return values.rgb.concat([values.alpha]);
		},
		hslaArray: function () {
			var values = this.values;
			return values.hsl.concat([values.alpha]);
		},
		alpha: function (val) {
			if (val === undefined) {
				return this.values.alpha;
			}
			this.setValues('alpha', val);
			return this;
		},

		red: function (val) {
			return this.setChannel('rgb', 0, val);
		},
		green: function (val) {
			return this.setChannel('rgb', 1, val);
		},
		blue: function (val) {
			return this.setChannel('rgb', 2, val);
		},
		hue: function (val) {
			if (val) {
				val %= 360;
				val = val < 0 ? 360 + val : val;
			}
			return this.setChannel('hsl', 0, val);
		},
		saturation: function (val) {
			return this.setChannel('hsl', 1, val);
		},
		lightness: function (val) {
			return this.setChannel('hsl', 2, val);
		},
		saturationv: function (val) {
			return this.setChannel('hsv', 1, val);
		},
		whiteness: function (val) {
			return this.setChannel('hwb', 1, val);
		},
		blackness: function (val) {
			return this.setChannel('hwb', 2, val);
		},
		value: function (val) {
			return this.setChannel('hsv', 2, val);
		},
		cyan: function (val) {
			return this.setChannel('cmyk', 0, val);
		},
		magenta: function (val) {
			return this.setChannel('cmyk', 1, val);
		},
		yellow: function (val) {
			return this.setChannel('cmyk', 2, val);
		},
		black: function (val) {
			return this.setChannel('cmyk', 3, val);
		},

		hexString: function () {
			return string.hexString(this.values.rgb);
		},
		rgbString: function () {
			return string.rgbString(this.values.rgb, this.values.alpha);
		},
		rgbaString: function () {
			return string.rgbaString(this.values.rgb, this.values.alpha);
		},
		percentString: function () {
			return string.percentString(this.values.rgb, this.values.alpha);
		},
		hslString: function () {
			return string.hslString(this.values.hsl, this.values.alpha);
		},
		hslaString: function () {
			return string.hslaString(this.values.hsl, this.values.alpha);
		},
		hwbString: function () {
			return string.hwbString(this.values.hwb, this.values.alpha);
		},
		keyword: function () {
			return string.keyword(this.values.rgb, this.values.alpha);
		},

		rgbNumber: function () {
			var rgb = this.values.rgb;
			return (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];
		},

		luminosity: function () {
			// http://www.w3.org/TR/WCAG20/#relativeluminancedef
			var rgb = this.values.rgb;
			var lum = [];
			for (var i = 0; i < rgb.length; i++) {
				var chan = rgb[i] / 255;
				lum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);
			}
			return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
		},

		contrast: function (color2) {
			// http://www.w3.org/TR/WCAG20/#contrast-ratiodef
			var lum1 = this.luminosity();
			var lum2 = color2.luminosity();
			if (lum1 > lum2) {
				return (lum1 + 0.05) / (lum2 + 0.05);
			}
			return (lum2 + 0.05) / (lum1 + 0.05);
		},

		level: function (color2) {
			var contrastRatio = this.contrast(color2);
			if (contrastRatio >= 7.1) {
				return 'AAA';
			}

			return (contrastRatio >= 4.5) ? 'AA' : '';
		},

		dark: function () {
			// YIQ equation from http://24ways.org/2010/calculating-color-contrast
			var rgb = this.values.rgb;
			var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
			return yiq < 128;
		},

		light: function () {
			return !this.dark();
		},

		negate: function () {
			var rgb = [];
			for (var i = 0; i < 3; i++) {
				rgb[i] = 255 - this.values.rgb[i];
			}
			this.setValues('rgb', rgb);
			return this;
		},

		lighten: function (ratio) {
			var hsl = this.values.hsl;
			hsl[2] += hsl[2] * ratio;
			this.setValues('hsl', hsl);
			return this;
		},

		darken: function (ratio) {
			var hsl = this.values.hsl;
			hsl[2] -= hsl[2] * ratio;
			this.setValues('hsl', hsl);
			return this;
		},

		saturate: function (ratio) {
			var hsl = this.values.hsl;
			hsl[1] += hsl[1] * ratio;
			this.setValues('hsl', hsl);
			return this;
		},

		desaturate: function (ratio) {
			var hsl = this.values.hsl;
			hsl[1] -= hsl[1] * ratio;
			this.setValues('hsl', hsl);
			return this;
		},

		whiten: function (ratio) {
			var hwb = this.values.hwb;
			hwb[1] += hwb[1] * ratio;
			this.setValues('hwb', hwb);
			return this;
		},

		blacken: function (ratio) {
			var hwb = this.values.hwb;
			hwb[2] += hwb[2] * ratio;
			this.setValues('hwb', hwb);
			return this;
		},

		greyscale: function () {
			var rgb = this.values.rgb;
			// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
			var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
			this.setValues('rgb', [val, val, val]);
			return this;
		},

		clearer: function (ratio) {
			var alpha = this.values.alpha;
			this.setValues('alpha', alpha - (alpha * ratio));
			return this;
		},

		opaquer: function (ratio) {
			var alpha = this.values.alpha;
			this.setValues('alpha', alpha + (alpha * ratio));
			return this;
		},

		rotate: function (degrees) {
			var hsl = this.values.hsl;
			var hue = (hsl[0] + degrees) % 360;
			hsl[0] = hue < 0 ? 360 + hue : hue;
			this.setValues('hsl', hsl);
			return this;
		},

		/**
		 * Ported from sass implementation in C
		 * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
		 */
		mix: function (mixinColor, weight) {
			var color1 = this;
			var color2 = mixinColor;
			var p = weight === undefined ? 0.5 : weight;

			var w = 2 * p - 1;
			var a = color1.alpha() - color2.alpha();

			var w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
			var w2 = 1 - w1;

			return this
				.rgb(
					w1 * color1.red() + w2 * color2.red(),
					w1 * color1.green() + w2 * color2.green(),
					w1 * color1.blue() + w2 * color2.blue()
				)
				.alpha(color1.alpha() * p + color2.alpha() * (1 - p));
		},

		toJSON: function () {
			return this.rgb();
		},

		clone: function () {
			// NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,
			// making the final build way to big to embed in Chart.js. So let's do it manually,
			// assuming that values to clone are 1 dimension arrays containing only numbers,
			// except 'alpha' which is a number.
			var result = new Color();
			var source = this.values;
			var target = result.values;
			var value, type;

			for (var prop in source) {
				if (source.hasOwnProperty(prop)) {
					value = source[prop];
					type = ({}).toString.call(value);
					if (type === '[object Array]') {
						target[prop] = value.slice(0);
					} else if (type === '[object Number]') {
						target[prop] = value;
					} else {
						console.error('unexpected color value:', value);
					}
				}
			}

			return result;
		}
	};

	Color.prototype.spaces = {
		rgb: ['red', 'green', 'blue'],
		hsl: ['hue', 'saturation', 'lightness'],
		hsv: ['hue', 'saturation', 'value'],
		hwb: ['hue', 'whiteness', 'blackness'],
		cmyk: ['cyan', 'magenta', 'yellow', 'black']
	};

	Color.prototype.maxes = {
		rgb: [255, 255, 255],
		hsl: [360, 100, 100],
		hsv: [360, 100, 100],
		hwb: [360, 100, 100],
		cmyk: [100, 100, 100, 100]
	};

	Color.prototype.getValues = function (space) {
		var values = this.values;
		var vals = {};

		for (var i = 0; i < space.length; i++) {
			vals[space.charAt(i)] = values[space][i];
		}

		if (values.alpha !== 1) {
			vals.a = values.alpha;
		}

		// {r: 255, g: 255, b: 255, a: 0.4}
		return vals;
	};

	Color.prototype.setValues = function (space, vals) {
		var values = this.values;
		var spaces = this.spaces;
		var maxes = this.maxes;
		var alpha = 1;
		var i;

		this.valid = true;

		if (space === 'alpha') {
			alpha = vals;
		} else if (vals.length) {
			// [10, 10, 10]
			values[space] = vals.slice(0, space.length);
			alpha = vals[space.length];
		} else if (vals[space.charAt(0)] !== undefined) {
			// {r: 10, g: 10, b: 10}
			for (i = 0; i < space.length; i++) {
				values[space][i] = vals[space.charAt(i)];
			}

			alpha = vals.a;
		} else if (vals[spaces[space][0]] !== undefined) {
			// {red: 10, green: 10, blue: 10}
			var chans = spaces[space];

			for (i = 0; i < space.length; i++) {
				values[space][i] = vals[chans[i]];
			}

			alpha = vals.alpha;
		}

		values.alpha = Math.max(0, Math.min(1, (alpha === undefined ? values.alpha : alpha)));

		if (space === 'alpha') {
			return false;
		}

		var capped;

		// cap values of the space prior converting all values
		for (i = 0; i < space.length; i++) {
			capped = Math.max(0, Math.min(maxes[space][i], values[space][i]));
			values[space][i] = Math.round(capped);
		}

		// convert to all the other color spaces
		for (var sname in spaces) {
			if (sname !== space) {
				values[sname] = convert[space][sname](values[space]);
			}
		}

		return true;
	};

	Color.prototype.setSpace = function (space, args) {
		var vals = args[0];

		if (vals === undefined) {
			// color.rgb()
			return this.getValues(space);
		}

		// color.rgb(10, 10, 10)
		if (typeof vals === 'number') {
			vals = Array.prototype.slice.call(args);
		}

		this.setValues(space, vals);
		return this;
	};

	Color.prototype.setChannel = function (space, index, val) {
		var svalues = this.values[space];
		if (val === undefined) {
			// color.red()
			return svalues[index];
		} else if (val === svalues[index]) {
			// color.red(color.red())
			return this;
		}

		// color.red(100)
		svalues[index] = val;
		this.setValues(space, svalues);

		return this;
	};

	if (typeof window !== 'undefined') {
		window.Color = Color;
	}

	module.exports = Color;


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

	var conversions = __webpack_require__(49);

	var convert = function() {
	   return new Converter();
	}

	for (var func in conversions) {
	  // export Raw versions
	  convert[func + "Raw"] =  (function(func) {
	    // accept array or plain args
	    return function(arg) {
	      if (typeof arg == "number")
	        arg = Array.prototype.slice.call(arguments);
	      return conversions[func](arg);
	    }
	  })(func);

	  var pair = /(\w+)2(\w+)/.exec(func),
	      from = pair[1],
	      to = pair[2];

	  // export rgb2hsl and ["rgb"]["hsl"]
	  convert[from] = convert[from] || {};

	  convert[from][to] = convert[func] = (function(func) { 
	    return function(arg) {
	      if (typeof arg == "number")
	        arg = Array.prototype.slice.call(arguments);
	      
	      var val = conversions[func](arg);
	      if (typeof val == "string" || val === undefined)
	        return val; // keyword

	      for (var i = 0; i < val.length; i++)
	        val[i] = Math.round(val[i]);
	      return val;
	    }
	  })(func);
	}


	/* Converter does lazy conversion and caching */
	var Converter = function() {
	   this.convs = {};
	};

	/* Either get the values for a space or
	  set the values for a space, depending on args */
	Converter.prototype.routeSpace = function(space, args) {
	   var values = args[0];
	   if (values === undefined) {
	      // color.rgb()
	      return this.getValues(space);
	   }
	   // color.rgb(10, 10, 10)
	   if (typeof values == "number") {
	      values = Array.prototype.slice.call(args);        
	   }

	   return this.setValues(space, values);
	};
	  
	/* Set the values for a space, invalidating cache */
	Converter.prototype.setValues = function(space, values) {
	   this.space = space;
	   this.convs = {};
	   this.convs[space] = values;
	   return this;
	};

	/* Get the values for a space. If there's already
	  a conversion for the space, fetch it, otherwise
	  compute it */
	Converter.prototype.getValues = function(space) {
	   var vals = this.convs[space];
	   if (!vals) {
	      var fspace = this.space,
	          from = this.convs[fspace];
	      vals = convert[fspace][space](from);

	      this.convs[space] = vals;
	   }
	  return vals;
	};

	["rgb", "hsl", "hsv", "cmyk", "keyword"].forEach(function(space) {
	   Converter.prototype[space] = function(vals) {
	      return this.routeSpace(space, arguments);
	   }
	});

	module.exports = convert;

/***/ }),
/* 49 */
/***/ (function(module, exports) {

	/* MIT license */

	module.exports = {
	  rgb2hsl: rgb2hsl,
	  rgb2hsv: rgb2hsv,
	  rgb2hwb: rgb2hwb,
	  rgb2cmyk: rgb2cmyk,
	  rgb2keyword: rgb2keyword,
	  rgb2xyz: rgb2xyz,
	  rgb2lab: rgb2lab,
	  rgb2lch: rgb2lch,

	  hsl2rgb: hsl2rgb,
	  hsl2hsv: hsl2hsv,
	  hsl2hwb: hsl2hwb,
	  hsl2cmyk: hsl2cmyk,
	  hsl2keyword: hsl2keyword,

	  hsv2rgb: hsv2rgb,
	  hsv2hsl: hsv2hsl,
	  hsv2hwb: hsv2hwb,
	  hsv2cmyk: hsv2cmyk,
	  hsv2keyword: hsv2keyword,

	  hwb2rgb: hwb2rgb,
	  hwb2hsl: hwb2hsl,
	  hwb2hsv: hwb2hsv,
	  hwb2cmyk: hwb2cmyk,
	  hwb2keyword: hwb2keyword,

	  cmyk2rgb: cmyk2rgb,
	  cmyk2hsl: cmyk2hsl,
	  cmyk2hsv: cmyk2hsv,
	  cmyk2hwb: cmyk2hwb,
	  cmyk2keyword: cmyk2keyword,

	  keyword2rgb: keyword2rgb,
	  keyword2hsl: keyword2hsl,
	  keyword2hsv: keyword2hsv,
	  keyword2hwb: keyword2hwb,
	  keyword2cmyk: keyword2cmyk,
	  keyword2lab: keyword2lab,
	  keyword2xyz: keyword2xyz,

	  xyz2rgb: xyz2rgb,
	  xyz2lab: xyz2lab,
	  xyz2lch: xyz2lch,

	  lab2xyz: lab2xyz,
	  lab2rgb: lab2rgb,
	  lab2lch: lab2lch,

	  lch2lab: lch2lab,
	  lch2xyz: lch2xyz,
	  lch2rgb: lch2rgb
	}


	function rgb2hsl(rgb) {
	  var r = rgb[0]/255,
	      g = rgb[1]/255,
	      b = rgb[2]/255,
	      min = Math.min(r, g, b),
	      max = Math.max(r, g, b),
	      delta = max - min,
	      h, s, l;

	  if (max == min)
	    h = 0;
	  else if (r == max)
	    h = (g - b) / delta;
	  else if (g == max)
	    h = 2 + (b - r) / delta;
	  else if (b == max)
	    h = 4 + (r - g)/ delta;

	  h = Math.min(h * 60, 360);

	  if (h < 0)
	    h += 360;

	  l = (min + max) / 2;

	  if (max == min)
	    s = 0;
	  else if (l <= 0.5)
	    s = delta / (max + min);
	  else
	    s = delta / (2 - max - min);

	  return [h, s * 100, l * 100];
	}

	function rgb2hsv(rgb) {
	  var r = rgb[0],
	      g = rgb[1],
	      b = rgb[2],
	      min = Math.min(r, g, b),
	      max = Math.max(r, g, b),
	      delta = max - min,
	      h, s, v;

	  if (max == 0)
	    s = 0;
	  else
	    s = (delta/max * 1000)/10;

	  if (max == min)
	    h = 0;
	  else if (r == max)
	    h = (g - b) / delta;
	  else if (g == max)
	    h = 2 + (b - r) / delta;
	  else if (b == max)
	    h = 4 + (r - g) / delta;

	  h = Math.min(h * 60, 360);

	  if (h < 0)
	    h += 360;

	  v = ((max / 255) * 1000) / 10;

	  return [h, s, v];
	}

	function rgb2hwb(rgb) {
	  var r = rgb[0],
	      g = rgb[1],
	      b = rgb[2],
	      h = rgb2hsl(rgb)[0],
	      w = 1/255 * Math.min(r, Math.min(g, b)),
	      b = 1 - 1/255 * Math.max(r, Math.max(g, b));

	  return [h, w * 100, b * 100];
	}

	function rgb2cmyk(rgb) {
	  var r = rgb[0] / 255,
	      g = rgb[1] / 255,
	      b = rgb[2] / 255,
	      c, m, y, k;

	  k = Math.min(1 - r, 1 - g, 1 - b);
	  c = (1 - r - k) / (1 - k) || 0;
	  m = (1 - g - k) / (1 - k) || 0;
	  y = (1 - b - k) / (1 - k) || 0;
	  return [c * 100, m * 100, y * 100, k * 100];
	}

	function rgb2keyword(rgb) {
	  return reverseKeywords[JSON.stringify(rgb)];
	}

	function rgb2xyz(rgb) {
	  var r = rgb[0] / 255,
	      g = rgb[1] / 255,
	      b = rgb[2] / 255;

	  // assume sRGB
	  r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
	  g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
	  b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

	  var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
	  var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
	  var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

	  return [x * 100, y *100, z * 100];
	}

	function rgb2lab(rgb) {
	  var xyz = rgb2xyz(rgb),
	        x = xyz[0],
	        y = xyz[1],
	        z = xyz[2],
	        l, a, b;

	  x /= 95.047;
	  y /= 100;
	  z /= 108.883;

	  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);
	  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);
	  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);

	  l = (116 * y) - 16;
	  a = 500 * (x - y);
	  b = 200 * (y - z);

	  return [l, a, b];
	}

	function rgb2lch(args) {
	  return lab2lch(rgb2lab(args));
	}

	function hsl2rgb(hsl) {
	  var h = hsl[0] / 360,
	      s = hsl[1] / 100,
	      l = hsl[2] / 100,
	      t1, t2, t3, rgb, val;

	  if (s == 0) {
	    val = l * 255;
	    return [val, val, val];
	  }

	  if (l < 0.5)
	    t2 = l * (1 + s);
	  else
	    t2 = l + s - l * s;
	  t1 = 2 * l - t2;

	  rgb = [0, 0, 0];
	  for (var i = 0; i < 3; i++) {
	    t3 = h + 1 / 3 * - (i - 1);
	    t3 < 0 && t3++;
	    t3 > 1 && t3--;

	    if (6 * t3 < 1)
	      val = t1 + (t2 - t1) * 6 * t3;
	    else if (2 * t3 < 1)
	      val = t2;
	    else if (3 * t3 < 2)
	      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
	    else
	      val = t1;

	    rgb[i] = val * 255;
	  }

	  return rgb;
	}

	function hsl2hsv(hsl) {
	  var h = hsl[0],
	      s = hsl[1] / 100,
	      l = hsl[2] / 100,
	      sv, v;

	  if(l === 0) {
	      // no need to do calc on black
	      // also avoids divide by 0 error
	      return [0, 0, 0];
	  }

	  l *= 2;
	  s *= (l <= 1) ? l : 2 - l;
	  v = (l + s) / 2;
	  sv = (2 * s) / (l + s);
	  return [h, sv * 100, v * 100];
	}

	function hsl2hwb(args) {
	  return rgb2hwb(hsl2rgb(args));
	}

	function hsl2cmyk(args) {
	  return rgb2cmyk(hsl2rgb(args));
	}

	function hsl2keyword(args) {
	  return rgb2keyword(hsl2rgb(args));
	}


	function hsv2rgb(hsv) {
	  var h = hsv[0] / 60,
	      s = hsv[1] / 100,
	      v = hsv[2] / 100,
	      hi = Math.floor(h) % 6;

	  var f = h - Math.floor(h),
	      p = 255 * v * (1 - s),
	      q = 255 * v * (1 - (s * f)),
	      t = 255 * v * (1 - (s * (1 - f))),
	      v = 255 * v;

	  switch(hi) {
	    case 0:
	      return [v, t, p];
	    case 1:
	      return [q, v, p];
	    case 2:
	      return [p, v, t];
	    case 3:
	      return [p, q, v];
	    case 4:
	      return [t, p, v];
	    case 5:
	      return [v, p, q];
	  }
	}

	function hsv2hsl(hsv) {
	  var h = hsv[0],
	      s = hsv[1] / 100,
	      v = hsv[2] / 100,
	      sl, l;

	  l = (2 - s) * v;
	  sl = s * v;
	  sl /= (l <= 1) ? l : 2 - l;
	  sl = sl || 0;
	  l /= 2;
	  return [h, sl * 100, l * 100];
	}

	function hsv2hwb(args) {
	  return rgb2hwb(hsv2rgb(args))
	}

	function hsv2cmyk(args) {
	  return rgb2cmyk(hsv2rgb(args));
	}

	function hsv2keyword(args) {
	  return rgb2keyword(hsv2rgb(args));
	}

	// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
	function hwb2rgb(hwb) {
	  var h = hwb[0] / 360,
	      wh = hwb[1] / 100,
	      bl = hwb[2] / 100,
	      ratio = wh + bl,
	      i, v, f, n;

	  // wh + bl cant be > 1
	  if (ratio > 1) {
	    wh /= ratio;
	    bl /= ratio;
	  }

	  i = Math.floor(6 * h);
	  v = 1 - bl;
	  f = 6 * h - i;
	  if ((i & 0x01) != 0) {
	    f = 1 - f;
	  }
	  n = wh + f * (v - wh);  // linear interpolation

	  switch (i) {
	    default:
	    case 6:
	    case 0: r = v; g = n; b = wh; break;
	    case 1: r = n; g = v; b = wh; break;
	    case 2: r = wh; g = v; b = n; break;
	    case 3: r = wh; g = n; b = v; break;
	    case 4: r = n; g = wh; b = v; break;
	    case 5: r = v; g = wh; b = n; break;
	  }

	  return [r * 255, g * 255, b * 255];
	}

	function hwb2hsl(args) {
	  return rgb2hsl(hwb2rgb(args));
	}

	function hwb2hsv(args) {
	  return rgb2hsv(hwb2rgb(args));
	}

	function hwb2cmyk(args) {
	  return rgb2cmyk(hwb2rgb(args));
	}

	function hwb2keyword(args) {
	  return rgb2keyword(hwb2rgb(args));
	}

	function cmyk2rgb(cmyk) {
	  var c = cmyk[0] / 100,
	      m = cmyk[1] / 100,
	      y = cmyk[2] / 100,
	      k = cmyk[3] / 100,
	      r, g, b;

	  r = 1 - Math.min(1, c * (1 - k) + k);
	  g = 1 - Math.min(1, m * (1 - k) + k);
	  b = 1 - Math.min(1, y * (1 - k) + k);
	  return [r * 255, g * 255, b * 255];
	}

	function cmyk2hsl(args) {
	  return rgb2hsl(cmyk2rgb(args));
	}

	function cmyk2hsv(args) {
	  return rgb2hsv(cmyk2rgb(args));
	}

	function cmyk2hwb(args) {
	  return rgb2hwb(cmyk2rgb(args));
	}

	function cmyk2keyword(args) {
	  return rgb2keyword(cmyk2rgb(args));
	}


	function xyz2rgb(xyz) {
	  var x = xyz[0] / 100,
	      y = xyz[1] / 100,
	      z = xyz[2] / 100,
	      r, g, b;

	  r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
	  g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
	  b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

	  // assume sRGB
	  r = r > 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
	    : r = (r * 12.92);

	  g = g > 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
	    : g = (g * 12.92);

	  b = b > 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
	    : b = (b * 12.92);

	  r = Math.min(Math.max(0, r), 1);
	  g = Math.min(Math.max(0, g), 1);
	  b = Math.min(Math.max(0, b), 1);

	  return [r * 255, g * 255, b * 255];
	}

	function xyz2lab(xyz) {
	  var x = xyz[0],
	      y = xyz[1],
	      z = xyz[2],
	      l, a, b;

	  x /= 95.047;
	  y /= 100;
	  z /= 108.883;

	  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);
	  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);
	  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);

	  l = (116 * y) - 16;
	  a = 500 * (x - y);
	  b = 200 * (y - z);

	  return [l, a, b];
	}

	function xyz2lch(args) {
	  return lab2lch(xyz2lab(args));
	}

	function lab2xyz(lab) {
	  var l = lab[0],
	      a = lab[1],
	      b = lab[2],
	      x, y, z, y2;

	  if (l <= 8) {
	    y = (l * 100) / 903.3;
	    y2 = (7.787 * (y / 100)) + (16 / 116);
	  } else {
	    y = 100 * Math.pow((l + 16) / 116, 3);
	    y2 = Math.pow(y / 100, 1/3);
	  }

	  x = x / 95.047 <= 0.008856 ? x = (95.047 * ((a / 500) + y2 - (16 / 116))) / 7.787 : 95.047 * Math.pow((a / 500) + y2, 3);

	  z = z / 108.883 <= 0.008859 ? z = (108.883 * (y2 - (b / 200) - (16 / 116))) / 7.787 : 108.883 * Math.pow(y2 - (b / 200), 3);

	  return [x, y, z];
	}

	function lab2lch(lab) {
	  var l = lab[0],
	      a = lab[1],
	      b = lab[2],
	      hr, h, c;

	  hr = Math.atan2(b, a);
	  h = hr * 360 / 2 / Math.PI;
	  if (h < 0) {
	    h += 360;
	  }
	  c = Math.sqrt(a * a + b * b);
	  return [l, c, h];
	}

	function lab2rgb(args) {
	  return xyz2rgb(lab2xyz(args));
	}

	function lch2lab(lch) {
	  var l = lch[0],
	      c = lch[1],
	      h = lch[2],
	      a, b, hr;

	  hr = h / 360 * 2 * Math.PI;
	  a = c * Math.cos(hr);
	  b = c * Math.sin(hr);
	  return [l, a, b];
	}

	function lch2xyz(args) {
	  return lab2xyz(lch2lab(args));
	}

	function lch2rgb(args) {
	  return lab2rgb(lch2lab(args));
	}

	function keyword2rgb(keyword) {
	  return cssKeywords[keyword];
	}

	function keyword2hsl(args) {
	  return rgb2hsl(keyword2rgb(args));
	}

	function keyword2hsv(args) {
	  return rgb2hsv(keyword2rgb(args));
	}

	function keyword2hwb(args) {
	  return rgb2hwb(keyword2rgb(args));
	}

	function keyword2cmyk(args) {
	  return rgb2cmyk(keyword2rgb(args));
	}

	function keyword2lab(args) {
	  return rgb2lab(keyword2rgb(args));
	}

	function keyword2xyz(args) {
	  return rgb2xyz(keyword2rgb(args));
	}

	var cssKeywords = {
	  aliceblue:  [240,248,255],
	  antiquewhite: [250,235,215],
	  aqua: [0,255,255],
	  aquamarine: [127,255,212],
	  azure:  [240,255,255],
	  beige:  [245,245,220],
	  bisque: [255,228,196],
	  black:  [0,0,0],
	  blanchedalmond: [255,235,205],
	  blue: [0,0,255],
	  blueviolet: [138,43,226],
	  brown:  [165,42,42],
	  burlywood:  [222,184,135],
	  cadetblue:  [95,158,160],
	  chartreuse: [127,255,0],
	  chocolate:  [210,105,30],
	  coral:  [255,127,80],
	  cornflowerblue: [100,149,237],
	  cornsilk: [255,248,220],
	  crimson:  [220,20,60],
	  cyan: [0,255,255],
	  darkblue: [0,0,139],
	  darkcyan: [0,139,139],
	  darkgoldenrod:  [184,134,11],
	  darkgray: [169,169,169],
	  darkgreen:  [0,100,0],
	  darkgrey: [169,169,169],
	  darkkhaki:  [189,183,107],
	  darkmagenta:  [139,0,139],
	  darkolivegreen: [85,107,47],
	  darkorange: [255,140,0],
	  darkorchid: [153,50,204],
	  darkred:  [139,0,0],
	  darksalmon: [233,150,122],
	  darkseagreen: [143,188,143],
	  darkslateblue:  [72,61,139],
	  darkslategray:  [47,79,79],
	  darkslategrey:  [47,79,79],
	  darkturquoise:  [0,206,209],
	  darkviolet: [148,0,211],
	  deeppink: [255,20,147],
	  deepskyblue:  [0,191,255],
	  dimgray:  [105,105,105],
	  dimgrey:  [105,105,105],
	  dodgerblue: [30,144,255],
	  firebrick:  [178,34,34],
	  floralwhite:  [255,250,240],
	  forestgreen:  [34,139,34],
	  fuchsia:  [255,0,255],
	  gainsboro:  [220,220,220],
	  ghostwhite: [248,248,255],
	  gold: [255,215,0],
	  goldenrod:  [218,165,32],
	  gray: [128,128,128],
	  green:  [0,128,0],
	  greenyellow:  [173,255,47],
	  grey: [128,128,128],
	  honeydew: [240,255,240],
	  hotpink:  [255,105,180],
	  indianred:  [205,92,92],
	  indigo: [75,0,130],
	  ivory:  [255,255,240],
	  khaki:  [240,230,140],
	  lavender: [230,230,250],
	  lavenderblush:  [255,240,245],
	  lawngreen:  [124,252,0],
	  lemonchiffon: [255,250,205],
	  lightblue:  [173,216,230],
	  lightcoral: [240,128,128],
	  lightcyan:  [224,255,255],
	  lightgoldenrodyellow: [250,250,210],
	  lightgray:  [211,211,211],
	  lightgreen: [144,238,144],
	  lightgrey:  [211,211,211],
	  lightpink:  [255,182,193],
	  lightsalmon:  [255,160,122],
	  lightseagreen:  [32,178,170],
	  lightskyblue: [135,206,250],
	  lightslategray: [119,136,153],
	  lightslategrey: [119,136,153],
	  lightsteelblue: [176,196,222],
	  lightyellow:  [255,255,224],
	  lime: [0,255,0],
	  limegreen:  [50,205,50],
	  linen:  [250,240,230],
	  magenta:  [255,0,255],
	  maroon: [128,0,0],
	  mediumaquamarine: [102,205,170],
	  mediumblue: [0,0,205],
	  mediumorchid: [186,85,211],
	  mediumpurple: [147,112,219],
	  mediumseagreen: [60,179,113],
	  mediumslateblue:  [123,104,238],
	  mediumspringgreen:  [0,250,154],
	  mediumturquoise:  [72,209,204],
	  mediumvioletred:  [199,21,133],
	  midnightblue: [25,25,112],
	  mintcream:  [245,255,250],
	  mistyrose:  [255,228,225],
	  moccasin: [255,228,181],
	  navajowhite:  [255,222,173],
	  navy: [0,0,128],
	  oldlace:  [253,245,230],
	  olive:  [128,128,0],
	  olivedrab:  [107,142,35],
	  orange: [255,165,0],
	  orangered:  [255,69,0],
	  orchid: [218,112,214],
	  palegoldenrod:  [238,232,170],
	  palegreen:  [152,251,152],
	  paleturquoise:  [175,238,238],
	  palevioletred:  [219,112,147],
	  papayawhip: [255,239,213],
	  peachpuff:  [255,218,185],
	  peru: [205,133,63],
	  pink: [255,192,203],
	  plum: [221,160,221],
	  powderblue: [176,224,230],
	  purple: [128,0,128],
	  rebeccapurple: [102, 51, 153],
	  red:  [255,0,0],
	  rosybrown:  [188,143,143],
	  royalblue:  [65,105,225],
	  saddlebrown:  [139,69,19],
	  salmon: [250,128,114],
	  sandybrown: [244,164,96],
	  seagreen: [46,139,87],
	  seashell: [255,245,238],
	  sienna: [160,82,45],
	  silver: [192,192,192],
	  skyblue:  [135,206,235],
	  slateblue:  [106,90,205],
	  slategray:  [112,128,144],
	  slategrey:  [112,128,144],
	  snow: [255,250,250],
	  springgreen:  [0,255,127],
	  steelblue:  [70,130,180],
	  tan:  [210,180,140],
	  teal: [0,128,128],
	  thistle:  [216,191,216],
	  tomato: [255,99,71],
	  turquoise:  [64,224,208],
	  violet: [238,130,238],
	  wheat:  [245,222,179],
	  white:  [255,255,255],
	  whitesmoke: [245,245,245],
	  yellow: [255,255,0],
	  yellowgreen:  [154,205,50]
	};

	var reverseKeywords = {};
	for (var key in cssKeywords) {
	  reverseKeywords[JSON.stringify(cssKeywords[key])] = key;
	}


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

	/* MIT license */
	var colorNames = __webpack_require__(51);

	module.exports = {
	   getRgba: getRgba,
	   getHsla: getHsla,
	   getRgb: getRgb,
	   getHsl: getHsl,
	   getHwb: getHwb,
	   getAlpha: getAlpha,

	   hexString: hexString,
	   rgbString: rgbString,
	   rgbaString: rgbaString,
	   percentString: percentString,
	   percentaString: percentaString,
	   hslString: hslString,
	   hslaString: hslaString,
	   hwbString: hwbString,
	   keyword: keyword
	}

	function getRgba(string) {
	   if (!string) {
	      return;
	   }
	   var abbr =  /^#([a-fA-F0-9]{3})$/i,
	       hex =  /^#([a-fA-F0-9]{6})$/i,
	       rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
	       per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
	       keyword = /(\w+)/;

	   var rgb = [0, 0, 0],
	       a = 1,
	       match = string.match(abbr);
	   if (match) {
	      match = match[1];
	      for (var i = 0; i < rgb.length; i++) {
	         rgb[i] = parseInt(match[i] + match[i], 16);
	      }
	   }
	   else if (match = string.match(hex)) {
	      match = match[1];
	      for (var i = 0; i < rgb.length; i++) {
	         rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);
	      }
	   }
	   else if (match = string.match(rgba)) {
	      for (var i = 0; i < rgb.length; i++) {
	         rgb[i] = parseInt(match[i + 1]);
	      }
	      a = parseFloat(match[4]);
	   }
	   else if (match = string.match(per)) {
	      for (var i = 0; i < rgb.length; i++) {
	         rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
	      }
	      a = parseFloat(match[4]);
	   }
	   else if (match = string.match(keyword)) {
	      if (match[1] == "transparent") {
	         return [0, 0, 0, 0];
	      }
	      rgb = colorNames[match[1]];
	      if (!rgb) {
	         return;
	      }
	   }

	   for (var i = 0; i < rgb.length; i++) {
	      rgb[i] = scale(rgb[i], 0, 255);
	   }
	   if (!a && a != 0) {
	      a = 1;
	   }
	   else {
	      a = scale(a, 0, 1);
	   }
	   rgb[3] = a;
	   return rgb;
	}

	function getHsla(string) {
	   if (!string) {
	      return;
	   }
	   var hsl = /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
	   var match = string.match(hsl);
	   if (match) {
	      var alpha = parseFloat(match[4]);
	      var h = scale(parseInt(match[1]), 0, 360),
	          s = scale(parseFloat(match[2]), 0, 100),
	          l = scale(parseFloat(match[3]), 0, 100),
	          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
	      return [h, s, l, a];
	   }
	}

	function getHwb(string) {
	   if (!string) {
	      return;
	   }
	   var hwb = /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
	   var match = string.match(hwb);
	   if (match) {
	    var alpha = parseFloat(match[4]);
	      var h = scale(parseInt(match[1]), 0, 360),
	          w = scale(parseFloat(match[2]), 0, 100),
	          b = scale(parseFloat(match[3]), 0, 100),
	          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
	      return [h, w, b, a];
	   }
	}

	function getRgb(string) {
	   var rgba = getRgba(string);
	   return rgba && rgba.slice(0, 3);
	}

	function getHsl(string) {
	  var hsla = getHsla(string);
	  return hsla && hsla.slice(0, 3);
	}

	function getAlpha(string) {
	   var vals = getRgba(string);
	   if (vals) {
	      return vals[3];
	   }
	   else if (vals = getHsla(string)) {
	      return vals[3];
	   }
	   else if (vals = getHwb(string)) {
	      return vals[3];
	   }
	}

	// generators
	function hexString(rgb) {
	   return "#" + hexDouble(rgb[0]) + hexDouble(rgb[1])
	              + hexDouble(rgb[2]);
	}

	function rgbString(rgba, alpha) {
	   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {
	      return rgbaString(rgba, alpha);
	   }
	   return "rgb(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ")";
	}

	function rgbaString(rgba, alpha) {
	   if (alpha === undefined) {
	      alpha = (rgba[3] !== undefined ? rgba[3] : 1);
	   }
	   return "rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2]
	           + ", " + alpha + ")";
	}

	function percentString(rgba, alpha) {
	   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {
	      return percentaString(rgba, alpha);
	   }
	   var r = Math.round(rgba[0]/255 * 100),
	       g = Math.round(rgba[1]/255 * 100),
	       b = Math.round(rgba[2]/255 * 100);

	   return "rgb(" + r + "%, " + g + "%, " + b + "%)";
	}

	function percentaString(rgba, alpha) {
	   var r = Math.round(rgba[0]/255 * 100),
	       g = Math.round(rgba[1]/255 * 100),
	       b = Math.round(rgba[2]/255 * 100);
	   return "rgba(" + r + "%, " + g + "%, " + b + "%, " + (alpha || rgba[3] || 1) + ")";
	}

	function hslString(hsla, alpha) {
	   if (alpha < 1 || (hsla[3] && hsla[3] < 1)) {
	      return hslaString(hsla, alpha);
	   }
	   return "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)";
	}

	function hslaString(hsla, alpha) {
	   if (alpha === undefined) {
	      alpha = (hsla[3] !== undefined ? hsla[3] : 1);
	   }
	   return "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, "
	           + alpha + ")";
	}

	// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
	// (hwb have alpha optional & 1 is default value)
	function hwbString(hwb, alpha) {
	   if (alpha === undefined) {
	      alpha = (hwb[3] !== undefined ? hwb[3] : 1);
	   }
	   return "hwb(" + hwb[0] + ", " + hwb[1] + "%, " + hwb[2] + "%"
	           + (alpha !== undefined && alpha !== 1 ? ", " + alpha : "") + ")";
	}

	function keyword(rgb) {
	  return reverseNames[rgb.slice(0, 3)];
	}

	// helpers
	function scale(num, min, max) {
	   return Math.min(Math.max(min, num), max);
	}

	function hexDouble(num) {
	  var str = num.toString(16).toUpperCase();
	  return (str.length < 2) ? "0" + str : str;
	}


	//create a list of reverse color names
	var reverseNames = {};
	for (var name in colorNames) {
	   reverseNames[colorNames[name]] = name;
	}


/***/ }),
/* 51 */
/***/ (function(module, exports) {

	'use strict'

	module.exports = {
		"aliceblue": [240, 248, 255],
		"antiquewhite": [250, 235, 215],
		"aqua": [0, 255, 255],
		"aquamarine": [127, 255, 212],
		"azure": [240, 255, 255],
		"beige": [245, 245, 220],
		"bisque": [255, 228, 196],
		"black": [0, 0, 0],
		"blanchedalmond": [255, 235, 205],
		"blue": [0, 0, 255],
		"blueviolet": [138, 43, 226],
		"brown": [165, 42, 42],
		"burlywood": [222, 184, 135],
		"cadetblue": [95, 158, 160],
		"chartreuse": [127, 255, 0],
		"chocolate": [210, 105, 30],
		"coral": [255, 127, 80],
		"cornflowerblue": [100, 149, 237],
		"cornsilk": [255, 248, 220],
		"crimson": [220, 20, 60],
		"cyan": [0, 255, 255],
		"darkblue": [0, 0, 139],
		"darkcyan": [0, 139, 139],
		"darkgoldenrod": [184, 134, 11],
		"darkgray": [169, 169, 169],
		"darkgreen": [0, 100, 0],
		"darkgrey": [169, 169, 169],
		"darkkhaki": [189, 183, 107],
		"darkmagenta": [139, 0, 139],
		"darkolivegreen": [85, 107, 47],
		"darkorange": [255, 140, 0],
		"darkorchid": [153, 50, 204],
		"darkred": [139, 0, 0],
		"darksalmon": [233, 150, 122],
		"darkseagreen": [143, 188, 143],
		"darkslateblue": [72, 61, 139],
		"darkslategray": [47, 79, 79],
		"darkslategrey": [47, 79, 79],
		"darkturquoise": [0, 206, 209],
		"darkviolet": [148, 0, 211],
		"deeppink": [255, 20, 147],
		"deepskyblue": [0, 191, 255],
		"dimgray": [105, 105, 105],
		"dimgrey": [105, 105, 105],
		"dodgerblue": [30, 144, 255],
		"firebrick": [178, 34, 34],
		"floralwhite": [255, 250, 240],
		"forestgreen": [34, 139, 34],
		"fuchsia": [255, 0, 255],
		"gainsboro": [220, 220, 220],
		"ghostwhite": [248, 248, 255],
		"gold": [255, 215, 0],
		"goldenrod": [218, 165, 32],
		"gray": [128, 128, 128],
		"green": [0, 128, 0],
		"greenyellow": [173, 255, 47],
		"grey": [128, 128, 128],
		"honeydew": [240, 255, 240],
		"hotpink": [255, 105, 180],
		"indianred": [205, 92, 92],
		"indigo": [75, 0, 130],
		"ivory": [255, 255, 240],
		"khaki": [240, 230, 140],
		"lavender": [230, 230, 250],
		"lavenderblush": [255, 240, 245],
		"lawngreen": [124, 252, 0],
		"lemonchiffon": [255, 250, 205],
		"lightblue": [173, 216, 230],
		"lightcoral": [240, 128, 128],
		"lightcyan": [224, 255, 255],
		"lightgoldenrodyellow": [250, 250, 210],
		"lightgray": [211, 211, 211],
		"lightgreen": [144, 238, 144],
		"lightgrey": [211, 211, 211],
		"lightpink": [255, 182, 193],
		"lightsalmon": [255, 160, 122],
		"lightseagreen": [32, 178, 170],
		"lightskyblue": [135, 206, 250],
		"lightslategray": [119, 136, 153],
		"lightslategrey": [119, 136, 153],
		"lightsteelblue": [176, 196, 222],
		"lightyellow": [255, 255, 224],
		"lime": [0, 255, 0],
		"limegreen": [50, 205, 50],
		"linen": [250, 240, 230],
		"magenta": [255, 0, 255],
		"maroon": [128, 0, 0],
		"mediumaquamarine": [102, 205, 170],
		"mediumblue": [0, 0, 205],
		"mediumorchid": [186, 85, 211],
		"mediumpurple": [147, 112, 219],
		"mediumseagreen": [60, 179, 113],
		"mediumslateblue": [123, 104, 238],
		"mediumspringgreen": [0, 250, 154],
		"mediumturquoise": [72, 209, 204],
		"mediumvioletred": [199, 21, 133],
		"midnightblue": [25, 25, 112],
		"mintcream": [245, 255, 250],
		"mistyrose": [255, 228, 225],
		"moccasin": [255, 228, 181],
		"navajowhite": [255, 222, 173],
		"navy": [0, 0, 128],
		"oldlace": [253, 245, 230],
		"olive": [128, 128, 0],
		"olivedrab": [107, 142, 35],
		"orange": [255, 165, 0],
		"orangered": [255, 69, 0],
		"orchid": [218, 112, 214],
		"palegoldenrod": [238, 232, 170],
		"palegreen": [152, 251, 152],
		"paleturquoise": [175, 238, 238],
		"palevioletred": [219, 112, 147],
		"papayawhip": [255, 239, 213],
		"peachpuff": [255, 218, 185],
		"peru": [205, 133, 63],
		"pink": [255, 192, 203],
		"plum": [221, 160, 221],
		"powderblue": [176, 224, 230],
		"purple": [128, 0, 128],
		"rebeccapurple": [102, 51, 153],
		"red": [255, 0, 0],
		"rosybrown": [188, 143, 143],
		"royalblue": [65, 105, 225],
		"saddlebrown": [139, 69, 19],
		"salmon": [250, 128, 114],
		"sandybrown": [244, 164, 96],
		"seagreen": [46, 139, 87],
		"seashell": [255, 245, 238],
		"sienna": [160, 82, 45],
		"silver": [192, 192, 192],
		"skyblue": [135, 206, 235],
		"slateblue": [106, 90, 205],
		"slategray": [112, 128, 144],
		"slategrey": [112, 128, 144],
		"snow": [255, 250, 250],
		"springgreen": [0, 255, 127],
		"steelblue": [70, 130, 180],
		"tan": [210, 180, 140],
		"teal": [0, 128, 128],
		"thistle": [216, 191, 216],
		"tomato": [255, 99, 71],
		"turquoise": [64, 224, 208],
		"violet": [238, 130, 238],
		"wheat": [245, 222, 179],
		"white": [255, 255, 255],
		"whitesmoke": [245, 245, 245],
		"yellow": [255, 255, 0],
		"yellowgreen": [154, 205, 50]
	};


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var color = __webpack_require__(47);
	var helpers = __webpack_require__(41);

	function interpolate(start, view, model, ease) {
		var keys = Object.keys(model);
		var i, ilen, key, actual, origin, target, type, c0, c1;

		for (i = 0, ilen = keys.length; i < ilen; ++i) {
			key = keys[i];

			target = model[key];

			// if a value is added to the model after pivot() has been called, the view
			// doesn't contain it, so let's initialize the view to the target value.
			if (!view.hasOwnProperty(key)) {
				view[key] = target;
			}

			actual = view[key];

			if (actual === target || key[0] === '_') {
				continue;
			}

			if (!start.hasOwnProperty(key)) {
				start[key] = actual;
			}

			origin = start[key];

			type = typeof target;

			if (type === typeof origin) {
				if (type === 'string') {
					c0 = color(origin);
					if (c0.valid) {
						c1 = color(target);
						if (c1.valid) {
							view[key] = c1.mix(c0, ease).rgbString();
							continue;
						}
					}
				} else if (type === 'number' && isFinite(origin) && isFinite(target)) {
					view[key] = origin + (target - origin) * ease;
					continue;
				}
			}

			view[key] = target;
		}
	}

	var Element = function(configuration) {
		helpers.extend(this, configuration);
		this.initialize.apply(this, arguments);
	};

	helpers.extend(Element.prototype, {

		initialize: function() {
			this.hidden = false;
		},

		pivot: function() {
			var me = this;
			if (!me._view) {
				me._view = helpers.clone(me._model);
			}
			me._start = {};
			return me;
		},

		transition: function(ease) {
			var me = this;
			var model = me._model;
			var start = me._start;
			var view = me._view;

			// No animation -> No Transition
			if (!model || ease === 1) {
				me._view = model;
				me._start = null;
				return me;
			}

			if (!view) {
				view = me._view = {};
			}

			if (!start) {
				start = me._start = {};
			}

			interpolate(start, view, model, ease);

			return me;
		},

		tooltipPosition: function() {
			return {
				x: this._model.x,
				y: this._model.y
			};
		},

		hasValue: function() {
			return helpers.isNumber(this._model.x) && helpers.isNumber(this._model.y);
		}
	});

	Element.extend = helpers.inherits;

	module.exports = Element;


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = {};
	module.exports.Arc = __webpack_require__(54);
	module.exports.Line = __webpack_require__(55);
	module.exports.Point = __webpack_require__(56);
	module.exports.Rectangle = __webpack_require__(57);


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var defaults = __webpack_require__(40);
	var Element = __webpack_require__(52);
	var helpers = __webpack_require__(41);

	defaults._set('global', {
		elements: {
			arc: {
				backgroundColor: defaults.global.defaultColor,
				borderColor: '#fff',
				borderWidth: 2
			}
		}
	});

	module.exports = Element.extend({
		inLabelRange: function(mouseX) {
			var vm = this._view;

			if (vm) {
				return (Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2));
			}
			return false;
		},

		inRange: function(chartX, chartY) {
			var vm = this._view;

			if (vm) {
				var pointRelativePosition = helpers.getAngleFromPoint(vm, {x: chartX, y: chartY});
				var	angle = pointRelativePosition.angle;
				var distance = pointRelativePosition.distance;

				// Sanitise angle range
				var startAngle = vm.startAngle;
				var endAngle = vm.endAngle;
				while (endAngle < startAngle) {
					endAngle += 2.0 * Math.PI;
				}
				while (angle > endAngle) {
					angle -= 2.0 * Math.PI;
				}
				while (angle < startAngle) {
					angle += 2.0 * Math.PI;
				}

				// Check if within the range of the open/close angle
				var betweenAngles = (angle >= startAngle && angle <= endAngle);
				var withinRadius = (distance >= vm.innerRadius && distance <= vm.outerRadius);

				return (betweenAngles && withinRadius);
			}
			return false;
		},

		getCenterPoint: function() {
			var vm = this._view;
			var halfAngle = (vm.startAngle + vm.endAngle) / 2;
			var halfRadius = (vm.innerRadius + vm.outerRadius) / 2;
			return {
				x: vm.x + Math.cos(halfAngle) * halfRadius,
				y: vm.y + Math.sin(halfAngle) * halfRadius
			};
		},

		getArea: function() {
			var vm = this._view;
			return Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));
		},

		tooltipPosition: function() {
			var vm = this._view;
			var centreAngle = vm.startAngle + ((vm.endAngle - vm.startAngle) / 2);
			var rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;

			return {
				x: vm.x + (Math.cos(centreAngle) * rangeFromCentre),
				y: vm.y + (Math.sin(centreAngle) * rangeFromCentre)
			};
		},

		draw: function() {
			var ctx = this._chart.ctx;
			var vm = this._view;
			var sA = vm.startAngle;
			var eA = vm.endAngle;

			ctx.beginPath();

			ctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);
			ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);

			ctx.closePath();
			ctx.strokeStyle = vm.borderColor;
			ctx.lineWidth = vm.borderWidth;

			ctx.fillStyle = vm.backgroundColor;

			ctx.fill();
			ctx.lineJoin = 'bevel';

			if (vm.borderWidth) {
				ctx.stroke();
			}
		}
	});


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var defaults = __webpack_require__(40);
	var Element = __webpack_require__(52);
	var helpers = __webpack_require__(41);

	var globalDefaults = defaults.global;

	defaults._set('global', {
		elements: {
			line: {
				tension: 0.4,
				backgroundColor: globalDefaults.defaultColor,
				borderWidth: 3,
				borderColor: globalDefaults.defaultColor,
				borderCapStyle: 'butt',
				borderDash: [],
				borderDashOffset: 0.0,
				borderJoinStyle: 'miter',
				capBezierPoints: true,
				fill: true, // do we fill in the area between the line and its base axis
			}
		}
	});

	module.exports = Element.extend({
		draw: function() {
			var me = this;
			var vm = me._view;
			var ctx = me._chart.ctx;
			var spanGaps = vm.spanGaps;
			var points = me._children.slice(); // clone array
			var globalOptionLineElements = globalDefaults.elements.line;
			var lastDrawnIndex = -1;
			var index, current, previous, currentVM;

			// If we are looping, adding the first point again
			if (me._loop && points.length) {
				points.push(points[0]);
			}

			ctx.save();

			// Stroke Line Options
			ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;

			// IE 9 and 10 do not support line dash
			if (ctx.setLineDash) {
				ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);
			}

			ctx.lineDashOffset = vm.borderDashOffset || globalOptionLineElements.borderDashOffset;
			ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;
			ctx.lineWidth = vm.borderWidth || globalOptionLineElements.borderWidth;
			ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;

			// Stroke Line
			ctx.beginPath();
			lastDrawnIndex = -1;

			for (index = 0; index < points.length; ++index) {
				current = points[index];
				previous = helpers.previousItem(points, index);
				currentVM = current._view;

				// First point moves to it's starting position no matter what
				if (index === 0) {
					if (!currentVM.skip) {
						ctx.moveTo(currentVM.x, currentVM.y);
						lastDrawnIndex = index;
					}
				} else {
					previous = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];

					if (!currentVM.skip) {
						if ((lastDrawnIndex !== (index - 1) && !spanGaps) || lastDrawnIndex === -1) {
							// There was a gap and this is the first point after the gap
							ctx.moveTo(currentVM.x, currentVM.y);
						} else {
							// Line to next point
							helpers.canvas.lineTo(ctx, previous._view, current._view);
						}
						lastDrawnIndex = index;
					}
				}
			}

			ctx.stroke();
			ctx.restore();
		}
	});


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var defaults = __webpack_require__(40);
	var Element = __webpack_require__(52);
	var helpers = __webpack_require__(41);

	var defaultColor = defaults.global.defaultColor;

	defaults._set('global', {
		elements: {
			point: {
				radius: 3,
				pointStyle: 'circle',
				backgroundColor: defaultColor,
				borderColor: defaultColor,
				borderWidth: 1,
				// Hover
				hitRadius: 1,
				hoverRadius: 4,
				hoverBorderWidth: 1
			}
		}
	});

	function xRange(mouseX) {
		var vm = this._view;
		return vm ? (Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hitRadius, 2)) : false;
	}

	function yRange(mouseY) {
		var vm = this._view;
		return vm ? (Math.pow(mouseY - vm.y, 2) < Math.pow(vm.radius + vm.hitRadius, 2)) : false;
	}

	module.exports = Element.extend({
		inRange: function(mouseX, mouseY) {
			var vm = this._view;
			return vm ? ((Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2)) < Math.pow(vm.hitRadius + vm.radius, 2)) : false;
		},

		inLabelRange: xRange,
		inXRange: xRange,
		inYRange: yRange,

		getCenterPoint: function() {
			var vm = this._view;
			return {
				x: vm.x,
				y: vm.y
			};
		},

		getArea: function() {
			return Math.PI * Math.pow(this._view.radius, 2);
		},

		tooltipPosition: function() {
			var vm = this._view;
			return {
				x: vm.x,
				y: vm.y,
				padding: vm.radius + vm.borderWidth
			};
		},

		draw: function(chartArea) {
			var vm = this._view;
			var model = this._model;
			var ctx = this._chart.ctx;
			var pointStyle = vm.pointStyle;
			var radius = vm.radius;
			var x = vm.x;
			var y = vm.y;
			var color = helpers.color;
			var errMargin = 1.01; // 1.01 is margin for Accumulated error. (Especially Edge, IE.)
			var ratio = 0;

			if (vm.skip) {
				return;
			}

			ctx.strokeStyle = vm.borderColor || defaultColor;
			ctx.lineWidth = helpers.valueOrDefault(vm.borderWidth, defaults.global.elements.point.borderWidth);
			ctx.fillStyle = vm.backgroundColor || defaultColor;

			// Cliping for Points.
			// going out from inner charArea?
			if ((chartArea !== undefined) && ((model.x < chartArea.left) || (chartArea.right * errMargin < model.x) || (model.y < chartArea.top) || (chartArea.bottom * errMargin < model.y))) {
				// Point fade out
				if (model.x < chartArea.left) {
					ratio = (x - model.x) / (chartArea.left - model.x);
				} else if (chartArea.right * errMargin < model.x) {
					ratio = (model.x - x) / (model.x - chartArea.right);
				} else if (model.y < chartArea.top) {
					ratio = (y - model.y) / (chartArea.top - model.y);
				} else if (chartArea.bottom * errMargin < model.y) {
					ratio = (model.y - y) / (model.y - chartArea.bottom);
				}
				ratio = Math.round(ratio * 100) / 100;
				ctx.strokeStyle = color(ctx.strokeStyle).alpha(ratio).rgbString();
				ctx.fillStyle = color(ctx.fillStyle).alpha(ratio).rgbString();
			}

			helpers.canvas.drawPoint(ctx, pointStyle, radius, x, y);
		}
	});


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var defaults = __webpack_require__(40);
	var Element = __webpack_require__(52);

	defaults._set('global', {
		elements: {
			rectangle: {
				backgroundColor: defaults.global.defaultColor,
				borderColor: defaults.global.defaultColor,
				borderSkipped: 'bottom',
				borderWidth: 0
			}
		}
	});

	function isVertical(bar) {
		return bar._view.width !== undefined;
	}

	/**
	 * Helper function to get the bounds of the bar regardless of the orientation
	 * @param bar {Chart.Element.Rectangle} the bar
	 * @return {Bounds} bounds of the bar
	 * @private
	 */
	function getBarBounds(bar) {
		var vm = bar._view;
		var x1, x2, y1, y2;

		if (isVertical(bar)) {
			// vertical
			var halfWidth = vm.width / 2;
			x1 = vm.x - halfWidth;
			x2 = vm.x + halfWidth;
			y1 = Math.min(vm.y, vm.base);
			y2 = Math.max(vm.y, vm.base);
		} else {
			// horizontal bar
			var halfHeight = vm.height / 2;
			x1 = Math.min(vm.x, vm.base);
			x2 = Math.max(vm.x, vm.base);
			y1 = vm.y - halfHeight;
			y2 = vm.y + halfHeight;
		}

		return {
			left: x1,
			top: y1,
			right: x2,
			bottom: y2
		};
	}

	module.exports = Element.extend({
		draw: function() {
			var ctx = this._chart.ctx;
			var vm = this._view;
			var left, right, top, bottom, signX, signY, borderSkipped;
			var borderWidth = vm.borderWidth;

			if (!vm.horizontal) {
				// bar
				left = vm.x - vm.width / 2;
				right = vm.x + vm.width / 2;
				top = vm.y;
				bottom = vm.base;
				signX = 1;
				signY = bottom > top ? 1 : -1;
				borderSkipped = vm.borderSkipped || 'bottom';
			} else {
				// horizontal bar
				left = vm.base;
				right = vm.x;
				top = vm.y - vm.height / 2;
				bottom = vm.y + vm.height / 2;
				signX = right > left ? 1 : -1;
				signY = 1;
				borderSkipped = vm.borderSkipped || 'left';
			}

			// Canvas doesn't allow us to stroke inside the width so we can
			// adjust the sizes to fit if we're setting a stroke on the line
			if (borderWidth) {
				// borderWidth shold be less than bar width and bar height.
				var barSize = Math.min(Math.abs(left - right), Math.abs(top - bottom));
				borderWidth = borderWidth > barSize ? barSize : borderWidth;
				var halfStroke = borderWidth / 2;
				// Adjust borderWidth when bar top position is near vm.base(zero).
				var borderLeft = left + (borderSkipped !== 'left' ? halfStroke * signX : 0);
				var borderRight = right + (borderSkipped !== 'right' ? -halfStroke * signX : 0);
				var borderTop = top + (borderSkipped !== 'top' ? halfStroke * signY : 0);
				var borderBottom = bottom + (borderSkipped !== 'bottom' ? -halfStroke * signY : 0);
				// not become a vertical line?
				if (borderLeft !== borderRight) {
					top = borderTop;
					bottom = borderBottom;
				}
				// not become a horizontal line?
				if (borderTop !== borderBottom) {
					left = borderLeft;
					right = borderRight;
				}
			}

			ctx.beginPath();
			ctx.fillStyle = vm.backgroundColor;
			ctx.strokeStyle = vm.borderColor;
			ctx.lineWidth = borderWidth;

			// Corner points, from bottom-left to bottom-right clockwise
			// | 1 2 |
			// | 0 3 |
			var corners = [
				[left, bottom],
				[left, top],
				[right, top],
				[right, bottom]
			];

			// Find first (starting) corner with fallback to 'bottom'
			var borders = ['bottom', 'left', 'top', 'right'];
			var startCorner = borders.indexOf(borderSkipped, 0);
			if (startCorner === -1) {
				startCorner = 0;
			}

			function cornerAt(index) {
				return corners[(startCorner + index) % 4];
			}

			// Draw rectangle from 'startCorner'
			var corner = cornerAt(0);
			ctx.moveTo(corner[0], corner[1]);

			for (var i = 1; i < 4; i++) {
				corner = cornerAt(i);
				ctx.lineTo(corner[0], corner[1]);
			}

			ctx.fill();
			if (borderWidth) {
				ctx.stroke();
			}
		},

		height: function() {
			var vm = this._view;
			return vm.base - vm.y;
		},

		inRange: function(mouseX, mouseY) {
			var inRange = false;

			if (this._view) {
				var bounds = getBarBounds(this);
				inRange = mouseX >= bounds.left && mouseX <= bounds.right && mouseY >= bounds.top && mouseY <= bounds.bottom;
			}

			return inRange;
		},

		inLabelRange: function(mouseX, mouseY) {
			var me = this;
			if (!me._view) {
				return false;
			}

			var inRange = false;
			var bounds = getBarBounds(me);

			if (isVertical(me)) {
				inRange = mouseX >= bounds.left && mouseX <= bounds.right;
			} else {
				inRange = mouseY >= bounds.top && mouseY <= bounds.bottom;
			}

			return inRange;
		},

		inXRange: function(mouseX) {
			var bounds = getBarBounds(this);
			return mouseX >= bounds.left && mouseX <= bounds.right;
		},

		inYRange: function(mouseY) {
			var bounds = getBarBounds(this);
			return mouseY >= bounds.top && mouseY <= bounds.bottom;
		},

		getCenterPoint: function() {
			var vm = this._view;
			var x, y;
			if (isVertical(this)) {
				x = vm.x;
				y = (vm.y + vm.base) / 2;
			} else {
				x = (vm.x + vm.base) / 2;
				y = vm.y;
			}

			return {x: x, y: y};
		},

		getArea: function() {
			var vm = this._view;
			return vm.width * Math.abs(vm.y - vm.base);
		},

		tooltipPosition: function() {
			var vm = this._view;
			return {
				x: vm.x,
				y: vm.y
			};
		}
	});


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var helpers = __webpack_require__(41);

	/**
	 * Helper function to get relative position for an event
	 * @param {Event|IEvent} event - The event to get the position for
	 * @param {Chart} chart - The chart
	 * @returns {Point} the event position
	 */
	function getRelativePosition(e, chart) {
		if (e.native) {
			return {
				x: e.x,
				y: e.y
			};
		}

		return helpers.getRelativePosition(e, chart);
	}

	/**
	 * Helper function to traverse all of the visible elements in the chart
	 * @param chart {chart} the chart
	 * @param handler {Function} the callback to execute for each visible item
	 */
	function parseVisibleItems(chart, handler) {
		var datasets = chart.data.datasets;
		var meta, i, j, ilen, jlen;

		for (i = 0, ilen = datasets.length; i < ilen; ++i) {
			if (!chart.isDatasetVisible(i)) {
				continue;
			}

			meta = chart.getDatasetMeta(i);
			for (j = 0, jlen = meta.data.length; j < jlen; ++j) {
				var element = meta.data[j];
				if (!element._view.skip) {
					handler(element);
				}
			}
		}
	}

	/**
	 * Helper function to get the items that intersect the event position
	 * @param items {ChartElement[]} elements to filter
	 * @param position {Point} the point to be nearest to
	 * @return {ChartElement[]} the nearest items
	 */
	function getIntersectItems(chart, position) {
		var elements = [];

		parseVisibleItems(chart, function(element) {
			if (element.inRange(position.x, position.y)) {
				elements.push(element);
			}
		});

		return elements;
	}

	/**
	 * Helper function to get the items nearest to the event position considering all visible items in teh chart
	 * @param chart {Chart} the chart to look at elements from
	 * @param position {Point} the point to be nearest to
	 * @param intersect {Boolean} if true, only consider items that intersect the position
	 * @param distanceMetric {Function} function to provide the distance between points
	 * @return {ChartElement[]} the nearest items
	 */
	function getNearestItems(chart, position, intersect, distanceMetric) {
		var minDistance = Number.POSITIVE_INFINITY;
		var nearestItems = [];

		parseVisibleItems(chart, function(element) {
			if (intersect && !element.inRange(position.x, position.y)) {
				return;
			}

			var center = element.getCenterPoint();
			var distance = distanceMetric(position, center);

			if (distance < minDistance) {
				nearestItems = [element];
				minDistance = distance;
			} else if (distance === minDistance) {
				// Can have multiple items at the same distance in which case we sort by size
				nearestItems.push(element);
			}
		});

		return nearestItems;
	}

	/**
	 * Get a distance metric function for two points based on the
	 * axis mode setting
	 * @param {String} axis the axis mode. x|y|xy
	 */
	function getDistanceMetricForAxis(axis) {
		var useX = axis.indexOf('x') !== -1;
		var useY = axis.indexOf('y') !== -1;

		return function(pt1, pt2) {
			var deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
			var deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
			return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
		};
	}

	function indexMode(chart, e, options) {
		var position = getRelativePosition(e, chart);
		// Default axis for index mode is 'x' to match old behaviour
		options.axis = options.axis || 'x';
		var distanceMetric = getDistanceMetricForAxis(options.axis);
		var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
		var elements = [];

		if (!items.length) {
			return [];
		}

		chart.data.datasets.forEach(function(dataset, datasetIndex) {
			if (chart.isDatasetVisible(datasetIndex)) {
				var meta = chart.getDatasetMeta(datasetIndex);
				var element = meta.data[items[0]._index];

				// don't count items that are skipped (null data)
				if (element && !element._view.skip) {
					elements.push(element);
				}
			}
		});

		return elements;
	}

	/**
	 * @interface IInteractionOptions
	 */
	/**
	 * If true, only consider items that intersect the point
	 * @name IInterfaceOptions#boolean
	 * @type Boolean
	 */

	/**
	 * Contains interaction related functions
	 * @namespace Chart.Interaction
	 */
	module.exports = {
		// Helper function for different modes
		modes: {
			single: function(chart, e) {
				var position = getRelativePosition(e, chart);
				var elements = [];

				parseVisibleItems(chart, function(element) {
					if (element.inRange(position.x, position.y)) {
						elements.push(element);
						return elements;
					}
				});

				return elements.slice(0, 1);
			},

			/**
			 * @function Chart.Interaction.modes.label
			 * @deprecated since version 2.4.0
			 * @todo remove at version 3
			 * @private
			 */
			label: indexMode,

			/**
			 * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something
			 * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item
			 * @function Chart.Interaction.modes.index
			 * @since v2.4.0
			 * @param chart {chart} the chart we are returning items from
			 * @param e {Event} the event we are find things at
			 * @param options {IInteractionOptions} options to use during interaction
			 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
			 */
			index: indexMode,

			/**
			 * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something
			 * If the options.intersect is false, we find the nearest item and return the items in that dataset
			 * @function Chart.Interaction.modes.dataset
			 * @param chart {chart} the chart we are returning items from
			 * @param e {Event} the event we are find things at
			 * @param options {IInteractionOptions} options to use during interaction
			 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
			 */
			dataset: function(chart, e, options) {
				var position = getRelativePosition(e, chart);
				options.axis = options.axis || 'xy';
				var distanceMetric = getDistanceMetricForAxis(options.axis);
				var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);

				if (items.length > 0) {
					items = chart.getDatasetMeta(items[0]._datasetIndex).data;
				}

				return items;
			},

			/**
			 * @function Chart.Interaction.modes.x-axis
			 * @deprecated since version 2.4.0. Use index mode and intersect == true
			 * @todo remove at version 3
			 * @private
			 */
			'x-axis': function(chart, e) {
				return indexMode(chart, e, {intersect: false});
			},

			/**
			 * Point mode returns all elements that hit test based on the event position
			 * of the event
			 * @function Chart.Interaction.modes.intersect
			 * @param chart {chart} the chart we are returning items from
			 * @param e {Event} the event we are find things at
			 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
			 */
			point: function(chart, e) {
				var position = getRelativePosition(e, chart);
				return getIntersectItems(chart, position);
			},

			/**
			 * nearest mode returns the element closest to the point
			 * @function Chart.Interaction.modes.intersect
			 * @param chart {chart} the chart we are returning items from
			 * @param e {Event} the event we are find things at
			 * @param options {IInteractionOptions} options to use
			 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
			 */
			nearest: function(chart, e, options) {
				var position = getRelativePosition(e, chart);
				options.axis = options.axis || 'xy';
				var distanceMetric = getDistanceMetricForAxis(options.axis);
				var nearestItems = getNearestItems(chart, position, options.intersect, distanceMetric);

				// We have multiple items at the same distance from the event. Now sort by smallest
				if (nearestItems.length > 1) {
					nearestItems.sort(function(a, b) {
						var sizeA = a.getArea();
						var sizeB = b.getArea();
						var ret = sizeA - sizeB;

						if (ret === 0) {
							// if equal sort by dataset index
							ret = a._datasetIndex - b._datasetIndex;
						}

						return ret;
					});
				}

				// Return only 1 item
				return nearestItems.slice(0, 1);
			},

			/**
			 * x mode returns the elements that hit-test at the current x coordinate
			 * @function Chart.Interaction.modes.x
			 * @param chart {chart} the chart we are returning items from
			 * @param e {Event} the event we are find things at
			 * @param options {IInteractionOptions} options to use
			 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
			 */
			x: function(chart, e, options) {
				var position = getRelativePosition(e, chart);
				var items = [];
				var intersectsItem = false;

				parseVisibleItems(chart, function(element) {
					if (element.inXRange(position.x)) {
						items.push(element);
					}

					if (element.inRange(position.x, position.y)) {
						intersectsItem = true;
					}
				});

				// If we want to trigger on an intersect and we don't have any items
				// that intersect the position, return nothing
				if (options.intersect && !intersectsItem) {
					items = [];
				}
				return items;
			},

			/**
			 * y mode returns the elements that hit-test at the current y coordinate
			 * @function Chart.Interaction.modes.y
			 * @param chart {chart} the chart we are returning items from
			 * @param e {Event} the event we are find things at
			 * @param options {IInteractionOptions} options to use
			 * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
			 */
			y: function(chart, e, options) {
				var position = getRelativePosition(e, chart);
				var items = [];
				var intersectsItem = false;

				parseVisibleItems(chart, function(element) {
					if (element.inYRange(position.y)) {
						items.push(element);
					}

					if (element.inRange(position.x, position.y)) {
						intersectsItem = true;
					}
				});

				// If we want to trigger on an intersect and we don't have any items
				// that intersect the position, return nothing
				if (options.intersect && !intersectsItem) {
					items = [];
				}
				return items;
			}
		}
	};


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var helpers = __webpack_require__(41);
	var basic = __webpack_require__(60);
	var dom = __webpack_require__(61);

	// @TODO Make possible to select another platform at build time.
	var implementation = dom._enabled ? dom : basic;

	/**
	 * @namespace Chart.platform
	 * @see https://chartjs.gitbooks.io/proposals/content/Platform.html
	 * @since 2.4.0
	 */
	module.exports = helpers.extend({
		/**
		 * @since 2.7.0
		 */
		initialize: function() {},

		/**
		 * Called at chart construction time, returns a context2d instance implementing
		 * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.
		 * @param {*} item - The native item from which to acquire context (platform specific)
		 * @param {Object} options - The chart options
		 * @returns {CanvasRenderingContext2D} context2d instance
		 */
		acquireContext: function() {},

		/**
		 * Called at chart destruction time, releases any resources associated to the context
		 * previously returned by the acquireContext() method.
		 * @param {CanvasRenderingContext2D} context - The context2d instance
		 * @returns {Boolean} true if the method succeeded, else false
		 */
		releaseContext: function() {},

		/**
		 * Registers the specified listener on the given chart.
		 * @param {Chart} chart - Chart from which to listen for event
		 * @param {String} type - The ({@link IEvent}) type to listen for
		 * @param {Function} listener - Receives a notification (an object that implements
		 * the {@link IEvent} interface) when an event of the specified type occurs.
		 */
		addEventListener: function() {},

		/**
		 * Removes the specified listener previously registered with addEventListener.
		 * @param {Chart} chart -Chart from which to remove the listener
		 * @param {String} type - The ({@link IEvent}) type to remove
		 * @param {Function} listener - The listener function to remove from the event target.
		 */
		removeEventListener: function() {}

	}, implementation);

	/**
	 * @interface IPlatform
	 * Allows abstracting platform dependencies away from the chart
	 * @borrows Chart.platform.acquireContext as acquireContext
	 * @borrows Chart.platform.releaseContext as releaseContext
	 * @borrows Chart.platform.addEventListener as addEventListener
	 * @borrows Chart.platform.removeEventListener as removeEventListener
	 */

	/**
	 * @interface IEvent
	 * @prop {String} type - The event type name, possible values are:
	 * 'contextmenu', 'mouseenter', 'mousedown', 'mousemove', 'mouseup', 'mouseout',
	 * 'click', 'dblclick', 'keydown', 'keypress', 'keyup' and 'resize'
	 * @prop {*} native - The original native event (null for emulated events, e.g. 'resize')
	 * @prop {Number} x - The mouse x position, relative to the canvas (null for incompatible events)
	 * @prop {Number} y - The mouse y position, relative to the canvas (null for incompatible events)
	 */


/***/ }),
/* 60 */
/***/ (function(module, exports) {

	/**
	 * Platform fallback implementation (minimal).
	 * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939
	 */

	module.exports = {
		acquireContext: function(item) {
			if (item && item.canvas) {
				// Support for any object associated to a canvas (including a context2d)
				item = item.canvas;
			}

			return item && item.getContext('2d') || null;
		}
	};


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Chart.Platform implementation for targeting a web browser
	 */

	'use strict';

	var helpers = __webpack_require__(41);

	var EXPANDO_KEY = '$chartjs';
	var CSS_PREFIX = 'chartjs-';
	var CSS_RENDER_MONITOR = CSS_PREFIX + 'render-monitor';
	var CSS_RENDER_ANIMATION = CSS_PREFIX + 'render-animation';
	var ANIMATION_START_EVENTS = ['animationstart', 'webkitAnimationStart'];

	/**
	 * DOM event types -> Chart.js event types.
	 * Note: only events with different types are mapped.
	 * @see https://developer.mozilla.org/en-US/docs/Web/Events
	 */
	var EVENT_TYPES = {
		touchstart: 'mousedown',
		touchmove: 'mousemove',
		touchend: 'mouseup',
		pointerenter: 'mouseenter',
		pointerdown: 'mousedown',
		pointermove: 'mousemove',
		pointerup: 'mouseup',
		pointerleave: 'mouseout',
		pointerout: 'mouseout'
	};

	/**
	 * The "used" size is the final value of a dimension property after all calculations have
	 * been performed. This method uses the computed style of `element` but returns undefined
	 * if the computed style is not expressed in pixels. That can happen in some cases where
	 * `element` has a size relative to its parent and this last one is not yet displayed,
	 * for example because of `display: none` on a parent node.
	 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
	 * @returns {Number} Size in pixels or undefined if unknown.
	 */
	function readUsedSize(element, property) {
		var value = helpers.getStyle(element, property);
		var matches = value && value.match(/^(\d+)(\.\d+)?px$/);
		return matches ? Number(matches[1]) : undefined;
	}

	/**
	 * Initializes the canvas style and render size without modifying the canvas display size,
	 * since responsiveness is handled by the controller.resize() method. The config is used
	 * to determine the aspect ratio to apply in case no explicit height has been specified.
	 */
	function initCanvas(canvas, config) {
		var style = canvas.style;

		// NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it
		// returns null or '' if no explicit value has been set to the canvas attribute.
		var renderHeight = canvas.getAttribute('height');
		var renderWidth = canvas.getAttribute('width');

		// Chart.js modifies some canvas values that we want to restore on destroy
		canvas[EXPANDO_KEY] = {
			initial: {
				height: renderHeight,
				width: renderWidth,
				style: {
					display: style.display,
					height: style.height,
					width: style.width
				}
			}
		};

		// Force canvas to display as block to avoid extra space caused by inline
		// elements, which would interfere with the responsive resize process.
		// https://github.com/chartjs/Chart.js/issues/2538
		style.display = style.display || 'block';

		if (renderWidth === null || renderWidth === '') {
			var displayWidth = readUsedSize(canvas, 'width');
			if (displayWidth !== undefined) {
				canvas.width = displayWidth;
			}
		}

		if (renderHeight === null || renderHeight === '') {
			if (canvas.style.height === '') {
				// If no explicit render height and style height, let's apply the aspect ratio,
				// which one can be specified by the user but also by charts as default option
				// (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.
				canvas.height = canvas.width / (config.options.aspectRatio || 2);
			} else {
				var displayHeight = readUsedSize(canvas, 'height');
				if (displayWidth !== undefined) {
					canvas.height = displayHeight;
				}
			}
		}

		return canvas;
	}

	/**
	 * Detects support for options object argument in addEventListener.
	 * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
	 * @private
	 */
	var supportsEventListenerOptions = (function() {
		var supports = false;
		try {
			var options = Object.defineProperty({}, 'passive', {
				get: function() {
					supports = true;
				}
			});
			window.addEventListener('e', null, options);
		} catch (e) {
			// continue regardless of error
		}
		return supports;
	}());

	// Default passive to true as expected by Chrome for 'touchstart' and 'touchend' events.
	// https://github.com/chartjs/Chart.js/issues/4287
	var eventListenerOptions = supportsEventListenerOptions ? {passive: true} : false;

	function addEventListener(node, type, listener) {
		node.addEventListener(type, listener, eventListenerOptions);
	}

	function removeEventListener(node, type, listener) {
		node.removeEventListener(type, listener, eventListenerOptions);
	}

	function createEvent(type, chart, x, y, nativeEvent) {
		return {
			type: type,
			chart: chart,
			native: nativeEvent || null,
			x: x !== undefined ? x : null,
			y: y !== undefined ? y : null,
		};
	}

	function fromNativeEvent(event, chart) {
		var type = EVENT_TYPES[event.type] || event.type;
		var pos = helpers.getRelativePosition(event, chart);
		return createEvent(type, chart, pos.x, pos.y, event);
	}

	function throttled(fn, thisArg) {
		var ticking = false;
		var args = [];

		return function() {
			args = Array.prototype.slice.call(arguments);
			thisArg = thisArg || this;

			if (!ticking) {
				ticking = true;
				helpers.requestAnimFrame.call(window, function() {
					ticking = false;
					fn.apply(thisArg, args);
				});
			}
		};
	}

	// Implementation based on https://github.com/marcj/css-element-queries
	function createResizer(handler) {
		var resizer = document.createElement('div');
		var cls = CSS_PREFIX + 'size-monitor';
		var maxSize = 1000000;
		var style =
			'position:absolute;' +
			'left:0;' +
			'top:0;' +
			'right:0;' +
			'bottom:0;' +
			'overflow:hidden;' +
			'pointer-events:none;' +
			'visibility:hidden;' +
			'z-index:-1;';

		resizer.style.cssText = style;
		resizer.className = cls;
		resizer.innerHTML =
			'<div class="' + cls + '-expand" style="' + style + '">' +
				'<div style="' +
					'position:absolute;' +
					'width:' + maxSize + 'px;' +
					'height:' + maxSize + 'px;' +
					'left:0;' +
					'top:0">' +
				'</div>' +
			'</div>' +
			'<div class="' + cls + '-shrink" style="' + style + '">' +
				'<div style="' +
					'position:absolute;' +
					'width:200%;' +
					'height:200%;' +
					'left:0; ' +
					'top:0">' +
				'</div>' +
			'</div>';

		var expand = resizer.childNodes[0];
		var shrink = resizer.childNodes[1];

		resizer._reset = function() {
			expand.scrollLeft = maxSize;
			expand.scrollTop = maxSize;
			shrink.scrollLeft = maxSize;
			shrink.scrollTop = maxSize;
		};
		var onScroll = function() {
			resizer._reset();
			handler();
		};

		addEventListener(expand, 'scroll', onScroll.bind(expand, 'expand'));
		addEventListener(shrink, 'scroll', onScroll.bind(shrink, 'shrink'));

		return resizer;
	}

	// https://davidwalsh.name/detect-node-insertion
	function watchForRender(node, handler) {
		var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});
		var proxy = expando.renderProxy = function(e) {
			if (e.animationName === CSS_RENDER_ANIMATION) {
				handler();
			}
		};

		helpers.each(ANIMATION_START_EVENTS, function(type) {
			addEventListener(node, type, proxy);
		});

		// #4737: Chrome might skip the CSS animation when the CSS_RENDER_MONITOR class
		// is removed then added back immediately (same animation frame?). Accessing the
		// `offsetParent` property will force a reflow and re-evaluate the CSS animation.
		// https://gist.github.com/paulirish/5d52fb081b3570c81e3a#box-metrics
		// https://github.com/chartjs/Chart.js/issues/4737
		expando.reflow = !!node.offsetParent;

		node.classList.add(CSS_RENDER_MONITOR);
	}

	function unwatchForRender(node) {
		var expando = node[EXPANDO_KEY] || {};
		var proxy = expando.renderProxy;

		if (proxy) {
			helpers.each(ANIMATION_START_EVENTS, function(type) {
				removeEventListener(node, type, proxy);
			});

			delete expando.renderProxy;
		}

		node.classList.remove(CSS_RENDER_MONITOR);
	}

	function addResizeListener(node, listener, chart) {
		var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});

		// Let's keep track of this added resizer and thus avoid DOM query when removing it.
		var resizer = expando.resizer = createResizer(throttled(function() {
			if (expando.resizer) {
				return listener(createEvent('resize', chart));
			}
		}));

		// The resizer needs to be attached to the node parent, so we first need to be
		// sure that `node` is attached to the DOM before injecting the resizer element.
		watchForRender(node, function() {
			if (expando.resizer) {
				var container = node.parentNode;
				if (container && container !== resizer.parentNode) {
					container.insertBefore(resizer, container.firstChild);
				}

				// The container size might have changed, let's reset the resizer state.
				resizer._reset();
			}
		});
	}

	function removeResizeListener(node) {
		var expando = node[EXPANDO_KEY] || {};
		var resizer = expando.resizer;

		delete expando.resizer;
		unwatchForRender(node);

		if (resizer && resizer.parentNode) {
			resizer.parentNode.removeChild(resizer);
		}
	}

	function injectCSS(platform, css) {
		// http://stackoverflow.com/q/3922139
		var style = platform._style || document.createElement('style');
		if (!platform._style) {
			platform._style = style;
			css = '/* Chart.js */\n' + css;
			style.setAttribute('type', 'text/css');
			document.getElementsByTagName('head')[0].appendChild(style);
		}

		style.appendChild(document.createTextNode(css));
	}

	module.exports = {
		/**
		 * This property holds whether this platform is enabled for the current environment.
		 * Currently used by platform.js to select the proper implementation.
		 * @private
		 */
		_enabled: typeof window !== 'undefined' && typeof document !== 'undefined',

		initialize: function() {
			var keyframes = 'from{opacity:0.99}to{opacity:1}';

			injectCSS(this,
				// DOM rendering detection
				// https://davidwalsh.name/detect-node-insertion
				'@-webkit-keyframes ' + CSS_RENDER_ANIMATION + '{' + keyframes + '}' +
				'@keyframes ' + CSS_RENDER_ANIMATION + '{' + keyframes + '}' +
				'.' + CSS_RENDER_MONITOR + '{' +
					'-webkit-animation:' + CSS_RENDER_ANIMATION + ' 0.001s;' +
					'animation:' + CSS_RENDER_ANIMATION + ' 0.001s;' +
				'}'
			);
		},

		acquireContext: function(item, config) {
			if (typeof item === 'string') {
				item = document.getElementById(item);
			} else if (item.length) {
				// Support for array based queries (such as jQuery)
				item = item[0];
			}

			if (item && item.canvas) {
				// Support for any object associated to a canvas (including a context2d)
				item = item.canvas;
			}

			// To prevent canvas fingerprinting, some add-ons undefine the getContext
			// method, for example: https://github.com/kkapsner/CanvasBlocker
			// https://github.com/chartjs/Chart.js/issues/2807
			var context = item && item.getContext && item.getContext('2d');

			// `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the item is
			// inside an iframe or when running in a protected environment. We could guess the
			// types from their toString() value but let's keep things flexible and assume it's
			// a sufficient condition if the item has a context2D which has item as `canvas`.
			// https://github.com/chartjs/Chart.js/issues/3887
			// https://github.com/chartjs/Chart.js/issues/4102
			// https://github.com/chartjs/Chart.js/issues/4152
			if (context && context.canvas === item) {
				initCanvas(item, config);
				return context;
			}

			return null;
		},

		releaseContext: function(context) {
			var canvas = context.canvas;
			if (!canvas[EXPANDO_KEY]) {
				return;
			}

			var initial = canvas[EXPANDO_KEY].initial;
			['height', 'width'].forEach(function(prop) {
				var value = initial[prop];
				if (helpers.isNullOrUndef(value)) {
					canvas.removeAttribute(prop);
				} else {
					canvas.setAttribute(prop, value);
				}
			});

			helpers.each(initial.style || {}, function(value, key) {
				canvas.style[key] = value;
			});

			// The canvas render size might have been changed (and thus the state stack discarded),
			// we can't use save() and restore() to restore the initial state. So make sure that at
			// least the canvas context is reset to the default state by setting the canvas width.
			// https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html
			canvas.width = canvas.width;

			delete canvas[EXPANDO_KEY];
		},

		addEventListener: function(chart, type, listener) {
			var canvas = chart.canvas;
			if (type === 'resize') {
				// Note: the resize event is not supported on all browsers.
				addResizeListener(canvas, listener, chart);
				return;
			}

			var expando = listener[EXPANDO_KEY] || (listener[EXPANDO_KEY] = {});
			var proxies = expando.proxies || (expando.proxies = {});
			var proxy = proxies[chart.id + '_' + type] = function(event) {
				listener(fromNativeEvent(event, chart));
			};

			addEventListener(canvas, type, proxy);
		},

		removeEventListener: function(chart, type, listener) {
			var canvas = chart.canvas;
			if (type === 'resize') {
				// Note: the resize event is not supported on all browsers.
				removeResizeListener(canvas, listener);
				return;
			}

			var expando = listener[EXPANDO_KEY] || {};
			var proxies = expando.proxies || {};
			var proxy = proxies[chart.id + '_' + type];
			if (!proxy) {
				return;
			}

			removeEventListener(canvas, type, proxy);
		}
	};

	// DEPRECATIONS

	/**
	 * Provided for backward compatibility, use EventTarget.addEventListener instead.
	 * EventTarget.addEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
	 * @function Chart.helpers.addEvent
	 * @deprecated since version 2.7.0
	 * @todo remove at version 3
	 * @private
	 */
	helpers.addEvent = addEventListener;

	/**
	 * Provided for backward compatibility, use EventTarget.removeEventListener instead.
	 * EventTarget.removeEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener
	 * @function Chart.helpers.removeEvent
	 * @deprecated since version 2.7.0
	 * @todo remove at version 3
	 * @private
	 */
	helpers.removeEvent = removeEventListener;


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var defaults = __webpack_require__(40);
	var Element = __webpack_require__(52);
	var helpers = __webpack_require__(41);

	defaults._set('global', {
		plugins: {}
	});

	module.exports = function(Chart) {

		/**
		 * The plugin service singleton
		 * @namespace Chart.plugins
		 * @since 2.1.0
		 */
		Chart.plugins = {
			/**
			 * Globally registered plugins.
			 * @private
			 */
			_plugins: [],

			/**
			 * This identifier is used to invalidate the descriptors cache attached to each chart
			 * when a global plugin is registered or unregistered. In this case, the cache ID is
			 * incremented and descriptors are regenerated during following API calls.
			 * @private
			 */
			_cacheId: 0,

			/**
			 * Registers the given plugin(s) if not already registered.
			 * @param {Array|Object} plugins plugin instance(s).
			 */
			register: function(plugins) {
				var p = this._plugins;
				([]).concat(plugins).forEach(function(plugin) {
					if (p.indexOf(plugin) === -1) {
						p.push(plugin);
					}
				});

				this._cacheId++;
			},

			/**
			 * Unregisters the given plugin(s) only if registered.
			 * @param {Array|Object} plugins plugin instance(s).
			 */
			unregister: function(plugins) {
				var p = this._plugins;
				([]).concat(plugins).forEach(function(plugin) {
					var idx = p.indexOf(plugin);
					if (idx !== -1) {
						p.splice(idx, 1);
					}
				});

				this._cacheId++;
			},

			/**
			 * Remove all registered plugins.
			 * @since 2.1.5
			 */
			clear: function() {
				this._plugins = [];
				this._cacheId++;
			},

			/**
			 * Returns the number of registered plugins?
			 * @returns {Number}
			 * @since 2.1.5
			 */
			count: function() {
				return this._plugins.length;
			},

			/**
			 * Returns all registered plugin instances.
			 * @returns {Array} array of plugin objects.
			 * @since 2.1.5
			 */
			getAll: function() {
				return this._plugins;
			},

			/**
			 * Calls enabled plugins for `chart` on the specified hook and with the given args.
			 * This method immediately returns as soon as a plugin explicitly returns false. The
			 * returned value can be used, for instance, to interrupt the current action.
			 * @param {Object} chart - The chart instance for which plugins should be called.
			 * @param {String} hook - The name of the plugin method to call (e.g. 'beforeUpdate').
			 * @param {Array} [args] - Extra arguments to apply to the hook call.
			 * @returns {Boolean} false if any of the plugins return false, else returns true.
			 */
			notify: function(chart, hook, args) {
				var descriptors = this.descriptors(chart);
				var ilen = descriptors.length;
				var i, descriptor, plugin, params, method;

				for (i = 0; i < ilen; ++i) {
					descriptor = descriptors[i];
					plugin = descriptor.plugin;
					method = plugin[hook];
					if (typeof method === 'function') {
						params = [chart].concat(args || []);
						params.push(descriptor.options);
						if (method.apply(plugin, params) === false) {
							return false;
						}
					}
				}

				return true;
			},

			/**
			 * Returns descriptors of enabled plugins for the given chart.
			 * @returns {Array} [{ plugin, options }]
			 * @private
			 */
			descriptors: function(chart) {
				var cache = chart._plugins || (chart._plugins = {});
				if (cache.id === this._cacheId) {
					return cache.descriptors;
				}

				var plugins = [];
				var descriptors = [];
				var config = (chart && chart.config) || {};
				var options = (config.options && config.options.plugins) || {};

				this._plugins.concat(config.plugins || []).forEach(function(plugin) {
					var idx = plugins.indexOf(plugin);
					if (idx !== -1) {
						return;
					}

					var id = plugin.id;
					var opts = options[id];
					if (opts === false) {
						return;
					}

					if (opts === true) {
						opts = helpers.clone(defaults.global.plugins[id]);
					}

					plugins.push(plugin);
					descriptors.push({
						plugin: plugin,
						options: opts || {}
					});
				});

				cache.descriptors = descriptors;
				cache.id = this._cacheId;
				return descriptors;
			}
		};

		/**
		 * Plugin extension hooks.
		 * @interface IPlugin
		 * @since 2.1.0
		 */
		/**
		 * @method IPlugin#beforeInit
		 * @desc Called before initializing `chart`.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Object} options - The plugin options.
		 */
		/**
		 * @method IPlugin#afterInit
		 * @desc Called after `chart` has been initialized and before the first update.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Object} options - The plugin options.
		 */
		/**
		 * @method IPlugin#beforeUpdate
		 * @desc Called before updating `chart`. If any plugin returns `false`, the update
		 * is cancelled (and thus subsequent render(s)) until another `update` is triggered.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Object} options - The plugin options.
		 * @returns {Boolean} `false` to cancel the chart update.
		 */
		/**
		 * @method IPlugin#afterUpdate
		 * @desc Called after `chart` has been updated and before rendering. Note that this
		 * hook will not be called if the chart update has been previously cancelled.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Object} options - The plugin options.
		 */
		/**
		 * @method IPlugin#beforeDatasetsUpdate
	 	 * @desc Called before updating the `chart` datasets. If any plugin returns `false`,
		 * the datasets update is cancelled until another `update` is triggered.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Object} options - The plugin options.
		 * @returns {Boolean} false to cancel the datasets update.
		 * @since version 2.1.5
		 */
		/**
		 * @method IPlugin#afterDatasetsUpdate
		 * @desc Called after the `chart` datasets have been updated. Note that this hook
		 * will not be called if the datasets update has been previously cancelled.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Object} options - The plugin options.
		 * @since version 2.1.5
		 */
		/**
		 * @method IPlugin#beforeDatasetUpdate
	 	 * @desc Called before updating the `chart` dataset at the given `args.index`. If any plugin
		 * returns `false`, the datasets update is cancelled until another `update` is triggered.
		 * @param {Chart} chart - The chart instance.
		 * @param {Object} args - The call arguments.
		 * @param {Number} args.index - The dataset index.
		 * @param {Object} args.meta - The dataset metadata.
		 * @param {Object} options - The plugin options.
		 * @returns {Boolean} `false` to cancel the chart datasets drawing.
		 */
		/**
		 * @method IPlugin#afterDatasetUpdate
	 	 * @desc Called after the `chart` datasets at the given `args.index` has been updated. Note
		 * that this hook will not be called if the datasets update has been previously cancelled.
		 * @param {Chart} chart - The chart instance.
		 * @param {Object} args - The call arguments.
		 * @param {Number} args.index - The dataset index.
		 * @param {Object} args.meta - The dataset metadata.
		 * @param {Object} options - The plugin options.
		 */
		/**
		 * @method IPlugin#beforeLayout
		 * @desc Called before laying out `chart`. If any plugin returns `false`,
		 * the layout update is cancelled until another `update` is triggered.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Object} options - The plugin options.
		 * @returns {Boolean} `false` to cancel the chart layout.
		 */
		/**
		 * @method IPlugin#afterLayout
		 * @desc Called after the `chart` has been layed out. Note that this hook will not
		 * be called if the layout update has been previously cancelled.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Object} options - The plugin options.
		 */
		/**
		 * @method IPlugin#beforeRender
		 * @desc Called before rendering `chart`. If any plugin returns `false`,
		 * the rendering is cancelled until another `render` is triggered.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Object} options - The plugin options.
		 * @returns {Boolean} `false` to cancel the chart rendering.
		 */
		/**
		 * @method IPlugin#afterRender
		 * @desc Called after the `chart` has been fully rendered (and animation completed). Note
		 * that this hook will not be called if the rendering has been previously cancelled.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Object} options - The plugin options.
		 */
		/**
		 * @method IPlugin#beforeDraw
		 * @desc Called before drawing `chart` at every animation frame specified by the given
		 * easing value. If any plugin returns `false`, the frame drawing is cancelled until
		 * another `render` is triggered.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
		 * @param {Object} options - The plugin options.
		 * @returns {Boolean} `false` to cancel the chart drawing.
		 */
		/**
		 * @method IPlugin#afterDraw
		 * @desc Called after the `chart` has been drawn for the specific easing value. Note
		 * that this hook will not be called if the drawing has been previously cancelled.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
		 * @param {Object} options - The plugin options.
		 */
		/**
		 * @method IPlugin#beforeDatasetsDraw
	 	 * @desc Called before drawing the `chart` datasets. If any plugin returns `false`,
		 * the datasets drawing is cancelled until another `render` is triggered.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
		 * @param {Object} options - The plugin options.
		 * @returns {Boolean} `false` to cancel the chart datasets drawing.
		 */
		/**
		 * @method IPlugin#afterDatasetsDraw
		 * @desc Called after the `chart` datasets have been drawn. Note that this hook
		 * will not be called if the datasets drawing has been previously cancelled.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Number} easingValue - The current animation value, between 0.0 and 1.0.
		 * @param {Object} options - The plugin options.
		 */
		/**
		 * @method IPlugin#beforeDatasetDraw
	 	 * @desc Called before drawing the `chart` dataset at the given `args.index` (datasets
		 * are drawn in the reverse order). If any plugin returns `false`, the datasets drawing
		 * is cancelled until another `render` is triggered.
		 * @param {Chart} chart - The chart instance.
		 * @param {Object} args - The call arguments.
		 * @param {Number} args.index - The dataset index.
		 * @param {Object} args.meta - The dataset metadata.
		 * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.
		 * @param {Object} options - The plugin options.
		 * @returns {Boolean} `false` to cancel the chart datasets drawing.
		 */
		/**
		 * @method IPlugin#afterDatasetDraw
	 	 * @desc Called after the `chart` datasets at the given `args.index` have been drawn
		 * (datasets are drawn in the reverse order). Note that this hook will not be called
		 * if the datasets drawing has been previously cancelled.
		 * @param {Chart} chart - The chart instance.
		 * @param {Object} args - The call arguments.
		 * @param {Number} args.index - The dataset index.
		 * @param {Object} args.meta - The dataset metadata.
		 * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.
		 * @param {Object} options - The plugin options.
		 */
		/**
	  	 * @method IPlugin#beforeTooltipDraw
		 * @desc Called before drawing the `tooltip`. If any plugin returns `false`,
		 * the tooltip drawing is cancelled until another `render` is triggered.
		 * @param {Chart} chart - The chart instance.
		 * @param {Object} args - The call arguments.
		 * @param {Object} args.tooltip - The tooltip.
		 * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.
		 * @param {Object} options - The plugin options.
		 * @returns {Boolean} `false` to cancel the chart tooltip drawing.
	  	 */
		/**
	 	 * @method IPlugin#afterTooltipDraw
	  	 * @desc Called after drawing the `tooltip`. Note that this hook will not
	 	 * be called if the tooltip drawing has been previously cancelled.
	 	 * @param {Chart} chart - The chart instance.
	 	 * @param {Object} args - The call arguments.
	 	 * @param {Object} args.tooltip - The tooltip.
		 * @param {Number} args.easingValue - The current animation value, between 0.0 and 1.0.
	 	 * @param {Object} options - The plugin options.
	 	 */
		/**
		 * @method IPlugin#beforeEvent
	 	 * @desc Called before processing the specified `event`. If any plugin returns `false`,
		 * the event will be discarded.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {IEvent} event - The event object.
		 * @param {Object} options - The plugin options.
		 */
		/**
		 * @method IPlugin#afterEvent
		 * @desc Called after the `event` has been consumed. Note that this hook
		 * will not be called if the `event` has been previously discarded.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {IEvent} event - The event object.
		 * @param {Object} options - The plugin options.
		 */
		/**
		 * @method IPlugin#resize
		 * @desc Called after the chart as been resized.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Number} size - The new canvas display size (eq. canvas.style width & height).
		 * @param {Object} options - The plugin options.
		 */
		/**
		 * @method IPlugin#destroy
		 * @desc Called after the chart as been destroyed.
		 * @param {Chart.Controller} chart - The chart instance.
		 * @param {Object} options - The plugin options.
		 */

		/**
		 * Provided for backward compatibility, use Chart.plugins instead
		 * @namespace Chart.pluginService
		 * @deprecated since version 2.1.5
		 * @todo remove at version 3
		 * @private
		 */
		Chart.pluginService = Chart.plugins;

		/**
		 * Provided for backward compatibility, inheriting from Chart.PlugingBase has no
		 * effect, instead simply create/register plugins via plain JavaScript objects.
		 * @interface Chart.PluginBase
		 * @deprecated since version 2.5.0
		 * @todo remove at version 3
		 * @private
		 */
		Chart.PluginBase = Element.extend({});
	};


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

	/* global window: false */
	'use strict';

	var defaults = __webpack_require__(40);
	var Element = __webpack_require__(52);
	var helpers = __webpack_require__(41);

	defaults._set('global', {
		animation: {
			duration: 1000,
			easing: 'easeOutQuart',
			onProgress: helpers.noop,
			onComplete: helpers.noop
		}
	});

	module.exports = function(Chart) {

		Chart.Animation = Element.extend({
			chart: null, // the animation associated chart instance
			currentStep: 0, // the current animation step
			numSteps: 60, // default number of steps
			easing: '', // the easing to use for this animation
			render: null, // render function used by the animation service

			onAnimationProgress: null, // user specified callback to fire on each step of the animation
			onAnimationComplete: null, // user specified callback to fire when the animation finishes
		});

		Chart.animationService = {
			frameDuration: 17,
			animations: [],
			dropFrames: 0,
			request: null,

			/**
			 * @param {Chart} chart - The chart to animate.
			 * @param {Chart.Animation} animation - The animation that we will animate.
			 * @param {Number} duration - The animation duration in ms.
			 * @param {Boolean} lazy - if true, the chart is not marked as animating to enable more responsive interactions
			 */
			addAnimation: function(chart, animation, duration, lazy) {
				var animations = this.animations;
				var i, ilen;

				animation.chart = chart;

				if (!lazy) {
					chart.animating = true;
				}

				for (i = 0, ilen = animations.length; i < ilen; ++i) {
					if (animations[i].chart === chart) {
						animations[i] = animation;
						return;
					}
				}

				animations.push(animation);

				// If there are no animations queued, manually kickstart a digest, for lack of a better word
				if (animations.length === 1) {
					this.requestAnimationFrame();
				}
			},

			cancelAnimation: function(chart) {
				var index = helpers.findIndex(this.animations, function(animation) {
					return animation.chart === chart;
				});

				if (index !== -1) {
					this.animations.splice(index, 1);
					chart.animating = false;
				}
			},

			requestAnimationFrame: function() {
				var me = this;
				if (me.request === null) {
					// Skip animation frame requests until the active one is executed.
					// This can happen when processing mouse events, e.g. 'mousemove'
					// and 'mouseout' events will trigger multiple renders.
					me.request = helpers.requestAnimFrame.call(window, function() {
						me.request = null;
						me.startDigest();
					});
				}
			},

			/**
			 * @private
			 */
			startDigest: function() {
				var me = this;
				var startTime = Date.now();
				var framesToDrop = 0;

				if (me.dropFrames > 1) {
					framesToDrop = Math.floor(me.dropFrames);
					me.dropFrames = me.dropFrames % 1;
				}

				me.advance(1 + framesToDrop);

				var endTime = Date.now();

				me.dropFrames += (endTime - startTime) / me.frameDuration;

				// Do we have more stuff to animate?
				if (me.animations.length > 0) {
					me.requestAnimationFrame();
				}
			},

			/**
			 * @private
			 */
			advance: function(count) {
				var animations = this.animations;
				var animation, chart;
				var i = 0;

				while (i < animations.length) {
					animation = animations[i];
					chart = animation.chart;

					animation.currentStep = (animation.currentStep || 0) + count;
					animation.currentStep = Math.min(animation.currentStep, animation.numSteps);

					helpers.callback(animation.render, [chart, animation], chart);
					helpers.callback(animation.onAnimationProgress, [animation], chart);

					if (animation.currentStep >= animation.numSteps) {
						helpers.callback(animation.onAnimationComplete, [animation], chart);
						chart.animating = false;
						animations.splice(i, 1);
					} else {
						++i;
					}
				}
			}
		};

		/**
		 * Provided for backward compatibility, use Chart.Animation instead
		 * @prop Chart.Animation#animationObject
		 * @deprecated since version 2.6.0
		 * @todo remove at version 3
		 */
		Object.defineProperty(Chart.Animation.prototype, 'animationObject', {
			get: function() {
				return this;
			}
		});

		/**
		 * Provided for backward compatibility, use Chart.Animation#chart instead
		 * @prop Chart.Animation#chartInstance
		 * @deprecated since version 2.6.0
		 * @todo remove at version 3
		 */
		Object.defineProperty(Chart.Animation.prototype, 'chartInstance', {
			get: function() {
				return this.chart;
			},
			set: function(value) {
				this.chart = value;
			}
		});

	};


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var defaults = __webpack_require__(40);
	var helpers = __webpack_require__(41);
	var Interaction = __webpack_require__(58);
	var platform = __webpack_require__(59);

	module.exports = function(Chart) {
		var plugins = Chart.plugins;

		// Create a dictionary of chart types, to allow for extension of existing types
		Chart.types = {};

		// Store a reference to each instance - allowing us to globally resize chart instances on window resize.
		// Destroy method on the chart will remove the instance of the chart from this reference.
		Chart.instances = {};

		// Controllers available for dataset visualization eg. bar, line, slice, etc.
		Chart.controllers = {};

		/**
		 * Initializes the given config with global and chart default values.
		 */
		function initConfig(config) {
			config = config || {};

			// Do NOT use configMerge() for the data object because this method merges arrays
			// and so would change references to labels and datasets, preventing data updates.
			var data = config.data = config.data || {};
			data.datasets = data.datasets || [];
			data.labels = data.labels || [];

			config.options = helpers.configMerge(
				defaults.global,
				defaults[config.type],
				config.options || {});

			return config;
		}

		/**
		 * Updates the config of the chart
		 * @param chart {Chart} chart to update the options for
		 */
		function updateConfig(chart) {
			var newOptions = chart.options;

			// Update Scale(s) with options
			if (newOptions.scale) {
				chart.scale.options = newOptions.scale;
			} else if (newOptions.scales) {
				newOptions.scales.xAxes.concat(newOptions.scales.yAxes).forEach(function(scaleOptions) {
					chart.scales[scaleOptions.id].options = scaleOptions;
				});
			}

			// Tooltip
			chart.tooltip._options = newOptions.tooltips;
		}

		function positionIsHorizontal(position) {
			return position === 'top' || position === 'bottom';
		}

		helpers.extend(Chart.prototype, /** @lends Chart */ {
			/**
			 * @private
			 */
			construct: function(item, config) {
				var me = this;

				config = initConfig(config);

				var context = platform.acquireContext(item, config);
				var canvas = context && context.canvas;
				var height = canvas && canvas.height;
				var width = canvas && canvas.width;

				me.id = helpers.uid();
				me.ctx = context;
				me.canvas = canvas;
				me.config = config;
				me.width = width;
				me.height = height;
				me.aspectRatio = height ? width / height : null;
				me.options = config.options;
				me._bufferedRender = false;

				/**
				 * Provided for backward compatibility, Chart and Chart.Controller have been merged,
				 * the "instance" still need to be defined since it might be called from plugins.
				 * @prop Chart#chart
				 * @deprecated since version 2.6.0
				 * @todo remove at version 3
				 * @private
				 */
				me.chart = me;
				me.controller = me; // chart.chart.controller #inception

				// Add the chart instance to the global namespace
				Chart.instances[me.id] = me;

				// Define alias to the config data: `chart.data === chart.config.data`
				Object.defineProperty(me, 'data', {
					get: function() {
						return me.config.data;
					},
					set: function(value) {
						me.config.data = value;
					}
				});

				if (!context || !canvas) {
					// The given item is not a compatible context2d element, let's return before finalizing
					// the chart initialization but after setting basic chart / controller properties that
					// can help to figure out that the chart is not valid (e.g chart.canvas !== null);
					// https://github.com/chartjs/Chart.js/issues/2807
					console.error("Failed to create chart: can't acquire context from the given item");
					return;
				}

				me.initialize();
				me.update();
			},

			/**
			 * @private
			 */
			initialize: function() {
				var me = this;

				// Before init plugin notification
				plugins.notify(me, 'beforeInit');

				helpers.retinaScale(me, me.options.devicePixelRatio);

				me.bindEvents();

				if (me.options.responsive) {
					// Initial resize before chart draws (must be silent to preserve initial animations).
					me.resize(true);
				}

				// Make sure scales have IDs and are built before we build any controllers.
				me.ensureScalesHaveIDs();
				me.buildScales();
				me.initToolTip();

				// After init plugin notification
				plugins.notify(me, 'afterInit');

				return me;
			},

			clear: function() {
				helpers.canvas.clear(this);
				return this;
			},

			stop: function() {
				// Stops any current animation loop occurring
				Chart.animationService.cancelAnimation(this);
				return this;
			},

			resize: function(silent) {
				var me = this;
				var options = me.options;
				var canvas = me.canvas;
				var aspectRatio = (options.maintainAspectRatio && me.aspectRatio) || null;

				// the canvas render width and height will be casted to integers so make sure that
				// the canvas display style uses the same integer values to avoid blurring effect.

				// Set to 0 instead of canvas.size because the size defaults to 300x150 if the element is collased
				var newWidth = Math.max(0, Math.floor(helpers.getMaximumWidth(canvas)));
				var newHeight = Math.max(0, Math.floor(aspectRatio ? newWidth / aspectRatio : helpers.getMaximumHeight(canvas)));

				if (me.width === newWidth && me.height === newHeight) {
					return;
				}

				canvas.width = me.width = newWidth;
				canvas.height = me.height = newHeight;
				canvas.style.width = newWidth + 'px';
				canvas.style.height = newHeight + 'px';

				helpers.retinaScale(me, options.devicePixelRatio);

				if (!silent) {
					// Notify any plugins about the resize
					var newSize = {width: newWidth, height: newHeight};
					plugins.notify(me, 'resize', [newSize]);

					// Notify of resize
					if (me.options.onResize) {
						me.options.onResize(me, newSize);
					}

					me.stop();
					me.update(me.options.responsiveAnimationDuration);
				}
			},

			ensureScalesHaveIDs: function() {
				var options = this.options;
				var scalesOptions = options.scales || {};
				var scaleOptions = options.scale;

				helpers.each(scalesOptions.xAxes, function(xAxisOptions, index) {
					xAxisOptions.id = xAxisOptions.id || ('x-axis-' + index);
				});

				helpers.each(scalesOptions.yAxes, function(yAxisOptions, index) {
					yAxisOptions.id = yAxisOptions.id || ('y-axis-' + index);
				});

				if (scaleOptions) {
					scaleOptions.id = scaleOptions.id || 'scale';
				}
			},

			/**
			 * Builds a map of scale ID to scale object for future lookup.
			 */
			buildScales: function() {
				var me = this;
				var options = me.options;
				var scales = me.scales = {};
				var items = [];

				if (options.scales) {
					items = items.concat(
						(options.scales.xAxes || []).map(function(xAxisOptions) {
							return {options: xAxisOptions, dtype: 'category', dposition: 'bottom'};
						}),
						(options.scales.yAxes || []).map(function(yAxisOptions) {
							return {options: yAxisOptions, dtype: 'linear', dposition: 'left'};
						})
					);
				}

				if (options.scale) {
					items.push({
						options: options.scale,
						dtype: 'radialLinear',
						isDefault: true,
						dposition: 'chartArea'
					});
				}

				helpers.each(items, function(item) {
					var scaleOptions = item.options;
					var scaleType = helpers.valueOrDefault(scaleOptions.type, item.dtype);
					var scaleClass = Chart.scaleService.getScaleConstructor(scaleType);
					if (!scaleClass) {
						return;
					}

					if (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {
						scaleOptions.position = item.dposition;
					}

					var scale = new scaleClass({
						id: scaleOptions.id,
						options: scaleOptions,
						ctx: me.ctx,
						chart: me
					});

					scales[scale.id] = scale;
					scale.mergeTicksOptions();

					// TODO(SB): I think we should be able to remove this custom case (options.scale)
					// and consider it as a regular scale part of the "scales"" map only! This would
					// make the logic easier and remove some useless? custom code.
					if (item.isDefault) {
						me.scale = scale;
					}
				});

				Chart.scaleService.addScalesToLayout(this);
			},

			buildOrUpdateControllers: function() {
				var me = this;
				var types = [];
				var newControllers = [];

				helpers.each(me.data.datasets, function(dataset, datasetIndex) {
					var meta = me.getDatasetMeta(datasetIndex);
					var type = dataset.type || me.config.type;

					if (meta.type && meta.type !== type) {
						me.destroyDatasetMeta(datasetIndex);
						meta = me.getDatasetMeta(datasetIndex);
					}
					meta.type = type;

					types.push(meta.type);

					if (meta.controller) {
						meta.controller.updateIndex(datasetIndex);
					} else {
						var ControllerClass = Chart.controllers[meta.type];
						if (ControllerClass === undefined) {
							throw new Error('"' + meta.type + '" is not a chart type.');
						}

						meta.controller = new ControllerClass(me, datasetIndex);
						newControllers.push(meta.controller);
					}
				}, me);

				return newControllers;
			},

			/**
			 * Reset the elements of all datasets
			 * @private
			 */
			resetElements: function() {
				var me = this;
				helpers.each(me.data.datasets, function(dataset, datasetIndex) {
					me.getDatasetMeta(datasetIndex).controller.reset();
				}, me);
			},

			/**
			* Resets the chart back to it's state before the initial animation
			*/
			reset: function() {
				this.resetElements();
				this.tooltip.initialize();
			},

			update: function(config) {
				var me = this;

				if (!config || typeof config !== 'object') {
					// backwards compatibility
					config = {
						duration: config,
						lazy: arguments[1]
					};
				}

				updateConfig(me);

				if (plugins.notify(me, 'beforeUpdate') === false) {
					return;
				}

				// In case the entire data object changed
				me.tooltip._data = me.data;

				// Make sure dataset controllers are updated and new controllers are reset
				var newControllers = me.buildOrUpdateControllers();

				// Make sure all dataset controllers have correct meta data counts
				helpers.each(me.data.datasets, function(dataset, datasetIndex) {
					me.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();
				}, me);

				me.updateLayout();

				// Can only reset the new controllers after the scales have been updated
				helpers.each(newControllers, function(controller) {
					controller.reset();
				});

				me.updateDatasets();

				// Need to reset tooltip in case it is displayed with elements that are removed
				// after update.
				me.tooltip.initialize();

				// Last active contains items that were previously in the tooltip.
				// When we reset the tooltip, we need to clear it
				me.lastActive = [];

				// Do this before render so that any plugins that need final scale updates can use it
				plugins.notify(me, 'afterUpdate');

				if (me._bufferedRender) {
					me._bufferedRequest = {
						duration: config.duration,
						easing: config.easing,
						lazy: config.lazy
					};
				} else {
					me.render(config);
				}
			},

			/**
			 * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`
			 * hook, in which case, plugins will not be called on `afterLayout`.
			 * @private
			 */
			updateLayout: function() {
				var me = this;

				if (plugins.notify(me, 'beforeLayout') === false) {
					return;
				}

				Chart.layoutService.update(this, this.width, this.height);

				/**
				 * Provided for backward compatibility, use `afterLayout` instead.
				 * @method IPlugin#afterScaleUpdate
				 * @deprecated since version 2.5.0
				 * @todo remove at version 3
				 * @private
				 */
				plugins.notify(me, 'afterScaleUpdate');
				plugins.notify(me, 'afterLayout');
			},

			/**
			 * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`
			 * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.
			 * @private
			 */
			updateDatasets: function() {
				var me = this;

				if (plugins.notify(me, 'beforeDatasetsUpdate') === false) {
					return;
				}

				for (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
					me.updateDataset(i);
				}

				plugins.notify(me, 'afterDatasetsUpdate');
			},

			/**
			 * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`
			 * hook, in which case, plugins will not be called on `afterDatasetUpdate`.
			 * @private
			 */
			updateDataset: function(index) {
				var me = this;
				var meta = me.getDatasetMeta(index);
				var args = {
					meta: meta,
					index: index
				};

				if (plugins.notify(me, 'beforeDatasetUpdate', [args]) === false) {
					return;
				}

				meta.controller.update();

				plugins.notify(me, 'afterDatasetUpdate', [args]);
			},

			render: function(config) {
				var me = this;

				if (!config || typeof config !== 'object') {
					// backwards compatibility
					config = {
						duration: config,
						lazy: arguments[1]
					};
				}

				var duration = config.duration;
				var lazy = config.lazy;

				if (plugins.notify(me, 'beforeRender') === false) {
					return;
				}

				var animationOptions = me.options.animation;
				var onComplete = function(animation) {
					plugins.notify(me, 'afterRender');
					helpers.callback(animationOptions && animationOptions.onComplete, [animation], me);
				};

				if (animationOptions && ((typeof duration !== 'undefined' && duration !== 0) || (typeof duration === 'undefined' && animationOptions.duration !== 0))) {
					var animation = new Chart.Animation({
						numSteps: (duration || animationOptions.duration) / 16.66, // 60 fps
						easing: config.easing || animationOptions.easing,

						render: function(chart, animationObject) {
							var easingFunction = helpers.easing.effects[animationObject.easing];
							var currentStep = animationObject.currentStep;
							var stepDecimal = currentStep / animationObject.numSteps;

							chart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);
						},

						onAnimationProgress: animationOptions.onProgress,
						onAnimationComplete: onComplete
					});

					Chart.animationService.addAnimation(me, animation, duration, lazy);
				} else {
					me.draw();

					// See https://github.com/chartjs/Chart.js/issues/3781
					onComplete(new Chart.Animation({numSteps: 0, chart: me}));
				}

				return me;
			},

			draw: function(easingValue) {
				var me = this;

				me.clear();

				if (helpers.isNullOrUndef(easingValue)) {
					easingValue = 1;
				}

				me.transition(easingValue);

				if (plugins.notify(me, 'beforeDraw', [easingValue]) === false) {
					return;
				}

				// Draw all the scales
				helpers.each(me.boxes, function(box) {
					box.draw(me.chartArea);
				}, me);

				if (me.scale) {
					me.scale.draw();
				}

				me.drawDatasets(easingValue);
				me._drawTooltip(easingValue);

				plugins.notify(me, 'afterDraw', [easingValue]);
			},

			/**
			 * @private
			 */
			transition: function(easingValue) {
				var me = this;

				for (var i = 0, ilen = (me.data.datasets || []).length; i < ilen; ++i) {
					if (me.isDatasetVisible(i)) {
						me.getDatasetMeta(i).controller.transition(easingValue);
					}
				}

				me.tooltip.transition(easingValue);
			},

			/**
			 * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`
			 * hook, in which case, plugins will not be called on `afterDatasetsDraw`.
			 * @private
			 */
			drawDatasets: function(easingValue) {
				var me = this;

				if (plugins.notify(me, 'beforeDatasetsDraw', [easingValue]) === false) {
					return;
				}

				// Draw datasets reversed to support proper line stacking
				for (var i = (me.data.datasets || []).length - 1; i >= 0; --i) {
					if (me.isDatasetVisible(i)) {
						me.drawDataset(i, easingValue);
					}
				}

				plugins.notify(me, 'afterDatasetsDraw', [easingValue]);
			},

			/**
			 * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`
			 * hook, in which case, plugins will not be called on `afterDatasetDraw`.
			 * @private
			 */
			drawDataset: function(index, easingValue) {
				var me = this;
				var meta = me.getDatasetMeta(index);
				var args = {
					meta: meta,
					index: index,
					easingValue: easingValue
				};

				if (plugins.notify(me, 'beforeDatasetDraw', [args]) === false) {
					return;
				}

				meta.controller.draw(easingValue);

				plugins.notify(me, 'afterDatasetDraw', [args]);
			},

			/**
			 * Draws tooltip unless a plugin returns `false` to the `beforeTooltipDraw`
			 * hook, in which case, plugins will not be called on `afterTooltipDraw`.
			 * @private
			 */
			_drawTooltip: function(easingValue) {
				var me = this;
				var tooltip = me.tooltip;
				var args = {
					tooltip: tooltip,
					easingValue: easingValue
				};

				if (plugins.notify(me, 'beforeTooltipDraw', [args]) === false) {
					return;
				}

				tooltip.draw();

				plugins.notify(me, 'afterTooltipDraw', [args]);
			},

			// Get the single element that was clicked on
			// @return : An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw
			getElementAtEvent: function(e) {
				return Interaction.modes.single(this, e);
			},

			getElementsAtEvent: function(e) {
				return Interaction.modes.label(this, e, {intersect: true});
			},

			getElementsAtXAxis: function(e) {
				return Interaction.modes['x-axis'](this, e, {intersect: true});
			},

			getElementsAtEventForMode: function(e, mode, options) {
				var method = Interaction.modes[mode];
				if (typeof method === 'function') {
					return method(this, e, options);
				}

				return [];
			},

			getDatasetAtEvent: function(e) {
				return Interaction.modes.dataset(this, e, {intersect: true});
			},

			getDatasetMeta: function(datasetIndex) {
				var me = this;
				var dataset = me.data.datasets[datasetIndex];
				if (!dataset._meta) {
					dataset._meta = {};
				}

				var meta = dataset._meta[me.id];
				if (!meta) {
					meta = dataset._meta[me.id] = {
						type: null,
						data: [],
						dataset: null,
						controller: null,
						hidden: null,			// See isDatasetVisible() comment
						xAxisID: null,
						yAxisID: null
					};
				}

				return meta;
			},

			getVisibleDatasetCount: function() {
				var count = 0;
				for (var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
					if (this.isDatasetVisible(i)) {
						count++;
					}
				}
				return count;
			},

			isDatasetVisible: function(datasetIndex) {
				var meta = this.getDatasetMeta(datasetIndex);

				// meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,
				// the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.
				return typeof meta.hidden === 'boolean' ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;
			},

			generateLegend: function() {
				return this.options.legendCallback(this);
			},

			/**
			 * @private
			 */
			destroyDatasetMeta: function(datasetIndex) {
				var id = this.id;
				var dataset = this.data.datasets[datasetIndex];
				var meta = dataset._meta && dataset._meta[id];

				if (meta) {
					meta.controller.destroy();
					delete dataset._meta[id];
				}
			},

			destroy: function() {
				var me = this;
				var canvas = me.canvas;
				var i, ilen;

				me.stop();

				// dataset controllers need to cleanup associated data
				for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
					me.destroyDatasetMeta(i);
				}

				if (canvas) {
					me.unbindEvents();
					helpers.canvas.clear(me);
					platform.releaseContext(me.ctx);
					me.canvas = null;
					me.ctx = null;
				}

				plugins.notify(me, 'destroy');

				delete Chart.instances[me.id];
			},

			toBase64Image: function() {
				return this.canvas.toDataURL.apply(this.canvas, arguments);
			},

			initToolTip: function() {
				var me = this;
				me.tooltip = new Chart.Tooltip({
					_chart: me,
					_chartInstance: me, // deprecated, backward compatibility
					_data: me.data,
					_options: me.options.tooltips
				}, me);
			},

			/**
			 * @private
			 */
			bindEvents: function() {
				var me = this;
				var listeners = me._listeners = {};
				var listener = function() {
					me.eventHandler.apply(me, arguments);
				};

				helpers.each(me.options.events, function(type) {
					platform.addEventListener(me, type, listener);
					listeners[type] = listener;
				});

				// Elements used to detect size change should not be injected for non responsive charts.
				// See https://github.com/chartjs/Chart.js/issues/2210
				if (me.options.responsive) {
					listener = function() {
						me.resize();
					};

					platform.addEventListener(me, 'resize', listener);
					listeners.resize = listener;
				}
			},

			/**
			 * @private
			 */
			unbindEvents: function() {
				var me = this;
				var listeners = me._listeners;
				if (!listeners) {
					return;
				}

				delete me._listeners;
				helpers.each(listeners, function(listener, type) {
					platform.removeEventListener(me, type, listener);
				});
			},

			updateHoverStyle: function(elements, mode, enabled) {
				var method = enabled ? 'setHoverStyle' : 'removeHoverStyle';
				var element, i, ilen;

				for (i = 0, ilen = elements.length; i < ilen; ++i) {
					element = elements[i];
					if (element) {
						this.getDatasetMeta(element._datasetIndex).controller[method](element);
					}
				}
			},

			/**
			 * @private
			 */
			eventHandler: function(e) {
				var me = this;
				var tooltip = me.tooltip;

				if (plugins.notify(me, 'beforeEvent', [e]) === false) {
					return;
				}

				// Buffer any update calls so that renders do not occur
				me._bufferedRender = true;
				me._bufferedRequest = null;

				var changed = me.handleEvent(e);
				changed |= tooltip && tooltip.handleEvent(e);

				plugins.notify(me, 'afterEvent', [e]);

				var bufferedRequest = me._bufferedRequest;
				if (bufferedRequest) {
					// If we have an update that was triggered, we need to do a normal render
					me.render(bufferedRequest);
				} else if (changed && !me.animating) {
					// If entering, leaving, or changing elements, animate the change via pivot
					me.stop();

					// We only need to render at this point. Updating will cause scales to be
					// recomputed generating flicker & using more memory than necessary.
					me.render(me.options.hover.animationDuration, true);
				}

				me._bufferedRender = false;
				me._bufferedRequest = null;

				return me;
			},

			/**
			 * Handle an event
			 * @private
			 * @param {IEvent} event the event to handle
			 * @return {Boolean} true if the chart needs to re-render
			 */
			handleEvent: function(e) {
				var me = this;
				var options = me.options || {};
				var hoverOptions = options.hover;
				var changed = false;

				me.lastActive = me.lastActive || [];

				// Find Active Elements for hover and tooltips
				if (e.type === 'mouseout') {
					me.active = [];
				} else {
					me.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);
				}

				// Invoke onHover hook
				// Need to call with native event here to not break backwards compatibility
				helpers.callback(options.onHover || options.hover.onHover, [e.native, me.active], me);

				if (e.type === 'mouseup' || e.type === 'click') {
					if (options.onClick) {
						// Use e.native here for backwards compatibility
						options.onClick.call(me, e.native, me.active);
					}
				}

				// Remove styling for last active (even if it may still be active)
				if (me.lastActive.length) {
					me.updateHoverStyle(me.lastActive, hoverOptions.mode, false);
				}

				// Built in hover styling
				if (me.active.length && hoverOptions.mode) {
					me.updateHoverStyle(me.active, hoverOptions.mode, true);
				}

				changed = !helpers.arrayEquals(me.active, me.lastActive);

				// Remember Last Actives
				me.lastActive = me.active;

				return changed;
			}
		});

		/**
		 * Provided for backward compatibility, use Chart instead.
		 * @class Chart.Controller
		 * @deprecated since version 2.6.0
		 * @todo remove at version 3
		 * @private
		 */
		Chart.Controller = Chart;
	};


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var helpers = __webpack_require__(41);

	module.exports = function(Chart) {

		var arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];

		/**
		 * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',
		 * 'unshift') and notify the listener AFTER the array has been altered. Listeners are
		 * called on the 'onData*' callbacks (e.g. onDataPush, etc.) with same arguments.
		 */
		function listenArrayEvents(array, listener) {
			if (array._chartjs) {
				array._chartjs.listeners.push(listener);
				return;
			}

			Object.defineProperty(array, '_chartjs', {
				configurable: true,
				enumerable: false,
				value: {
					listeners: [listener]
				}
			});

			arrayEvents.forEach(function(key) {
				var method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);
				var base = array[key];

				Object.defineProperty(array, key, {
					configurable: true,
					enumerable: false,
					value: function() {
						var args = Array.prototype.slice.call(arguments);
						var res = base.apply(this, args);

						helpers.each(array._chartjs.listeners, function(object) {
							if (typeof object[method] === 'function') {
								object[method].apply(object, args);
							}
						});

						return res;
					}
				});
			});
		}

		/**
		 * Removes the given array event listener and cleanup extra attached properties (such as
		 * the _chartjs stub and overridden methods) if array doesn't have any more listeners.
		 */
		function unlistenArrayEvents(array, listener) {
			var stub = array._chartjs;
			if (!stub) {
				return;
			}

			var listeners = stub.listeners;
			var index = listeners.indexOf(listener);
			if (index !== -1) {
				listeners.splice(index, 1);
			}

			if (listeners.length > 0) {
				return;
			}

			arrayEvents.forEach(function(key) {
				delete array[key];
			});

			delete array._chartjs;
		}

		// Base class for all dataset controllers (line, bar, etc)
		Chart.DatasetController = function(chart, datasetIndex) {
			this.initialize(chart, datasetIndex);
		};

		helpers.extend(Chart.DatasetController.prototype, {

			/**
			 * Element type used to generate a meta dataset (e.g. Chart.element.Line).
			 * @type {Chart.core.element}
			 */
			datasetElementType: null,

			/**
			 * Element type used to generate a meta data (e.g. Chart.element.Point).
			 * @type {Chart.core.element}
			 */
			dataElementType: null,

			initialize: function(chart, datasetIndex) {
				var me = this;
				me.chart = chart;
				me.index = datasetIndex;
				me.linkScales();
				me.addElements();
			},

			updateIndex: function(datasetIndex) {
				this.index = datasetIndex;
			},

			linkScales: function() {
				var me = this;
				var meta = me.getMeta();
				var dataset = me.getDataset();

				if (meta.xAxisID === null) {
					meta.xAxisID = dataset.xAxisID || me.chart.options.scales.xAxes[0].id;
				}
				if (meta.yAxisID === null) {
					meta.yAxisID = dataset.yAxisID || me.chart.options.scales.yAxes[0].id;
				}
			},

			getDataset: function() {
				return this.chart.data.datasets[this.index];
			},

			getMeta: function() {
				return this.chart.getDatasetMeta(this.index);
			},

			getScaleForId: function(scaleID) {
				return this.chart.scales[scaleID];
			},

			reset: function() {
				this.update(true);
			},

			/**
			 * @private
			 */
			destroy: function() {
				if (this._data) {
					unlistenArrayEvents(this._data, this);
				}
			},

			createMetaDataset: function() {
				var me = this;
				var type = me.datasetElementType;
				return type && new type({
					_chart: me.chart,
					_datasetIndex: me.index
				});
			},

			createMetaData: function(index) {
				var me = this;
				var type = me.dataElementType;
				return type && new type({
					_chart: me.chart,
					_datasetIndex: me.index,
					_index: index
				});
			},

			addElements: function() {
				var me = this;
				var meta = me.getMeta();
				var data = me.getDataset().data || [];
				var metaData = meta.data;
				var i, ilen;

				for (i = 0, ilen = data.length; i < ilen; ++i) {
					metaData[i] = metaData[i] || me.createMetaData(i);
				}

				meta.dataset = meta.dataset || me.createMetaDataset();
			},

			addElementAndReset: function(index) {
				var element = this.createMetaData(index);
				this.getMeta().data.splice(index, 0, element);
				this.updateElement(element, index, true);
			},

			buildOrUpdateElements: function() {
				var me = this;
				var dataset = me.getDataset();
				var data = dataset.data || (dataset.data = []);

				// In order to correctly handle data addition/deletion animation (an thus simulate
				// real-time charts), we need to monitor these data modifications and synchronize
				// the internal meta data accordingly.
				if (me._data !== data) {
					if (me._data) {
						// This case happens when the user replaced the data array instance.
						unlistenArrayEvents(me._data, me);
					}

					listenArrayEvents(data, me);
					me._data = data;
				}

				// Re-sync meta data in case the user replaced the data array or if we missed
				// any updates and so make sure that we handle number of datapoints changing.
				me.resyncElements();
			},

			update: helpers.noop,

			transition: function(easingValue) {
				var meta = this.getMeta();
				var elements = meta.data || [];
				var ilen = elements.length;
				var i = 0;

				for (; i < ilen; ++i) {
					elements[i].transition(easingValue);
				}

				if (meta.dataset) {
					meta.dataset.transition(easingValue);
				}
			},

			draw: function() {
				var meta = this.getMeta();
				var elements = meta.data || [];
				var ilen = elements.length;
				var i = 0;

				if (meta.dataset) {
					meta.dataset.draw();
				}

				for (; i < ilen; ++i) {
					elements[i].draw();
				}
			},

			removeHoverStyle: function(element, elementOpts) {
				var dataset = this.chart.data.datasets[element._datasetIndex];
				var index = element._index;
				var custom = element.custom || {};
				var valueOrDefault = helpers.valueAtIndexOrDefault;
				var model = element._model;

				model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueOrDefault(dataset.backgroundColor, index, elementOpts.backgroundColor);
				model.borderColor = custom.borderColor ? custom.borderColor : valueOrDefault(dataset.borderColor, index, elementOpts.borderColor);
				model.borderWidth = custom.borderWidth ? custom.borderWidth : valueOrDefault(dataset.borderWidth, index, elementOpts.borderWidth);
			},

			setHoverStyle: function(element) {
				var dataset = this.chart.data.datasets[element._datasetIndex];
				var index = element._index;
				var custom = element.custom || {};
				var valueOrDefault = helpers.valueAtIndexOrDefault;
				var getHoverColor = helpers.getHoverColor;
				var model = element._model;

				model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : valueOrDefault(dataset.hoverBackgroundColor, index, getHoverColor(model.backgroundColor));
				model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : valueOrDefault(dataset.hoverBorderColor, index, getHoverColor(model.borderColor));
				model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : valueOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);
			},

			/**
			 * @private
			 */
			resyncElements: function() {
				var me = this;
				var meta = me.getMeta();
				var data = me.getDataset().data;
				var numMeta = meta.data.length;
				var numData = data.length;

				if (numData < numMeta) {
					meta.data.splice(numData, numMeta - numData);
				} else if (numData > numMeta) {
					me.insertElements(numMeta, numData - numMeta);
				}
			},

			/**
			 * @private
			 */
			insertElements: function(start, count) {
				for (var i = 0; i < count; ++i) {
					this.addElementAndReset(start + i);
				}
			},

			/**
			 * @private
			 */
			onDataPush: function() {
				this.insertElements(this.getDataset().data.length - 1, arguments.length);
			},

			/**
			 * @private
			 */
			onDataPop: function() {
				this.getMeta().data.pop();
			},

			/**
			 * @private
			 */
			onDataShift: function() {
				this.getMeta().data.shift();
			},

			/**
			 * @private
			 */
			onDataSplice: function(start, count) {
				this.getMeta().data.splice(start, count);
				this.insertElements(start, arguments.length - 2);
			},

			/**
			 * @private
			 */
			onDataUnshift: function() {
				this.insertElements(0, arguments.length);
			}
		});

		Chart.DatasetController.extend = helpers.inherits;
	};


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var helpers = __webpack_require__(41);

	module.exports = function(Chart) {

		function filterByPosition(array, position) {
			return helpers.where(array, function(v) {
				return v.position === position;
			});
		}

		function sortByWeight(array, reverse) {
			array.forEach(function(v, i) {
				v._tmpIndex_ = i;
				return v;
			});
			array.sort(function(a, b) {
				var v0 = reverse ? b : a;
				var v1 = reverse ? a : b;
				return v0.weight === v1.weight ?
					v0._tmpIndex_ - v1._tmpIndex_ :
					v0.weight - v1.weight;
			});
			array.forEach(function(v) {
				delete v._tmpIndex_;
			});
		}

		/**
		 * @interface ILayoutItem
		 * @prop {String} position - The position of the item in the chart layout. Possible values are
		 * 'left', 'top', 'right', 'bottom', and 'chartArea'
		 * @prop {Number} weight - The weight used to sort the item. Higher weights are further away from the chart area
		 * @prop {Boolean} fullWidth - if true, and the item is horizontal, then push vertical boxes down
		 * @prop {Function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)
		 * @prop {Function} update - Takes two parameters: width and height. Returns size of item
		 * @prop {Function} getPadding -  Returns an object with padding on the edges
		 * @prop {Number} width - Width of item. Must be valid after update()
		 * @prop {Number} height - Height of item. Must be valid after update()
		 * @prop {Number} left - Left edge of the item. Set by layout system and cannot be used in update
		 * @prop {Number} top - Top edge of the item. Set by layout system and cannot be used in update
		 * @prop {Number} right - Right edge of the item. Set by layout system and cannot be used in update
		 * @prop {Number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update
		 */

		// The layout service is very self explanatory.  It's responsible for the layout within a chart.
		// Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need
		// It is this service's responsibility of carrying out that layout.
		Chart.layoutService = {
			defaults: {},

			/**
			 * Register a box to a chart.
			 * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.
			 * @param {Chart} chart - the chart to use
			 * @param {ILayoutItem} item - the item to add to be layed out
			 */
			addBox: function(chart, item) {
				if (!chart.boxes) {
					chart.boxes = [];
				}

				// initialize item with default values
				item.fullWidth = item.fullWidth || false;
				item.position = item.position || 'top';
				item.weight = item.weight || 0;

				chart.boxes.push(item);
			},

			/**
			 * Remove a layoutItem from a chart
			 * @param {Chart} chart - the chart to remove the box from
			 * @param {Object} layoutItem - the item to remove from the layout
			 */
			removeBox: function(chart, layoutItem) {
				var index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
				if (index !== -1) {
					chart.boxes.splice(index, 1);
				}
			},

			/**
			 * Sets (or updates) options on the given `item`.
			 * @param {Chart} chart - the chart in which the item lives (or will be added to)
			 * @param {Object} item - the item to configure with the given options
			 * @param {Object} options - the new item options.
			 */
			configure: function(chart, item, options) {
				var props = ['fullWidth', 'position', 'weight'];
				var ilen = props.length;
				var i = 0;
				var prop;

				for (; i < ilen; ++i) {
					prop = props[i];
					if (options.hasOwnProperty(prop)) {
						item[prop] = options[prop];
					}
				}
			},

			/**
			 * Fits boxes of the given chart into the given size by having each box measure itself
			 * then running a fitting algorithm
			 * @param {Chart} chart - the chart
			 * @param {Number} width - the width to fit into
			 * @param {Number} height - the height to fit into
			 */
			update: function(chart, width, height) {
				if (!chart) {
					return;
				}

				var layoutOptions = chart.options.layout || {};
				var padding = helpers.options.toPadding(layoutOptions.padding);
				var leftPadding = padding.left;
				var rightPadding = padding.right;
				var topPadding = padding.top;
				var bottomPadding = padding.bottom;

				var leftBoxes = filterByPosition(chart.boxes, 'left');
				var rightBoxes = filterByPosition(chart.boxes, 'right');
				var topBoxes = filterByPosition(chart.boxes, 'top');
				var bottomBoxes = filterByPosition(chart.boxes, 'bottom');
				var chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea');

				// Sort boxes by weight. A higher weight is further away from the chart area
				sortByWeight(leftBoxes, true);
				sortByWeight(rightBoxes, false);
				sortByWeight(topBoxes, true);
				sortByWeight(bottomBoxes, false);

				// Essentially we now have any number of boxes on each of the 4 sides.
				// Our canvas looks like the following.
				// The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and
				// B1 is the bottom axis
				// There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays
				// These locations are single-box locations only, when trying to register a chartArea location that is already taken,
				// an error will be thrown.
				//
				// |----------------------------------------------------|
				// |                  T1 (Full Width)                   |
				// |----------------------------------------------------|
				// |    |    |                 T2                  |    |
				// |    |----|-------------------------------------|----|
				// |    |    | C1 |                           | C2 |    |
				// |    |    |----|                           |----|    |
				// |    |    |                                     |    |
				// | L1 | L2 |           ChartArea (C0)            | R1 |
				// |    |    |                                     |    |
				// |    |    |----|                           |----|    |
				// |    |    | C3 |                           | C4 |    |
				// |    |----|-------------------------------------|----|
				// |    |    |                 B1                  |    |
				// |----------------------------------------------------|
				// |                  B2 (Full Width)                   |
				// |----------------------------------------------------|
				//
				// What we do to find the best sizing, we do the following
				// 1. Determine the minimum size of the chart area.
				// 2. Split the remaining width equally between each vertical axis
				// 3. Split the remaining height equally between each horizontal axis
				// 4. Give each layout the maximum size it can be. The layout will return it's minimum size
				// 5. Adjust the sizes of each axis based on it's minimum reported size.
				// 6. Refit each axis
				// 7. Position each axis in the final location
				// 8. Tell the chart the final location of the chart area
				// 9. Tell any axes that overlay the chart area the positions of the chart area

				// Step 1
				var chartWidth = width - leftPadding - rightPadding;
				var chartHeight = height - topPadding - bottomPadding;
				var chartAreaWidth = chartWidth / 2; // min 50%
				var chartAreaHeight = chartHeight / 2; // min 50%

				// Step 2
				var verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length);

				// Step 3
				var horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length);

				// Step 4
				var maxChartAreaWidth = chartWidth;
				var maxChartAreaHeight = chartHeight;
				var minBoxSizes = [];

				function getMinimumBoxSize(box) {
					var minSize;
					var isHorizontal = box.isHorizontal();

					if (isHorizontal) {
						minSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);
						maxChartAreaHeight -= minSize.height;
					} else {
						minSize = box.update(verticalBoxWidth, chartAreaHeight);
						maxChartAreaWidth -= minSize.width;
					}

					minBoxSizes.push({
						horizontal: isHorizontal,
						minSize: minSize,
						box: box,
					});
				}

				helpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize);

				// If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)
				var maxHorizontalLeftPadding = 0;
				var maxHorizontalRightPadding = 0;
				var maxVerticalTopPadding = 0;
				var maxVerticalBottomPadding = 0;

				helpers.each(topBoxes.concat(bottomBoxes), function(horizontalBox) {
					if (horizontalBox.getPadding) {
						var boxPadding = horizontalBox.getPadding();
						maxHorizontalLeftPadding = Math.max(maxHorizontalLeftPadding, boxPadding.left);
						maxHorizontalRightPadding = Math.max(maxHorizontalRightPadding, boxPadding.right);
					}
				});

				helpers.each(leftBoxes.concat(rightBoxes), function(verticalBox) {
					if (verticalBox.getPadding) {
						var boxPadding = verticalBox.getPadding();
						maxVerticalTopPadding = Math.max(maxVerticalTopPadding, boxPadding.top);
						maxVerticalBottomPadding = Math.max(maxVerticalBottomPadding, boxPadding.bottom);
					}
				});

				// At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could
				// be if the axes are drawn at their minimum sizes.
				// Steps 5 & 6
				var totalLeftBoxesWidth = leftPadding;
				var totalRightBoxesWidth = rightPadding;
				var totalTopBoxesHeight = topPadding;
				var totalBottomBoxesHeight = bottomPadding;

				// Function to fit a box
				function fitBox(box) {
					var minBoxSize = helpers.findNextWhere(minBoxSizes, function(minBox) {
						return minBox.box === box;
					});

					if (minBoxSize) {
						if (box.isHorizontal()) {
							var scaleMargin = {
								left: Math.max(totalLeftBoxesWidth, maxHorizontalLeftPadding),
								right: Math.max(totalRightBoxesWidth, maxHorizontalRightPadding),
								top: 0,
								bottom: 0
							};

							// Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends
							// on the margin. Sometimes they need to increase in size slightly
							box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);
						} else {
							box.update(minBoxSize.minSize.width, maxChartAreaHeight);
						}
					}
				}

				// Update, and calculate the left and right margins for the horizontal boxes
				helpers.each(leftBoxes.concat(rightBoxes), fitBox);

				helpers.each(leftBoxes, function(box) {
					totalLeftBoxesWidth += box.width;
				});

				helpers.each(rightBoxes, function(box) {
					totalRightBoxesWidth += box.width;
				});

				// Set the Left and Right margins for the horizontal boxes
				helpers.each(topBoxes.concat(bottomBoxes), fitBox);

				// Figure out how much margin is on the top and bottom of the vertical boxes
				helpers.each(topBoxes, function(box) {
					totalTopBoxesHeight += box.height;
				});

				helpers.each(bottomBoxes, function(box) {
					totalBottomBoxesHeight += box.height;
				});

				function finalFitVerticalBox(box) {
					var minBoxSize = helpers.findNextWhere(minBoxSizes, function(minSize) {
						return minSize.box === box;
					});

					var scaleMargin = {
						left: 0,
						right: 0,
						top: totalTopBoxesHeight,
						bottom: totalBottomBoxesHeight
					};

					if (minBoxSize) {
						box.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);
					}
				}

				// Let the left layout know the final margin
				helpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox);

				// Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)
				totalLeftBoxesWidth = leftPadding;
				totalRightBoxesWidth = rightPadding;
				totalTopBoxesHeight = topPadding;
				totalBottomBoxesHeight = bottomPadding;

				helpers.each(leftBoxes, function(box) {
					totalLeftBoxesWidth += box.width;
				});

				helpers.each(rightBoxes, function(box) {
					totalRightBoxesWidth += box.width;
				});

				helpers.each(topBoxes, function(box) {
					totalTopBoxesHeight += box.height;
				});
				helpers.each(bottomBoxes, function(box) {
					totalBottomBoxesHeight += box.height;
				});

				// We may be adding some padding to account for rotated x axis labels
				var leftPaddingAddition = Math.max(maxHorizontalLeftPadding - totalLeftBoxesWidth, 0);
				totalLeftBoxesWidth += leftPaddingAddition;
				totalRightBoxesWidth += Math.max(maxHorizontalRightPadding - totalRightBoxesWidth, 0);

				var topPaddingAddition = Math.max(maxVerticalTopPadding - totalTopBoxesHeight, 0);
				totalTopBoxesHeight += topPaddingAddition;
				totalBottomBoxesHeight += Math.max(maxVerticalBottomPadding - totalBottomBoxesHeight, 0);

				// Figure out if our chart area changed. This would occur if the dataset layout label rotation
				// changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do
				// without calling `fit` again
				var newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;
				var newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;

				if (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {
					helpers.each(leftBoxes, function(box) {
						box.height = newMaxChartAreaHeight;
					});

					helpers.each(rightBoxes, function(box) {
						box.height = newMaxChartAreaHeight;
					});

					helpers.each(topBoxes, function(box) {
						if (!box.fullWidth) {
							box.width = newMaxChartAreaWidth;
						}
					});

					helpers.each(bottomBoxes, function(box) {
						if (!box.fullWidth) {
							box.width = newMaxChartAreaWidth;
						}
					});

					maxChartAreaHeight = newMaxChartAreaHeight;
					maxChartAreaWidth = newMaxChartAreaWidth;
				}

				// Step 7 - Position the boxes
				var left = leftPadding + leftPaddingAddition;
				var top = topPadding + topPaddingAddition;

				function placeBox(box) {
					if (box.isHorizontal()) {
						box.left = box.fullWidth ? leftPadding : totalLeftBoxesWidth;
						box.right = box.fullWidth ? width - rightPadding : totalLeftBoxesWidth + maxChartAreaWidth;
						box.top = top;
						box.bottom = top + box.height;

						// Move to next point
						top = box.bottom;

					} else {

						box.left = left;
						box.right = left + box.width;
						box.top = totalTopBoxesHeight;
						box.bottom = totalTopBoxesHeight + maxChartAreaHeight;

						// Move to next point
						left = box.right;
					}
				}

				helpers.each(leftBoxes.concat(topBoxes), placeBox);

				// Account for chart width and height
				left += maxChartAreaWidth;
				top += maxChartAreaHeight;

				helpers.each(rightBoxes, placeBox);
				helpers.each(bottomBoxes, placeBox);

				// Step 8
				chart.chartArea = {
					left: totalLeftBoxesWidth,
					top: totalTopBoxesHeight,
					right: totalLeftBoxesWidth + maxChartAreaWidth,
					bottom: totalTopBoxesHeight + maxChartAreaHeight
				};

				// Step 9
				helpers.each(chartAreaBoxes, function(box) {
					box.left = chart.chartArea.left;
					box.top = chart.chartArea.top;
					box.right = chart.chartArea.right;
					box.bottom = chart.chartArea.bottom;

					box.update(maxChartAreaWidth, maxChartAreaHeight);
				});
			}
		};
	};


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var defaults = __webpack_require__(40);
	var helpers = __webpack_require__(41);

	module.exports = function(Chart) {

		Chart.scaleService = {
			// Scale registration object. Extensions can register new scale types (such as log or DB scales) and then
			// use the new chart options to grab the correct scale
			constructors: {},
			// Use a registration function so that we can move to an ES6 map when we no longer need to support
			// old browsers

			// Scale config defaults
			defaults: {},
			registerScaleType: function(type, scaleConstructor, scaleDefaults) {
				this.constructors[type] = scaleConstructor;
				this.defaults[type] = helpers.clone(scaleDefaults);
			},
			getScaleConstructor: function(type) {
				return this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;
			},
			getScaleDefaults: function(type) {
				// Return the scale defaults merged with the global settings so that we always use the latest ones
				return this.defaults.hasOwnProperty(type) ? helpers.merge({}, [defaults.scale, this.defaults[type]]) : {};
			},
			updateScaleDefaults: function(type, additions) {
				var me = this;
				if (me.defaults.hasOwnProperty(type)) {
					me.defaults[type] = helpers.extend(me.defaults[type], additions);
				}
			},
			addScalesToLayout: function(chart) {
				// Adds each scale to the chart.boxes array to be sized accordingly
				helpers.each(chart.scales, function(scale) {
					// Set ILayoutItem parameters for backwards compatibility
					scale.fullWidth = scale.options.fullWidth;
					scale.position = scale.options.position;
					scale.weight = scale.options.weight;
					Chart.layoutService.addBox(chart, scale);
				});
			}
		};
	};


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var defaults = __webpack_require__(40);
	var Element = __webpack_require__(52);
	var helpers = __webpack_require__(41);
	var Ticks = __webpack_require__(69);

	defaults._set('scale', {
		display: true,
		position: 'left',
		offset: false,

		// grid line settings
		gridLines: {
			display: true,
			color: 'rgba(0, 0, 0, 0.1)',
			lineWidth: 1,
			drawBorder: true,
			drawOnChartArea: true,
			drawTicks: true,
			tickMarkLength: 10,
			zeroLineWidth: 1,
			zeroLineColor: 'rgba(0,0,0,0.25)',
			zeroLineBorderDash: [],
			zeroLineBorderDashOffset: 0.0,
			offsetGridLines: false,
			borderDash: [],
			borderDashOffset: 0.0
		},

		// scale label
		scaleLabel: {
			// display property
			display: false,

			// actual label
			labelString: '',

			// line height
			lineHeight: 1.2,

			// top/bottom padding
			padding: {
				top: 4,
				bottom: 4
			}
		},

		// label settings
		ticks: {
			beginAtZero: false,
			minRotation: 0,
			maxRotation: 50,
			mirror: false,
			padding: 0,
			reverse: false,
			display: true,
			autoSkip: true,
			autoSkipPadding: 0,
			labelOffset: 0,
			// We pass through arrays to be rendered as multiline labels, we convert Others to strings here.
			callback: Ticks.formatters.values,
			minor: {},
			major: {}
		}
	});

	function labelsFromTicks(ticks) {
		var labels = [];
		var i, ilen;

		for (i = 0, ilen = ticks.length; i < ilen; ++i) {
			labels.push(ticks[i].label);
		}

		return labels;
	}

	function getLineValue(scale, index, offsetGridLines) {
		var lineValue = scale.getPixelForTick(index);

		if (offsetGridLines) {
			if (index === 0) {
				lineValue -= (scale.getPixelForTick(1) - lineValue) / 2;
			} else {
				lineValue -= (lineValue - scale.getPixelForTick(index - 1)) / 2;
			}
		}
		return lineValue;
	}

	module.exports = function(Chart) {

		function computeTextSize(context, tick, font) {
			return helpers.isArray(tick) ?
				helpers.longestText(context, font, tick) :
				context.measureText(tick).width;
		}

		function parseFontOptions(options) {
			var valueOrDefault = helpers.valueOrDefault;
			var globalDefaults = defaults.global;
			var size = valueOrDefault(options.fontSize, globalDefaults.defaultFontSize);
			var style = valueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle);
			var family = valueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily);

			return {
				size: size,
				style: style,
				family: family,
				font: helpers.fontString(size, style, family)
			};
		}

		function parseLineHeight(options) {
			return helpers.options.toLineHeight(
				helpers.valueOrDefault(options.lineHeight, 1.2),
				helpers.valueOrDefault(options.fontSize, defaults.global.defaultFontSize));
		}

		Chart.Scale = Element.extend({
			/**
			 * Get the padding needed for the scale
			 * @method getPadding
			 * @private
			 * @returns {Padding} the necessary padding
			 */
			getPadding: function() {
				var me = this;
				return {
					left: me.paddingLeft || 0,
					top: me.paddingTop || 0,
					right: me.paddingRight || 0,
					bottom: me.paddingBottom || 0
				};
			},

			/**
			 * Returns the scale tick objects ({label, major})
			 * @since 2.7
			 */
			getTicks: function() {
				return this._ticks;
			},

			// These methods are ordered by lifecyle. Utilities then follow.
			// Any function defined here is inherited by all scale types.
			// Any function can be extended by the scale type

			mergeTicksOptions: function() {
				var ticks = this.options.ticks;
				if (ticks.minor === false) {
					ticks.minor = {
						display: false
					};
				}
				if (ticks.major === false) {
					ticks.major = {
						display: false
					};
				}
				for (var key in ticks) {
					if (key !== 'major' && key !== 'minor') {
						if (typeof ticks.minor[key] === 'undefined') {
							ticks.minor[key] = ticks[key];
						}
						if (typeof ticks.major[key] === 'undefined') {
							ticks.major[key] = ticks[key];
						}
					}
				}
			},
			beforeUpdate: function() {
				helpers.callback(this.options.beforeUpdate, [this]);
			},
			update: function(maxWidth, maxHeight, margins) {
				var me = this;
				var i, ilen, labels, label, ticks, tick;

				// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
				me.beforeUpdate();

				// Absorb the master measurements
				me.maxWidth = maxWidth;
				me.maxHeight = maxHeight;
				me.margins = helpers.extend({
					left: 0,
					right: 0,
					top: 0,
					bottom: 0
				}, margins);
				me.longestTextCache = me.longestTextCache || {};

				// Dimensions
				me.beforeSetDimensions();
				me.setDimensions();
				me.afterSetDimensions();

				// Data min/max
				me.beforeDataLimits();
				me.determineDataLimits();
				me.afterDataLimits();

				// Ticks - `this.ticks` is now DEPRECATED!
				// Internal ticks are now stored as objects in the PRIVATE `this._ticks` member
				// and must not be accessed directly from outside this class. `this.ticks` being
				// around for long time and not marked as private, we can't change its structure
				// without unexpected breaking changes. If you need to access the scale ticks,
				// use scale.getTicks() instead.

				me.beforeBuildTicks();

				// New implementations should return an array of objects but for BACKWARD COMPAT,
				// we still support no return (`this.ticks` internally set by calling this method).
				ticks = me.buildTicks() || [];

				me.afterBuildTicks();

				me.beforeTickToLabelConversion();

				// New implementations should return the formatted tick labels but for BACKWARD
				// COMPAT, we still support no return (`this.ticks` internally changed by calling
				// this method and supposed to contain only string values).
				labels = me.convertTicksToLabels(ticks) || me.ticks;

				me.afterTickToLabelConversion();

				me.ticks = labels;   // BACKWARD COMPATIBILITY

				// IMPORTANT: from this point, we consider that `this.ticks` will NEVER change!

				// BACKWARD COMPAT: synchronize `_ticks` with labels (so potentially `this.ticks`)
				for (i = 0, ilen = labels.length; i < ilen; ++i) {
					label = labels[i];
					tick = ticks[i];
					if (!tick) {
						ticks.push(tick = {
							label: label,
							major: false
						});
					} else {
						tick.label = label;
					}
				}

				me._ticks = ticks;

				// Tick Rotation
				me.beforeCalculateTickRotation();
				me.calculateTickRotation();
				me.afterCalculateTickRotation();
				// Fit
				me.beforeFit();
				me.fit();
				me.afterFit();
				//
				me.afterUpdate();

				return me.minSize;

			},
			afterUpdate: function() {
				helpers.callback(this.options.afterUpdate, [this]);
			},

			//

			beforeSetDimensions: function() {
				helpers.callback(this.options.beforeSetDimensions, [this]);
			},
			setDimensions: function() {
				var me = this;
				// Set the unconstrained dimension before label rotation
				if (me.isHorizontal()) {
					// Reset position before calculating rotation
					me.width = me.maxWidth;
					me.left = 0;
					me.right = me.width;
				} else {
					me.height = me.maxHeight;

					// Reset position before calculating rotation
					me.top = 0;
					me.bottom = me.height;
				}

				// Reset padding
				me.paddingLeft = 0;
				me.paddingTop = 0;
				me.paddingRight = 0;
				me.paddingBottom = 0;
			},
			afterSetDimensions: function() {
				helpers.callback(this.options.afterSetDimensions, [this]);
			},

			// Data limits
			beforeDataLimits: function() {
				helpers.callback(this.options.beforeDataLimits, [this]);
			},
			determineDataLimits: helpers.noop,
			afterDataLimits: function() {
				helpers.callback(this.options.afterDataLimits, [this]);
			},

			//
			beforeBuildTicks: function() {
				helpers.callback(this.options.beforeBuildTicks, [this]);
			},
			buildTicks: helpers.noop,
			afterBuildTicks: function() {
				helpers.callback(this.options.afterBuildTicks, [this]);
			},

			beforeTickToLabelConversion: function() {
				helpers.callback(this.options.beforeTickToLabelConversion, [this]);
			},
			convertTicksToLabels: function() {
				var me = this;
				// Convert ticks to strings
				var tickOpts = me.options.ticks;
				me.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);
			},
			afterTickToLabelConversion: function() {
				helpers.callback(this.options.afterTickToLabelConversion, [this]);
			},

			//

			beforeCalculateTickRotation: function() {
				helpers.callback(this.options.beforeCalculateTickRotation, [this]);
			},
			calculateTickRotation: function() {
				var me = this;
				var context = me.ctx;
				var tickOpts = me.options.ticks;
				var labels = labelsFromTicks(me._ticks);

				// Get the width of each grid by calculating the difference
				// between x offsets between 0 and 1.
				var tickFont = parseFontOptions(tickOpts);
				context.font = tickFont.font;

				var labelRotation = tickOpts.minRotation || 0;

				if (labels.length && me.options.display && me.isHorizontal()) {
					var originalLabelWidth = helpers.longestText(context, tickFont.font, labels, me.longestTextCache);
					var labelWidth = originalLabelWidth;
					var cosRotation, sinRotation;

					// Allow 3 pixels x2 padding either side for label readability
					var tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6;

					// Max label rotation can be set or default to 90 - also act as a loop counter
					while (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {
						var angleRadians = helpers.toRadians(labelRotation);
						cosRotation = Math.cos(angleRadians);
						sinRotation = Math.sin(angleRadians);

						if (sinRotation * originalLabelWidth > me.maxHeight) {
							// go back one step
							labelRotation--;
							break;
						}

						labelRotation++;
						labelWidth = cosRotation * originalLabelWidth;
					}
				}

				me.labelRotation = labelRotation;
			},
			afterCalculateTickRotation: function() {
				helpers.callback(this.options.afterCalculateTickRotation, [this]);
			},

			//

			beforeFit: function() {
				helpers.callback(this.options.beforeFit, [this]);
			},
			fit: function() {
				var me = this;
				// Reset
				var minSize = me.minSize = {
					width: 0,
					height: 0
				};

				var labels = labelsFromTicks(me._ticks);

				var opts = me.options;
				var tickOpts = opts.ticks;
				var scaleLabelOpts = opts.scaleLabel;
				var gridLineOpts = opts.gridLines;
				var display = opts.display;
				var isHorizontal = me.isHorizontal();

				var tickFont = parseFontOptions(tickOpts);
				var tickMarkLength = opts.gridLines.tickMarkLength;

				// Width
				if (isHorizontal) {
					// subtract the margins to line up with the chartArea if we are a full width scale
					minSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;
				} else {
					minSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
				}

				// height
				if (isHorizontal) {
					minSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
				} else {
					minSize.height = me.maxHeight; // fill all the height
				}

				// Are we showing a title for the scale?
				if (scaleLabelOpts.display && display) {
					var scaleLabelLineHeight = parseLineHeight(scaleLabelOpts);
					var scaleLabelPadding = helpers.options.toPadding(scaleLabelOpts.padding);
					var deltaHeight = scaleLabelLineHeight + scaleLabelPadding.height;

					if (isHorizontal) {
						minSize.height += deltaHeight;
					} else {
						minSize.width += deltaHeight;
					}
				}

				// Don't bother fitting the ticks if we are not showing them
				if (tickOpts.display && display) {
					var largestTextWidth = helpers.longestText(me.ctx, tickFont.font, labels, me.longestTextCache);
					var tallestLabelHeightInLines = helpers.numberOfLabelLines(labels);
					var lineSpace = tickFont.size * 0.5;
					var tickPadding = me.options.ticks.padding;

					if (isHorizontal) {
						// A horizontal axis is more constrained by the height.
						me.longestLabelWidth = largestTextWidth;

						var angleRadians = helpers.toRadians(me.labelRotation);
						var cosRotation = Math.cos(angleRadians);
						var sinRotation = Math.sin(angleRadians);

						// TODO - improve this calculation
						var labelHeight = (sinRotation * largestTextWidth)
							+ (tickFont.size * tallestLabelHeightInLines)
							+ (lineSpace * (tallestLabelHeightInLines - 1))
							+ lineSpace; // padding

						minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);

						me.ctx.font = tickFont.font;
						var firstLabelWidth = computeTextSize(me.ctx, labels[0], tickFont.font);
						var lastLabelWidth = computeTextSize(me.ctx, labels[labels.length - 1], tickFont.font);

						// Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned
						// which means that the right padding is dominated by the font height
						if (me.labelRotation !== 0) {
							me.paddingLeft = opts.position === 'bottom' ? (cosRotation * firstLabelWidth) + 3 : (cosRotation * lineSpace) + 3; // add 3 px to move away from canvas edges
							me.paddingRight = opts.position === 'bottom' ? (cosRotation * lineSpace) + 3 : (cosRotation * lastLabelWidth) + 3;
						} else {
							me.paddingLeft = firstLabelWidth / 2 + 3; // add 3 px to move away from canvas edges
							me.paddingRight = lastLabelWidth / 2 + 3;
						}
					} else {
						// A vertical axis is more constrained by the width. Labels are the
						// dominant factor here, so get that length first and account for padding
						if (tickOpts.mirror) {
							largestTextWidth = 0;
						} else {
							// use lineSpace for consistency with horizontal axis
							// tickPadding is not implemented for horizontal
							largestTextWidth += tickPadding + lineSpace;
						}

						minSize.width = Math.min(me.maxWidth, minSize.width + largestTextWidth);

						me.paddingTop = tickFont.size / 2;
						me.paddingBottom = tickFont.size / 2;
					}
				}

				me.handleMargins();

				me.width = minSize.width;
				me.height = minSize.height;
			},

			/**
			 * Handle margins and padding interactions
			 * @private
			 */
			handleMargins: function() {
				var me = this;
				if (me.margins) {
					me.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);
					me.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);
					me.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);
					me.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);
				}
			},

			afterFit: function() {
				helpers.callback(this.options.afterFit, [this]);
			},

			// Shared Methods
			isHorizontal: function() {
				return this.options.position === 'top' || this.options.position === 'bottom';
			},
			isFullWidth: function() {
				return (this.options.fullWidth);
			},

			// Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not
			getRightValue: function(rawValue) {
				// Null and undefined values first
				if (helpers.isNullOrUndef(rawValue)) {
					return NaN;
				}
				// isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values
				if (typeof rawValue === 'number' && !isFinite(rawValue)) {
					return NaN;
				}
				// If it is in fact an object, dive in one more level
				if (rawValue) {
					if (this.isHorizontal()) {
						if (rawValue.x !== undefined) {
							return this.getRightValue(rawValue.x);
						}
					} else if (rawValue.y !== undefined) {
						return this.getRightValue(rawValue.y);
					}
				}

				// Value is good, return it
				return rawValue;
			},

			/**
			 * Used to get the value to display in the tooltip for the data at the given index
			 * @param index
			 * @param datasetIndex
			 */
			getLabelForIndex: helpers.noop,

			/**
			 * Returns the location of the given data point. Value can either be an index or a numerical value
			 * The coordinate (0, 0) is at the upper-left corner of the canvas
			 * @param value
			 * @param index
			 * @param datasetIndex
			 */
			getPixelForValue: helpers.noop,

			/**
			 * Used to get the data value from a given pixel. This is the inverse of getPixelForValue
			 * The coordinate (0, 0) is at the upper-left corner of the canvas
			 * @param pixel
			 */
			getValueForPixel: helpers.noop,

			/**
			 * Returns the location of the tick at the given index
			 * The coordinate (0, 0) is at the upper-left corner of the canvas
			 */
			getPixelForTick: function(index) {
				var me = this;
				var offset = me.options.offset;
				if (me.isHorizontal()) {
					var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
					var tickWidth = innerWidth / Math.max((me._ticks.length - (offset ? 0 : 1)), 1);
					var pixel = (tickWidth * index) + me.paddingLeft;

					if (offset) {
						pixel += tickWidth / 2;
					}

					var finalVal = me.left + Math.round(pixel);
					finalVal += me.isFullWidth() ? me.margins.left : 0;
					return finalVal;
				}
				var innerHeight = me.height - (me.paddingTop + me.paddingBottom);
				return me.top + (index * (innerHeight / (me._ticks.length - 1)));
			},

			/**
			 * Utility for getting the pixel location of a percentage of scale
			 * The coordinate (0, 0) is at the upper-left corner of the canvas
			 */
			getPixelForDecimal: function(decimal) {
				var me = this;
				if (me.isHorizontal()) {
					var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
					var valueOffset = (innerWidth * decimal) + me.paddingLeft;

					var finalVal = me.left + Math.round(valueOffset);
					finalVal += me.isFullWidth() ? me.margins.left : 0;
					return finalVal;
				}
				return me.top + (decimal * me.height);
			},

			/**
			 * Returns the pixel for the minimum chart value
			 * The coordinate (0, 0) is at the upper-left corner of the canvas
			 */
			getBasePixel: function() {
				return this.getPixelForValue(this.getBaseValue());
			},

			getBaseValue: function() {
				var me = this;
				var min = me.min;
				var max = me.max;

				return me.beginAtZero ? 0 :
					min < 0 && max < 0 ? max :
					min > 0 && max > 0 ? min :
					0;
			},

			/**
			 * Returns a subset of ticks to be plotted to avoid overlapping labels.
			 * @private
			 */
			_autoSkip: function(ticks) {
				var skipRatio;
				var me = this;
				var isHorizontal = me.isHorizontal();
				var optionTicks = me.options.ticks.minor;
				var tickCount = ticks.length;
				var labelRotationRadians = helpers.toRadians(me.labelRotation);
				var cosRotation = Math.cos(labelRotationRadians);
				var longestRotatedLabel = me.longestLabelWidth * cosRotation;
				var result = [];
				var i, tick, shouldSkip;

				// figure out the maximum number of gridlines to show
				var maxTicks;
				if (optionTicks.maxTicksLimit) {
					maxTicks = optionTicks.maxTicksLimit;
				}

				if (isHorizontal) {
					skipRatio = false;

					if ((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount > (me.width - (me.paddingLeft + me.paddingRight))) {
						skipRatio = 1 + Math.floor(((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount) / (me.width - (me.paddingLeft + me.paddingRight)));
					}

					// if they defined a max number of optionTicks,
					// increase skipRatio until that number is met
					if (maxTicks && tickCount > maxTicks) {
						skipRatio = Math.max(skipRatio, Math.floor(tickCount / maxTicks));
					}
				}

				for (i = 0; i < tickCount; i++) {
					tick = ticks[i];

					// Since we always show the last tick,we need may need to hide the last shown one before
					shouldSkip = (skipRatio > 1 && i % skipRatio > 0) || (i % skipRatio === 0 && i + skipRatio >= tickCount);
					if (shouldSkip && i !== tickCount - 1) {
						// leave tick in place but make sure it's not displayed (#4635)
						delete tick.label;
					}
					result.push(tick);
				}
				return result;
			},

			// Actually draw the scale on the canvas
			// @param {rectangle} chartArea : the area of the chart to draw full grid lines on
			draw: function(chartArea) {
				var me = this;
				var options = me.options;
				if (!options.display) {
					return;
				}

				var context = me.ctx;
				var globalDefaults = defaults.global;
				var optionTicks = options.ticks.minor;
				var optionMajorTicks = options.ticks.major || optionTicks;
				var gridLines = options.gridLines;
				var scaleLabel = options.scaleLabel;

				var isRotated = me.labelRotation !== 0;
				var isHorizontal = me.isHorizontal();

				var ticks = optionTicks.autoSkip ? me._autoSkip(me.getTicks()) : me.getTicks();
				var tickFontColor = helpers.valueOrDefault(optionTicks.fontColor, globalDefaults.defaultFontColor);
				var tickFont = parseFontOptions(optionTicks);
				var majorTickFontColor = helpers.valueOrDefault(optionMajorTicks.fontColor, globalDefaults.defaultFontColor);
				var majorTickFont = parseFontOptions(optionMajorTicks);

				var tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;

				var scaleLabelFontColor = helpers.valueOrDefault(scaleLabel.fontColor, globalDefaults.defaultFontColor);
				var scaleLabelFont = parseFontOptions(scaleLabel);
				var scaleLabelPadding = helpers.options.toPadding(scaleLabel.padding);
				var labelRotationRadians = helpers.toRadians(me.labelRotation);

				var itemsToDraw = [];

				var xTickStart = options.position === 'right' ? me.left : me.right - tl;
				var xTickEnd = options.position === 'right' ? me.left + tl : me.right;
				var yTickStart = options.position === 'bottom' ? me.top : me.bottom - tl;
				var yTickEnd = options.position === 'bottom' ? me.top + tl : me.bottom;

				helpers.each(ticks, function(tick, index) {
					// autoskipper skipped this tick (#4635)
					if (helpers.isNullOrUndef(tick.label)) {
						return;
					}

					var label = tick.label;
					var lineWidth, lineColor, borderDash, borderDashOffset;
					if (index === me.zeroLineIndex && options.offset === gridLines.offsetGridLines) {
						// Draw the first index specially
						lineWidth = gridLines.zeroLineWidth;
						lineColor = gridLines.zeroLineColor;
						borderDash = gridLines.zeroLineBorderDash;
						borderDashOffset = gridLines.zeroLineBorderDashOffset;
					} else {
						lineWidth = helpers.valueAtIndexOrDefault(gridLines.lineWidth, index);
						lineColor = helpers.valueAtIndexOrDefault(gridLines.color, index);
						borderDash = helpers.valueOrDefault(gridLines.borderDash, globalDefaults.borderDash);
						borderDashOffset = helpers.valueOrDefault(gridLines.borderDashOffset, globalDefaults.borderDashOffset);
					}

					// Common properties
					var tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY;
					var textAlign = 'middle';
					var textBaseline = 'middle';
					var tickPadding = optionTicks.padding;

					if (isHorizontal) {
						var labelYOffset = tl + tickPadding;

						if (options.position === 'bottom') {
							// bottom
							textBaseline = !isRotated ? 'top' : 'middle';
							textAlign = !isRotated ? 'center' : 'right';
							labelY = me.top + labelYOffset;
						} else {
							// top
							textBaseline = !isRotated ? 'bottom' : 'middle';
							textAlign = !isRotated ? 'center' : 'left';
							labelY = me.bottom - labelYOffset;
						}

						var xLineValue = getLineValue(me, index, gridLines.offsetGridLines && ticks.length > 1);
						if (xLineValue < me.left) {
							lineColor = 'rgba(0,0,0,0)';
						}
						xLineValue += helpers.aliasPixel(lineWidth);

						labelX = me.getPixelForTick(index) + optionTicks.labelOffset; // x values for optionTicks (need to consider offsetLabel option)

						tx1 = tx2 = x1 = x2 = xLineValue;
						ty1 = yTickStart;
						ty2 = yTickEnd;
						y1 = chartArea.top;
						y2 = chartArea.bottom;
					} else {
						var isLeft = options.position === 'left';
						var labelXOffset;

						if (optionTicks.mirror) {
							textAlign = isLeft ? 'left' : 'right';
							labelXOffset = tickPadding;
						} else {
							textAlign = isLeft ? 'right' : 'left';
							labelXOffset = tl + tickPadding;
						}

						labelX = isLeft ? me.right - labelXOffset : me.left + labelXOffset;

						var yLineValue = getLineValue(me, index, gridLines.offsetGridLines && ticks.length > 1);
						if (yLineValue < me.top) {
							lineColor = 'rgba(0,0,0,0)';
						}
						yLineValue += helpers.aliasPixel(lineWidth);

						labelY = me.getPixelForTick(index) + optionTicks.labelOffset;

						tx1 = xTickStart;
						tx2 = xTickEnd;
						x1 = chartArea.left;
						x2 = chartArea.right;
						ty1 = ty2 = y1 = y2 = yLineValue;
					}

					itemsToDraw.push({
						tx1: tx1,
						ty1: ty1,
						tx2: tx2,
						ty2: ty2,
						x1: x1,
						y1: y1,
						x2: x2,
						y2: y2,
						labelX: labelX,
						labelY: labelY,
						glWidth: lineWidth,
						glColor: lineColor,
						glBorderDash: borderDash,
						glBorderDashOffset: borderDashOffset,
						rotation: -1 * labelRotationRadians,
						label: label,
						major: tick.major,
						textBaseline: textBaseline,
						textAlign: textAlign
					});
				});

				// Draw all of the tick labels, tick marks, and grid lines at the correct places
				helpers.each(itemsToDraw, function(itemToDraw) {
					if (gridLines.display) {
						context.save();
						context.lineWidth = itemToDraw.glWidth;
						context.strokeStyle = itemToDraw.glColor;
						if (context.setLineDash) {
							context.setLineDash(itemToDraw.glBorderDash);
							context.lineDashOffset = itemToDraw.glBorderDashOffset;
						}

						context.beginPath();

						if (gridLines.drawTicks) {
							context.moveTo(itemToDraw.tx1, itemToDraw.ty1);
							context.lineTo(itemToDraw.tx2, itemToDraw.ty2);
						}

						if (gridLines.drawOnChartArea) {
							context.moveTo(itemToDraw.x1, itemToDraw.y1);
							context.lineTo(itemToDraw.x2, itemToDraw.y2);
						}

						context.stroke();
						context.restore();
					}

					if (optionTicks.display) {
						// Make sure we draw text in the correct color and font
						context.save();
						context.translate(itemToDraw.labelX, itemToDraw.labelY);
						context.rotate(itemToDraw.rotation);
						context.font = itemToDraw.major ? majorTickFont.font : tickFont.font;
						context.fillStyle = itemToDraw.major ? majorTickFontColor : tickFontColor;
						context.textBaseline = itemToDraw.textBaseline;
						context.textAlign = itemToDraw.textAlign;

						var label = itemToDraw.label;
						if (helpers.isArray(label)) {
							for (var i = 0, y = 0; i < label.length; ++i) {
								// We just make sure the multiline element is a string here..
								context.fillText('' + label[i], 0, y);
								// apply same lineSpacing as calculated @ L#320
								y += (tickFont.size * 1.5);
							}
						} else {
							context.fillText(label, 0, 0);
						}
						context.restore();
					}
				});

				if (scaleLabel.display) {
					// Draw the scale label
					var scaleLabelX;
					var scaleLabelY;
					var rotation = 0;
					var halfLineHeight = parseLineHeight(scaleLabel) / 2;

					if (isHorizontal) {
						scaleLabelX = me.left + ((me.right - me.left) / 2); // midpoint of the width
						scaleLabelY = options.position === 'bottom'
							? me.bottom - halfLineHeight - scaleLabelPadding.bottom
							: me.top + halfLineHeight + scaleLabelPadding.top;
					} else {
						var isLeft = options.position === 'left';
						scaleLabelX = isLeft
							? me.left + halfLineHeight + scaleLabelPadding.top
							: me.right - halfLineHeight - scaleLabelPadding.top;
						scaleLabelY = me.top + ((me.bottom - me.top) / 2);
						rotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;
					}

					context.save();
					context.translate(scaleLabelX, scaleLabelY);
					context.rotate(rotation);
					context.textAlign = 'center';
					context.textBaseline = 'middle';
					context.fillStyle = scaleLabelFontColor; // render in correct colour
					context.font = scaleLabelFont.font;
					context.fillText(scaleLabel.labelString, 0, 0);
					context.restore();
				}

				if (gridLines.drawBorder) {
					// Draw the line at the edge of the axis
					context.lineWidth = helpers.valueAtIndexOrDefault(gridLines.lineWidth, 0);
					context.strokeStyle = helpers.valueAtIndexOrDefault(gridLines.color, 0);
					var x1 = me.left;
					var x2 = me.right;
					var y1 = me.top;
					var y2 = me.bottom;

					var aliasPixel = helpers.aliasPixel(context.lineWidth);
					if (isHorizontal) {
						y1 = y2 = options.position === 'top' ? me.bottom : me.top;
						y1 += aliasPixel;
						y2 += aliasPixel;
					} else {
						x1 = x2 = options.position === 'left' ? me.right : me.left;
						x1 += aliasPixel;
						x2 += aliasPixel;
					}

					context.beginPath();
					context.moveTo(x1, y1);
					context.lineTo(x2, y2);
					context.stroke();
				}
			}
		});
	};


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var helpers = __webpack_require__(41);

	/**
	 * Namespace to hold static tick generation functions
	 * @namespace Chart.Ticks
	 */
	module.exports = {
		/**
		 * Namespace to hold generators for different types of ticks
		 * @namespace Chart.Ticks.generators
		 */
		generators: {
			/**
			 * Interface for the options provided to the numeric tick generator
			 * @interface INumericTickGenerationOptions
			 */
			/**
			 * The maximum number of ticks to display
			 * @name INumericTickGenerationOptions#maxTicks
			 * @type Number
			 */
			/**
			 * The distance between each tick.
			 * @name INumericTickGenerationOptions#stepSize
			 * @type Number
			 * @optional
			 */
			/**
			 * Forced minimum for the ticks. If not specified, the minimum of the data range is used to calculate the tick minimum
			 * @name INumericTickGenerationOptions#min
			 * @type Number
			 * @optional
			 */
			/**
			 * The maximum value of the ticks. If not specified, the maximum of the data range is used to calculate the tick maximum
			 * @name INumericTickGenerationOptions#max
			 * @type Number
			 * @optional
			 */

			/**
			 * Generate a set of linear ticks
			 * @method Chart.Ticks.generators.linear
			 * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks
			 * @param dataRange {IRange} the range of the data
			 * @returns {Array<Number>} array of tick values
			 */
			linear: function(generationOptions, dataRange) {
				var ticks = [];
				// To get a "nice" value for the tick spacing, we will use the appropriately named
				// "nice number" algorithm. See http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks
				// for details.

				var spacing;
				if (generationOptions.stepSize && generationOptions.stepSize > 0) {
					spacing = generationOptions.stepSize;
				} else {
					var niceRange = helpers.niceNum(dataRange.max - dataRange.min, false);
					spacing = helpers.niceNum(niceRange / (generationOptions.maxTicks - 1), true);
				}
				var niceMin = Math.floor(dataRange.min / spacing) * spacing;
				var niceMax = Math.ceil(dataRange.max / spacing) * spacing;

				// If min, max and stepSize is set and they make an evenly spaced scale use it.
				if (generationOptions.min && generationOptions.max && generationOptions.stepSize) {
					// If very close to our whole number, use it.
					if (helpers.almostWhole((generationOptions.max - generationOptions.min) / generationOptions.stepSize, spacing / 1000)) {
						niceMin = generationOptions.min;
						niceMax = generationOptions.max;
					}
				}

				var numSpaces = (niceMax - niceMin) / spacing;
				// If very close to our rounded value, use it.
				if (helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {
					numSpaces = Math.round(numSpaces);
				} else {
					numSpaces = Math.ceil(numSpaces);
				}

				// Put the values into the ticks array
				ticks.push(generationOptions.min !== undefined ? generationOptions.min : niceMin);
				for (var j = 1; j < numSpaces; ++j) {
					ticks.push(niceMin + (j * spacing));
				}
				ticks.push(generationOptions.max !== undefined ? generationOptions.max : niceMax);

				return ticks;
			},

			/**
			 * Generate a set of logarithmic ticks
			 * @method Chart.Ticks.generators.logarithmic
			 * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks
			 * @param dataRange {IRange} the range of the data
			 * @returns {Array<Number>} array of tick values
			 */
			logarithmic: function(generationOptions, dataRange) {
				var ticks = [];
				var valueOrDefault = helpers.valueOrDefault;

				// Figure out what the max number of ticks we can support it is based on the size of
				// the axis area. For now, we say that the minimum tick spacing in pixels must be 50
				// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
				// the graph
				var tickVal = valueOrDefault(generationOptions.min, Math.pow(10, Math.floor(helpers.log10(dataRange.min))));

				var endExp = Math.floor(helpers.log10(dataRange.max));
				var endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
				var exp, significand;

				if (tickVal === 0) {
					exp = Math.floor(helpers.log10(dataRange.minNotZero));
					significand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));

					ticks.push(tickVal);
					tickVal = significand * Math.pow(10, exp);
				} else {
					exp = Math.floor(helpers.log10(tickVal));
					significand = Math.floor(tickVal / Math.pow(10, exp));
				}

				do {
					ticks.push(tickVal);

					++significand;
					if (significand === 10) {
						significand = 1;
						++exp;
					}

					tickVal = significand * Math.pow(10, exp);
				} while (exp < endExp || (exp === endExp && significand < endSignificand));

				var lastTick = valueOrDefault(generationOptions.max, tickVal);
				ticks.push(lastTick);

				return ticks;
			}
		},

		/**
		 * Namespace to hold formatters for different types of ticks
		 * @namespace Chart.Ticks.formatters
		 */
		formatters: {
			/**
			 * Formatter for value labels
			 * @method Chart.Ticks.formatters.values
			 * @param value the value to display
			 * @return {String|Array} the label to display
			 */
			values: function(value) {
				return helpers.isArray(value) ? value : '' + value;
			},

			/**
			 * Formatter for linear numeric ticks
			 * @method Chart.Ticks.formatters.linear
			 * @param tickValue {Number} the value to be formatted
			 * @param index {Number} the position of the tickValue parameter in the ticks array
			 * @param ticks {Array<Number>} the list of ticks being converted
			 * @return {String} string representation of the tickValue parameter
			 */
			linear: function(tickValue, index, ticks) {
				// If we have lots of ticks, don't use the ones
				var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];

				// If we have a number like 2.5 as the delta, figure out how many decimal places we need
				if (Math.abs(delta) > 1) {
					if (tickValue !== Math.floor(tickValue)) {
						// not an integer
						delta = tickValue - Math.floor(tickValue);
					}
				}

				var logDelta = helpers.log10(Math.abs(delta));
				var tickString = '';

				if (tickValue !== 0) {
					var numDecimal = -1 * Math.floor(logDelta);
					numDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places
					tickString = tickValue.toFixed(numDecimal);
				} else {
					tickString = '0'; // never show decimal places for 0
				}

				return tickString;
			},

			logarithmic: function(tickValue, index, ticks) {
				var remain = tickValue / (Math.pow(10, Math.floor(helpers.log10(tickValue))));

				if (tickValue === 0) {
					return '0';
				} else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {
					return tickValue.toExponential();
				}
				return '';
			}
		}
	};


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var defaults = __webpack_require__(40);
	var Element = __webpack_require__(52);
	var helpers = __webpack_require__(41);

	defaults._set('global', {
		tooltips: {
			enabled: true,
			custom: null,
			mode: 'nearest',
			position: 'average',
			intersect: true,
			backgroundColor: 'rgba(0,0,0,0.8)',
			titleFontStyle: 'bold',
			titleSpacing: 2,
			titleMarginBottom: 6,
			titleFontColor: '#fff',
			titleAlign: 'left',
			bodySpacing: 2,
			bodyFontColor: '#fff',
			bodyAlign: 'left',
			footerFontStyle: 'bold',
			footerSpacing: 2,
			footerMarginTop: 6,
			footerFontColor: '#fff',
			footerAlign: 'left',
			yPadding: 6,
			xPadding: 6,
			caretPadding: 2,
			caretSize: 5,
			cornerRadius: 6,
			multiKeyBackground: '#fff',
			displayColors: true,
			borderColor: 'rgba(0,0,0,0)',
			borderWidth: 0,
			callbacks: {
				// Args are: (tooltipItems, data)
				beforeTitle: helpers.noop,
				title: function(tooltipItems, data) {
					// Pick first xLabel for now
					var title = '';
					var labels = data.labels;
					var labelCount = labels ? labels.length : 0;

					if (tooltipItems.length > 0) {
						var item = tooltipItems[0];

						if (item.xLabel) {
							title = item.xLabel;
						} else if (labelCount > 0 && item.index < labelCount) {
							title = labels[item.index];
						}
					}

					return title;
				},
				afterTitle: helpers.noop,

				// Args are: (tooltipItems, data)
				beforeBody: helpers.noop,

				// Args are: (tooltipItem, data)
				beforeLabel: helpers.noop,
				label: function(tooltipItem, data) {
					var label = data.datasets[tooltipItem.datasetIndex].label || '';

					if (label) {
						label += ': ';
					}
					label += tooltipItem.yLabel;
					return label;
				},
				labelColor: function(tooltipItem, chart) {
					var meta = chart.getDatasetMeta(tooltipItem.datasetIndex);
					var activeElement = meta.data[tooltipItem.index];
					var view = activeElement._view;
					return {
						borderColor: view.borderColor,
						backgroundColor: view.backgroundColor
					};
				},
				labelTextColor: function() {
					return this._options.bodyFontColor;
				},
				afterLabel: helpers.noop,

				// Args are: (tooltipItems, data)
				afterBody: helpers.noop,

				// Args are: (tooltipItems, data)
				beforeFooter: helpers.noop,
				footer: helpers.noop,
				afterFooter: helpers.noop
			}
		}
	});

	module.exports = function(Chart) {

		/**
	 	 * Helper method to merge the opacity into a color
	 	 */
		function mergeOpacity(colorString, opacity) {
			var color = helpers.color(colorString);
			return color.alpha(opacity * color.alpha()).rgbaString();
		}

		// Helper to push or concat based on if the 2nd parameter is an array or not
		function pushOrConcat(base, toPush) {
			if (toPush) {
				if (helpers.isArray(toPush)) {
					// base = base.concat(toPush);
					Array.prototype.push.apply(base, toPush);
				} else {
					base.push(toPush);
				}
			}

			return base;
		}

		// Private helper to create a tooltip item model
		// @param element : the chart element (point, arc, bar) to create the tooltip item for
		// @return : new tooltip item
		function createTooltipItem(element) {
			var xScale = element._xScale;
			var yScale = element._yScale || element._scale; // handle radar || polarArea charts
			var index = element._index;
			var datasetIndex = element._datasetIndex;

			return {
				xLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',
				yLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',
				index: index,
				datasetIndex: datasetIndex,
				x: element._model.x,
				y: element._model.y
			};
		}

		/**
		 * Helper to get the reset model for the tooltip
		 * @param tooltipOpts {Object} the tooltip options
		 */
		function getBaseModel(tooltipOpts) {
			var globalDefaults = defaults.global;
			var valueOrDefault = helpers.valueOrDefault;

			return {
				// Positioning
				xPadding: tooltipOpts.xPadding,
				yPadding: tooltipOpts.yPadding,
				xAlign: tooltipOpts.xAlign,
				yAlign: tooltipOpts.yAlign,

				// Body
				bodyFontColor: tooltipOpts.bodyFontColor,
				_bodyFontFamily: valueOrDefault(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),
				_bodyFontStyle: valueOrDefault(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),
				_bodyAlign: tooltipOpts.bodyAlign,
				bodyFontSize: valueOrDefault(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),
				bodySpacing: tooltipOpts.bodySpacing,

				// Title
				titleFontColor: tooltipOpts.titleFontColor,
				_titleFontFamily: valueOrDefault(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),
				_titleFontStyle: valueOrDefault(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),
				titleFontSize: valueOrDefault(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),
				_titleAlign: tooltipOpts.titleAlign,
				titleSpacing: tooltipOpts.titleSpacing,
				titleMarginBottom: tooltipOpts.titleMarginBottom,

				// Footer
				footerFontColor: tooltipOpts.footerFontColor,
				_footerFontFamily: valueOrDefault(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),
				_footerFontStyle: valueOrDefault(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),
				footerFontSize: valueOrDefault(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),
				_footerAlign: tooltipOpts.footerAlign,
				footerSpacing: tooltipOpts.footerSpacing,
				footerMarginTop: tooltipOpts.footerMarginTop,

				// Appearance
				caretSize: tooltipOpts.caretSize,
				cornerRadius: tooltipOpts.cornerRadius,
				backgroundColor: tooltipOpts.backgroundColor,
				opacity: 0,
				legendColorBackground: tooltipOpts.multiKeyBackground,
				displayColors: tooltipOpts.displayColors,
				borderColor: tooltipOpts.borderColor,
				borderWidth: tooltipOpts.borderWidth
			};
		}

		/**
		 * Get the size of the tooltip
		 */
		function getTooltipSize(tooltip, model) {
			var ctx = tooltip._chart.ctx;

			var height = model.yPadding * 2; // Tooltip Padding
			var width = 0;

			// Count of all lines in the body
			var body = model.body;
			var combinedBodyLength = body.reduce(function(count, bodyItem) {
				return count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;
			}, 0);
			combinedBodyLength += model.beforeBody.length + model.afterBody.length;

			var titleLineCount = model.title.length;
			var footerLineCount = model.footer.length;
			var titleFontSize = model.titleFontSize;
			var bodyFontSize = model.bodyFontSize;
			var footerFontSize = model.footerFontSize;

			height += titleLineCount * titleFontSize; // Title Lines
			height += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0; // Title Line Spacing
			height += titleLineCount ? model.titleMarginBottom : 0; // Title's bottom Margin
			height += combinedBodyLength * bodyFontSize; // Body Lines
			height += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0; // Body Line Spacing
			height += footerLineCount ? model.footerMarginTop : 0; // Footer Margin
			height += footerLineCount * (footerFontSize); // Footer Lines
			height += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0; // Footer Line Spacing

			// Title width
			var widthPadding = 0;
			var maxLineWidth = function(line) {
				width = Math.max(width, ctx.measureText(line).width + widthPadding);
			};

			ctx.font = helpers.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);
			helpers.each(model.title, maxLineWidth);

			// Body width
			ctx.font = helpers.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);
			helpers.each(model.beforeBody.concat(model.afterBody), maxLineWidth);

			// Body lines may include some extra width due to the color box
			widthPadding = model.displayColors ? (bodyFontSize + 2) : 0;
			helpers.each(body, function(bodyItem) {
				helpers.each(bodyItem.before, maxLineWidth);
				helpers.each(bodyItem.lines, maxLineWidth);
				helpers.each(bodyItem.after, maxLineWidth);
			});

			// Reset back to 0
			widthPadding = 0;

			// Footer width
			ctx.font = helpers.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);
			helpers.each(model.footer, maxLineWidth);

			// Add padding
			width += 2 * model.xPadding;

			return {
				width: width,
				height: height
			};
		}

		/**
		 * Helper to get the alignment of a tooltip given the size
		 */
		function determineAlignment(tooltip, size) {
			var model = tooltip._model;
			var chart = tooltip._chart;
			var chartArea = tooltip._chart.chartArea;
			var xAlign = 'center';
			var yAlign = 'center';

			if (model.y < size.height) {
				yAlign = 'top';
			} else if (model.y > (chart.height - size.height)) {
				yAlign = 'bottom';
			}

			var lf, rf; // functions to determine left, right alignment
			var olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart
			var yf; // function to get the y alignment if the tooltip goes outside of the left or right edges
			var midX = (chartArea.left + chartArea.right) / 2;
			var midY = (chartArea.top + chartArea.bottom) / 2;

			if (yAlign === 'center') {
				lf = function(x) {
					return x <= midX;
				};
				rf = function(x) {
					return x > midX;
				};
			} else {
				lf = function(x) {
					return x <= (size.width / 2);
				};
				rf = function(x) {
					return x >= (chart.width - (size.width / 2));
				};
			}

			olf = function(x) {
				return x + size.width > chart.width;
			};
			orf = function(x) {
				return x - size.width < 0;
			};
			yf = function(y) {
				return y <= midY ? 'top' : 'bottom';
			};

			if (lf(model.x)) {
				xAlign = 'left';

				// Is tooltip too wide and goes over the right side of the chart.?
				if (olf(model.x)) {
					xAlign = 'center';
					yAlign = yf(model.y);
				}
			} else if (rf(model.x)) {
				xAlign = 'right';

				// Is tooltip too wide and goes outside left edge of canvas?
				if (orf(model.x)) {
					xAlign = 'center';
					yAlign = yf(model.y);
				}
			}

			var opts = tooltip._options;
			return {
				xAlign: opts.xAlign ? opts.xAlign : xAlign,
				yAlign: opts.yAlign ? opts.yAlign : yAlign
			};
		}

		/**
		 * @Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment
		 */
		function getBackgroundPoint(vm, size, alignment) {
			// Background Position
			var x = vm.x;
			var y = vm.y;

			var caretSize = vm.caretSize;
			var caretPadding = vm.caretPadding;
			var cornerRadius = vm.cornerRadius;
			var xAlign = alignment.xAlign;
			var yAlign = alignment.yAlign;
			var paddingAndSize = caretSize + caretPadding;
			var radiusAndPadding = cornerRadius + caretPadding;

			if (xAlign === 'right') {
				x -= size.width;
			} else if (xAlign === 'center') {
				x -= (size.width / 2);
			}

			if (yAlign === 'top') {
				y += paddingAndSize;
			} else if (yAlign === 'bottom') {
				y -= size.height + paddingAndSize;
			} else {
				y -= (size.height / 2);
			}

			if (yAlign === 'center') {
				if (xAlign === 'left') {
					x += paddingAndSize;
				} else if (xAlign === 'right') {
					x -= paddingAndSize;
				}
			} else if (xAlign === 'left') {
				x -= radiusAndPadding;
			} else if (xAlign === 'right') {
				x += radiusAndPadding;
			}

			return {
				x: x,
				y: y
			};
		}

		Chart.Tooltip = Element.extend({
			initialize: function() {
				this._model = getBaseModel(this._options);
				this._lastActive = [];
			},

			// Get the title
			// Args are: (tooltipItem, data)
			getTitle: function() {
				var me = this;
				var opts = me._options;
				var callbacks = opts.callbacks;

				var beforeTitle = callbacks.beforeTitle.apply(me, arguments);
				var title = callbacks.title.apply(me, arguments);
				var afterTitle = callbacks.afterTitle.apply(me, arguments);

				var lines = [];
				lines = pushOrConcat(lines, beforeTitle);
				lines = pushOrConcat(lines, title);
				lines = pushOrConcat(lines, afterTitle);

				return lines;
			},

			// Args are: (tooltipItem, data)
			getBeforeBody: function() {
				var lines = this._options.callbacks.beforeBody.apply(this, arguments);
				return helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];
			},

			// Args are: (tooltipItem, data)
			getBody: function(tooltipItems, data) {
				var me = this;
				var callbacks = me._options.callbacks;
				var bodyItems = [];

				helpers.each(tooltipItems, function(tooltipItem) {
					var bodyItem = {
						before: [],
						lines: [],
						after: []
					};
					pushOrConcat(bodyItem.before, callbacks.beforeLabel.call(me, tooltipItem, data));
					pushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));
					pushOrConcat(bodyItem.after, callbacks.afterLabel.call(me, tooltipItem, data));

					bodyItems.push(bodyItem);
				});

				return bodyItems;
			},

			// Args are: (tooltipItem, data)
			getAfterBody: function() {
				var lines = this._options.callbacks.afterBody.apply(this, arguments);
				return helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];
			},

			// Get the footer and beforeFooter and afterFooter lines
			// Args are: (tooltipItem, data)
			getFooter: function() {
				var me = this;
				var callbacks = me._options.callbacks;

				var beforeFooter = callbacks.beforeFooter.apply(me, arguments);
				var footer = callbacks.footer.apply(me, arguments);
				var afterFooter = callbacks.afterFooter.apply(me, arguments);

				var lines = [];
				lines = pushOrConcat(lines, beforeFooter);
				lines = pushOrConcat(lines, footer);
				lines = pushOrConcat(lines, afterFooter);

				return lines;
			},

			update: function(changed) {
				var me = this;
				var opts = me._options;

				// Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition
				// that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time
				// which breaks any animations.
				var existingModel = me._model;
				var model = me._model = getBaseModel(opts);
				var active = me._active;

				var data = me._data;

				// In the case where active.length === 0 we need to keep these at existing values for good animations
				var alignment = {
					xAlign: existingModel.xAlign,
					yAlign: existingModel.yAlign
				};
				var backgroundPoint = {
					x: existingModel.x,
					y: existingModel.y
				};
				var tooltipSize = {
					width: existingModel.width,
					height: existingModel.height
				};
				var tooltipPosition = {
					x: existingModel.caretX,
					y: existingModel.caretY
				};

				var i, len;

				if (active.length) {
					model.opacity = 1;

					var labelColors = [];
					var labelTextColors = [];
					tooltipPosition = Chart.Tooltip.positioners[opts.position].call(me, active, me._eventPosition);

					var tooltipItems = [];
					for (i = 0, len = active.length; i < len; ++i) {
						tooltipItems.push(createTooltipItem(active[i]));
					}

					// If the user provided a filter function, use it to modify the tooltip items
					if (opts.filter) {
						tooltipItems = tooltipItems.filter(function(a) {
							return opts.filter(a, data);
						});
					}

					// If the user provided a sorting function, use it to modify the tooltip items
					if (opts.itemSort) {
						tooltipItems = tooltipItems.sort(function(a, b) {
							return opts.itemSort(a, b, data);
						});
					}

					// Determine colors for boxes
					helpers.each(tooltipItems, function(tooltipItem) {
						labelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));
						labelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));
					});


					// Build the Text Lines
					model.title = me.getTitle(tooltipItems, data);
					model.beforeBody = me.getBeforeBody(tooltipItems, data);
					model.body = me.getBody(tooltipItems, data);
					model.afterBody = me.getAfterBody(tooltipItems, data);
					model.footer = me.getFooter(tooltipItems, data);

					// Initial positioning and colors
					model.x = Math.round(tooltipPosition.x);
					model.y = Math.round(tooltipPosition.y);
					model.caretPadding = opts.caretPadding;
					model.labelColors = labelColors;
					model.labelTextColors = labelTextColors;

					// data points
					model.dataPoints = tooltipItems;

					// We need to determine alignment of the tooltip
					tooltipSize = getTooltipSize(this, model);
					alignment = determineAlignment(this, tooltipSize);
					// Final Size and Position
					backgroundPoint = getBackgroundPoint(model, tooltipSize, alignment);
				} else {
					model.opacity = 0;
				}

				model.xAlign = alignment.xAlign;
				model.yAlign = alignment.yAlign;
				model.x = backgroundPoint.x;
				model.y = backgroundPoint.y;
				model.width = tooltipSize.width;
				model.height = tooltipSize.height;

				// Point where the caret on the tooltip points to
				model.caretX = tooltipPosition.x;
				model.caretY = tooltipPosition.y;

				me._model = model;

				if (changed && opts.custom) {
					opts.custom.call(me, model);
				}

				return me;
			},
			drawCaret: function(tooltipPoint, size) {
				var ctx = this._chart.ctx;
				var vm = this._view;
				var caretPosition = this.getCaretPosition(tooltipPoint, size, vm);

				ctx.lineTo(caretPosition.x1, caretPosition.y1);
				ctx.lineTo(caretPosition.x2, caretPosition.y2);
				ctx.lineTo(caretPosition.x3, caretPosition.y3);
			},
			getCaretPosition: function(tooltipPoint, size, vm) {
				var x1, x2, x3, y1, y2, y3;
				var caretSize = vm.caretSize;
				var cornerRadius = vm.cornerRadius;
				var xAlign = vm.xAlign;
				var yAlign = vm.yAlign;
				var ptX = tooltipPoint.x;
				var ptY = tooltipPoint.y;
				var width = size.width;
				var height = size.height;

				if (yAlign === 'center') {
					y2 = ptY + (height / 2);

					if (xAlign === 'left') {
						x1 = ptX;
						x2 = x1 - caretSize;
						x3 = x1;

						y1 = y2 + caretSize;
						y3 = y2 - caretSize;
					} else {
						x1 = ptX + width;
						x2 = x1 + caretSize;
						x3 = x1;

						y1 = y2 - caretSize;
						y3 = y2 + caretSize;
					}
				} else {
					if (xAlign === 'left') {
						x2 = ptX + cornerRadius + (caretSize);
						x1 = x2 - caretSize;
						x3 = x2 + caretSize;
					} else if (xAlign === 'right') {
						x2 = ptX + width - cornerRadius - caretSize;
						x1 = x2 - caretSize;
						x3 = x2 + caretSize;
					} else {
						x2 = ptX + (width / 2);
						x1 = x2 - caretSize;
						x3 = x2 + caretSize;
					}
					if (yAlign === 'top') {
						y1 = ptY;
						y2 = y1 - caretSize;
						y3 = y1;
					} else {
						y1 = ptY + height;
						y2 = y1 + caretSize;
						y3 = y1;
						// invert drawing order
						var tmp = x3;
						x3 = x1;
						x1 = tmp;
					}
				}
				return {x1: x1, x2: x2, x3: x3, y1: y1, y2: y2, y3: y3};
			},
			drawTitle: function(pt, vm, ctx, opacity) {
				var title = vm.title;

				if (title.length) {
					ctx.textAlign = vm._titleAlign;
					ctx.textBaseline = 'top';

					var titleFontSize = vm.titleFontSize;
					var titleSpacing = vm.titleSpacing;

					ctx.fillStyle = mergeOpacity(vm.titleFontColor, opacity);
					ctx.font = helpers.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);

					var i, len;
					for (i = 0, len = title.length; i < len; ++i) {
						ctx.fillText(title[i], pt.x, pt.y);
						pt.y += titleFontSize + titleSpacing; // Line Height and spacing

						if (i + 1 === title.length) {
							pt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing
						}
					}
				}
			},
			drawBody: function(pt, vm, ctx, opacity) {
				var bodyFontSize = vm.bodyFontSize;
				var bodySpacing = vm.bodySpacing;
				var body = vm.body;

				ctx.textAlign = vm._bodyAlign;
				ctx.textBaseline = 'top';
				ctx.font = helpers.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);

				// Before Body
				var xLinePadding = 0;
				var fillLineOfText = function(line) {
					ctx.fillText(line, pt.x + xLinePadding, pt.y);
					pt.y += bodyFontSize + bodySpacing;
				};

				// Before body lines
				ctx.fillStyle = mergeOpacity(vm.bodyFontColor, opacity);
				helpers.each(vm.beforeBody, fillLineOfText);

				var drawColorBoxes = vm.displayColors;
				xLinePadding = drawColorBoxes ? (bodyFontSize + 2) : 0;

				// Draw body lines now
				helpers.each(body, function(bodyItem, i) {
					var textColor = mergeOpacity(vm.labelTextColors[i], opacity);
					ctx.fillStyle = textColor;
					helpers.each(bodyItem.before, fillLineOfText);

					helpers.each(bodyItem.lines, function(line) {
						// Draw Legend-like boxes if needed
						if (drawColorBoxes) {
							// Fill a white rect so that colours merge nicely if the opacity is < 1
							ctx.fillStyle = mergeOpacity(vm.legendColorBackground, opacity);
							ctx.fillRect(pt.x, pt.y, bodyFontSize, bodyFontSize);

							// Border
							ctx.lineWidth = 1;
							ctx.strokeStyle = mergeOpacity(vm.labelColors[i].borderColor, opacity);
							ctx.strokeRect(pt.x, pt.y, bodyFontSize, bodyFontSize);

							// Inner square
							ctx.fillStyle = mergeOpacity(vm.labelColors[i].backgroundColor, opacity);
							ctx.fillRect(pt.x + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);
							ctx.fillStyle = textColor;
						}

						fillLineOfText(line);
					});

					helpers.each(bodyItem.after, fillLineOfText);
				});

				// Reset back to 0 for after body
				xLinePadding = 0;

				// After body lines
				helpers.each(vm.afterBody, fillLineOfText);
				pt.y -= bodySpacing; // Remove last body spacing
			},
			drawFooter: function(pt, vm, ctx, opacity) {
				var footer = vm.footer;

				if (footer.length) {
					pt.y += vm.footerMarginTop;

					ctx.textAlign = vm._footerAlign;
					ctx.textBaseline = 'top';

					ctx.fillStyle = mergeOpacity(vm.footerFontColor, opacity);
					ctx.font = helpers.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);

					helpers.each(footer, function(line) {
						ctx.fillText(line, pt.x, pt.y);
						pt.y += vm.footerFontSize + vm.footerSpacing;
					});
				}
			},
			drawBackground: function(pt, vm, ctx, tooltipSize, opacity) {
				ctx.fillStyle = mergeOpacity(vm.backgroundColor, opacity);
				ctx.strokeStyle = mergeOpacity(vm.borderColor, opacity);
				ctx.lineWidth = vm.borderWidth;
				var xAlign = vm.xAlign;
				var yAlign = vm.yAlign;
				var x = pt.x;
				var y = pt.y;
				var width = tooltipSize.width;
				var height = tooltipSize.height;
				var radius = vm.cornerRadius;

				ctx.beginPath();
				ctx.moveTo(x + radius, y);
				if (yAlign === 'top') {
					this.drawCaret(pt, tooltipSize);
				}
				ctx.lineTo(x + width - radius, y);
				ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
				if (yAlign === 'center' && xAlign === 'right') {
					this.drawCaret(pt, tooltipSize);
				}
				ctx.lineTo(x + width, y + height - radius);
				ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
				if (yAlign === 'bottom') {
					this.drawCaret(pt, tooltipSize);
				}
				ctx.lineTo(x + radius, y + height);
				ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
				if (yAlign === 'center' && xAlign === 'left') {
					this.drawCaret(pt, tooltipSize);
				}
				ctx.lineTo(x, y + radius);
				ctx.quadraticCurveTo(x, y, x + radius, y);
				ctx.closePath();

				ctx.fill();

				if (vm.borderWidth > 0) {
					ctx.stroke();
				}
			},
			draw: function() {
				var ctx = this._chart.ctx;
				var vm = this._view;

				if (vm.opacity === 0) {
					return;
				}

				var tooltipSize = {
					width: vm.width,
					height: vm.height
				};
				var pt = {
					x: vm.x,
					y: vm.y
				};

				// IE11/Edge does not like very small opacities, so snap to 0
				var opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity;

				// Truthy/falsey value for empty tooltip
				var hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;

				if (this._options.enabled && hasTooltipContent) {
					// Draw Background
					this.drawBackground(pt, vm, ctx, tooltipSize, opacity);

					// Draw Title, Body, and Footer
					pt.x += vm.xPadding;
					pt.y += vm.yPadding;

					// Titles
					this.drawTitle(pt, vm, ctx, opacity);

					// Body
					this.drawBody(pt, vm, ctx, opacity);

					// Footer
					this.drawFooter(pt, vm, ctx, opacity);
				}
			},

			/**
			 * Handle an event
			 * @private
			 * @param {IEvent} event - The event to handle
			 * @returns {Boolean} true if the tooltip changed
			 */
			handleEvent: function(e) {
				var me = this;
				var options = me._options;
				var changed = false;

				me._lastActive = me._lastActive || [];

				// Find Active Elements for tooltips
				if (e.type === 'mouseout') {
					me._active = [];
				} else {
					me._active = me._chart.getElementsAtEventForMode(e, options.mode, options);
				}

				// Remember Last Actives
				changed = !helpers.arrayEquals(me._active, me._lastActive);

				// If tooltip didn't change, do not handle the target event
				if (!changed) {
					return false;
				}

				me._lastActive = me._active;

				if (options.enabled || options.custom) {
					me._eventPosition = {
						x: e.x,
						y: e.y
					};

					var model = me._model;
					me.update(true);
					me.pivot();

					// See if our tooltip position changed
					changed |= (model.x !== me._model.x) || (model.y !== me._model.y);
				}

				return changed;
			}
		});

		/**
		 * @namespace Chart.Tooltip.positioners
		 */
		Chart.Tooltip.positioners = {
			/**
			 * Average mode places the tooltip at the average position of the elements shown
			 * @function Chart.Tooltip.positioners.average
			 * @param elements {ChartElement[]} the elements being displayed in the tooltip
			 * @returns {Point} tooltip position
			 */
			average: function(elements) {
				if (!elements.length) {
					return false;
				}

				var i, len;
				var x = 0;
				var y = 0;
				var count = 0;

				for (i = 0, len = elements.length; i < len; ++i) {
					var el = elements[i];
					if (el && el.hasValue()) {
						var pos = el.tooltipPosition();
						x += pos.x;
						y += pos.y;
						++count;
					}
				}

				return {
					x: Math.round(x / count),
					y: Math.round(y / count)
				};
			},

			/**
			 * Gets the tooltip position nearest of the item nearest to the event position
			 * @function Chart.Tooltip.positioners.nearest
			 * @param elements {Chart.Element[]} the tooltip elements
			 * @param eventPosition {Point} the position of the event in canvas coordinates
			 * @returns {Point} the tooltip position
			 */
			nearest: function(elements, eventPosition) {
				var x = eventPosition.x;
				var y = eventPosition.y;
				var minDistance = Number.POSITIVE_INFINITY;
				var i, len, nearestElement;

				for (i = 0, len = elements.length; i < len; ++i) {
					var el = elements[i];
					if (el && el.hasValue()) {
						var center = el.getCenterPoint();
						var d = helpers.distanceBetweenPoints(eventPosition, center);

						if (d < minDistance) {
							minDistance = d;
							nearestElement = el;
						}
					}
				}

				if (nearestElement) {
					var tp = nearestElement.tooltipPosition();
					x = tp.x;
					y = tp.y;
				}

				return {
					x: x,
					y: y
				};
			}
		};
	};


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var helpers = __webpack_require__(41);
	var Ticks = __webpack_require__(69);

	module.exports = function(Chart) {

		var noop = helpers.noop;

		Chart.LinearScaleBase = Chart.Scale.extend({
			getRightValue: function(value) {
				if (typeof value === 'string') {
					return +value;
				}
				return Chart.Scale.prototype.getRightValue.call(this, value);
			},

			handleTickRangeOptions: function() {
				var me = this;
				var opts = me.options;
				var tickOpts = opts.ticks;

				// If we are forcing it to begin at 0, but 0 will already be rendered on the chart,
				// do nothing since that would make the chart weird. If the user really wants a weird chart
				// axis, they can manually override it
				if (tickOpts.beginAtZero) {
					var minSign = helpers.sign(me.min);
					var maxSign = helpers.sign(me.max);

					if (minSign < 0 && maxSign < 0) {
						// move the top up to 0
						me.max = 0;
					} else if (minSign > 0 && maxSign > 0) {
						// move the bottom down to 0
						me.min = 0;
					}
				}

				var setMin = tickOpts.min !== undefined || tickOpts.suggestedMin !== undefined;
				var setMax = tickOpts.max !== undefined || tickOpts.suggestedMax !== undefined;

				if (tickOpts.min !== undefined) {
					me.min = tickOpts.min;
				} else if (tickOpts.suggestedMin !== undefined) {
					if (me.min === null) {
						me.min = tickOpts.suggestedMin;
					} else {
						me.min = Math.min(me.min, tickOpts.suggestedMin);
					}
				}

				if (tickOpts.max !== undefined) {
					me.max = tickOpts.max;
				} else if (tickOpts.suggestedMax !== undefined) {
					if (me.max === null) {
						me.max = tickOpts.suggestedMax;
					} else {
						me.max = Math.max(me.max, tickOpts.suggestedMax);
					}
				}

				if (setMin !== setMax) {
					// We set the min or the max but not both.
					// So ensure that our range is good
					// Inverted or 0 length range can happen when
					// ticks.min is set, and no datasets are visible
					if (me.min >= me.max) {
						if (setMin) {
							me.max = me.min + 1;
						} else {
							me.min = me.max - 1;
						}
					}
				}

				if (me.min === me.max) {
					me.max++;

					if (!tickOpts.beginAtZero) {
						me.min--;
					}
				}
			},
			getTickLimit: noop,
			handleDirectionalChanges: noop,

			buildTicks: function() {
				var me = this;
				var opts = me.options;
				var tickOpts = opts.ticks;

				// Figure out what the max number of ticks we can support it is based on the size of
				// the axis area. For now, we say that the minimum tick spacing in pixels must be 50
				// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
				// the graph. Make sure we always have at least 2 ticks
				var maxTicks = me.getTickLimit();
				maxTicks = Math.max(2, maxTicks);

				var numericGeneratorOptions = {
					maxTicks: maxTicks,
					min: tickOpts.min,
					max: tickOpts.max,
					stepSize: helpers.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)
				};
				var ticks = me.ticks = Ticks.generators.linear(numericGeneratorOptions, me);

				me.handleDirectionalChanges();

				// At this point, we need to update our max and min given the tick values since we have expanded the
				// range of the scale
				me.max = helpers.max(ticks);
				me.min = helpers.min(ticks);

				if (tickOpts.reverse) {
					ticks.reverse();

					me.start = me.max;
					me.end = me.min;
				} else {
					me.start = me.min;
					me.end = me.max;
				}
			},
			convertTicksToLabels: function() {
				var me = this;
				me.ticksAsNumbers = me.ticks.slice();
				me.zeroLineIndex = me.ticks.indexOf(0);

				Chart.Scale.prototype.convertTicksToLabels.call(me);
			}
		});
	};


/***/ }),
/* 72 */
/***/ (function(module, exports) {

	'use strict';

	module.exports = function(Chart) {

		// Default config for a category scale
		var defaultConfig = {
			position: 'bottom'
		};

		var DatasetScale = Chart.Scale.extend({
			/**
			* Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those
			* else fall back to data.labels
			* @private
			*/
			getLabels: function() {
				var data = this.chart.data;
				return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;
			},

			determineDataLimits: function() {
				var me = this;
				var labels = me.getLabels();
				me.minIndex = 0;
				me.maxIndex = labels.length - 1;
				var findIndex;

				if (me.options.ticks.min !== undefined) {
					// user specified min value
					findIndex = labels.indexOf(me.options.ticks.min);
					me.minIndex = findIndex !== -1 ? findIndex : me.minIndex;
				}

				if (me.options.ticks.max !== undefined) {
					// user specified max value
					findIndex = labels.indexOf(me.options.ticks.max);
					me.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;
				}

				me.min = labels[me.minIndex];
				me.max = labels[me.maxIndex];
			},

			buildTicks: function() {
				var me = this;
				var labels = me.getLabels();
				// If we are viewing some subset of labels, slice the original array
				me.ticks = (me.minIndex === 0 && me.maxIndex === labels.length - 1) ? labels : labels.slice(me.minIndex, me.maxIndex + 1);
			},

			getLabelForIndex: function(index, datasetIndex) {
				var me = this;
				var data = me.chart.data;
				var isHorizontal = me.isHorizontal();

				if (data.yLabels && !isHorizontal) {
					return me.getRightValue(data.datasets[datasetIndex].data[index]);
				}
				return me.ticks[index - me.minIndex];
			},

			// Used to get data value locations.  Value can either be an index or a numerical value
			getPixelForValue: function(value, index) {
				var me = this;
				var offset = me.options.offset;
				// 1 is added because we need the length but we have the indexes
				var offsetAmt = Math.max((me.maxIndex + 1 - me.minIndex - (offset ? 0 : 1)), 1);

				// If value is a data object, then index is the index in the data array,
				// not the index of the scale. We need to change that.
				var valueCategory;
				if (value !== undefined && value !== null) {
					valueCategory = me.isHorizontal() ? value.x : value.y;
				}
				if (valueCategory !== undefined || (value !== undefined && isNaN(index))) {
					var labels = me.getLabels();
					value = valueCategory || value;
					var idx = labels.indexOf(value);
					index = idx !== -1 ? idx : index;
				}

				if (me.isHorizontal()) {
					var valueWidth = me.width / offsetAmt;
					var widthOffset = (valueWidth * (index - me.minIndex));

					if (offset) {
						widthOffset += (valueWidth / 2);
					}

					return me.left + Math.round(widthOffset);
				}
				var valueHeight = me.height / offsetAmt;
				var heightOffset = (valueHeight * (index - me.minIndex));

				if (offset) {
					heightOffset += (valueHeight / 2);
				}

				return me.top + Math.round(heightOffset);
			},
			getPixelForTick: function(index) {
				return this.getPixelForValue(this.ticks[index], index + this.minIndex, null);
			},
			getValueForPixel: function(pixel) {
				var me = this;
				var offset = me.options.offset;
				var value;
				var offsetAmt = Math.max((me._ticks.length - (offset ? 0 : 1)), 1);
				var horz = me.isHorizontal();
				var valueDimension = (horz ? me.width : me.height) / offsetAmt;

				pixel -= horz ? me.left : me.top;

				if (offset) {
					pixel -= (valueDimension / 2);
				}

				if (pixel <= 0) {
					value = 0;
				} else {
					value = Math.round(pixel / valueDimension);
				}

				return value + me.minIndex;
			},
			getBasePixel: function() {
				return this.bottom;
			}
		});

		Chart.scaleService.registerScaleType('category', DatasetScale, defaultConfig);

	};


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var defaults = __webpack_require__(40);
	var helpers = __webpack_require__(41);
	var Ticks = __webpack_require__(69);

	module.exports = function(Chart) {

		var defaultConfig = {
			position: 'left',
			ticks: {
				callback: Ticks.formatters.linear
			}
		};

		var LinearScale = Chart.LinearScaleBase.extend({

			determineDataLimits: function() {
				var me = this;
				var opts = me.options;
				var chart = me.chart;
				var data = chart.data;
				var datasets = data.datasets;
				var isHorizontal = me.isHorizontal();
				var DEFAULT_MIN = 0;
				var DEFAULT_MAX = 1;

				function IDMatches(meta) {
					return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
				}

				// First Calculate the range
				me.min = null;
				me.max = null;

				var hasStacks = opts.stacked;
				if (hasStacks === undefined) {
					helpers.each(datasets, function(dataset, datasetIndex) {
						if (hasStacks) {
							return;
						}

						var meta = chart.getDatasetMeta(datasetIndex);
						if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&
							meta.stack !== undefined) {
							hasStacks = true;
						}
					});
				}

				if (opts.stacked || hasStacks) {
					var valuesPerStack = {};

					helpers.each(datasets, function(dataset, datasetIndex) {
						var meta = chart.getDatasetMeta(datasetIndex);
						var key = [
							meta.type,
							// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
							((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),
							meta.stack
						].join('.');

						if (valuesPerStack[key] === undefined) {
							valuesPerStack[key] = {
								positiveValues: [],
								negativeValues: []
							};
						}

						// Store these per type
						var positiveValues = valuesPerStack[key].positiveValues;
						var negativeValues = valuesPerStack[key].negativeValues;

						if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
							helpers.each(dataset.data, function(rawValue, index) {
								var value = +me.getRightValue(rawValue);
								if (isNaN(value) || meta.data[index].hidden) {
									return;
								}

								positiveValues[index] = positiveValues[index] || 0;
								negativeValues[index] = negativeValues[index] || 0;

								if (opts.relativePoints) {
									positiveValues[index] = 100;
								} else if (value < 0) {
									negativeValues[index] += value;
								} else {
									positiveValues[index] += value;
								}
							});
						}
					});

					helpers.each(valuesPerStack, function(valuesForType) {
						var values = valuesForType.positiveValues.concat(valuesForType.negativeValues);
						var minVal = helpers.min(values);
						var maxVal = helpers.max(values);
						me.min = me.min === null ? minVal : Math.min(me.min, minVal);
						me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
					});

				} else {
					helpers.each(datasets, function(dataset, datasetIndex) {
						var meta = chart.getDatasetMeta(datasetIndex);
						if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
							helpers.each(dataset.data, function(rawValue, index) {
								var value = +me.getRightValue(rawValue);
								if (isNaN(value) || meta.data[index].hidden) {
									return;
								}

								if (me.min === null) {
									me.min = value;
								} else if (value < me.min) {
									me.min = value;
								}

								if (me.max === null) {
									me.max = value;
								} else if (value > me.max) {
									me.max = value;
								}
							});
						}
					});
				}

				me.min = isFinite(me.min) && !isNaN(me.min) ? me.min : DEFAULT_MIN;
				me.max = isFinite(me.max) && !isNaN(me.max) ? me.max : DEFAULT_MAX;

				// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero
				this.handleTickRangeOptions();
			},
			getTickLimit: function() {
				var maxTicks;
				var me = this;
				var tickOpts = me.options.ticks;

				if (me.isHorizontal()) {
					maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.width / 50));
				} else {
					// The factor of 2 used to scale the font size has been experimentally determined.
					var tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, defaults.global.defaultFontSize);
					maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.height / (2 * tickFontSize)));
				}

				return maxTicks;
			},
			// Called after the ticks are built. We need
			handleDirectionalChanges: function() {
				if (!this.isHorizontal()) {
					// We are in a vertical orientation. The top value is the highest. So reverse the array
					this.ticks.reverse();
				}
			},
			getLabelForIndex: function(index, datasetIndex) {
				return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
			},
			// Utils
			getPixelForValue: function(value) {
				// This must be called after fit has been run so that
				// this.left, this.top, this.right, and this.bottom have been defined
				var me = this;
				var start = me.start;

				var rightValue = +me.getRightValue(value);
				var pixel;
				var range = me.end - start;

				if (me.isHorizontal()) {
					pixel = me.left + (me.width / range * (rightValue - start));
					return Math.round(pixel);
				}

				pixel = me.bottom - (me.height / range * (rightValue - start));
				return Math.round(pixel);
			},
			getValueForPixel: function(pixel) {
				var me = this;
				var isHorizontal = me.isHorizontal();
				var innerDimension = isHorizontal ? me.width : me.height;
				var offset = (isHorizontal ? pixel - me.left : me.bottom - pixel) / innerDimension;
				return me.start + ((me.end - me.start) * offset);
			},
			getPixelForTick: function(index) {
				return this.getPixelForValue(this.ticksAsNumbers[index]);
			}
		});
		Chart.scaleService.registerScaleType('linear', LinearScale, defaultConfig);

	};


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var helpers = __webpack_require__(41);
	var Ticks = __webpack_require__(69);

	module.exports = function(Chart) {

		var defaultConfig = {
			position: 'left',

			// label settings
			ticks: {
				callback: Ticks.formatters.logarithmic
			}
		};

		var LogarithmicScale = Chart.Scale.extend({
			determineDataLimits: function() {
				var me = this;
				var opts = me.options;
				var tickOpts = opts.ticks;
				var chart = me.chart;
				var data = chart.data;
				var datasets = data.datasets;
				var valueOrDefault = helpers.valueOrDefault;
				var isHorizontal = me.isHorizontal();
				function IDMatches(meta) {
					return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
				}

				// Calculate Range
				me.min = null;
				me.max = null;
				me.minNotZero = null;

				var hasStacks = opts.stacked;
				if (hasStacks === undefined) {
					helpers.each(datasets, function(dataset, datasetIndex) {
						if (hasStacks) {
							return;
						}

						var meta = chart.getDatasetMeta(datasetIndex);
						if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&
							meta.stack !== undefined) {
							hasStacks = true;
						}
					});
				}

				if (opts.stacked || hasStacks) {
					var valuesPerStack = {};

					helpers.each(datasets, function(dataset, datasetIndex) {
						var meta = chart.getDatasetMeta(datasetIndex);
						var key = [
							meta.type,
							// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
							((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),
							meta.stack
						].join('.');

						if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
							if (valuesPerStack[key] === undefined) {
								valuesPerStack[key] = [];
							}

							helpers.each(dataset.data, function(rawValue, index) {
								var values = valuesPerStack[key];
								var value = +me.getRightValue(rawValue);
								if (isNaN(value) || meta.data[index].hidden) {
									return;
								}

								values[index] = values[index] || 0;

								if (opts.relativePoints) {
									values[index] = 100;
								} else {
									// Don't need to split positive and negative since the log scale can't handle a 0 crossing
									values[index] += value;
								}
							});
						}
					});

					helpers.each(valuesPerStack, function(valuesForType) {
						var minVal = helpers.min(valuesForType);
						var maxVal = helpers.max(valuesForType);
						me.min = me.min === null ? minVal : Math.min(me.min, minVal);
						me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
					});

				} else {
					helpers.each(datasets, function(dataset, datasetIndex) {
						var meta = chart.getDatasetMeta(datasetIndex);
						if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
							helpers.each(dataset.data, function(rawValue, index) {
								var value = +me.getRightValue(rawValue);
								if (isNaN(value) || meta.data[index].hidden) {
									return;
								}

								if (me.min === null) {
									me.min = value;
								} else if (value < me.min) {
									me.min = value;
								}

								if (me.max === null) {
									me.max = value;
								} else if (value > me.max) {
									me.max = value;
								}

								if (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {
									me.minNotZero = value;
								}
							});
						}
					});
				}

				me.min = valueOrDefault(tickOpts.min, me.min);
				me.max = valueOrDefault(tickOpts.max, me.max);

				if (me.min === me.max) {
					if (me.min !== 0 && me.min !== null) {
						me.min = Math.pow(10, Math.floor(helpers.log10(me.min)) - 1);
						me.max = Math.pow(10, Math.floor(helpers.log10(me.max)) + 1);
					} else {
						me.min = 1;
						me.max = 10;
					}
				}
			},
			buildTicks: function() {
				var me = this;
				var opts = me.options;
				var tickOpts = opts.ticks;

				var generationOptions = {
					min: tickOpts.min,
					max: tickOpts.max
				};
				var ticks = me.ticks = Ticks.generators.logarithmic(generationOptions, me);

				if (!me.isHorizontal()) {
					// We are in a vertical orientation. The top value is the highest. So reverse the array
					ticks.reverse();
				}

				// At this point, we need to update our max and min given the tick values since we have expanded the
				// range of the scale
				me.max = helpers.max(ticks);
				me.min = helpers.min(ticks);

				if (tickOpts.reverse) {
					ticks.reverse();

					me.start = me.max;
					me.end = me.min;
				} else {
					me.start = me.min;
					me.end = me.max;
				}
			},
			convertTicksToLabels: function() {
				this.tickValues = this.ticks.slice();

				Chart.Scale.prototype.convertTicksToLabels.call(this);
			},
			// Get the correct tooltip label
			getLabelForIndex: function(index, datasetIndex) {
				return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
			},
			getPixelForTick: function(index) {
				return this.getPixelForValue(this.tickValues[index]);
			},
			getPixelForValue: function(value) {
				var me = this;
				var start = me.start;
				var newVal = +me.getRightValue(value);
				var opts = me.options;
				var tickOpts = opts.ticks;
				var innerDimension, pixel, range;

				if (me.isHorizontal()) {
					range = helpers.log10(me.end) - helpers.log10(start); // todo: if start === 0
					if (newVal === 0) {
						pixel = me.left;
					} else {
						innerDimension = me.width;
						pixel = me.left + (innerDimension / range * (helpers.log10(newVal) - helpers.log10(start)));
					}
				} else {
					// Bottom - top since pixels increase downward on a screen
					innerDimension = me.height;
					if (start === 0 && !tickOpts.reverse) {
						range = helpers.log10(me.end) - helpers.log10(me.minNotZero);
						if (newVal === start) {
							pixel = me.bottom;
						} else if (newVal === me.minNotZero) {
							pixel = me.bottom - innerDimension * 0.02;
						} else {
							pixel = me.bottom - innerDimension * 0.02 - (innerDimension * 0.98 / range * (helpers.log10(newVal) - helpers.log10(me.minNotZero)));
						}
					} else if (me.end === 0 && tickOpts.reverse) {
						range = helpers.log10(me.start) - helpers.log10(me.minNotZero);
						if (newVal === me.end) {
							pixel = me.top;
						} else if (newVal === me.minNotZero) {
							pixel = me.top + innerDimension * 0.02;
						} else {
							pixel = me.top + innerDimension * 0.02 + (innerDimension * 0.98 / range * (helpers.log10(newVal) - helpers.log10(me.minNotZero)));
						}
					} else if (newVal === 0) {
						pixel = tickOpts.reverse ? me.top : me.bottom;
					} else {
						range = helpers.log10(me.end) - helpers.log10(start);
						innerDimension = me.height;
						pixel = me.bottom - (innerDimension / range * (helpers.log10(newVal) - helpers.log10(start)));
					}
				}
				return pixel;
			},
			getValueForPixel: function(pixel) {
				var me = this;
				var range = helpers.log10(me.end) - helpers.log10(me.start);
				var value, innerDimension;

				if (me.isHorizontal()) {
					innerDimension = me.width;
					value = me.start * Math.pow(10, (pixel - me.left) * range / innerDimension);
				} else { // todo: if start === 0
					innerDimension = me.height;
					value = Math.pow(10, (me.bottom - pixel) * range / innerDimension) / me.start;
				}
				return value;
			}
		});
		Chart.scaleService.registerScaleType('logarithmic', LogarithmicScale, defaultConfig);

	};


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var defaults = __webpack_require__(40);
	var helpers = __webpack_require__(41);
	var Ticks = __webpack_require__(69);

	module.exports = function(Chart) {

		var globalDefaults = defaults.global;

		var defaultConfig = {
			display: true,

			// Boolean - Whether to animate scaling the chart from the centre
			animate: true,
			position: 'chartArea',

			angleLines: {
				display: true,
				color: 'rgba(0, 0, 0, 0.1)',
				lineWidth: 1
			},

			gridLines: {
				circular: false
			},

			// label settings
			ticks: {
				// Boolean - Show a backdrop to the scale label
				showLabelBackdrop: true,

				// String - The colour of the label backdrop
				backdropColor: 'rgba(255,255,255,0.75)',

				// Number - The backdrop padding above & below the label in pixels
				backdropPaddingY: 2,

				// Number - The backdrop padding to the side of the label in pixels
				backdropPaddingX: 2,

				callback: Ticks.formatters.linear
			},

			pointLabels: {
				// Boolean - if true, show point labels
				display: true,

				// Number - Point label font size in pixels
				fontSize: 10,

				// Function - Used to convert point labels
				callback: function(label) {
					return label;
				}
			}
		};

		function getValueCount(scale) {
			var opts = scale.options;
			return opts.angleLines.display || opts.pointLabels.display ? scale.chart.data.labels.length : 0;
		}

		function getPointLabelFontOptions(scale) {
			var pointLabelOptions = scale.options.pointLabels;
			var fontSize = helpers.valueOrDefault(pointLabelOptions.fontSize, globalDefaults.defaultFontSize);
			var fontStyle = helpers.valueOrDefault(pointLabelOptions.fontStyle, globalDefaults.defaultFontStyle);
			var fontFamily = helpers.valueOrDefault(pointLabelOptions.fontFamily, globalDefaults.defaultFontFamily);
			var font = helpers.fontString(fontSize, fontStyle, fontFamily);

			return {
				size: fontSize,
				style: fontStyle,
				family: fontFamily,
				font: font
			};
		}

		function measureLabelSize(ctx, fontSize, label) {
			if (helpers.isArray(label)) {
				return {
					w: helpers.longestText(ctx, ctx.font, label),
					h: (label.length * fontSize) + ((label.length - 1) * 1.5 * fontSize)
				};
			}

			return {
				w: ctx.measureText(label).width,
				h: fontSize
			};
		}

		function determineLimits(angle, pos, size, min, max) {
			if (angle === min || angle === max) {
				return {
					start: pos - (size / 2),
					end: pos + (size / 2)
				};
			} else if (angle < min || angle > max) {
				return {
					start: pos - size - 5,
					end: pos
				};
			}

			return {
				start: pos,
				end: pos + size + 5
			};
		}

		/**
		 * Helper function to fit a radial linear scale with point labels
		 */
		function fitWithPointLabels(scale) {
			/*
			 * Right, this is really confusing and there is a lot of maths going on here
			 * The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9
			 *
			 * Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif
			 *
			 * Solution:
			 *
			 * We assume the radius of the polygon is half the size of the canvas at first
			 * at each index we check if the text overlaps.
			 *
			 * Where it does, we store that angle and that index.
			 *
			 * After finding the largest index and angle we calculate how much we need to remove
			 * from the shape radius to move the point inwards by that x.
			 *
			 * We average the left and right distances to get the maximum shape radius that can fit in the box
			 * along with labels.
			 *
			 * Once we have that, we can find the centre point for the chart, by taking the x text protrusion
			 * on each side, removing that from the size, halving it and adding the left x protrusion width.
			 *
			 * This will mean we have a shape fitted to the canvas, as large as it can be with the labels
			 * and position it in the most space efficient manner
			 *
			 * https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif
			 */

			var plFont = getPointLabelFontOptions(scale);

			// Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.
			// Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points
			var largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);
			var furthestLimits = {
				r: scale.width,
				l: 0,
				t: scale.height,
				b: 0
			};
			var furthestAngles = {};
			var i, textSize, pointPosition;

			scale.ctx.font = plFont.font;
			scale._pointLabelSizes = [];

			var valueCount = getValueCount(scale);
			for (i = 0; i < valueCount; i++) {
				pointPosition = scale.getPointPosition(i, largestPossibleRadius);
				textSize = measureLabelSize(scale.ctx, plFont.size, scale.pointLabels[i] || '');
				scale._pointLabelSizes[i] = textSize;

				// Add quarter circle to make degree 0 mean top of circle
				var angleRadians = scale.getIndexAngle(i);
				var angle = helpers.toDegrees(angleRadians) % 360;
				var hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
				var vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);

				if (hLimits.start < furthestLimits.l) {
					furthestLimits.l = hLimits.start;
					furthestAngles.l = angleRadians;
				}

				if (hLimits.end > furthestLimits.r) {
					furthestLimits.r = hLimits.end;
					furthestAngles.r = angleRadians;
				}

				if (vLimits.start < furthestLimits.t) {
					furthestLimits.t = vLimits.start;
					furthestAngles.t = angleRadians;
				}

				if (vLimits.end > furthestLimits.b) {
					furthestLimits.b = vLimits.end;
					furthestAngles.b = angleRadians;
				}
			}

			scale.setReductions(largestPossibleRadius, furthestLimits, furthestAngles);
		}

		/**
		 * Helper function to fit a radial linear scale with no point labels
		 */
		function fit(scale) {
			var largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);
			scale.drawingArea = Math.round(largestPossibleRadius);
			scale.setCenterPoint(0, 0, 0, 0);
		}

		function getTextAlignForAngle(angle) {
			if (angle === 0 || angle === 180) {
				return 'center';
			} else if (angle < 180) {
				return 'left';
			}

			return 'right';
		}

		function fillText(ctx, text, position, fontSize) {
			if (helpers.isArray(text)) {
				var y = position.y;
				var spacing = 1.5 * fontSize;

				for (var i = 0; i < text.length; ++i) {
					ctx.fillText(text[i], position.x, y);
					y += spacing;
				}
			} else {
				ctx.fillText(text, position.x, position.y);
			}
		}

		function adjustPointPositionForLabelHeight(angle, textSize, position) {
			if (angle === 90 || angle === 270) {
				position.y -= (textSize.h / 2);
			} else if (angle > 270 || angle < 90) {
				position.y -= textSize.h;
			}
		}

		function drawPointLabels(scale) {
			var ctx = scale.ctx;
			var valueOrDefault = helpers.valueOrDefault;
			var opts = scale.options;
			var angleLineOpts = opts.angleLines;
			var pointLabelOpts = opts.pointLabels;

			ctx.lineWidth = angleLineOpts.lineWidth;
			ctx.strokeStyle = angleLineOpts.color;

			var outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);

			// Point Label Font
			var plFont = getPointLabelFontOptions(scale);

			ctx.textBaseline = 'top';

			for (var i = getValueCount(scale) - 1; i >= 0; i--) {
				if (angleLineOpts.display) {
					var outerPosition = scale.getPointPosition(i, outerDistance);
					ctx.beginPath();
					ctx.moveTo(scale.xCenter, scale.yCenter);
					ctx.lineTo(outerPosition.x, outerPosition.y);
					ctx.stroke();
					ctx.closePath();
				}

				if (pointLabelOpts.display) {
					// Extra 3px out for some label spacing
					var pointLabelPosition = scale.getPointPosition(i, outerDistance + 5);

					// Keep this in loop since we may support array properties here
					var pointLabelFontColor = valueOrDefault(pointLabelOpts.fontColor, globalDefaults.defaultFontColor);
					ctx.font = plFont.font;
					ctx.fillStyle = pointLabelFontColor;

					var angleRadians = scale.getIndexAngle(i);
					var angle = helpers.toDegrees(angleRadians);
					ctx.textAlign = getTextAlignForAngle(angle);
					adjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);
					fillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.size);
				}
			}
		}

		function drawRadiusLine(scale, gridLineOpts, radius, index) {
			var ctx = scale.ctx;
			ctx.strokeStyle = helpers.valueAtIndexOrDefault(gridLineOpts.color, index - 1);
			ctx.lineWidth = helpers.valueAtIndexOrDefault(gridLineOpts.lineWidth, index - 1);

			if (scale.options.gridLines.circular) {
				// Draw circular arcs between the points
				ctx.beginPath();
				ctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);
				ctx.closePath();
				ctx.stroke();
			} else {
				// Draw straight lines connecting each index
				var valueCount = getValueCount(scale);

				if (valueCount === 0) {
					return;
				}

				ctx.beginPath();
				var pointPosition = scale.getPointPosition(0, radius);
				ctx.moveTo(pointPosition.x, pointPosition.y);

				for (var i = 1; i < valueCount; i++) {
					pointPosition = scale.getPointPosition(i, radius);
					ctx.lineTo(pointPosition.x, pointPosition.y);
				}

				ctx.closePath();
				ctx.stroke();
			}
		}

		function numberOrZero(param) {
			return helpers.isNumber(param) ? param : 0;
		}

		var LinearRadialScale = Chart.LinearScaleBase.extend({
			setDimensions: function() {
				var me = this;
				var opts = me.options;
				var tickOpts = opts.ticks;
				// Set the unconstrained dimension before label rotation
				me.width = me.maxWidth;
				me.height = me.maxHeight;
				me.xCenter = Math.round(me.width / 2);
				me.yCenter = Math.round(me.height / 2);

				var minSize = helpers.min([me.height, me.width]);
				var tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
				me.drawingArea = opts.display ? (minSize / 2) - (tickFontSize / 2 + tickOpts.backdropPaddingY) : (minSize / 2);
			},
			determineDataLimits: function() {
				var me = this;
				var chart = me.chart;
				var min = Number.POSITIVE_INFINITY;
				var max = Number.NEGATIVE_INFINITY;

				helpers.each(chart.data.datasets, function(dataset, datasetIndex) {
					if (chart.isDatasetVisible(datasetIndex)) {
						var meta = chart.getDatasetMeta(datasetIndex);

						helpers.each(dataset.data, function(rawValue, index) {
							var value = +me.getRightValue(rawValue);
							if (isNaN(value) || meta.data[index].hidden) {
								return;
							}

							min = Math.min(value, min);
							max = Math.max(value, max);
						});
					}
				});

				me.min = (min === Number.POSITIVE_INFINITY ? 0 : min);
				me.max = (max === Number.NEGATIVE_INFINITY ? 0 : max);

				// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero
				me.handleTickRangeOptions();
			},
			getTickLimit: function() {
				var tickOpts = this.options.ticks;
				var tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
				return Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * tickFontSize)));
			},
			convertTicksToLabels: function() {
				var me = this;

				Chart.LinearScaleBase.prototype.convertTicksToLabels.call(me);

				// Point labels
				me.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);
			},
			getLabelForIndex: function(index, datasetIndex) {
				return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
			},
			fit: function() {
				if (this.options.pointLabels.display) {
					fitWithPointLabels(this);
				} else {
					fit(this);
				}
			},
			/**
			 * Set radius reductions and determine new radius and center point
			 * @private
			 */
			setReductions: function(largestPossibleRadius, furthestLimits, furthestAngles) {
				var me = this;
				var radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);
				var radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);
				var radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);
				var radiusReductionBottom = -Math.max(furthestLimits.b - me.height, 0) / Math.cos(furthestAngles.b);

				radiusReductionLeft = numberOrZero(radiusReductionLeft);
				radiusReductionRight = numberOrZero(radiusReductionRight);
				radiusReductionTop = numberOrZero(radiusReductionTop);
				radiusReductionBottom = numberOrZero(radiusReductionBottom);

				me.drawingArea = Math.min(
					Math.round(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2),
					Math.round(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));
				me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);
			},
			setCenterPoint: function(leftMovement, rightMovement, topMovement, bottomMovement) {
				var me = this;
				var maxRight = me.width - rightMovement - me.drawingArea;
				var maxLeft = leftMovement + me.drawingArea;
				var maxTop = topMovement + me.drawingArea;
				var maxBottom = me.height - bottomMovement - me.drawingArea;

				me.xCenter = Math.round(((maxLeft + maxRight) / 2) + me.left);
				me.yCenter = Math.round(((maxTop + maxBottom) / 2) + me.top);
			},

			getIndexAngle: function(index) {
				var angleMultiplier = (Math.PI * 2) / getValueCount(this);
				var startAngle = this.chart.options && this.chart.options.startAngle ?
					this.chart.options.startAngle :
					0;

				var startAngleRadians = startAngle * Math.PI * 2 / 360;

				// Start from the top instead of right, so remove a quarter of the circle
				return index * angleMultiplier + startAngleRadians;
			},
			getDistanceFromCenterForValue: function(value) {
				var me = this;

				if (value === null) {
					return 0; // null always in center
				}

				// Take into account half font size + the yPadding of the top value
				var scalingFactor = me.drawingArea / (me.max - me.min);
				if (me.options.ticks.reverse) {
					return (me.max - value) * scalingFactor;
				}
				return (value - me.min) * scalingFactor;
			},
			getPointPosition: function(index, distanceFromCenter) {
				var me = this;
				var thisAngle = me.getIndexAngle(index) - (Math.PI / 2);
				return {
					x: Math.round(Math.cos(thisAngle) * distanceFromCenter) + me.xCenter,
					y: Math.round(Math.sin(thisAngle) * distanceFromCenter) + me.yCenter
				};
			},
			getPointPositionForValue: function(index, value) {
				return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
			},

			getBasePosition: function() {
				var me = this;
				var min = me.min;
				var max = me.max;

				return me.getPointPositionForValue(0,
					me.beginAtZero ? 0 :
					min < 0 && max < 0 ? max :
					min > 0 && max > 0 ? min :
					0);
			},

			draw: function() {
				var me = this;
				var opts = me.options;
				var gridLineOpts = opts.gridLines;
				var tickOpts = opts.ticks;
				var valueOrDefault = helpers.valueOrDefault;

				if (opts.display) {
					var ctx = me.ctx;
					var startAngle = this.getIndexAngle(0);

					// Tick Font
					var tickFontSize = valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
					var tickFontStyle = valueOrDefault(tickOpts.fontStyle, globalDefaults.defaultFontStyle);
					var tickFontFamily = valueOrDefault(tickOpts.fontFamily, globalDefaults.defaultFontFamily);
					var tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);

					helpers.each(me.ticks, function(label, index) {
						// Don't draw a centre value (if it is minimum)
						if (index > 0 || tickOpts.reverse) {
							var yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);

							// Draw circular lines around the scale
							if (gridLineOpts.display && index !== 0) {
								drawRadiusLine(me, gridLineOpts, yCenterOffset, index);
							}

							if (tickOpts.display) {
								var tickFontColor = valueOrDefault(tickOpts.fontColor, globalDefaults.defaultFontColor);
								ctx.font = tickLabelFont;

								ctx.save();
								ctx.translate(me.xCenter, me.yCenter);
								ctx.rotate(startAngle);

								if (tickOpts.showLabelBackdrop) {
									var labelWidth = ctx.measureText(label).width;
									ctx.fillStyle = tickOpts.backdropColor;
									ctx.fillRect(
										-labelWidth / 2 - tickOpts.backdropPaddingX,
										-yCenterOffset - tickFontSize / 2 - tickOpts.backdropPaddingY,
										labelWidth + tickOpts.backdropPaddingX * 2,
										tickFontSize + tickOpts.backdropPaddingY * 2
									);
								}

								ctx.textAlign = 'center';
								ctx.textBaseline = 'middle';
								ctx.fillStyle = tickFontColor;
								ctx.fillText(label, 0, -yCenterOffset);
								ctx.restore();
							}
						}
					});

					if (opts.angleLines.display || opts.pointLabels.display) {
						drawPointLabels(me);
					}
				}
			}
		});
		Chart.scaleService.registerScaleType('radialLinear', LinearRadialScale, defaultConfig);

	};


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

	/* global window: false */
	'use strict';

	var moment = __webpack_require__(77);
	moment = typeof moment === 'function' ? moment : window.moment;

	var defaults = __webpack_require__(40);
	var helpers = __webpack_require__(41);

	// Integer constants are from the ES6 spec.
	var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
	var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;

	var INTERVALS = {
		millisecond: {
			common: true,
			size: 1,
			steps: [1, 2, 5, 10, 20, 50, 100, 250, 500]
		},
		second: {
			common: true,
			size: 1000,
			steps: [1, 2, 5, 10, 30]
		},
		minute: {
			common: true,
			size: 60000,
			steps: [1, 2, 5, 10, 30]
		},
		hour: {
			common: true,
			size: 3600000,
			steps: [1, 2, 3, 6, 12]
		},
		day: {
			common: true,
			size: 86400000,
			steps: [1, 2, 5]
		},
		week: {
			common: false,
			size: 604800000,
			steps: [1, 2, 3, 4]
		},
		month: {
			common: true,
			size: 2.628e9,
			steps: [1, 2, 3]
		},
		quarter: {
			common: false,
			size: 7.884e9,
			steps: [1, 2, 3, 4]
		},
		year: {
			common: true,
			size: 3.154e10
		}
	};

	var UNITS = Object.keys(INTERVALS);

	function sorter(a, b) {
		return a - b;
	}

	function arrayUnique(items) {
		var hash = {};
		var out = [];
		var i, ilen, item;

		for (i = 0, ilen = items.length; i < ilen; ++i) {
			item = items[i];
			if (!hash[item]) {
				hash[item] = true;
				out.push(item);
			}
		}

		return out;
	}

	/**
	 * Returns an array of {time, pos} objects used to interpolate a specific `time` or position
	 * (`pos`) on the scale, by searching entries before and after the requested value. `pos` is
	 * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other
	 * extremity (left + width or top + height). Note that it would be more optimized to directly
	 * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need
	 * to create the lookup table. The table ALWAYS contains at least two items: min and max.
	 *
	 * @param {Number[]} timestamps - timestamps sorted from lowest to highest.
	 * @param {String} distribution - If 'linear', timestamps will be spread linearly along the min
	 * and max range, so basically, the table will contains only two items: {min, 0} and {max, 1}.
	 * If 'series', timestamps will be positioned at the same distance from each other. In this
	 * case, only timestamps that break the time linearity are registered, meaning that in the
	 * best case, all timestamps are linear, the table contains only min and max.
	 */
	function buildLookupTable(timestamps, min, max, distribution) {
		if (distribution === 'linear' || !timestamps.length) {
			return [
				{time: min, pos: 0},
				{time: max, pos: 1}
			];
		}

		var table = [];
		var items = [min];
		var i, ilen, prev, curr, next;

		for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
			curr = timestamps[i];
			if (curr > min && curr < max) {
				items.push(curr);
			}
		}

		items.push(max);

		for (i = 0, ilen = items.length; i < ilen; ++i) {
			next = items[i + 1];
			prev = items[i - 1];
			curr = items[i];

			// only add points that breaks the scale linearity
			if (prev === undefined || next === undefined || Math.round((next + prev) / 2) !== curr) {
				table.push({time: curr, pos: i / (ilen - 1)});
			}
		}

		return table;
	}

	// @see adapted from http://www.anujgakhar.com/2014/03/01/binary-search-in-javascript/
	function lookup(table, key, value) {
		var lo = 0;
		var hi = table.length - 1;
		var mid, i0, i1;

		while (lo >= 0 && lo <= hi) {
			mid = (lo + hi) >> 1;
			i0 = table[mid - 1] || null;
			i1 = table[mid];

			if (!i0) {
				// given value is outside table (before first item)
				return {lo: null, hi: i1};
			} else if (i1[key] < value) {
				lo = mid + 1;
			} else if (i0[key] > value) {
				hi = mid - 1;
			} else {
				return {lo: i0, hi: i1};
			}
		}

		// given value is outside table (after last item)
		return {lo: i1, hi: null};
	}

	/**
	 * Linearly interpolates the given source `value` using the table items `skey` values and
	 * returns the associated `tkey` value. For example, interpolate(table, 'time', 42, 'pos')
	 * returns the position for a timestamp equal to 42. If value is out of bounds, values at
	 * index [0, 1] or [n - 1, n] are used for the interpolation.
	 */
	function interpolate(table, skey, sval, tkey) {
		var range = lookup(table, skey, sval);

		// Note: the lookup table ALWAYS contains at least 2 items (min and max)
		var prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;
		var next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;

		var span = next[skey] - prev[skey];
		var ratio = span ? (sval - prev[skey]) / span : 0;
		var offset = (next[tkey] - prev[tkey]) * ratio;

		return prev[tkey] + offset;
	}

	/**
	 * Convert the given value to a moment object using the given time options.
	 * @see http://momentjs.com/docs/#/parsing/
	 */
	function momentify(value, options) {
		var parser = options.parser;
		var format = options.parser || options.format;

		if (typeof parser === 'function') {
			return parser(value);
		}

		if (typeof value === 'string' && typeof format === 'string') {
			return moment(value, format);
		}

		if (!(value instanceof moment)) {
			value = moment(value);
		}

		if (value.isValid()) {
			return value;
		}

		// Labels are in an incompatible moment format and no `parser` has been provided.
		// The user might still use the deprecated `format` option to convert his inputs.
		if (typeof format === 'function') {
			return format(value);
		}

		return value;
	}

	function parse(input, scale) {
		if (helpers.isNullOrUndef(input)) {
			return null;
		}

		var options = scale.options.time;
		var value = momentify(scale.getRightValue(input), options);
		if (!value.isValid()) {
			return null;
		}

		if (options.round) {
			value.startOf(options.round);
		}

		return value.valueOf();
	}

	/**
	 * Returns the number of unit to skip to be able to display up to `capacity` number of ticks
	 * in `unit` for the given `min` / `max` range and respecting the interval steps constraints.
	 */
	function determineStepSize(min, max, unit, capacity) {
		var range = max - min;
		var interval = INTERVALS[unit];
		var milliseconds = interval.size;
		var steps = interval.steps;
		var i, ilen, factor;

		if (!steps) {
			return Math.ceil(range / ((capacity || 1) * milliseconds));
		}

		for (i = 0, ilen = steps.length; i < ilen; ++i) {
			factor = steps[i];
			if (Math.ceil(range / (milliseconds * factor)) <= capacity) {
				break;
			}
		}

		return factor;
	}

	/**
	 * Figures out what unit results in an appropriate number of auto-generated ticks
	 */
	function determineUnitForAutoTicks(minUnit, min, max, capacity) {
		var ilen = UNITS.length;
		var i, interval, factor;

		for (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
			interval = INTERVALS[UNITS[i]];
			factor = interval.steps ? interval.steps[interval.steps.length - 1] : MAX_INTEGER;

			if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
				return UNITS[i];
			}
		}

		return UNITS[ilen - 1];
	}

	/**
	 * Figures out what unit to format a set of ticks with
	 */
	function determineUnitForFormatting(ticks, minUnit, min, max) {
		var duration = moment.duration(moment(max).diff(moment(min)));
		var ilen = UNITS.length;
		var i, unit;

		for (i = ilen - 1; i >= UNITS.indexOf(minUnit); i--) {
			unit = UNITS[i];
			if (INTERVALS[unit].common && duration.as(unit) >= ticks.length) {
				return unit;
			}
		}

		return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
	}

	function determineMajorUnit(unit) {
		for (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
			if (INTERVALS[UNITS[i]].common) {
				return UNITS[i];
			}
		}
	}

	/**
	 * Generates a maximum of `capacity` timestamps between min and max, rounded to the
	 * `minor` unit, aligned on the `major` unit and using the given scale time `options`.
	 * Important: this method can return ticks outside the min and max range, it's the
	 * responsibility of the calling code to clamp values if needed.
	 */
	function generate(min, max, capacity, options) {
		var timeOpts = options.time;
		var minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);
		var major = determineMajorUnit(minor);
		var stepSize = helpers.valueOrDefault(timeOpts.stepSize, timeOpts.unitStepSize);
		var weekday = minor === 'week' ? timeOpts.isoWeekday : false;
		var majorTicksEnabled = options.ticks.major.enabled;
		var interval = INTERVALS[minor];
		var first = moment(min);
		var last = moment(max);
		var ticks = [];
		var time;

		if (!stepSize) {
			stepSize = determineStepSize(min, max, minor, capacity);
		}

		// For 'week' unit, handle the first day of week option
		if (weekday) {
			first = first.isoWeekday(weekday);
			last = last.isoWeekday(weekday);
		}

		// Align first/last ticks on unit
		first = first.startOf(weekday ? 'day' : minor);
		last = last.startOf(weekday ? 'day' : minor);

		// Make sure that the last tick include max
		if (last < max) {
			last.add(1, minor);
		}

		time = moment(first);

		if (majorTicksEnabled && major && !weekday && !timeOpts.round) {
			// Align the first tick on the previous `minor` unit aligned on the `major` unit:
			// we first aligned time on the previous `major` unit then add the number of full
			// stepSize there is between first and the previous major time.
			time.startOf(major);
			time.add(~~((first - time) / (interval.size * stepSize)) * stepSize, minor);
		}

		for (; time < last; time.add(stepSize, minor)) {
			ticks.push(+time);
		}

		ticks.push(+time);

		return ticks;
	}

	/**
	 * Returns the right and left offsets from edges in the form of {left, right}.
	 * Offsets are added when the `offset` option is true.
	 */
	function computeOffsets(table, ticks, min, max, options) {
		var left = 0;
		var right = 0;
		var upper, lower;

		if (options.offset && ticks.length) {
			if (!options.time.min) {
				upper = ticks.length > 1 ? ticks[1] : max;
				lower = ticks[0];
				left = (
					interpolate(table, 'time', upper, 'pos') -
					interpolate(table, 'time', lower, 'pos')
				) / 2;
			}
			if (!options.time.max) {
				upper = ticks[ticks.length - 1];
				lower = ticks.length > 1 ? ticks[ticks.length - 2] : min;
				right = (
					interpolate(table, 'time', upper, 'pos') -
					interpolate(table, 'time', lower, 'pos')
				) / 2;
			}
		}

		return {left: left, right: right};
	}

	function ticksFromTimestamps(values, majorUnit) {
		var ticks = [];
		var i, ilen, value, major;

		for (i = 0, ilen = values.length; i < ilen; ++i) {
			value = values[i];
			major = majorUnit ? value === +moment(value).startOf(majorUnit) : false;

			ticks.push({
				value: value,
				major: major
			});
		}

		return ticks;
	}

	module.exports = function(Chart) {

		var defaultConfig = {
			position: 'bottom',

			/**
			 * Data distribution along the scale:
			 * - 'linear': data are spread according to their time (distances can vary),
			 * - 'series': data are spread at the same distance from each other.
			 * @see https://github.com/chartjs/Chart.js/pull/4507
			 * @since 2.7.0
			 */
			distribution: 'linear',

			/**
			 * Scale boundary strategy (bypassed by min/max time options)
			 * - `data`: make sure data are fully visible, ticks outside are removed
			 * - `ticks`: make sure ticks are fully visible, data outside are truncated
			 * @see https://github.com/chartjs/Chart.js/pull/4556
			 * @since 2.7.0
			 */
			bounds: 'data',

			time: {
				parser: false, // false == a pattern string from http://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment
				format: false, // DEPRECATED false == date objects, moment object, callback or a pattern string from http://momentjs.com/docs/#/parsing/string-format/
				unit: false, // false == automatic or override with week, month, year, etc.
				round: false, // none, or override with week, month, year, etc.
				displayFormat: false, // DEPRECATED
				isoWeekday: false, // override week start day - see http://momentjs.com/docs/#/get-set/iso-weekday/
				minUnit: 'millisecond',

				// defaults to unit's corresponding unitFormat below or override using pattern string from http://momentjs.com/docs/#/displaying/format/
				displayFormats: {
					millisecond: 'h:mm:ss.SSS a', // 11:20:01.123 AM,
					second: 'h:mm:ss a', // 11:20:01 AM
					minute: 'h:mm a', // 11:20 AM
					hour: 'hA', // 5PM
					day: 'MMM D', // Sep 4
					week: 'll', // Week 46, or maybe "[W]WW - YYYY" ?
					month: 'MMM YYYY', // Sept 2015
					quarter: '[Q]Q - YYYY', // Q3
					year: 'YYYY' // 2015
				},
			},
			ticks: {
				autoSkip: false,

				/**
				 * Ticks generation input values:
				 * - 'auto': generates "optimal" ticks based on scale size and time options.
				 * - 'data': generates ticks from data (including labels from data {t|x|y} objects).
				 * - 'labels': generates ticks from user given `data.labels` values ONLY.
				 * @see https://github.com/chartjs/Chart.js/pull/4507
				 * @since 2.7.0
				 */
				source: 'auto',

				major: {
					enabled: false
				}
			}
		};

		var TimeScale = Chart.Scale.extend({
			initialize: function() {
				if (!moment) {
					throw new Error('Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com');
				}

				this.mergeTicksOptions();

				Chart.Scale.prototype.initialize.call(this);
			},

			update: function() {
				var me = this;
				var options = me.options;

				// DEPRECATIONS: output a message only one time per update
				if (options.time && options.time.format) {
					console.warn('options.time.format is deprecated and replaced by options.time.parser.');
				}

				return Chart.Scale.prototype.update.apply(me, arguments);
			},

			/**
			 * Allows data to be referenced via 't' attribute
			 */
			getRightValue: function(rawValue) {
				if (rawValue && rawValue.t !== undefined) {
					rawValue = rawValue.t;
				}
				return Chart.Scale.prototype.getRightValue.call(this, rawValue);
			},

			determineDataLimits: function() {
				var me = this;
				var chart = me.chart;
				var timeOpts = me.options.time;
				var min = MAX_INTEGER;
				var max = MIN_INTEGER;
				var timestamps = [];
				var datasets = [];
				var labels = [];
				var i, j, ilen, jlen, data, timestamp;

				// Convert labels to timestamps
				for (i = 0, ilen = chart.data.labels.length; i < ilen; ++i) {
					labels.push(parse(chart.data.labels[i], me));
				}

				// Convert data to timestamps
				for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
					if (chart.isDatasetVisible(i)) {
						data = chart.data.datasets[i].data;

						// Let's consider that all data have the same format.
						if (helpers.isObject(data[0])) {
							datasets[i] = [];

							for (j = 0, jlen = data.length; j < jlen; ++j) {
								timestamp = parse(data[j], me);
								timestamps.push(timestamp);
								datasets[i][j] = timestamp;
							}
						} else {
							timestamps.push.apply(timestamps, labels);
							datasets[i] = labels.slice(0);
						}
					} else {
						datasets[i] = [];
					}
				}

				if (labels.length) {
					// Sort labels **after** data have been converted
					labels = arrayUnique(labels).sort(sorter);
					min = Math.min(min, labels[0]);
					max = Math.max(max, labels[labels.length - 1]);
				}

				if (timestamps.length) {
					timestamps = arrayUnique(timestamps).sort(sorter);
					min = Math.min(min, timestamps[0]);
					max = Math.max(max, timestamps[timestamps.length - 1]);
				}

				min = parse(timeOpts.min, me) || min;
				max = parse(timeOpts.max, me) || max;

				// In case there is no valid min/max, let's use today limits
				min = min === MAX_INTEGER ? +moment().startOf('day') : min;
				max = max === MIN_INTEGER ? +moment().endOf('day') + 1 : max;

				// Make sure that max is strictly higher than min (required by the lookup table)
				me.min = Math.min(min, max);
				me.max = Math.max(min + 1, max);

				// PRIVATE
				me._horizontal = me.isHorizontal();
				me._table = [];
				me._timestamps = {
					data: timestamps,
					datasets: datasets,
					labels: labels
				};
			},

			buildTicks: function() {
				var me = this;
				var min = me.min;
				var max = me.max;
				var options = me.options;
				var timeOpts = options.time;
				var timestamps = [];
				var ticks = [];
				var i, ilen, timestamp;

				switch (options.ticks.source) {
				case 'data':
					timestamps = me._timestamps.data;
					break;
				case 'labels':
					timestamps = me._timestamps.labels;
					break;
				case 'auto':
				default:
					timestamps = generate(min, max, me.getLabelCapacity(min), options);
				}

				if (options.bounds === 'ticks' && timestamps.length) {
					min = timestamps[0];
					max = timestamps[timestamps.length - 1];
				}

				// Enforce limits with user min/max options
				min = parse(timeOpts.min, me) || min;
				max = parse(timeOpts.max, me) || max;

				// Remove ticks outside the min/max range
				for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
					timestamp = timestamps[i];
					if (timestamp >= min && timestamp <= max) {
						ticks.push(timestamp);
					}
				}

				me.min = min;
				me.max = max;

				// PRIVATE
				me._unit = timeOpts.unit || determineUnitForFormatting(ticks, timeOpts.minUnit, me.min, me.max);
				me._majorUnit = determineMajorUnit(me._unit);
				me._table = buildLookupTable(me._timestamps.data, min, max, options.distribution);
				me._offsets = computeOffsets(me._table, ticks, min, max, options);

				return ticksFromTimestamps(ticks, me._majorUnit);
			},

			getLabelForIndex: function(index, datasetIndex) {
				var me = this;
				var data = me.chart.data;
				var timeOpts = me.options.time;
				var label = data.labels && index < data.labels.length ? data.labels[index] : '';
				var value = data.datasets[datasetIndex].data[index];

				if (helpers.isObject(value)) {
					label = me.getRightValue(value);
				}
				if (timeOpts.tooltipFormat) {
					label = momentify(label, timeOpts).format(timeOpts.tooltipFormat);
				}

				return label;
			},

			/**
			 * Function to format an individual tick mark
			 * @private
			 */
			tickFormatFunction: function(tick, index, ticks, formatOverride) {
				var me = this;
				var options = me.options;
				var time = tick.valueOf();
				var formats = options.time.displayFormats;
				var minorFormat = formats[me._unit];
				var majorUnit = me._majorUnit;
				var majorFormat = formats[majorUnit];
				var majorTime = tick.clone().startOf(majorUnit).valueOf();
				var majorTickOpts = options.ticks.major;
				var major = majorTickOpts.enabled && majorUnit && majorFormat && time === majorTime;
				var label = tick.format(formatOverride ? formatOverride : major ? majorFormat : minorFormat);
				var tickOpts = major ? majorTickOpts : options.ticks.minor;
				var formatter = helpers.valueOrDefault(tickOpts.callback, tickOpts.userCallback);

				return formatter ? formatter(label, index, ticks) : label;
			},

			convertTicksToLabels: function(ticks) {
				var labels = [];
				var i, ilen;

				for (i = 0, ilen = ticks.length; i < ilen; ++i) {
					labels.push(this.tickFormatFunction(moment(ticks[i].value), i, ticks));
				}

				return labels;
			},

			/**
			 * @private
			 */
			getPixelForOffset: function(time) {
				var me = this;
				var size = me._horizontal ? me.width : me.height;
				var start = me._horizontal ? me.left : me.top;
				var pos = interpolate(me._table, 'time', time, 'pos');

				return start + size * (me._offsets.left + pos) / (me._offsets.left + 1 + me._offsets.right);
			},

			getPixelForValue: function(value, index, datasetIndex) {
				var me = this;
				var time = null;

				if (index !== undefined && datasetIndex !== undefined) {
					time = me._timestamps.datasets[datasetIndex][index];
				}

				if (time === null) {
					time = parse(value, me);
				}

				if (time !== null) {
					return me.getPixelForOffset(time);
				}
			},

			getPixelForTick: function(index) {
				var ticks = this.getTicks();
				return index >= 0 && index < ticks.length ?
					this.getPixelForOffset(ticks[index].value) :
					null;
			},

			getValueForPixel: function(pixel) {
				var me = this;
				var size = me._horizontal ? me.width : me.height;
				var start = me._horizontal ? me.left : me.top;
				var pos = (size ? (pixel - start) / size : 0) * (me._offsets.left + 1 + me._offsets.left) - me._offsets.right;
				var time = interpolate(me._table, 'pos', pos, 'time');

				return moment(time);
			},

			/**
			 * Crude approximation of what the label width might be
			 * @private
			 */
			getLabelWidth: function(label) {
				var me = this;
				var ticksOpts = me.options.ticks;
				var tickLabelWidth = me.ctx.measureText(label).width;
				var angle = helpers.toRadians(ticksOpts.maxRotation);
				var cosRotation = Math.cos(angle);
				var sinRotation = Math.sin(angle);
				var tickFontSize = helpers.valueOrDefault(ticksOpts.fontSize, defaults.global.defaultFontSize);

				return (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation);
			},

			/**
			 * @private
			 */
			getLabelCapacity: function(exampleTime) {
				var me = this;

				var formatOverride = me.options.time.displayFormats.millisecond;	// Pick the longest format for guestimation

				var exampleLabel = me.tickFormatFunction(moment(exampleTime), 0, [], formatOverride);
				var tickLabelWidth = me.getLabelWidth(exampleLabel);
				var innerWidth = me.isHorizontal() ? me.width : me.height;

				return Math.floor(innerWidth / tickLabelWidth);
			}
		});

		Chart.scaleService.registerScaleType('time', TimeScale, defaultConfig);
	};


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {//! moment.js
	//! version : 2.18.1
	//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
	//! license : MIT
	//! momentjs.com

	;(function (global, factory) {
	     true ? module.exports = factory() :
	    typeof define === 'function' && define.amd ? define(factory) :
	    global.moment = factory()
	}(this, (function () { 'use strict';

	var hookCallback;

	function hooks () {
	    return hookCallback.apply(null, arguments);
	}

	// This is done to register the method called with moment()
	// without creating circular dependencies.
	function setHookCallback (callback) {
	    hookCallback = callback;
	}

	function isArray(input) {
	    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
	}

	function isObject(input) {
	    // IE8 will treat undefined and null as object if it wasn't for
	    // input != null
	    return input != null && Object.prototype.toString.call(input) === '[object Object]';
	}

	function isObjectEmpty(obj) {
	    var k;
	    for (k in obj) {
	        // even if its not own property I'd still call it non-empty
	        return false;
	    }
	    return true;
	}

	function isUndefined(input) {
	    return input === void 0;
	}

	function isNumber(input) {
	    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
	}

	function isDate(input) {
	    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
	}

	function map(arr, fn) {
	    var res = [], i;
	    for (i = 0; i < arr.length; ++i) {
	        res.push(fn(arr[i], i));
	    }
	    return res;
	}

	function hasOwnProp(a, b) {
	    return Object.prototype.hasOwnProperty.call(a, b);
	}

	function extend(a, b) {
	    for (var i in b) {
	        if (hasOwnProp(b, i)) {
	            a[i] = b[i];
	        }
	    }

	    if (hasOwnProp(b, 'toString')) {
	        a.toString = b.toString;
	    }

	    if (hasOwnProp(b, 'valueOf')) {
	        a.valueOf = b.valueOf;
	    }

	    return a;
	}

	function createUTC (input, format, locale, strict) {
	    return createLocalOrUTC(input, format, locale, strict, true).utc();
	}

	function defaultParsingFlags() {
	    // We need to deep clone this object.
	    return {
	        empty           : false,
	        unusedTokens    : [],
	        unusedInput     : [],
	        overflow        : -2,
	        charsLeftOver   : 0,
	        nullInput       : false,
	        invalidMonth    : null,
	        invalidFormat   : false,
	        userInvalidated : false,
	        iso             : false,
	        parsedDateParts : [],
	        meridiem        : null,
	        rfc2822         : false,
	        weekdayMismatch : false
	    };
	}

	function getParsingFlags(m) {
	    if (m._pf == null) {
	        m._pf = defaultParsingFlags();
	    }
	    return m._pf;
	}

	var some;
	if (Array.prototype.some) {
	    some = Array.prototype.some;
	} else {
	    some = function (fun) {
	        var t = Object(this);
	        var len = t.length >>> 0;

	        for (var i = 0; i < len; i++) {
	            if (i in t && fun.call(this, t[i], i, t)) {
	                return true;
	            }
	        }

	        return false;
	    };
	}

	var some$1 = some;

	function isValid(m) {
	    if (m._isValid == null) {
	        var flags = getParsingFlags(m);
	        var parsedParts = some$1.call(flags.parsedDateParts, function (i) {
	            return i != null;
	        });
	        var isNowValid = !isNaN(m._d.getTime()) &&
	            flags.overflow < 0 &&
	            !flags.empty &&
	            !flags.invalidMonth &&
	            !flags.invalidWeekday &&
	            !flags.nullInput &&
	            !flags.invalidFormat &&
	            !flags.userInvalidated &&
	            (!flags.meridiem || (flags.meridiem && parsedParts));

	        if (m._strict) {
	            isNowValid = isNowValid &&
	                flags.charsLeftOver === 0 &&
	                flags.unusedTokens.length === 0 &&
	                flags.bigHour === undefined;
	        }

	        if (Object.isFrozen == null || !Object.isFrozen(m)) {
	            m._isValid = isNowValid;
	        }
	        else {
	            return isNowValid;
	        }
	    }
	    return m._isValid;
	}

	function createInvalid (flags) {
	    var m = createUTC(NaN);
	    if (flags != null) {
	        extend(getParsingFlags(m), flags);
	    }
	    else {
	        getParsingFlags(m).userInvalidated = true;
	    }

	    return m;
	}

	// Plugins that add properties should also add the key here (null value),
	// so we can properly clone ourselves.
	var momentProperties = hooks.momentProperties = [];

	function copyConfig(to, from) {
	    var i, prop, val;

	    if (!isUndefined(from._isAMomentObject)) {
	        to._isAMomentObject = from._isAMomentObject;
	    }
	    if (!isUndefined(from._i)) {
	        to._i = from._i;
	    }
	    if (!isUndefined(from._f)) {
	        to._f = from._f;
	    }
	    if (!isUndefined(from._l)) {
	        to._l = from._l;
	    }
	    if (!isUndefined(from._strict)) {
	        to._strict = from._strict;
	    }
	    if (!isUndefined(from._tzm)) {
	        to._tzm = from._tzm;
	    }
	    if (!isUndefined(from._isUTC)) {
	        to._isUTC = from._isUTC;
	    }
	    if (!isUndefined(from._offset)) {
	        to._offset = from._offset;
	    }
	    if (!isUndefined(from._pf)) {
	        to._pf = getParsingFlags(from);
	    }
	    if (!isUndefined(from._locale)) {
	        to._locale = from._locale;
	    }

	    if (momentProperties.length > 0) {
	        for (i = 0; i < momentProperties.length; i++) {
	            prop = momentProperties[i];
	            val = from[prop];
	            if (!isUndefined(val)) {
	                to[prop] = val;
	            }
	        }
	    }

	    return to;
	}

	var updateInProgress = false;

	// Moment prototype object
	function Moment(config) {
	    copyConfig(this, config);
	    this._d = new Date(config._d != null ? config._d.getTime() : NaN);
	    if (!this.isValid()) {
	        this._d = new Date(NaN);
	    }
	    // Prevent infinite loop in case updateOffset creates new moment
	    // objects.
	    if (updateInProgress === false) {
	        updateInProgress = true;
	        hooks.updateOffset(this);
	        updateInProgress = false;
	    }
	}

	function isMoment (obj) {
	    return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
	}

	function absFloor (number) {
	    if (number < 0) {
	        // -0 -> 0
	        return Math.ceil(number) || 0;
	    } else {
	        return Math.floor(number);
	    }
	}

	function toInt(argumentForCoercion) {
	    var coercedNumber = +argumentForCoercion,
	        value = 0;

	    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
	        value = absFloor(coercedNumber);
	    }

	    return value;
	}

	// compare two arrays, return the number of differences
	function compareArrays(array1, array2, dontConvert) {
	    var len = Math.min(array1.length, array2.length),
	        lengthDiff = Math.abs(array1.length - array2.length),
	        diffs = 0,
	        i;
	    for (i = 0; i < len; i++) {
	        if ((dontConvert && array1[i] !== array2[i]) ||
	            (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
	            diffs++;
	        }
	    }
	    return diffs + lengthDiff;
	}

	function warn(msg) {
	    if (hooks.suppressDeprecationWarnings === false &&
	            (typeof console !==  'undefined') && console.warn) {
	        console.warn('Deprecation warning: ' + msg);
	    }
	}

	function deprecate(msg, fn) {
	    var firstTime = true;

	    return extend(function () {
	        if (hooks.deprecationHandler != null) {
	            hooks.deprecationHandler(null, msg);
	        }
	        if (firstTime) {
	            var args = [];
	            var arg;
	            for (var i = 0; i < arguments.length; i++) {
	                arg = '';
	                if (typeof arguments[i] === 'object') {
	                    arg += '\n[' + i + '] ';
	                    for (var key in arguments[0]) {
	                        arg += key + ': ' + arguments[0][key] + ', ';
	                    }
	                    arg = arg.slice(0, -2); // Remove trailing comma and space
	                } else {
	                    arg = arguments[i];
	                }
	                args.push(arg);
	            }
	            warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
	            firstTime = false;
	        }
	        return fn.apply(this, arguments);
	    }, fn);
	}

	var deprecations = {};

	function deprecateSimple(name, msg) {
	    if (hooks.deprecationHandler != null) {
	        hooks.deprecationHandler(name, msg);
	    }
	    if (!deprecations[name]) {
	        warn(msg);
	        deprecations[name] = true;
	    }
	}

	hooks.suppressDeprecationWarnings = false;
	hooks.deprecationHandler = null;

	function isFunction(input) {
	    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
	}

	function set (config) {
	    var prop, i;
	    for (i in config) {
	        prop = config[i];
	        if (isFunction(prop)) {
	            this[i] = prop;
	        } else {
	            this['_' + i] = prop;
	        }
	    }
	    this._config = config;
	    // Lenient ordinal parsing accepts just a number in addition to
	    // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
	    // TODO: Remove "ordinalParse" fallback in next major release.
	    this._dayOfMonthOrdinalParseLenient = new RegExp(
	        (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
	            '|' + (/\d{1,2}/).source);
	}

	function mergeConfigs(parentConfig, childConfig) {
	    var res = extend({}, parentConfig), prop;
	    for (prop in childConfig) {
	        if (hasOwnProp(childConfig, prop)) {
	            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
	                res[prop] = {};
	                extend(res[prop], parentConfig[prop]);
	                extend(res[prop], childConfig[prop]);
	            } else if (childConfig[prop] != null) {
	                res[prop] = childConfig[prop];
	            } else {
	                delete res[prop];
	            }
	        }
	    }
	    for (prop in parentConfig) {
	        if (hasOwnProp(parentConfig, prop) &&
	                !hasOwnProp(childConfig, prop) &&
	                isObject(parentConfig[prop])) {
	            // make sure changes to properties don't modify parent config
	            res[prop] = extend({}, res[prop]);
	        }
	    }
	    return res;
	}

	function Locale(config) {
	    if (config != null) {
	        this.set(config);
	    }
	}

	var keys;

	if (Object.keys) {
	    keys = Object.keys;
	} else {
	    keys = function (obj) {
	        var i, res = [];
	        for (i in obj) {
	            if (hasOwnProp(obj, i)) {
	                res.push(i);
	            }
	        }
	        return res;
	    };
	}

	var keys$1 = keys;

	var defaultCalendar = {
	    sameDay : '[Today at] LT',
	    nextDay : '[Tomorrow at] LT',
	    nextWeek : 'dddd [at] LT',
	    lastDay : '[Yesterday at] LT',
	    lastWeek : '[Last] dddd [at] LT',
	    sameElse : 'L'
	};

	function calendar (key, mom, now) {
	    var output = this._calendar[key] || this._calendar['sameElse'];
	    return isFunction(output) ? output.call(mom, now) : output;
	}

	var defaultLongDateFormat = {
	    LTS  : 'h:mm:ss A',
	    LT   : 'h:mm A',
	    L    : 'MM/DD/YYYY',
	    LL   : 'MMMM D, YYYY',
	    LLL  : 'MMMM D, YYYY h:mm A',
	    LLLL : 'dddd, MMMM D, YYYY h:mm A'
	};

	function longDateFormat (key) {
	    var format = this._longDateFormat[key],
	        formatUpper = this._longDateFormat[key.toUpperCase()];

	    if (format || !formatUpper) {
	        return format;
	    }

	    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
	        return val.slice(1);
	    });

	    return this._longDateFormat[key];
	}

	var defaultInvalidDate = 'Invalid date';

	function invalidDate () {
	    return this._invalidDate;
	}

	var defaultOrdinal = '%d';
	var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

	function ordinal (number) {
	    return this._ordinal.replace('%d', number);
	}

	var defaultRelativeTime = {
	    future : 'in %s',
	    past   : '%s ago',
	    s  : 'a few seconds',
	    ss : '%d seconds',
	    m  : 'a minute',
	    mm : '%d minutes',
	    h  : 'an hour',
	    hh : '%d hours',
	    d  : 'a day',
	    dd : '%d days',
	    M  : 'a month',
	    MM : '%d months',
	    y  : 'a year',
	    yy : '%d years'
	};

	function relativeTime (number, withoutSuffix, string, isFuture) {
	    var output = this._relativeTime[string];
	    return (isFunction(output)) ?
	        output(number, withoutSuffix, string, isFuture) :
	        output.replace(/%d/i, number);
	}

	function pastFuture (diff, output) {
	    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
	    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
	}

	var aliases = {};

	function addUnitAlias (unit, shorthand) {
	    var lowerCase = unit.toLowerCase();
	    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
	}

	function normalizeUnits(units) {
	    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
	}

	function normalizeObjectUnits(inputObject) {
	    var normalizedInput = {},
	        normalizedProp,
	        prop;

	    for (prop in inputObject) {
	        if (hasOwnProp(inputObject, prop)) {
	            normalizedProp = normalizeUnits(prop);
	            if (normalizedProp) {
	                normalizedInput[normalizedProp] = inputObject[prop];
	            }
	        }
	    }

	    return normalizedInput;
	}

	var priorities = {};

	function addUnitPriority(unit, priority) {
	    priorities[unit] = priority;
	}

	function getPrioritizedUnits(unitsObj) {
	    var units = [];
	    for (var u in unitsObj) {
	        units.push({unit: u, priority: priorities[u]});
	    }
	    units.sort(function (a, b) {
	        return a.priority - b.priority;
	    });
	    return units;
	}

	function makeGetSet (unit, keepTime) {
	    return function (value) {
	        if (value != null) {
	            set$1(this, unit, value);
	            hooks.updateOffset(this, keepTime);
	            return this;
	        } else {
	            return get(this, unit);
	        }
	    };
	}

	function get (mom, unit) {
	    return mom.isValid() ?
	        mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
	}

	function set$1 (mom, unit, value) {
	    if (mom.isValid()) {
	        mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
	    }
	}

	// MOMENTS

	function stringGet (units) {
	    units = normalizeUnits(units);
	    if (isFunction(this[units])) {
	        return this[units]();
	    }
	    return this;
	}


	function stringSet (units, value) {
	    if (typeof units === 'object') {
	        units = normalizeObjectUnits(units);
	        var prioritized = getPrioritizedUnits(units);
	        for (var i = 0; i < prioritized.length; i++) {
	            this[prioritized[i].unit](units[prioritized[i].unit]);
	        }
	    } else {
	        units = normalizeUnits(units);
	        if (isFunction(this[units])) {
	            return this[units](value);
	        }
	    }
	    return this;
	}

	function zeroFill(number, targetLength, forceSign) {
	    var absNumber = '' + Math.abs(number),
	        zerosToFill = targetLength - absNumber.length,
	        sign = number >= 0;
	    return (sign ? (forceSign ? '+' : '') : '-') +
	        Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
	}

	var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

	var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

	var formatFunctions = {};

	var formatTokenFunctions = {};

	// token:    'M'
	// padded:   ['MM', 2]
	// ordinal:  'Mo'
	// callback: function () { this.month() + 1 }
	function addFormatToken (token, padded, ordinal, callback) {
	    var func = callback;
	    if (typeof callback === 'string') {
	        func = function () {
	            return this[callback]();
	        };
	    }
	    if (token) {
	        formatTokenFunctions[token] = func;
	    }
	    if (padded) {
	        formatTokenFunctions[padded[0]] = function () {
	            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
	        };
	    }
	    if (ordinal) {
	        formatTokenFunctions[ordinal] = function () {
	            return this.localeData().ordinal(func.apply(this, arguments), token);
	        };
	    }
	}

	function removeFormattingTokens(input) {
	    if (input.match(/\[[\s\S]/)) {
	        return input.replace(/^\[|\]$/g, '');
	    }
	    return input.replace(/\\/g, '');
	}

	function makeFormatFunction(format) {
	    var array = format.match(formattingTokens), i, length;

	    for (i = 0, length = array.length; i < length; i++) {
	        if (formatTokenFunctions[array[i]]) {
	            array[i] = formatTokenFunctions[array[i]];
	        } else {
	            array[i] = removeFormattingTokens(array[i]);
	        }
	    }

	    return function (mom) {
	        var output = '', i;
	        for (i = 0; i < length; i++) {
	            output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
	        }
	        return output;
	    };
	}

	// format date using native date object
	function formatMoment(m, format) {
	    if (!m.isValid()) {
	        return m.localeData().invalidDate();
	    }

	    format = expandFormat(format, m.localeData());
	    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

	    return formatFunctions[format](m);
	}

	function expandFormat(format, locale) {
	    var i = 5;

	    function replaceLongDateFormatTokens(input) {
	        return locale.longDateFormat(input) || input;
	    }

	    localFormattingTokens.lastIndex = 0;
	    while (i >= 0 && localFormattingTokens.test(format)) {
	        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
	        localFormattingTokens.lastIndex = 0;
	        i -= 1;
	    }

	    return format;
	}

	var match1         = /\d/;            //       0 - 9
	var match2         = /\d\d/;          //      00 - 99
	var match3         = /\d{3}/;         //     000 - 999
	var match4         = /\d{4}/;         //    0000 - 9999
	var match6         = /[+-]?\d{6}/;    // -999999 - 999999
	var match1to2      = /\d\d?/;         //       0 - 99
	var match3to4      = /\d\d\d\d?/;     //     999 - 9999
	var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
	var match1to3      = /\d{1,3}/;       //       0 - 999
	var match1to4      = /\d{1,4}/;       //       0 - 9999
	var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

	var matchUnsigned  = /\d+/;           //       0 - inf
	var matchSigned    = /[+-]?\d+/;      //    -inf - inf

	var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
	var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

	var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

	// any word (or two) characters or numbers including two/three word month in arabic.
	// includes scottish gaelic two word and hyphenated months
	var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;


	var regexes = {};

	function addRegexToken (token, regex, strictRegex) {
	    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
	        return (isStrict && strictRegex) ? strictRegex : regex;
	    };
	}

	function getParseRegexForToken (token, config) {
	    if (!hasOwnProp(regexes, token)) {
	        return new RegExp(unescapeFormat(token));
	    }

	    return regexes[token](config._strict, config._locale);
	}

	// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
	function unescapeFormat(s) {
	    return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
	        return p1 || p2 || p3 || p4;
	    }));
	}

	function regexEscape(s) {
	    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
	}

	var tokens = {};

	function addParseToken (token, callback) {
	    var i, func = callback;
	    if (typeof token === 'string') {
	        token = [token];
	    }
	    if (isNumber(callback)) {
	        func = function (input, array) {
	            array[callback] = toInt(input);
	        };
	    }
	    for (i = 0; i < token.length; i++) {
	        tokens[token[i]] = func;
	    }
	}

	function addWeekParseToken (token, callback) {
	    addParseToken(token, function (input, array, config, token) {
	        config._w = config._w || {};
	        callback(input, config._w, config, token);
	    });
	}

	function addTimeToArrayFromToken(token, input, config) {
	    if (input != null && hasOwnProp(tokens, token)) {
	        tokens[token](input, config._a, config, token);
	    }
	}

	var YEAR = 0;
	var MONTH = 1;
	var DATE = 2;
	var HOUR = 3;
	var MINUTE = 4;
	var SECOND = 5;
	var MILLISECOND = 6;
	var WEEK = 7;
	var WEEKDAY = 8;

	var indexOf;

	if (Array.prototype.indexOf) {
	    indexOf = Array.prototype.indexOf;
	} else {
	    indexOf = function (o) {
	        // I know
	        var i;
	        for (i = 0; i < this.length; ++i) {
	            if (this[i] === o) {
	                return i;
	            }
	        }
	        return -1;
	    };
	}

	var indexOf$1 = indexOf;

	function daysInMonth(year, month) {
	    return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
	}

	// FORMATTING

	addFormatToken('M', ['MM', 2], 'Mo', function () {
	    return this.month() + 1;
	});

	addFormatToken('MMM', 0, 0, function (format) {
	    return this.localeData().monthsShort(this, format);
	});

	addFormatToken('MMMM', 0, 0, function (format) {
	    return this.localeData().months(this, format);
	});

	// ALIASES

	addUnitAlias('month', 'M');

	// PRIORITY

	addUnitPriority('month', 8);

	// PARSING

	addRegexToken('M',    match1to2);
	addRegexToken('MM',   match1to2, match2);
	addRegexToken('MMM',  function (isStrict, locale) {
	    return locale.monthsShortRegex(isStrict);
	});
	addRegexToken('MMMM', function (isStrict, locale) {
	    return locale.monthsRegex(isStrict);
	});

	addParseToken(['M', 'MM'], function (input, array) {
	    array[MONTH] = toInt(input) - 1;
	});

	addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
	    var month = config._locale.monthsParse(input, token, config._strict);
	    // if we didn't find a month name, mark the date as invalid.
	    if (month != null) {
	        array[MONTH] = month;
	    } else {
	        getParsingFlags(config).invalidMonth = input;
	    }
	});

	// LOCALES

	var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
	var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
	function localeMonths (m, format) {
	    if (!m) {
	        return isArray(this._months) ? this._months :
	            this._months['standalone'];
	    }
	    return isArray(this._months) ? this._months[m.month()] :
	        this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
	}

	var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
	function localeMonthsShort (m, format) {
	    if (!m) {
	        return isArray(this._monthsShort) ? this._monthsShort :
	            this._monthsShort['standalone'];
	    }
	    return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
	        this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
	}

	function handleStrictParse(monthName, format, strict) {
	    var i, ii, mom, llc = monthName.toLocaleLowerCase();
	    if (!this._monthsParse) {
	        // this is not used
	        this._monthsParse = [];
	        this._longMonthsParse = [];
	        this._shortMonthsParse = [];
	        for (i = 0; i < 12; ++i) {
	            mom = createUTC([2000, i]);
	            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
	            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
	        }
	    }

	    if (strict) {
	        if (format === 'MMM') {
	            ii = indexOf$1.call(this._shortMonthsParse, llc);
	            return ii !== -1 ? ii : null;
	        } else {
	            ii = indexOf$1.call(this._longMonthsParse, llc);
	            return ii !== -1 ? ii : null;
	        }
	    } else {
	        if (format === 'MMM') {
	            ii = indexOf$1.call(this._shortMonthsParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf$1.call(this._longMonthsParse, llc);
	            return ii !== -1 ? ii : null;
	        } else {
	            ii = indexOf$1.call(this._longMonthsParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf$1.call(this._shortMonthsParse, llc);
	            return ii !== -1 ? ii : null;
	        }
	    }
	}

	function localeMonthsParse (monthName, format, strict) {
	    var i, mom, regex;

	    if (this._monthsParseExact) {
	        return handleStrictParse.call(this, monthName, format, strict);
	    }

	    if (!this._monthsParse) {
	        this._monthsParse = [];
	        this._longMonthsParse = [];
	        this._shortMonthsParse = [];
	    }

	    // TODO: add sorting
	    // Sorting makes sure if one month (or abbr) is a prefix of another
	    // see sorting in computeMonthsParse
	    for (i = 0; i < 12; i++) {
	        // make the regex if we don't have it already
	        mom = createUTC([2000, i]);
	        if (strict && !this._longMonthsParse[i]) {
	            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
	            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
	        }
	        if (!strict && !this._monthsParse[i]) {
	            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
	            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
	        }
	        // test the regex
	        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
	            return i;
	        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
	            return i;
	        } else if (!strict && this._monthsParse[i].test(monthName)) {
	            return i;
	        }
	    }
	}

	// MOMENTS

	function setMonth (mom, value) {
	    var dayOfMonth;

	    if (!mom.isValid()) {
	        // No op
	        return mom;
	    }

	    if (typeof value === 'string') {
	        if (/^\d+$/.test(value)) {
	            value = toInt(value);
	        } else {
	            value = mom.localeData().monthsParse(value);
	            // TODO: Another silent failure?
	            if (!isNumber(value)) {
	                return mom;
	            }
	        }
	    }

	    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
	    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
	    return mom;
	}

	function getSetMonth (value) {
	    if (value != null) {
	        setMonth(this, value);
	        hooks.updateOffset(this, true);
	        return this;
	    } else {
	        return get(this, 'Month');
	    }
	}

	function getDaysInMonth () {
	    return daysInMonth(this.year(), this.month());
	}

	var defaultMonthsShortRegex = matchWord;
	function monthsShortRegex (isStrict) {
	    if (this._monthsParseExact) {
	        if (!hasOwnProp(this, '_monthsRegex')) {
	            computeMonthsParse.call(this);
	        }
	        if (isStrict) {
	            return this._monthsShortStrictRegex;
	        } else {
	            return this._monthsShortRegex;
	        }
	    } else {
	        if (!hasOwnProp(this, '_monthsShortRegex')) {
	            this._monthsShortRegex = defaultMonthsShortRegex;
	        }
	        return this._monthsShortStrictRegex && isStrict ?
	            this._monthsShortStrictRegex : this._monthsShortRegex;
	    }
	}

	var defaultMonthsRegex = matchWord;
	function monthsRegex (isStrict) {
	    if (this._monthsParseExact) {
	        if (!hasOwnProp(this, '_monthsRegex')) {
	            computeMonthsParse.call(this);
	        }
	        if (isStrict) {
	            return this._monthsStrictRegex;
	        } else {
	            return this._monthsRegex;
	        }
	    } else {
	        if (!hasOwnProp(this, '_monthsRegex')) {
	            this._monthsRegex = defaultMonthsRegex;
	        }
	        return this._monthsStrictRegex && isStrict ?
	            this._monthsStrictRegex : this._monthsRegex;
	    }
	}

	function computeMonthsParse () {
	    function cmpLenRev(a, b) {
	        return b.length - a.length;
	    }

	    var shortPieces = [], longPieces = [], mixedPieces = [],
	        i, mom;
	    for (i = 0; i < 12; i++) {
	        // make the regex if we don't have it already
	        mom = createUTC([2000, i]);
	        shortPieces.push(this.monthsShort(mom, ''));
	        longPieces.push(this.months(mom, ''));
	        mixedPieces.push(this.months(mom, ''));
	        mixedPieces.push(this.monthsShort(mom, ''));
	    }
	    // Sorting makes sure if one month (or abbr) is a prefix of another it
	    // will match the longer piece.
	    shortPieces.sort(cmpLenRev);
	    longPieces.sort(cmpLenRev);
	    mixedPieces.sort(cmpLenRev);
	    for (i = 0; i < 12; i++) {
	        shortPieces[i] = regexEscape(shortPieces[i]);
	        longPieces[i] = regexEscape(longPieces[i]);
	    }
	    for (i = 0; i < 24; i++) {
	        mixedPieces[i] = regexEscape(mixedPieces[i]);
	    }

	    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
	    this._monthsShortRegex = this._monthsRegex;
	    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
	    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
	}

	// FORMATTING

	addFormatToken('Y', 0, 0, function () {
	    var y = this.year();
	    return y <= 9999 ? '' + y : '+' + y;
	});

	addFormatToken(0, ['YY', 2], 0, function () {
	    return this.year() % 100;
	});

	addFormatToken(0, ['YYYY',   4],       0, 'year');
	addFormatToken(0, ['YYYYY',  5],       0, 'year');
	addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

	// ALIASES

	addUnitAlias('year', 'y');

	// PRIORITIES

	addUnitPriority('year', 1);

	// PARSING

	addRegexToken('Y',      matchSigned);
	addRegexToken('YY',     match1to2, match2);
	addRegexToken('YYYY',   match1to4, match4);
	addRegexToken('YYYYY',  match1to6, match6);
	addRegexToken('YYYYYY', match1to6, match6);

	addParseToken(['YYYYY', 'YYYYYY'], YEAR);
	addParseToken('YYYY', function (input, array) {
	    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
	});
	addParseToken('YY', function (input, array) {
	    array[YEAR] = hooks.parseTwoDigitYear(input);
	});
	addParseToken('Y', function (input, array) {
	    array[YEAR] = parseInt(input, 10);
	});

	// HELPERS

	function daysInYear(year) {
	    return isLeapYear(year) ? 366 : 365;
	}

	function isLeapYear(year) {
	    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
	}

	// HOOKS

	hooks.parseTwoDigitYear = function (input) {
	    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
	};

	// MOMENTS

	var getSetYear = makeGetSet('FullYear', true);

	function getIsLeapYear () {
	    return isLeapYear(this.year());
	}

	function createDate (y, m, d, h, M, s, ms) {
	    // can't just apply() to create a date:
	    // https://stackoverflow.com/q/181348
	    var date = new Date(y, m, d, h, M, s, ms);

	    // the date constructor remaps years 0-99 to 1900-1999
	    if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
	        date.setFullYear(y);
	    }
	    return date;
	}

	function createUTCDate (y) {
	    var date = new Date(Date.UTC.apply(null, arguments));

	    // the Date.UTC function remaps years 0-99 to 1900-1999
	    if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
	        date.setUTCFullYear(y);
	    }
	    return date;
	}

	// start-of-first-week - start-of-year
	function firstWeekOffset(year, dow, doy) {
	    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
	        fwd = 7 + dow - doy,
	        // first-week day local weekday -- which local weekday is fwd
	        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

	    return -fwdlw + fwd - 1;
	}

	// https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
	function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
	    var localWeekday = (7 + weekday - dow) % 7,
	        weekOffset = firstWeekOffset(year, dow, doy),
	        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
	        resYear, resDayOfYear;

	    if (dayOfYear <= 0) {
	        resYear = year - 1;
	        resDayOfYear = daysInYear(resYear) + dayOfYear;
	    } else if (dayOfYear > daysInYear(year)) {
	        resYear = year + 1;
	        resDayOfYear = dayOfYear - daysInYear(year);
	    } else {
	        resYear = year;
	        resDayOfYear = dayOfYear;
	    }

	    return {
	        year: resYear,
	        dayOfYear: resDayOfYear
	    };
	}

	function weekOfYear(mom, dow, doy) {
	    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
	        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
	        resWeek, resYear;

	    if (week < 1) {
	        resYear = mom.year() - 1;
	        resWeek = week + weeksInYear(resYear, dow, doy);
	    } else if (week > weeksInYear(mom.year(), dow, doy)) {
	        resWeek = week - weeksInYear(mom.year(), dow, doy);
	        resYear = mom.year() + 1;
	    } else {
	        resYear = mom.year();
	        resWeek = week;
	    }

	    return {
	        week: resWeek,
	        year: resYear
	    };
	}

	function weeksInYear(year, dow, doy) {
	    var weekOffset = firstWeekOffset(year, dow, doy),
	        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
	    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
	}

	// FORMATTING

	addFormatToken('w', ['ww', 2], 'wo', 'week');
	addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

	// ALIASES

	addUnitAlias('week', 'w');
	addUnitAlias('isoWeek', 'W');

	// PRIORITIES

	addUnitPriority('week', 5);
	addUnitPriority('isoWeek', 5);

	// PARSING

	addRegexToken('w',  match1to2);
	addRegexToken('ww', match1to2, match2);
	addRegexToken('W',  match1to2);
	addRegexToken('WW', match1to2, match2);

	addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
	    week[token.substr(0, 1)] = toInt(input);
	});

	// HELPERS

	// LOCALES

	function localeWeek (mom) {
	    return weekOfYear(mom, this._week.dow, this._week.doy).week;
	}

	var defaultLocaleWeek = {
	    dow : 0, // Sunday is the first day of the week.
	    doy : 6  // The week that contains Jan 1st is the first week of the year.
	};

	function localeFirstDayOfWeek () {
	    return this._week.dow;
	}

	function localeFirstDayOfYear () {
	    return this._week.doy;
	}

	// MOMENTS

	function getSetWeek (input) {
	    var week = this.localeData().week(this);
	    return input == null ? week : this.add((input - week) * 7, 'd');
	}

	function getSetISOWeek (input) {
	    var week = weekOfYear(this, 1, 4).week;
	    return input == null ? week : this.add((input - week) * 7, 'd');
	}

	// FORMATTING

	addFormatToken('d', 0, 'do', 'day');

	addFormatToken('dd', 0, 0, function (format) {
	    return this.localeData().weekdaysMin(this, format);
	});

	addFormatToken('ddd', 0, 0, function (format) {
	    return this.localeData().weekdaysShort(this, format);
	});

	addFormatToken('dddd', 0, 0, function (format) {
	    return this.localeData().weekdays(this, format);
	});

	addFormatToken('e', 0, 0, 'weekday');
	addFormatToken('E', 0, 0, 'isoWeekday');

	// ALIASES

	addUnitAlias('day', 'd');
	addUnitAlias('weekday', 'e');
	addUnitAlias('isoWeekday', 'E');

	// PRIORITY
	addUnitPriority('day', 11);
	addUnitPriority('weekday', 11);
	addUnitPriority('isoWeekday', 11);

	// PARSING

	addRegexToken('d',    match1to2);
	addRegexToken('e',    match1to2);
	addRegexToken('E',    match1to2);
	addRegexToken('dd',   function (isStrict, locale) {
	    return locale.weekdaysMinRegex(isStrict);
	});
	addRegexToken('ddd',   function (isStrict, locale) {
	    return locale.weekdaysShortRegex(isStrict);
	});
	addRegexToken('dddd',   function (isStrict, locale) {
	    return locale.weekdaysRegex(isStrict);
	});

	addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
	    var weekday = config._locale.weekdaysParse(input, token, config._strict);
	    // if we didn't get a weekday name, mark the date as invalid
	    if (weekday != null) {
	        week.d = weekday;
	    } else {
	        getParsingFlags(config).invalidWeekday = input;
	    }
	});

	addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
	    week[token] = toInt(input);
	});

	// HELPERS

	function parseWeekday(input, locale) {
	    if (typeof input !== 'string') {
	        return input;
	    }

	    if (!isNaN(input)) {
	        return parseInt(input, 10);
	    }

	    input = locale.weekdaysParse(input);
	    if (typeof input === 'number') {
	        return input;
	    }

	    return null;
	}

	function parseIsoWeekday(input, locale) {
	    if (typeof input === 'string') {
	        return locale.weekdaysParse(input) % 7 || 7;
	    }
	    return isNaN(input) ? null : input;
	}

	// LOCALES

	var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
	function localeWeekdays (m, format) {
	    if (!m) {
	        return isArray(this._weekdays) ? this._weekdays :
	            this._weekdays['standalone'];
	    }
	    return isArray(this._weekdays) ? this._weekdays[m.day()] :
	        this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
	}

	var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
	function localeWeekdaysShort (m) {
	    return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
	}

	var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
	function localeWeekdaysMin (m) {
	    return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
	}

	function handleStrictParse$1(weekdayName, format, strict) {
	    var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
	    if (!this._weekdaysParse) {
	        this._weekdaysParse = [];
	        this._shortWeekdaysParse = [];
	        this._minWeekdaysParse = [];

	        for (i = 0; i < 7; ++i) {
	            mom = createUTC([2000, 1]).day(i);
	            this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
	            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
	            this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
	        }
	    }

	    if (strict) {
	        if (format === 'dddd') {
	            ii = indexOf$1.call(this._weekdaysParse, llc);
	            return ii !== -1 ? ii : null;
	        } else if (format === 'ddd') {
	            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
	            return ii !== -1 ? ii : null;
	        } else {
	            ii = indexOf$1.call(this._minWeekdaysParse, llc);
	            return ii !== -1 ? ii : null;
	        }
	    } else {
	        if (format === 'dddd') {
	            ii = indexOf$1.call(this._weekdaysParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf$1.call(this._minWeekdaysParse, llc);
	            return ii !== -1 ? ii : null;
	        } else if (format === 'ddd') {
	            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf$1.call(this._weekdaysParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf$1.call(this._minWeekdaysParse, llc);
	            return ii !== -1 ? ii : null;
	        } else {
	            ii = indexOf$1.call(this._minWeekdaysParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf$1.call(this._weekdaysParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
	            return ii !== -1 ? ii : null;
	        }
	    }
	}

	function localeWeekdaysParse (weekdayName, format, strict) {
	    var i, mom, regex;

	    if (this._weekdaysParseExact) {
	        return handleStrictParse$1.call(this, weekdayName, format, strict);
	    }

	    if (!this._weekdaysParse) {
	        this._weekdaysParse = [];
	        this._minWeekdaysParse = [];
	        this._shortWeekdaysParse = [];
	        this._fullWeekdaysParse = [];
	    }

	    for (i = 0; i < 7; i++) {
	        // make the regex if we don't have it already

	        mom = createUTC([2000, 1]).day(i);
	        if (strict && !this._fullWeekdaysParse[i]) {
	            this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
	            this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
	            this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
	        }
	        if (!this._weekdaysParse[i]) {
	            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
	            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
	        }
	        // test the regex
	        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
	            return i;
	        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
	            return i;
	        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
	            return i;
	        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
	            return i;
	        }
	    }
	}

	// MOMENTS

	function getSetDayOfWeek (input) {
	    if (!this.isValid()) {
	        return input != null ? this : NaN;
	    }
	    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
	    if (input != null) {
	        input = parseWeekday(input, this.localeData());
	        return this.add(input - day, 'd');
	    } else {
	        return day;
	    }
	}

	function getSetLocaleDayOfWeek (input) {
	    if (!this.isValid()) {
	        return input != null ? this : NaN;
	    }
	    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
	    return input == null ? weekday : this.add(input - weekday, 'd');
	}

	function getSetISODayOfWeek (input) {
	    if (!this.isValid()) {
	        return input != null ? this : NaN;
	    }

	    // behaves the same as moment#day except
	    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
	    // as a setter, sunday should belong to the previous week.

	    if (input != null) {
	        var weekday = parseIsoWeekday(input, this.localeData());
	        return this.day(this.day() % 7 ? weekday : weekday - 7);
	    } else {
	        return this.day() || 7;
	    }
	}

	var defaultWeekdaysRegex = matchWord;
	function weekdaysRegex (isStrict) {
	    if (this._weekdaysParseExact) {
	        if (!hasOwnProp(this, '_weekdaysRegex')) {
	            computeWeekdaysParse.call(this);
	        }
	        if (isStrict) {
	            return this._weekdaysStrictRegex;
	        } else {
	            return this._weekdaysRegex;
	        }
	    } else {
	        if (!hasOwnProp(this, '_weekdaysRegex')) {
	            this._weekdaysRegex = defaultWeekdaysRegex;
	        }
	        return this._weekdaysStrictRegex && isStrict ?
	            this._weekdaysStrictRegex : this._weekdaysRegex;
	    }
	}

	var defaultWeekdaysShortRegex = matchWord;
	function weekdaysShortRegex (isStrict) {
	    if (this._weekdaysParseExact) {
	        if (!hasOwnProp(this, '_weekdaysRegex')) {
	            computeWeekdaysParse.call(this);
	        }
	        if (isStrict) {
	            return this._weekdaysShortStrictRegex;
	        } else {
	            return this._weekdaysShortRegex;
	        }
	    } else {
	        if (!hasOwnProp(this, '_weekdaysShortRegex')) {
	            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
	        }
	        return this._weekdaysShortStrictRegex && isStrict ?
	            this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
	    }
	}

	var defaultWeekdaysMinRegex = matchWord;
	function weekdaysMinRegex (isStrict) {
	    if (this._weekdaysParseExact) {
	        if (!hasOwnProp(this, '_weekdaysRegex')) {
	            computeWeekdaysParse.call(this);
	        }
	        if (isStrict) {
	            return this._weekdaysMinStrictRegex;
	        } else {
	            return this._weekdaysMinRegex;
	        }
	    } else {
	        if (!hasOwnProp(this, '_weekdaysMinRegex')) {
	            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
	        }
	        return this._weekdaysMinStrictRegex && isStrict ?
	            this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
	    }
	}


	function computeWeekdaysParse () {
	    function cmpLenRev(a, b) {
	        return b.length - a.length;
	    }

	    var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
	        i, mom, minp, shortp, longp;
	    for (i = 0; i < 7; i++) {
	        // make the regex if we don't have it already
	        mom = createUTC([2000, 1]).day(i);
	        minp = this.weekdaysMin(mom, '');
	        shortp = this.weekdaysShort(mom, '');
	        longp = this.weekdays(mom, '');
	        minPieces.push(minp);
	        shortPieces.push(shortp);
	        longPieces.push(longp);
	        mixedPieces.push(minp);
	        mixedPieces.push(shortp);
	        mixedPieces.push(longp);
	    }
	    // Sorting makes sure if one weekday (or abbr) is a prefix of another it
	    // will match the longer piece.
	    minPieces.sort(cmpLenRev);
	    shortPieces.sort(cmpLenRev);
	    longPieces.sort(cmpLenRev);
	    mixedPieces.sort(cmpLenRev);
	    for (i = 0; i < 7; i++) {
	        shortPieces[i] = regexEscape(shortPieces[i]);
	        longPieces[i] = regexEscape(longPieces[i]);
	        mixedPieces[i] = regexEscape(mixedPieces[i]);
	    }

	    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
	    this._weekdaysShortRegex = this._weekdaysRegex;
	    this._weekdaysMinRegex = this._weekdaysRegex;

	    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
	    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
	    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
	}

	// FORMATTING

	function hFormat() {
	    return this.hours() % 12 || 12;
	}

	function kFormat() {
	    return this.hours() || 24;
	}

	addFormatToken('H', ['HH', 2], 0, 'hour');
	addFormatToken('h', ['hh', 2], 0, hFormat);
	addFormatToken('k', ['kk', 2], 0, kFormat);

	addFormatToken('hmm', 0, 0, function () {
	    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
	});

	addFormatToken('hmmss', 0, 0, function () {
	    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
	        zeroFill(this.seconds(), 2);
	});

	addFormatToken('Hmm', 0, 0, function () {
	    return '' + this.hours() + zeroFill(this.minutes(), 2);
	});

	addFormatToken('Hmmss', 0, 0, function () {
	    return '' + this.hours() + zeroFill(this.minutes(), 2) +
	        zeroFill(this.seconds(), 2);
	});

	function meridiem (token, lowercase) {
	    addFormatToken(token, 0, 0, function () {
	        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
	    });
	}

	meridiem('a', true);
	meridiem('A', false);

	// ALIASES

	addUnitAlias('hour', 'h');

	// PRIORITY
	addUnitPriority('hour', 13);

	// PARSING

	function matchMeridiem (isStrict, locale) {
	    return locale._meridiemParse;
	}

	addRegexToken('a',  matchMeridiem);
	addRegexToken('A',  matchMeridiem);
	addRegexToken('H',  match1to2);
	addRegexToken('h',  match1to2);
	addRegexToken('k',  match1to2);
	addRegexToken('HH', match1to2, match2);
	addRegexToken('hh', match1to2, match2);
	addRegexToken('kk', match1to2, match2);

	addRegexToken('hmm', match3to4);
	addRegexToken('hmmss', match5to6);
	addRegexToken('Hmm', match3to4);
	addRegexToken('Hmmss', match5to6);

	addParseToken(['H', 'HH'], HOUR);
	addParseToken(['k', 'kk'], function (input, array, config) {
	    var kInput = toInt(input);
	    array[HOUR] = kInput === 24 ? 0 : kInput;
	});
	addParseToken(['a', 'A'], function (input, array, config) {
	    config._isPm = config._locale.isPM(input);
	    config._meridiem = input;
	});
	addParseToken(['h', 'hh'], function (input, array, config) {
	    array[HOUR] = toInt(input);
	    getParsingFlags(config).bigHour = true;
	});
	addParseToken('hmm', function (input, array, config) {
	    var pos = input.length - 2;
	    array[HOUR] = toInt(input.substr(0, pos));
	    array[MINUTE] = toInt(input.substr(pos));
	    getParsingFlags(config).bigHour = true;
	});
	addParseToken('hmmss', function (input, array, config) {
	    var pos1 = input.length - 4;
	    var pos2 = input.length - 2;
	    array[HOUR] = toInt(input.substr(0, pos1));
	    array[MINUTE] = toInt(input.substr(pos1, 2));
	    array[SECOND] = toInt(input.substr(pos2));
	    getParsingFlags(config).bigHour = true;
	});
	addParseToken('Hmm', function (input, array, config) {
	    var pos = input.length - 2;
	    array[HOUR] = toInt(input.substr(0, pos));
	    array[MINUTE] = toInt(input.substr(pos));
	});
	addParseToken('Hmmss', function (input, array, config) {
	    var pos1 = input.length - 4;
	    var pos2 = input.length - 2;
	    array[HOUR] = toInt(input.substr(0, pos1));
	    array[MINUTE] = toInt(input.substr(pos1, 2));
	    array[SECOND] = toInt(input.substr(pos2));
	});

	// LOCALES

	function localeIsPM (input) {
	    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
	    // Using charAt should be more compatible.
	    return ((input + '').toLowerCase().charAt(0) === 'p');
	}

	var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
	function localeMeridiem (hours, minutes, isLower) {
	    if (hours > 11) {
	        return isLower ? 'pm' : 'PM';
	    } else {
	        return isLower ? 'am' : 'AM';
	    }
	}


	// MOMENTS

	// Setting the hour should keep the time, because the user explicitly
	// specified which hour he wants. So trying to maintain the same hour (in
	// a new timezone) makes sense. Adding/subtracting hours does not follow
	// this rule.
	var getSetHour = makeGetSet('Hours', true);

	// months
	// week
	// weekdays
	// meridiem
	var baseConfig = {
	    calendar: defaultCalendar,
	    longDateFormat: defaultLongDateFormat,
	    invalidDate: defaultInvalidDate,
	    ordinal: defaultOrdinal,
	    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
	    relativeTime: defaultRelativeTime,

	    months: defaultLocaleMonths,
	    monthsShort: defaultLocaleMonthsShort,

	    week: defaultLocaleWeek,

	    weekdays: defaultLocaleWeekdays,
	    weekdaysMin: defaultLocaleWeekdaysMin,
	    weekdaysShort: defaultLocaleWeekdaysShort,

	    meridiemParse: defaultLocaleMeridiemParse
	};

	// internal storage for locale config files
	var locales = {};
	var localeFamilies = {};
	var globalLocale;

	function normalizeLocale(key) {
	    return key ? key.toLowerCase().replace('_', '-') : key;
	}

	// pick the locale from the array
	// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
	// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
	function chooseLocale(names) {
	    var i = 0, j, next, locale, split;

	    while (i < names.length) {
	        split = normalizeLocale(names[i]).split('-');
	        j = split.length;
	        next = normalizeLocale(names[i + 1]);
	        next = next ? next.split('-') : null;
	        while (j > 0) {
	            locale = loadLocale(split.slice(0, j).join('-'));
	            if (locale) {
	                return locale;
	            }
	            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
	                //the next array item is better than a shallower substring of this one
	                break;
	            }
	            j--;
	        }
	        i++;
	    }
	    return null;
	}

	function loadLocale(name) {
	    var oldLocale = null;
	    // TODO: Find a better way to register and load all the locales in Node
	    if (!locales[name] && (typeof module !== 'undefined') &&
	            module && module.exports) {
	        try {
	            oldLocale = globalLocale._abbr;
	            __webpack_require__(79)("./" + name);
	            // because defineLocale currently also sets the global locale, we
	            // want to undo that for lazy loaded locales
	            getSetGlobalLocale(oldLocale);
	        } catch (e) { }
	    }
	    return locales[name];
	}

	// This function will load locale and then set the global locale.  If
	// no arguments are passed in, it will simply return the current global
	// locale key.
	function getSetGlobalLocale (key, values) {
	    var data;
	    if (key) {
	        if (isUndefined(values)) {
	            data = getLocale(key);
	        }
	        else {
	            data = defineLocale(key, values);
	        }

	        if (data) {
	            // moment.duration._locale = moment._locale = data;
	            globalLocale = data;
	        }
	    }

	    return globalLocale._abbr;
	}

	function defineLocale (name, config) {
	    if (config !== null) {
	        var parentConfig = baseConfig;
	        config.abbr = name;
	        if (locales[name] != null) {
	            deprecateSimple('defineLocaleOverride',
	                    'use moment.updateLocale(localeName, config) to change ' +
	                    'an existing locale. moment.defineLocale(localeName, ' +
	                    'config) should only be used for creating a new locale ' +
	                    'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
	            parentConfig = locales[name]._config;
	        } else if (config.parentLocale != null) {
	            if (locales[config.parentLocale] != null) {
	                parentConfig = locales[config.parentLocale]._config;
	            } else {
	                if (!localeFamilies[config.parentLocale]) {
	                    localeFamilies[config.parentLocale] = [];
	                }
	                localeFamilies[config.parentLocale].push({
	                    name: name,
	                    config: config
	                });
	                return null;
	            }
	        }
	        locales[name] = new Locale(mergeConfigs(parentConfig, config));

	        if (localeFamilies[name]) {
	            localeFamilies[name].forEach(function (x) {
	                defineLocale(x.name, x.config);
	            });
	        }

	        // backwards compat for now: also set the locale
	        // make sure we set the locale AFTER all child locales have been
	        // created, so we won't end up with the child locale set.
	        getSetGlobalLocale(name);


	        return locales[name];
	    } else {
	        // useful for testing
	        delete locales[name];
	        return null;
	    }
	}

	function updateLocale(name, config) {
	    if (config != null) {
	        var locale, parentConfig = baseConfig;
	        // MERGE
	        if (locales[name] != null) {
	            parentConfig = locales[name]._config;
	        }
	        config = mergeConfigs(parentConfig, config);
	        locale = new Locale(config);
	        locale.parentLocale = locales[name];
	        locales[name] = locale;

	        // backwards compat for now: also set the locale
	        getSetGlobalLocale(name);
	    } else {
	        // pass null for config to unupdate, useful for tests
	        if (locales[name] != null) {
	            if (locales[name].parentLocale != null) {
	                locales[name] = locales[name].parentLocale;
	            } else if (locales[name] != null) {
	                delete locales[name];
	            }
	        }
	    }
	    return locales[name];
	}

	// returns locale data
	function getLocale (key) {
	    var locale;

	    if (key && key._locale && key._locale._abbr) {
	        key = key._locale._abbr;
	    }

	    if (!key) {
	        return globalLocale;
	    }

	    if (!isArray(key)) {
	        //short-circuit everything else
	        locale = loadLocale(key);
	        if (locale) {
	            return locale;
	        }
	        key = [key];
	    }

	    return chooseLocale(key);
	}

	function listLocales() {
	    return keys$1(locales);
	}

	function checkOverflow (m) {
	    var overflow;
	    var a = m._a;

	    if (a && getParsingFlags(m).overflow === -2) {
	        overflow =
	            a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
	            a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
	            a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
	            a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
	            a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
	            a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
	            -1;

	        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
	            overflow = DATE;
	        }
	        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
	            overflow = WEEK;
	        }
	        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
	            overflow = WEEKDAY;
	        }

	        getParsingFlags(m).overflow = overflow;
	    }

	    return m;
	}

	// iso 8601 regex
	// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
	var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
	var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

	var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

	var isoDates = [
	    ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
	    ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
	    ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
	    ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
	    ['YYYY-DDD', /\d{4}-\d{3}/],
	    ['YYYY-MM', /\d{4}-\d\d/, false],
	    ['YYYYYYMMDD', /[+-]\d{10}/],
	    ['YYYYMMDD', /\d{8}/],
	    // YYYYMM is NOT allowed by the standard
	    ['GGGG[W]WWE', /\d{4}W\d{3}/],
	    ['GGGG[W]WW', /\d{4}W\d{2}/, false],
	    ['YYYYDDD', /\d{7}/]
	];

	// iso time formats and regexes
	var isoTimes = [
	    ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
	    ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
	    ['HH:mm:ss', /\d\d:\d\d:\d\d/],
	    ['HH:mm', /\d\d:\d\d/],
	    ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
	    ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
	    ['HHmmss', /\d\d\d\d\d\d/],
	    ['HHmm', /\d\d\d\d/],
	    ['HH', /\d\d/]
	];

	var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

	// date from iso format
	function configFromISO(config) {
	    var i, l,
	        string = config._i,
	        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
	        allowTime, dateFormat, timeFormat, tzFormat;

	    if (match) {
	        getParsingFlags(config).iso = true;

	        for (i = 0, l = isoDates.length; i < l; i++) {
	            if (isoDates[i][1].exec(match[1])) {
	                dateFormat = isoDates[i][0];
	                allowTime = isoDates[i][2] !== false;
	                break;
	            }
	        }
	        if (dateFormat == null) {
	            config._isValid = false;
	            return;
	        }
	        if (match[3]) {
	            for (i = 0, l = isoTimes.length; i < l; i++) {
	                if (isoTimes[i][1].exec(match[3])) {
	                    // match[2] should be 'T' or space
	                    timeFormat = (match[2] || ' ') + isoTimes[i][0];
	                    break;
	                }
	            }
	            if (timeFormat == null) {
	                config._isValid = false;
	                return;
	            }
	        }
	        if (!allowTime && timeFormat != null) {
	            config._isValid = false;
	            return;
	        }
	        if (match[4]) {
	            if (tzRegex.exec(match[4])) {
	                tzFormat = 'Z';
	            } else {
	                config._isValid = false;
	                return;
	            }
	        }
	        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
	        configFromStringAndFormat(config);
	    } else {
	        config._isValid = false;
	    }
	}

	// RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
	var basicRfcRegex = /^((?:Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d?\d\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(?:\d\d)?\d\d\s)(\d\d:\d\d)(\:\d\d)?(\s(?:UT|GMT|[ECMP][SD]T|[A-IK-Za-ik-z]|[+-]\d{4}))$/;

	// date and time from ref 2822 format
	function configFromRFC2822(config) {
	    var string, match, dayFormat,
	        dateFormat, timeFormat, tzFormat;
	    var timezones = {
	        ' GMT': ' +0000',
	        ' EDT': ' -0400',
	        ' EST': ' -0500',
	        ' CDT': ' -0500',
	        ' CST': ' -0600',
	        ' MDT': ' -0600',
	        ' MST': ' -0700',
	        ' PDT': ' -0700',
	        ' PST': ' -0800'
	    };
	    var military = 'YXWVUTSRQPONZABCDEFGHIKLM';
	    var timezone, timezoneIndex;

	    string = config._i
	        .replace(/\([^\)]*\)|[\n\t]/g, ' ') // Remove comments and folding whitespace
	        .replace(/(\s\s+)/g, ' ') // Replace multiple-spaces with a single space
	        .replace(/^\s|\s$/g, ''); // Remove leading and trailing spaces
	    match = basicRfcRegex.exec(string);

	    if (match) {
	        dayFormat = match[1] ? 'ddd' + ((match[1].length === 5) ? ', ' : ' ') : '';
	        dateFormat = 'D MMM ' + ((match[2].length > 10) ? 'YYYY ' : 'YY ');
	        timeFormat = 'HH:mm' + (match[4] ? ':ss' : '');

	        // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
	        if (match[1]) { // day of week given
	            var momentDate = new Date(match[2]);
	            var momentDay = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'][momentDate.getDay()];

	            if (match[1].substr(0,3) !== momentDay) {
	                getParsingFlags(config).weekdayMismatch = true;
	                config._isValid = false;
	                return;
	            }
	        }

	        switch (match[5].length) {
	            case 2: // military
	                if (timezoneIndex === 0) {
	                    timezone = ' +0000';
	                } else {
	                    timezoneIndex = military.indexOf(match[5][1].toUpperCase()) - 12;
	                    timezone = ((timezoneIndex < 0) ? ' -' : ' +') +
	                        (('' + timezoneIndex).replace(/^-?/, '0')).match(/..$/)[0] + '00';
	                }
	                break;
	            case 4: // Zone
	                timezone = timezones[match[5]];
	                break;
	            default: // UT or +/-9999
	                timezone = timezones[' GMT'];
	        }
	        match[5] = timezone;
	        config._i = match.splice(1).join('');
	        tzFormat = ' ZZ';
	        config._f = dayFormat + dateFormat + timeFormat + tzFormat;
	        configFromStringAndFormat(config);
	        getParsingFlags(config).rfc2822 = true;
	    } else {
	        config._isValid = false;
	    }
	}

	// date from iso format or fallback
	function configFromString(config) {
	    var matched = aspNetJsonRegex.exec(config._i);

	    if (matched !== null) {
	        config._d = new Date(+matched[1]);
	        return;
	    }

	    configFromISO(config);
	    if (config._isValid === false) {
	        delete config._isValid;
	    } else {
	        return;
	    }

	    configFromRFC2822(config);
	    if (config._isValid === false) {
	        delete config._isValid;
	    } else {
	        return;
	    }

	    // Final attempt, use Input Fallback
	    hooks.createFromInputFallback(config);
	}

	hooks.createFromInputFallback = deprecate(
	    'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
	    'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
	    'discouraged and will be removed in an upcoming major release. Please refer to ' +
	    'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
	    function (config) {
	        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
	    }
	);

	// Pick the first defined of two or three arguments.
	function defaults(a, b, c) {
	    if (a != null) {
	        return a;
	    }
	    if (b != null) {
	        return b;
	    }
	    return c;
	}

	function currentDateArray(config) {
	    // hooks is actually the exported moment object
	    var nowValue = new Date(hooks.now());
	    if (config._useUTC) {
	        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
	    }
	    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
	}

	// convert an array to a date.
	// the array should mirror the parameters below
	// note: all values past the year are optional and will default to the lowest possible value.
	// [year, month, day , hour, minute, second, millisecond]
	function configFromArray (config) {
	    var i, date, input = [], currentDate, yearToUse;

	    if (config._d) {
	        return;
	    }

	    currentDate = currentDateArray(config);

	    //compute day of the year from weeks and weekdays
	    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
	        dayOfYearFromWeekInfo(config);
	    }

	    //if the day of the year is set, figure out what it is
	    if (config._dayOfYear != null) {
	        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

	        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
	            getParsingFlags(config)._overflowDayOfYear = true;
	        }

	        date = createUTCDate(yearToUse, 0, config._dayOfYear);
	        config._a[MONTH] = date.getUTCMonth();
	        config._a[DATE] = date.getUTCDate();
	    }

	    // Default to current date.
	    // * if no year, month, day of month are given, default to today
	    // * if day of month is given, default month and year
	    // * if month is given, default only year
	    // * if year is given, don't default anything
	    for (i = 0; i < 3 && config._a[i] == null; ++i) {
	        config._a[i] = input[i] = currentDate[i];
	    }

	    // Zero out whatever was not defaulted, including time
	    for (; i < 7; i++) {
	        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
	    }

	    // Check for 24:00:00.000
	    if (config._a[HOUR] === 24 &&
	            config._a[MINUTE] === 0 &&
	            config._a[SECOND] === 0 &&
	            config._a[MILLISECOND] === 0) {
	        config._nextDay = true;
	        config._a[HOUR] = 0;
	    }

	    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
	    // Apply timezone offset from input. The actual utcOffset can be changed
	    // with parseZone.
	    if (config._tzm != null) {
	        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
	    }

	    if (config._nextDay) {
	        config._a[HOUR] = 24;
	    }
	}

	function dayOfYearFromWeekInfo(config) {
	    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

	    w = config._w;
	    if (w.GG != null || w.W != null || w.E != null) {
	        dow = 1;
	        doy = 4;

	        // TODO: We need to take the current isoWeekYear, but that depends on
	        // how we interpret now (local, utc, fixed offset). So create
	        // a now version of current config (take local/utc/offset flags, and
	        // create now).
	        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
	        week = defaults(w.W, 1);
	        weekday = defaults(w.E, 1);
	        if (weekday < 1 || weekday > 7) {
	            weekdayOverflow = true;
	        }
	    } else {
	        dow = config._locale._week.dow;
	        doy = config._locale._week.doy;

	        var curWeek = weekOfYear(createLocal(), dow, doy);

	        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

	        // Default to current week.
	        week = defaults(w.w, curWeek.week);

	        if (w.d != null) {
	            // weekday -- low day numbers are considered next week
	            weekday = w.d;
	            if (weekday < 0 || weekday > 6) {
	                weekdayOverflow = true;
	            }
	        } else if (w.e != null) {
	            // local weekday -- counting starts from begining of week
	            weekday = w.e + dow;
	            if (w.e < 0 || w.e > 6) {
	                weekdayOverflow = true;
	            }
	        } else {
	            // default to begining of week
	            weekday = dow;
	        }
	    }
	    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
	        getParsingFlags(config)._overflowWeeks = true;
	    } else if (weekdayOverflow != null) {
	        getParsingFlags(config)._overflowWeekday = true;
	    } else {
	        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
	        config._a[YEAR] = temp.year;
	        config._dayOfYear = temp.dayOfYear;
	    }
	}

	// constant that refers to the ISO standard
	hooks.ISO_8601 = function () {};

	// constant that refers to the RFC 2822 form
	hooks.RFC_2822 = function () {};

	// date from string and format string
	function configFromStringAndFormat(config) {
	    // TODO: Move this to another part of the creation flow to prevent circular deps
	    if (config._f === hooks.ISO_8601) {
	        configFromISO(config);
	        return;
	    }
	    if (config._f === hooks.RFC_2822) {
	        configFromRFC2822(config);
	        return;
	    }
	    config._a = [];
	    getParsingFlags(config).empty = true;

	    // This array is used to make a Date, either with `new Date` or `Date.UTC`
	    var string = '' + config._i,
	        i, parsedInput, tokens, token, skipped,
	        stringLength = string.length,
	        totalParsedInputLength = 0;

	    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

	    for (i = 0; i < tokens.length; i++) {
	        token = tokens[i];
	        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
	        // console.log('token', token, 'parsedInput', parsedInput,
	        //         'regex', getParseRegexForToken(token, config));
	        if (parsedInput) {
	            skipped = string.substr(0, string.indexOf(parsedInput));
	            if (skipped.length > 0) {
	                getParsingFlags(config).unusedInput.push(skipped);
	            }
	            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
	            totalParsedInputLength += parsedInput.length;
	        }
	        // don't parse if it's not a known token
	        if (formatTokenFunctions[token]) {
	            if (parsedInput) {
	                getParsingFlags(config).empty = false;
	            }
	            else {
	                getParsingFlags(config).unusedTokens.push(token);
	            }
	            addTimeToArrayFromToken(token, parsedInput, config);
	        }
	        else if (config._strict && !parsedInput) {
	            getParsingFlags(config).unusedTokens.push(token);
	        }
	    }

	    // add remaining unparsed input length to the string
	    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
	    if (string.length > 0) {
	        getParsingFlags(config).unusedInput.push(string);
	    }

	    // clear _12h flag if hour is <= 12
	    if (config._a[HOUR] <= 12 &&
	        getParsingFlags(config).bigHour === true &&
	        config._a[HOUR] > 0) {
	        getParsingFlags(config).bigHour = undefined;
	    }

	    getParsingFlags(config).parsedDateParts = config._a.slice(0);
	    getParsingFlags(config).meridiem = config._meridiem;
	    // handle meridiem
	    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

	    configFromArray(config);
	    checkOverflow(config);
	}


	function meridiemFixWrap (locale, hour, meridiem) {
	    var isPm;

	    if (meridiem == null) {
	        // nothing to do
	        return hour;
	    }
	    if (locale.meridiemHour != null) {
	        return locale.meridiemHour(hour, meridiem);
	    } else if (locale.isPM != null) {
	        // Fallback
	        isPm = locale.isPM(meridiem);
	        if (isPm && hour < 12) {
	            hour += 12;
	        }
	        if (!isPm && hour === 12) {
	            hour = 0;
	        }
	        return hour;
	    } else {
	        // this is not supposed to happen
	        return hour;
	    }
	}

	// date from string and array of format strings
	function configFromStringAndArray(config) {
	    var tempConfig,
	        bestMoment,

	        scoreToBeat,
	        i,
	        currentScore;

	    if (config._f.length === 0) {
	        getParsingFlags(config).invalidFormat = true;
	        config._d = new Date(NaN);
	        return;
	    }

	    for (i = 0; i < config._f.length; i++) {
	        currentScore = 0;
	        tempConfig = copyConfig({}, config);
	        if (config._useUTC != null) {
	            tempConfig._useUTC = config._useUTC;
	        }
	        tempConfig._f = config._f[i];
	        configFromStringAndFormat(tempConfig);

	        if (!isValid(tempConfig)) {
	            continue;
	        }

	        // if there is any input that was not parsed add a penalty for that format
	        currentScore += getParsingFlags(tempConfig).charsLeftOver;

	        //or tokens
	        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

	        getParsingFlags(tempConfig).score = currentScore;

	        if (scoreToBeat == null || currentScore < scoreToBeat) {
	            scoreToBeat = currentScore;
	            bestMoment = tempConfig;
	        }
	    }

	    extend(config, bestMoment || tempConfig);
	}

	function configFromObject(config) {
	    if (config._d) {
	        return;
	    }

	    var i = normalizeObjectUnits(config._i);
	    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
	        return obj && parseInt(obj, 10);
	    });

	    configFromArray(config);
	}

	function createFromConfig (config) {
	    var res = new Moment(checkOverflow(prepareConfig(config)));
	    if (res._nextDay) {
	        // Adding is smart enough around DST
	        res.add(1, 'd');
	        res._nextDay = undefined;
	    }

	    return res;
	}

	function prepareConfig (config) {
	    var input = config._i,
	        format = config._f;

	    config._locale = config._locale || getLocale(config._l);

	    if (input === null || (format === undefined && input === '')) {
	        return createInvalid({nullInput: true});
	    }

	    if (typeof input === 'string') {
	        config._i = input = config._locale.preparse(input);
	    }

	    if (isMoment(input)) {
	        return new Moment(checkOverflow(input));
	    } else if (isDate(input)) {
	        config._d = input;
	    } else if (isArray(format)) {
	        configFromStringAndArray(config);
	    } else if (format) {
	        configFromStringAndFormat(config);
	    }  else {
	        configFromInput(config);
	    }

	    if (!isValid(config)) {
	        config._d = null;
	    }

	    return config;
	}

	function configFromInput(config) {
	    var input = config._i;
	    if (isUndefined(input)) {
	        config._d = new Date(hooks.now());
	    } else if (isDate(input)) {
	        config._d = new Date(input.valueOf());
	    } else if (typeof input === 'string') {
	        configFromString(config);
	    } else if (isArray(input)) {
	        config._a = map(input.slice(0), function (obj) {
	            return parseInt(obj, 10);
	        });
	        configFromArray(config);
	    } else if (isObject(input)) {
	        configFromObject(config);
	    } else if (isNumber(input)) {
	        // from milliseconds
	        config._d = new Date(input);
	    } else {
	        hooks.createFromInputFallback(config);
	    }
	}

	function createLocalOrUTC (input, format, locale, strict, isUTC) {
	    var c = {};

	    if (locale === true || locale === false) {
	        strict = locale;
	        locale = undefined;
	    }

	    if ((isObject(input) && isObjectEmpty(input)) ||
	            (isArray(input) && input.length === 0)) {
	        input = undefined;
	    }
	    // object construction must be done this way.
	    // https://github.com/moment/moment/issues/1423
	    c._isAMomentObject = true;
	    c._useUTC = c._isUTC = isUTC;
	    c._l = locale;
	    c._i = input;
	    c._f = format;
	    c._strict = strict;

	    return createFromConfig(c);
	}

	function createLocal (input, format, locale, strict) {
	    return createLocalOrUTC(input, format, locale, strict, false);
	}

	var prototypeMin = deprecate(
	    'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
	    function () {
	        var other = createLocal.apply(null, arguments);
	        if (this.isValid() && other.isValid()) {
	            return other < this ? this : other;
	        } else {
	            return createInvalid();
	        }
	    }
	);

	var prototypeMax = deprecate(
	    'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
	    function () {
	        var other = createLocal.apply(null, arguments);
	        if (this.isValid() && other.isValid()) {
	            return other > this ? this : other;
	        } else {
	            return createInvalid();
	        }
	    }
	);

	// Pick a moment m from moments so that m[fn](other) is true for all
	// other. This relies on the function fn to be transitive.
	//
	// moments should either be an array of moment objects or an array, whose
	// first element is an array of moment objects.
	function pickBy(fn, moments) {
	    var res, i;
	    if (moments.length === 1 && isArray(moments[0])) {
	        moments = moments[0];
	    }
	    if (!moments.length) {
	        return createLocal();
	    }
	    res = moments[0];
	    for (i = 1; i < moments.length; ++i) {
	        if (!moments[i].isValid() || moments[i][fn](res)) {
	            res = moments[i];
	        }
	    }
	    return res;
	}

	// TODO: Use [].sort instead?
	function min () {
	    var args = [].slice.call(arguments, 0);

	    return pickBy('isBefore', args);
	}

	function max () {
	    var args = [].slice.call(arguments, 0);

	    return pickBy('isAfter', args);
	}

	var now = function () {
	    return Date.now ? Date.now() : +(new Date());
	};

	var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

	function isDurationValid(m) {
	    for (var key in m) {
	        if (!(ordering.indexOf(key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
	            return false;
	        }
	    }

	    var unitHasDecimal = false;
	    for (var i = 0; i < ordering.length; ++i) {
	        if (m[ordering[i]]) {
	            if (unitHasDecimal) {
	                return false; // only allow non-integers for smallest unit
	            }
	            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
	                unitHasDecimal = true;
	            }
	        }
	    }

	    return true;
	}

	function isValid$1() {
	    return this._isValid;
	}

	function createInvalid$1() {
	    return createDuration(NaN);
	}

	function Duration (duration) {
	    var normalizedInput = normalizeObjectUnits(duration),
	        years = normalizedInput.year || 0,
	        quarters = normalizedInput.quarter || 0,
	        months = normalizedInput.month || 0,
	        weeks = normalizedInput.week || 0,
	        days = normalizedInput.day || 0,
	        hours = normalizedInput.hour || 0,
	        minutes = normalizedInput.minute || 0,
	        seconds = normalizedInput.second || 0,
	        milliseconds = normalizedInput.millisecond || 0;

	    this._isValid = isDurationValid(normalizedInput);

	    // representation for dateAddRemove
	    this._milliseconds = +milliseconds +
	        seconds * 1e3 + // 1000
	        minutes * 6e4 + // 1000 * 60
	        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
	    // Because of dateAddRemove treats 24 hours as different from a
	    // day when working around DST, we need to store them separately
	    this._days = +days +
	        weeks * 7;
	    // It is impossible translate months into days without knowing
	    // which months you are are talking about, so we have to store
	    // it separately.
	    this._months = +months +
	        quarters * 3 +
	        years * 12;

	    this._data = {};

	    this._locale = getLocale();

	    this._bubble();
	}

	function isDuration (obj) {
	    return obj instanceof Duration;
	}

	function absRound (number) {
	    if (number < 0) {
	        return Math.round(-1 * number) * -1;
	    } else {
	        return Math.round(number);
	    }
	}

	// FORMATTING

	function offset (token, separator) {
	    addFormatToken(token, 0, 0, function () {
	        var offset = this.utcOffset();
	        var sign = '+';
	        if (offset < 0) {
	            offset = -offset;
	            sign = '-';
	        }
	        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
	    });
	}

	offset('Z', ':');
	offset('ZZ', '');

	// PARSING

	addRegexToken('Z',  matchShortOffset);
	addRegexToken('ZZ', matchShortOffset);
	addParseToken(['Z', 'ZZ'], function (input, array, config) {
	    config._useUTC = true;
	    config._tzm = offsetFromString(matchShortOffset, input);
	});

	// HELPERS

	// timezone chunker
	// '+10:00' > ['10',  '00']
	// '-1530'  > ['-15', '30']
	var chunkOffset = /([\+\-]|\d\d)/gi;

	function offsetFromString(matcher, string) {
	    var matches = (string || '').match(matcher);

	    if (matches === null) {
	        return null;
	    }

	    var chunk   = matches[matches.length - 1] || [];
	    var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
	    var minutes = +(parts[1] * 60) + toInt(parts[2]);

	    return minutes === 0 ?
	      0 :
	      parts[0] === '+' ? minutes : -minutes;
	}

	// Return a moment from input, that is local/utc/zone equivalent to model.
	function cloneWithOffset(input, model) {
	    var res, diff;
	    if (model._isUTC) {
	        res = model.clone();
	        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
	        // Use low-level api, because this fn is low-level api.
	        res._d.setTime(res._d.valueOf() + diff);
	        hooks.updateOffset(res, false);
	        return res;
	    } else {
	        return createLocal(input).local();
	    }
	}

	function getDateOffset (m) {
	    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
	    // https://github.com/moment/moment/pull/1871
	    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
	}

	// HOOKS

	// This function will be called whenever a moment is mutated.
	// It is intended to keep the offset in sync with the timezone.
	hooks.updateOffset = function () {};

	// MOMENTS

	// keepLocalTime = true means only change the timezone, without
	// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
	// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
	// +0200, so we adjust the time as needed, to be valid.
	//
	// Keeping the time actually adds/subtracts (one hour)
	// from the actual represented time. That is why we call updateOffset
	// a second time. In case it wants us to change the offset again
	// _changeInProgress == true case, then we have to adjust, because
	// there is no such time in the given timezone.
	function getSetOffset (input, keepLocalTime, keepMinutes) {
	    var offset = this._offset || 0,
	        localAdjust;
	    if (!this.isValid()) {
	        return input != null ? this : NaN;
	    }
	    if (input != null) {
	        if (typeof input === 'string') {
	            input = offsetFromString(matchShortOffset, input);
	            if (input === null) {
	                return this;
	            }
	        } else if (Math.abs(input) < 16 && !keepMinutes) {
	            input = input * 60;
	        }
	        if (!this._isUTC && keepLocalTime) {
	            localAdjust = getDateOffset(this);
	        }
	        this._offset = input;
	        this._isUTC = true;
	        if (localAdjust != null) {
	            this.add(localAdjust, 'm');
	        }
	        if (offset !== input) {
	            if (!keepLocalTime || this._changeInProgress) {
	                addSubtract(this, createDuration(input - offset, 'm'), 1, false);
	            } else if (!this._changeInProgress) {
	                this._changeInProgress = true;
	                hooks.updateOffset(this, true);
	                this._changeInProgress = null;
	            }
	        }
	        return this;
	    } else {
	        return this._isUTC ? offset : getDateOffset(this);
	    }
	}

	function getSetZone (input, keepLocalTime) {
	    if (input != null) {
	        if (typeof input !== 'string') {
	            input = -input;
	        }

	        this.utcOffset(input, keepLocalTime);

	        return this;
	    } else {
	        return -this.utcOffset();
	    }
	}

	function setOffsetToUTC (keepLocalTime) {
	    return this.utcOffset(0, keepLocalTime);
	}

	function setOffsetToLocal (keepLocalTime) {
	    if (this._isUTC) {
	        this.utcOffset(0, keepLocalTime);
	        this._isUTC = false;

	        if (keepLocalTime) {
	            this.subtract(getDateOffset(this), 'm');
	        }
	    }
	    return this;
	}

	function setOffsetToParsedOffset () {
	    if (this._tzm != null) {
	        this.utcOffset(this._tzm, false, true);
	    } else if (typeof this._i === 'string') {
	        var tZone = offsetFromString(matchOffset, this._i);
	        if (tZone != null) {
	            this.utcOffset(tZone);
	        }
	        else {
	            this.utcOffset(0, true);
	        }
	    }
	    return this;
	}

	function hasAlignedHourOffset (input) {
	    if (!this.isValid()) {
	        return false;
	    }
	    input = input ? createLocal(input).utcOffset() : 0;

	    return (this.utcOffset() - input) % 60 === 0;
	}

	function isDaylightSavingTime () {
	    return (
	        this.utcOffset() > this.clone().month(0).utcOffset() ||
	        this.utcOffset() > this.clone().month(5).utcOffset()
	    );
	}

	function isDaylightSavingTimeShifted () {
	    if (!isUndefined(this._isDSTShifted)) {
	        return this._isDSTShifted;
	    }

	    var c = {};

	    copyConfig(c, this);
	    c = prepareConfig(c);

	    if (c._a) {
	        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
	        this._isDSTShifted = this.isValid() &&
	            compareArrays(c._a, other.toArray()) > 0;
	    } else {
	        this._isDSTShifted = false;
	    }

	    return this._isDSTShifted;
	}

	function isLocal () {
	    return this.isValid() ? !this._isUTC : false;
	}

	function isUtcOffset () {
	    return this.isValid() ? this._isUTC : false;
	}

	function isUtc () {
	    return this.isValid() ? this._isUTC && this._offset === 0 : false;
	}

	// ASP.NET json date format regex
	var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

	// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
	// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
	// and further modified to allow for strings containing both week and day
	var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;

	function createDuration (input, key) {
	    var duration = input,
	        // matching against regexp is expensive, do it on demand
	        match = null,
	        sign,
	        ret,
	        diffRes;

	    if (isDuration(input)) {
	        duration = {
	            ms : input._milliseconds,
	            d  : input._days,
	            M  : input._months
	        };
	    } else if (isNumber(input)) {
	        duration = {};
	        if (key) {
	            duration[key] = input;
	        } else {
	            duration.milliseconds = input;
	        }
	    } else if (!!(match = aspNetRegex.exec(input))) {
	        sign = (match[1] === '-') ? -1 : 1;
	        duration = {
	            y  : 0,
	            d  : toInt(match[DATE])                         * sign,
	            h  : toInt(match[HOUR])                         * sign,
	            m  : toInt(match[MINUTE])                       * sign,
	            s  : toInt(match[SECOND])                       * sign,
	            ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
	        };
	    } else if (!!(match = isoRegex.exec(input))) {
	        sign = (match[1] === '-') ? -1 : 1;
	        duration = {
	            y : parseIso(match[2], sign),
	            M : parseIso(match[3], sign),
	            w : parseIso(match[4], sign),
	            d : parseIso(match[5], sign),
	            h : parseIso(match[6], sign),
	            m : parseIso(match[7], sign),
	            s : parseIso(match[8], sign)
	        };
	    } else if (duration == null) {// checks for null or undefined
	        duration = {};
	    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
	        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

	        duration = {};
	        duration.ms = diffRes.milliseconds;
	        duration.M = diffRes.months;
	    }

	    ret = new Duration(duration);

	    if (isDuration(input) && hasOwnProp(input, '_locale')) {
	        ret._locale = input._locale;
	    }

	    return ret;
	}

	createDuration.fn = Duration.prototype;
	createDuration.invalid = createInvalid$1;

	function parseIso (inp, sign) {
	    // We'd normally use ~~inp for this, but unfortunately it also
	    // converts floats to ints.
	    // inp may be undefined, so careful calling replace on it.
	    var res = inp && parseFloat(inp.replace(',', '.'));
	    // apply sign while we're at it
	    return (isNaN(res) ? 0 : res) * sign;
	}

	function positiveMomentsDifference(base, other) {
	    var res = {milliseconds: 0, months: 0};

	    res.months = other.month() - base.month() +
	        (other.year() - base.year()) * 12;
	    if (base.clone().add(res.months, 'M').isAfter(other)) {
	        --res.months;
	    }

	    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

	    return res;
	}

	function momentsDifference(base, other) {
	    var res;
	    if (!(base.isValid() && other.isValid())) {
	        return {milliseconds: 0, months: 0};
	    }

	    other = cloneWithOffset(other, base);
	    if (base.isBefore(other)) {
	        res = positiveMomentsDifference(base, other);
	    } else {
	        res = positiveMomentsDifference(other, base);
	        res.milliseconds = -res.milliseconds;
	        res.months = -res.months;
	    }

	    return res;
	}

	// TODO: remove 'name' arg after deprecation is removed
	function createAdder(direction, name) {
	    return function (val, period) {
	        var dur, tmp;
	        //invert the arguments, but complain about it
	        if (period !== null && !isNaN(+period)) {
	            deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
	            'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
	            tmp = val; val = period; period = tmp;
	        }

	        val = typeof val === 'string' ? +val : val;
	        dur = createDuration(val, period);
	        addSubtract(this, dur, direction);
	        return this;
	    };
	}

	function addSubtract (mom, duration, isAdding, updateOffset) {
	    var milliseconds = duration._milliseconds,
	        days = absRound(duration._days),
	        months = absRound(duration._months);

	    if (!mom.isValid()) {
	        // No op
	        return;
	    }

	    updateOffset = updateOffset == null ? true : updateOffset;

	    if (milliseconds) {
	        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
	    }
	    if (days) {
	        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
	    }
	    if (months) {
	        setMonth(mom, get(mom, 'Month') + months * isAdding);
	    }
	    if (updateOffset) {
	        hooks.updateOffset(mom, days || months);
	    }
	}

	var add      = createAdder(1, 'add');
	var subtract = createAdder(-1, 'subtract');

	function getCalendarFormat(myMoment, now) {
	    var diff = myMoment.diff(now, 'days', true);
	    return diff < -6 ? 'sameElse' :
	            diff < -1 ? 'lastWeek' :
	            diff < 0 ? 'lastDay' :
	            diff < 1 ? 'sameDay' :
	            diff < 2 ? 'nextDay' :
	            diff < 7 ? 'nextWeek' : 'sameElse';
	}

	function calendar$1 (time, formats) {
	    // We want to compare the start of today, vs this.
	    // Getting start-of-today depends on whether we're local/utc/offset or not.
	    var now = time || createLocal(),
	        sod = cloneWithOffset(now, this).startOf('day'),
	        format = hooks.calendarFormat(this, sod) || 'sameElse';

	    var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

	    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
	}

	function clone () {
	    return new Moment(this);
	}

	function isAfter (input, units) {
	    var localInput = isMoment(input) ? input : createLocal(input);
	    if (!(this.isValid() && localInput.isValid())) {
	        return false;
	    }
	    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
	    if (units === 'millisecond') {
	        return this.valueOf() > localInput.valueOf();
	    } else {
	        return localInput.valueOf() < this.clone().startOf(units).valueOf();
	    }
	}

	function isBefore (input, units) {
	    var localInput = isMoment(input) ? input : createLocal(input);
	    if (!(this.isValid() && localInput.isValid())) {
	        return false;
	    }
	    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
	    if (units === 'millisecond') {
	        return this.valueOf() < localInput.valueOf();
	    } else {
	        return this.clone().endOf(units).valueOf() < localInput.valueOf();
	    }
	}

	function isBetween (from, to, units, inclusivity) {
	    inclusivity = inclusivity || '()';
	    return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
	        (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
	}

	function isSame (input, units) {
	    var localInput = isMoment(input) ? input : createLocal(input),
	        inputMs;
	    if (!(this.isValid() && localInput.isValid())) {
	        return false;
	    }
	    units = normalizeUnits(units || 'millisecond');
	    if (units === 'millisecond') {
	        return this.valueOf() === localInput.valueOf();
	    } else {
	        inputMs = localInput.valueOf();
	        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
	    }
	}

	function isSameOrAfter (input, units) {
	    return this.isSame(input, units) || this.isAfter(input,units);
	}

	function isSameOrBefore (input, units) {
	    return this.isSame(input, units) || this.isBefore(input,units);
	}

	function diff (input, units, asFloat) {
	    var that,
	        zoneDelta,
	        delta, output;

	    if (!this.isValid()) {
	        return NaN;
	    }

	    that = cloneWithOffset(input, this);

	    if (!that.isValid()) {
	        return NaN;
	    }

	    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

	    units = normalizeUnits(units);

	    if (units === 'year' || units === 'month' || units === 'quarter') {
	        output = monthDiff(this, that);
	        if (units === 'quarter') {
	            output = output / 3;
	        } else if (units === 'year') {
	            output = output / 12;
	        }
	    } else {
	        delta = this - that;
	        output = units === 'second' ? delta / 1e3 : // 1000
	            units === 'minute' ? delta / 6e4 : // 1000 * 60
	            units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
	            units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
	            units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
	            delta;
	    }
	    return asFloat ? output : absFloor(output);
	}

	function monthDiff (a, b) {
	    // difference in months
	    var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
	        // b is in (anchor - 1 month, anchor + 1 month)
	        anchor = a.clone().add(wholeMonthDiff, 'months'),
	        anchor2, adjust;

	    if (b - anchor < 0) {
	        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
	        // linear across the month
	        adjust = (b - anchor) / (anchor - anchor2);
	    } else {
	        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
	        // linear across the month
	        adjust = (b - anchor) / (anchor2 - anchor);
	    }

	    //check for negative zero, return zero if negative zero
	    return -(wholeMonthDiff + adjust) || 0;
	}

	hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
	hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

	function toString () {
	    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
	}

	function toISOString() {
	    if (!this.isValid()) {
	        return null;
	    }
	    var m = this.clone().utc();
	    if (m.year() < 0 || m.year() > 9999) {
	        return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
	    }
	    if (isFunction(Date.prototype.toISOString)) {
	        // native implementation is ~50x faster, use it when we can
	        return this.toDate().toISOString();
	    }
	    return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
	}

	/**
	 * Return a human readable representation of a moment that can
	 * also be evaluated to get a new moment which is the same
	 *
	 * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
	 */
	function inspect () {
	    if (!this.isValid()) {
	        return 'moment.invalid(/* ' + this._i + ' */)';
	    }
	    var func = 'moment';
	    var zone = '';
	    if (!this.isLocal()) {
	        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
	        zone = 'Z';
	    }
	    var prefix = '[' + func + '("]';
	    var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
	    var datetime = '-MM-DD[T]HH:mm:ss.SSS';
	    var suffix = zone + '[")]';

	    return this.format(prefix + year + datetime + suffix);
	}

	function format (inputString) {
	    if (!inputString) {
	        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
	    }
	    var output = formatMoment(this, inputString);
	    return this.localeData().postformat(output);
	}

	function from (time, withoutSuffix) {
	    if (this.isValid() &&
	            ((isMoment(time) && time.isValid()) ||
	             createLocal(time).isValid())) {
	        return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
	    } else {
	        return this.localeData().invalidDate();
	    }
	}

	function fromNow (withoutSuffix) {
	    return this.from(createLocal(), withoutSuffix);
	}

	function to (time, withoutSuffix) {
	    if (this.isValid() &&
	            ((isMoment(time) && time.isValid()) ||
	             createLocal(time).isValid())) {
	        return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
	    } else {
	        return this.localeData().invalidDate();
	    }
	}

	function toNow (withoutSuffix) {
	    return this.to(createLocal(), withoutSuffix);
	}

	// If passed a locale key, it will set the locale for this
	// instance.  Otherwise, it will return the locale configuration
	// variables for this instance.
	function locale (key) {
	    var newLocaleData;

	    if (key === undefined) {
	        return this._locale._abbr;
	    } else {
	        newLocaleData = getLocale(key);
	        if (newLocaleData != null) {
	            this._locale = newLocaleData;
	        }
	        return this;
	    }
	}

	var lang = deprecate(
	    'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
	    function (key) {
	        if (key === undefined) {
	            return this.localeData();
	        } else {
	            return this.locale(key);
	        }
	    }
	);

	function localeData () {
	    return this._locale;
	}

	function startOf (units) {
	    units = normalizeUnits(units);
	    // the following switch intentionally omits break keywords
	    // to utilize falling through the cases.
	    switch (units) {
	        case 'year':
	            this.month(0);
	            /* falls through */
	        case 'quarter':
	        case 'month':
	            this.date(1);
	            /* falls through */
	        case 'week':
	        case 'isoWeek':
	        case 'day':
	        case 'date':
	            this.hours(0);
	            /* falls through */
	        case 'hour':
	            this.minutes(0);
	            /* falls through */
	        case 'minute':
	            this.seconds(0);
	            /* falls through */
	        case 'second':
	            this.milliseconds(0);
	    }

	    // weeks are a special case
	    if (units === 'week') {
	        this.weekday(0);
	    }
	    if (units === 'isoWeek') {
	        this.isoWeekday(1);
	    }

	    // quarters are also special
	    if (units === 'quarter') {
	        this.month(Math.floor(this.month() / 3) * 3);
	    }

	    return this;
	}

	function endOf (units) {
	    units = normalizeUnits(units);
	    if (units === undefined || units === 'millisecond') {
	        return this;
	    }

	    // 'date' is an alias for 'day', so it should be considered as such.
	    if (units === 'date') {
	        units = 'day';
	    }

	    return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
	}

	function valueOf () {
	    return this._d.valueOf() - ((this._offset || 0) * 60000);
	}

	function unix () {
	    return Math.floor(this.valueOf() / 1000);
	}

	function toDate () {
	    return new Date(this.valueOf());
	}

	function toArray () {
	    var m = this;
	    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
	}

	function toObject () {
	    var m = this;
	    return {
	        years: m.year(),
	        months: m.month(),
	        date: m.date(),
	        hours: m.hours(),
	        minutes: m.minutes(),
	        seconds: m.seconds(),
	        milliseconds: m.milliseconds()
	    };
	}

	function toJSON () {
	    // new Date(NaN).toJSON() === null
	    return this.isValid() ? this.toISOString() : null;
	}

	function isValid$2 () {
	    return isValid(this);
	}

	function parsingFlags () {
	    return extend({}, getParsingFlags(this));
	}

	function invalidAt () {
	    return getParsingFlags(this).overflow;
	}

	function creationData() {
	    return {
	        input: this._i,
	        format: this._f,
	        locale: this._locale,
	        isUTC: this._isUTC,
	        strict: this._strict
	    };
	}

	// FORMATTING

	addFormatToken(0, ['gg', 2], 0, function () {
	    return this.weekYear() % 100;
	});

	addFormatToken(0, ['GG', 2], 0, function () {
	    return this.isoWeekYear() % 100;
	});

	function addWeekYearFormatToken (token, getter) {
	    addFormatToken(0, [token, token.length], 0, getter);
	}

	addWeekYearFormatToken('gggg',     'weekYear');
	addWeekYearFormatToken('ggggg',    'weekYear');
	addWeekYearFormatToken('GGGG',  'isoWeekYear');
	addWeekYearFormatToken('GGGGG', 'isoWeekYear');

	// ALIASES

	addUnitAlias('weekYear', 'gg');
	addUnitAlias('isoWeekYear', 'GG');

	// PRIORITY

	addUnitPriority('weekYear', 1);
	addUnitPriority('isoWeekYear', 1);


	// PARSING

	addRegexToken('G',      matchSigned);
	addRegexToken('g',      matchSigned);
	addRegexToken('GG',     match1to2, match2);
	addRegexToken('gg',     match1to2, match2);
	addRegexToken('GGGG',   match1to4, match4);
	addRegexToken('gggg',   match1to4, match4);
	addRegexToken('GGGGG',  match1to6, match6);
	addRegexToken('ggggg',  match1to6, match6);

	addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
	    week[token.substr(0, 2)] = toInt(input);
	});

	addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
	    week[token] = hooks.parseTwoDigitYear(input);
	});

	// MOMENTS

	function getSetWeekYear (input) {
	    return getSetWeekYearHelper.call(this,
	            input,
	            this.week(),
	            this.weekday(),
	            this.localeData()._week.dow,
	            this.localeData()._week.doy);
	}

	function getSetISOWeekYear (input) {
	    return getSetWeekYearHelper.call(this,
	            input, this.isoWeek(), this.isoWeekday(), 1, 4);
	}

	function getISOWeeksInYear () {
	    return weeksInYear(this.year(), 1, 4);
	}

	function getWeeksInYear () {
	    var weekInfo = this.localeData()._week;
	    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
	}

	function getSetWeekYearHelper(input, week, weekday, dow, doy) {
	    var weeksTarget;
	    if (input == null) {
	        return weekOfYear(this, dow, doy).year;
	    } else {
	        weeksTarget = weeksInYear(input, dow, doy);
	        if (week > weeksTarget) {
	            week = weeksTarget;
	        }
	        return setWeekAll.call(this, input, week, weekday, dow, doy);
	    }
	}

	function setWeekAll(weekYear, week, weekday, dow, doy) {
	    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
	        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

	    this.year(date.getUTCFullYear());
	    this.month(date.getUTCMonth());
	    this.date(date.getUTCDate());
	    return this;
	}

	// FORMATTING

	addFormatToken('Q', 0, 'Qo', 'quarter');

	// ALIASES

	addUnitAlias('quarter', 'Q');

	// PRIORITY

	addUnitPriority('quarter', 7);

	// PARSING

	addRegexToken('Q', match1);
	addParseToken('Q', function (input, array) {
	    array[MONTH] = (toInt(input) - 1) * 3;
	});

	// MOMENTS

	function getSetQuarter (input) {
	    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
	}

	// FORMATTING

	addFormatToken('D', ['DD', 2], 'Do', 'date');

	// ALIASES

	addUnitAlias('date', 'D');

	// PRIOROITY
	addUnitPriority('date', 9);

	// PARSING

	addRegexToken('D',  match1to2);
	addRegexToken('DD', match1to2, match2);
	addRegexToken('Do', function (isStrict, locale) {
	    // TODO: Remove "ordinalParse" fallback in next major release.
	    return isStrict ?
	      (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
	      locale._dayOfMonthOrdinalParseLenient;
	});

	addParseToken(['D', 'DD'], DATE);
	addParseToken('Do', function (input, array) {
	    array[DATE] = toInt(input.match(match1to2)[0], 10);
	});

	// MOMENTS

	var getSetDayOfMonth = makeGetSet('Date', true);

	// FORMATTING

	addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

	// ALIASES

	addUnitAlias('dayOfYear', 'DDD');

	// PRIORITY
	addUnitPriority('dayOfYear', 4);

	// PARSING

	addRegexToken('DDD',  match1to3);
	addRegexToken('DDDD', match3);
	addParseToken(['DDD', 'DDDD'], function (input, array, config) {
	    config._dayOfYear = toInt(input);
	});

	// HELPERS

	// MOMENTS

	function getSetDayOfYear (input) {
	    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
	    return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
	}

	// FORMATTING

	addFormatToken('m', ['mm', 2], 0, 'minute');

	// ALIASES

	addUnitAlias('minute', 'm');

	// PRIORITY

	addUnitPriority('minute', 14);

	// PARSING

	addRegexToken('m',  match1to2);
	addRegexToken('mm', match1to2, match2);
	addParseToken(['m', 'mm'], MINUTE);

	// MOMENTS

	var getSetMinute = makeGetSet('Minutes', false);

	// FORMATTING

	addFormatToken('s', ['ss', 2], 0, 'second');

	// ALIASES

	addUnitAlias('second', 's');

	// PRIORITY

	addUnitPriority('second', 15);

	// PARSING

	addRegexToken('s',  match1to2);
	addRegexToken('ss', match1to2, match2);
	addParseToken(['s', 'ss'], SECOND);

	// MOMENTS

	var getSetSecond = makeGetSet('Seconds', false);

	// FORMATTING

	addFormatToken('S', 0, 0, function () {
	    return ~~(this.millisecond() / 100);
	});

	addFormatToken(0, ['SS', 2], 0, function () {
	    return ~~(this.millisecond() / 10);
	});

	addFormatToken(0, ['SSS', 3], 0, 'millisecond');
	addFormatToken(0, ['SSSS', 4], 0, function () {
	    return this.millisecond() * 10;
	});
	addFormatToken(0, ['SSSSS', 5], 0, function () {
	    return this.millisecond() * 100;
	});
	addFormatToken(0, ['SSSSSS', 6], 0, function () {
	    return this.millisecond() * 1000;
	});
	addFormatToken(0, ['SSSSSSS', 7], 0, function () {
	    return this.millisecond() * 10000;
	});
	addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
	    return this.millisecond() * 100000;
	});
	addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
	    return this.millisecond() * 1000000;
	});


	// ALIASES

	addUnitAlias('millisecond', 'ms');

	// PRIORITY

	addUnitPriority('millisecond', 16);

	// PARSING

	addRegexToken('S',    match1to3, match1);
	addRegexToken('SS',   match1to3, match2);
	addRegexToken('SSS',  match1to3, match3);

	var token;
	for (token = 'SSSS'; token.length <= 9; token += 'S') {
	    addRegexToken(token, matchUnsigned);
	}

	function parseMs(input, array) {
	    array[MILLISECOND] = toInt(('0.' + input) * 1000);
	}

	for (token = 'S'; token.length <= 9; token += 'S') {
	    addParseToken(token, parseMs);
	}
	// MOMENTS

	var getSetMillisecond = makeGetSet('Milliseconds', false);

	// FORMATTING

	addFormatToken('z',  0, 0, 'zoneAbbr');
	addFormatToken('zz', 0, 0, 'zoneName');

	// MOMENTS

	function getZoneAbbr () {
	    return this._isUTC ? 'UTC' : '';
	}

	function getZoneName () {
	    return this._isUTC ? 'Coordinated Universal Time' : '';
	}

	var proto = Moment.prototype;

	proto.add               = add;
	proto.calendar          = calendar$1;
	proto.clone             = clone;
	proto.diff              = diff;
	proto.endOf             = endOf;
	proto.format            = format;
	proto.from              = from;
	proto.fromNow           = fromNow;
	proto.to                = to;
	proto.toNow             = toNow;
	proto.get               = stringGet;
	proto.invalidAt         = invalidAt;
	proto.isAfter           = isAfter;
	proto.isBefore          = isBefore;
	proto.isBetween         = isBetween;
	proto.isSame            = isSame;
	proto.isSameOrAfter     = isSameOrAfter;
	proto.isSameOrBefore    = isSameOrBefore;
	proto.isValid           = isValid$2;
	proto.lang              = lang;
	proto.locale            = locale;
	proto.localeData        = localeData;
	proto.max               = prototypeMax;
	proto.min               = prototypeMin;
	proto.parsingFlags      = parsingFlags;
	proto.set               = stringSet;
	proto.startOf           = startOf;
	proto.subtract          = subtract;
	proto.toArray           = toArray;
	proto.toObject          = toObject;
	proto.toDate            = toDate;
	proto.toISOString       = toISOString;
	proto.inspect           = inspect;
	proto.toJSON            = toJSON;
	proto.toString          = toString;
	proto.unix              = unix;
	proto.valueOf           = valueOf;
	proto.creationData      = creationData;

	// Year
	proto.year       = getSetYear;
	proto.isLeapYear = getIsLeapYear;

	// Week Year
	proto.weekYear    = getSetWeekYear;
	proto.isoWeekYear = getSetISOWeekYear;

	// Quarter
	proto.quarter = proto.quarters = getSetQuarter;

	// Month
	proto.month       = getSetMonth;
	proto.daysInMonth = getDaysInMonth;

	// Week
	proto.week           = proto.weeks        = getSetWeek;
	proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
	proto.weeksInYear    = getWeeksInYear;
	proto.isoWeeksInYear = getISOWeeksInYear;

	// Day
	proto.date       = getSetDayOfMonth;
	proto.day        = proto.days             = getSetDayOfWeek;
	proto.weekday    = getSetLocaleDayOfWeek;
	proto.isoWeekday = getSetISODayOfWeek;
	proto.dayOfYear  = getSetDayOfYear;

	// Hour
	proto.hour = proto.hours = getSetHour;

	// Minute
	proto.minute = proto.minutes = getSetMinute;

	// Second
	proto.second = proto.seconds = getSetSecond;

	// Millisecond
	proto.millisecond = proto.milliseconds = getSetMillisecond;

	// Offset
	proto.utcOffset            = getSetOffset;
	proto.utc                  = setOffsetToUTC;
	proto.local                = setOffsetToLocal;
	proto.parseZone            = setOffsetToParsedOffset;
	proto.hasAlignedHourOffset = hasAlignedHourOffset;
	proto.isDST                = isDaylightSavingTime;
	proto.isLocal              = isLocal;
	proto.isUtcOffset          = isUtcOffset;
	proto.isUtc                = isUtc;
	proto.isUTC                = isUtc;

	// Timezone
	proto.zoneAbbr = getZoneAbbr;
	proto.zoneName = getZoneName;

	// Deprecations
	proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
	proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
	proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
	proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
	proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

	function createUnix (input) {
	    return createLocal(input * 1000);
	}

	function createInZone () {
	    return createLocal.apply(null, arguments).parseZone();
	}

	function preParsePostFormat (string) {
	    return string;
	}

	var proto$1 = Locale.prototype;

	proto$1.calendar        = calendar;
	proto$1.longDateFormat  = longDateFormat;
	proto$1.invalidDate     = invalidDate;
	proto$1.ordinal         = ordinal;
	proto$1.preparse        = preParsePostFormat;
	proto$1.postformat      = preParsePostFormat;
	proto$1.relativeTime    = relativeTime;
	proto$1.pastFuture      = pastFuture;
	proto$1.set             = set;

	// Month
	proto$1.months            =        localeMonths;
	proto$1.monthsShort       =        localeMonthsShort;
	proto$1.monthsParse       =        localeMonthsParse;
	proto$1.monthsRegex       = monthsRegex;
	proto$1.monthsShortRegex  = monthsShortRegex;

	// Week
	proto$1.week = localeWeek;
	proto$1.firstDayOfYear = localeFirstDayOfYear;
	proto$1.firstDayOfWeek = localeFirstDayOfWeek;

	// Day of Week
	proto$1.weekdays       =        localeWeekdays;
	proto$1.weekdaysMin    =        localeWeekdaysMin;
	proto$1.weekdaysShort  =        localeWeekdaysShort;
	proto$1.weekdaysParse  =        localeWeekdaysParse;

	proto$1.weekdaysRegex       =        weekdaysRegex;
	proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
	proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

	// Hours
	proto$1.isPM = localeIsPM;
	proto$1.meridiem = localeMeridiem;

	function get$1 (format, index, field, setter) {
	    var locale = getLocale();
	    var utc = createUTC().set(setter, index);
	    return locale[field](utc, format);
	}

	function listMonthsImpl (format, index, field) {
	    if (isNumber(format)) {
	        index = format;
	        format = undefined;
	    }

	    format = format || '';

	    if (index != null) {
	        return get$1(format, index, field, 'month');
	    }

	    var i;
	    var out = [];
	    for (i = 0; i < 12; i++) {
	        out[i] = get$1(format, i, field, 'month');
	    }
	    return out;
	}

	// ()
	// (5)
	// (fmt, 5)
	// (fmt)
	// (true)
	// (true, 5)
	// (true, fmt, 5)
	// (true, fmt)
	function listWeekdaysImpl (localeSorted, format, index, field) {
	    if (typeof localeSorted === 'boolean') {
	        if (isNumber(format)) {
	            index = format;
	            format = undefined;
	        }

	        format = format || '';
	    } else {
	        format = localeSorted;
	        index = format;
	        localeSorted = false;

	        if (isNumber(format)) {
	            index = format;
	            format = undefined;
	        }

	        format = format || '';
	    }

	    var locale = getLocale(),
	        shift = localeSorted ? locale._week.dow : 0;

	    if (index != null) {
	        return get$1(format, (index + shift) % 7, field, 'day');
	    }

	    var i;
	    var out = [];
	    for (i = 0; i < 7; i++) {
	        out[i] = get$1(format, (i + shift) % 7, field, 'day');
	    }
	    return out;
	}

	function listMonths (format, index) {
	    return listMonthsImpl(format, index, 'months');
	}

	function listMonthsShort (format, index) {
	    return listMonthsImpl(format, index, 'monthsShort');
	}

	function listWeekdays (localeSorted, format, index) {
	    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
	}

	function listWeekdaysShort (localeSorted, format, index) {
	    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
	}

	function listWeekdaysMin (localeSorted, format, index) {
	    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
	}

	getSetGlobalLocale('en', {
	    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (toInt(number % 100 / 10) === 1) ? 'th' :
	            (b === 1) ? 'st' :
	            (b === 2) ? 'nd' :
	            (b === 3) ? 'rd' : 'th';
	        return number + output;
	    }
	});

	// Side effect imports
	hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
	hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

	var mathAbs = Math.abs;

	function abs () {
	    var data           = this._data;

	    this._milliseconds = mathAbs(this._milliseconds);
	    this._days         = mathAbs(this._days);
	    this._months       = mathAbs(this._months);

	    data.milliseconds  = mathAbs(data.milliseconds);
	    data.seconds       = mathAbs(data.seconds);
	    data.minutes       = mathAbs(data.minutes);
	    data.hours         = mathAbs(data.hours);
	    data.months        = mathAbs(data.months);
	    data.years         = mathAbs(data.years);

	    return this;
	}

	function addSubtract$1 (duration, input, value, direction) {
	    var other = createDuration(input, value);

	    duration._milliseconds += direction * other._milliseconds;
	    duration._days         += direction * other._days;
	    duration._months       += direction * other._months;

	    return duration._bubble();
	}

	// supports only 2.0-style add(1, 's') or add(duration)
	function add$1 (input, value) {
	    return addSubtract$1(this, input, value, 1);
	}

	// supports only 2.0-style subtract(1, 's') or subtract(duration)
	function subtract$1 (input, value) {
	    return addSubtract$1(this, input, value, -1);
	}

	function absCeil (number) {
	    if (number < 0) {
	        return Math.floor(number);
	    } else {
	        return Math.ceil(number);
	    }
	}

	function bubble () {
	    var milliseconds = this._milliseconds;
	    var days         = this._days;
	    var months       = this._months;
	    var data         = this._data;
	    var seconds, minutes, hours, years, monthsFromDays;

	    // if we have a mix of positive and negative values, bubble down first
	    // check: https://github.com/moment/moment/issues/2166
	    if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
	            (milliseconds <= 0 && days <= 0 && months <= 0))) {
	        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
	        days = 0;
	        months = 0;
	    }

	    // The following code bubbles up values, see the tests for
	    // examples of what that means.
	    data.milliseconds = milliseconds % 1000;

	    seconds           = absFloor(milliseconds / 1000);
	    data.seconds      = seconds % 60;

	    minutes           = absFloor(seconds / 60);
	    data.minutes      = minutes % 60;

	    hours             = absFloor(minutes / 60);
	    data.hours        = hours % 24;

	    days += absFloor(hours / 24);

	    // convert days to months
	    monthsFromDays = absFloor(daysToMonths(days));
	    months += monthsFromDays;
	    days -= absCeil(monthsToDays(monthsFromDays));

	    // 12 months -> 1 year
	    years = absFloor(months / 12);
	    months %= 12;

	    data.days   = days;
	    data.months = months;
	    data.years  = years;

	    return this;
	}

	function daysToMonths (days) {
	    // 400 years have 146097 days (taking into account leap year rules)
	    // 400 years have 12 months === 4800
	    return days * 4800 / 146097;
	}

	function monthsToDays (months) {
	    // the reverse of daysToMonths
	    return months * 146097 / 4800;
	}

	function as (units) {
	    if (!this.isValid()) {
	        return NaN;
	    }
	    var days;
	    var months;
	    var milliseconds = this._milliseconds;

	    units = normalizeUnits(units);

	    if (units === 'month' || units === 'year') {
	        days   = this._days   + milliseconds / 864e5;
	        months = this._months + daysToMonths(days);
	        return units === 'month' ? months : months / 12;
	    } else {
	        // handle milliseconds separately because of floating point math errors (issue #1867)
	        days = this._days + Math.round(monthsToDays(this._months));
	        switch (units) {
	            case 'week'   : return days / 7     + milliseconds / 6048e5;
	            case 'day'    : return days         + milliseconds / 864e5;
	            case 'hour'   : return days * 24    + milliseconds / 36e5;
	            case 'minute' : return days * 1440  + milliseconds / 6e4;
	            case 'second' : return days * 86400 + milliseconds / 1000;
	            // Math.floor prevents floating point math errors here
	            case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
	            default: throw new Error('Unknown unit ' + units);
	        }
	    }
	}

	// TODO: Use this.as('ms')?
	function valueOf$1 () {
	    if (!this.isValid()) {
	        return NaN;
	    }
	    return (
	        this._milliseconds +
	        this._days * 864e5 +
	        (this._months % 12) * 2592e6 +
	        toInt(this._months / 12) * 31536e6
	    );
	}

	function makeAs (alias) {
	    return function () {
	        return this.as(alias);
	    };
	}

	var asMilliseconds = makeAs('ms');
	var asSeconds      = makeAs('s');
	var asMinutes      = makeAs('m');
	var asHours        = makeAs('h');
	var asDays         = makeAs('d');
	var asWeeks        = makeAs('w');
	var asMonths       = makeAs('M');
	var asYears        = makeAs('y');

	function get$2 (units) {
	    units = normalizeUnits(units);
	    return this.isValid() ? this[units + 's']() : NaN;
	}

	function makeGetter(name) {
	    return function () {
	        return this.isValid() ? this._data[name] : NaN;
	    };
	}

	var milliseconds = makeGetter('milliseconds');
	var seconds      = makeGetter('seconds');
	var minutes      = makeGetter('minutes');
	var hours        = makeGetter('hours');
	var days         = makeGetter('days');
	var months       = makeGetter('months');
	var years        = makeGetter('years');

	function weeks () {
	    return absFloor(this.days() / 7);
	}

	var round = Math.round;
	var thresholds = {
	    ss: 44,         // a few seconds to seconds
	    s : 45,         // seconds to minute
	    m : 45,         // minutes to hour
	    h : 22,         // hours to day
	    d : 26,         // days to month
	    M : 11          // months to year
	};

	// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
	function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
	    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
	}

	function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
	    var duration = createDuration(posNegDuration).abs();
	    var seconds  = round(duration.as('s'));
	    var minutes  = round(duration.as('m'));
	    var hours    = round(duration.as('h'));
	    var days     = round(duration.as('d'));
	    var months   = round(duration.as('M'));
	    var years    = round(duration.as('y'));

	    var a = seconds <= thresholds.ss && ['s', seconds]  ||
	            seconds < thresholds.s   && ['ss', seconds] ||
	            minutes <= 1             && ['m']           ||
	            minutes < thresholds.m   && ['mm', minutes] ||
	            hours   <= 1             && ['h']           ||
	            hours   < thresholds.h   && ['hh', hours]   ||
	            days    <= 1             && ['d']           ||
	            days    < thresholds.d   && ['dd', days]    ||
	            months  <= 1             && ['M']           ||
	            months  < thresholds.M   && ['MM', months]  ||
	            years   <= 1             && ['y']           || ['yy', years];

	    a[2] = withoutSuffix;
	    a[3] = +posNegDuration > 0;
	    a[4] = locale;
	    return substituteTimeAgo.apply(null, a);
	}

	// This function allows you to set the rounding function for relative time strings
	function getSetRelativeTimeRounding (roundingFunction) {
	    if (roundingFunction === undefined) {
	        return round;
	    }
	    if (typeof(roundingFunction) === 'function') {
	        round = roundingFunction;
	        return true;
	    }
	    return false;
	}

	// This function allows you to set a threshold for relative time strings
	function getSetRelativeTimeThreshold (threshold, limit) {
	    if (thresholds[threshold] === undefined) {
	        return false;
	    }
	    if (limit === undefined) {
	        return thresholds[threshold];
	    }
	    thresholds[threshold] = limit;
	    if (threshold === 's') {
	        thresholds.ss = limit - 1;
	    }
	    return true;
	}

	function humanize (withSuffix) {
	    if (!this.isValid()) {
	        return this.localeData().invalidDate();
	    }

	    var locale = this.localeData();
	    var output = relativeTime$1(this, !withSuffix, locale);

	    if (withSuffix) {
	        output = locale.pastFuture(+this, output);
	    }

	    return locale.postformat(output);
	}

	var abs$1 = Math.abs;

	function toISOString$1() {
	    // for ISO strings we do not use the normal bubbling rules:
	    //  * milliseconds bubble up until they become hours
	    //  * days do not bubble at all
	    //  * months bubble up until they become years
	    // This is because there is no context-free conversion between hours and days
	    // (think of clock changes)
	    // and also not between days and months (28-31 days per month)
	    if (!this.isValid()) {
	        return this.localeData().invalidDate();
	    }

	    var seconds = abs$1(this._milliseconds) / 1000;
	    var days         = abs$1(this._days);
	    var months       = abs$1(this._months);
	    var minutes, hours, years;

	    // 3600 seconds -> 60 minutes -> 1 hour
	    minutes           = absFloor(seconds / 60);
	    hours             = absFloor(minutes / 60);
	    seconds %= 60;
	    minutes %= 60;

	    // 12 months -> 1 year
	    years  = absFloor(months / 12);
	    months %= 12;


	    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
	    var Y = years;
	    var M = months;
	    var D = days;
	    var h = hours;
	    var m = minutes;
	    var s = seconds;
	    var total = this.asSeconds();

	    if (!total) {
	        // this is the same as C#'s (Noda) and python (isodate)...
	        // but not other JS (goog.date)
	        return 'P0D';
	    }

	    return (total < 0 ? '-' : '') +
	        'P' +
	        (Y ? Y + 'Y' : '') +
	        (M ? M + 'M' : '') +
	        (D ? D + 'D' : '') +
	        ((h || m || s) ? 'T' : '') +
	        (h ? h + 'H' : '') +
	        (m ? m + 'M' : '') +
	        (s ? s + 'S' : '');
	}

	var proto$2 = Duration.prototype;

	proto$2.isValid        = isValid$1;
	proto$2.abs            = abs;
	proto$2.add            = add$1;
	proto$2.subtract       = subtract$1;
	proto$2.as             = as;
	proto$2.asMilliseconds = asMilliseconds;
	proto$2.asSeconds      = asSeconds;
	proto$2.asMinutes      = asMinutes;
	proto$2.asHours        = asHours;
	proto$2.asDays         = asDays;
	proto$2.asWeeks        = asWeeks;
	proto$2.asMonths       = asMonths;
	proto$2.asYears        = asYears;
	proto$2.valueOf        = valueOf$1;
	proto$2._bubble        = bubble;
	proto$2.get            = get$2;
	proto$2.milliseconds   = milliseconds;
	proto$2.seconds        = seconds;
	proto$2.minutes        = minutes;
	proto$2.hours          = hours;
	proto$2.days           = days;
	proto$2.weeks          = weeks;
	proto$2.months         = months;
	proto$2.years          = years;
	proto$2.humanize       = humanize;
	proto$2.toISOString    = toISOString$1;
	proto$2.toString       = toISOString$1;
	proto$2.toJSON         = toISOString$1;
	proto$2.locale         = locale;
	proto$2.localeData     = localeData;

	// Deprecations
	proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
	proto$2.lang = lang;

	// Side effect imports

	// FORMATTING

	addFormatToken('X', 0, 0, 'unix');
	addFormatToken('x', 0, 0, 'valueOf');

	// PARSING

	addRegexToken('x', matchSigned);
	addRegexToken('X', matchTimestamp);
	addParseToken('X', function (input, array, config) {
	    config._d = new Date(parseFloat(input, 10) * 1000);
	});
	addParseToken('x', function (input, array, config) {
	    config._d = new Date(toInt(input));
	});

	// Side effect imports


	hooks.version = '2.18.1';

	setHookCallback(createLocal);

	hooks.fn                    = proto;
	hooks.min                   = min;
	hooks.max                   = max;
	hooks.now                   = now;
	hooks.utc                   = createUTC;
	hooks.unix                  = createUnix;
	hooks.months                = listMonths;
	hooks.isDate                = isDate;
	hooks.locale                = getSetGlobalLocale;
	hooks.invalid               = createInvalid;
	hooks.duration              = createDuration;
	hooks.isMoment              = isMoment;
	hooks.weekdays              = listWeekdays;
	hooks.parseZone             = createInZone;
	hooks.localeData            = getLocale;
	hooks.isDuration            = isDuration;
	hooks.monthsShort           = listMonthsShort;
	hooks.weekdaysMin           = listWeekdaysMin;
	hooks.defineLocale          = defineLocale;
	hooks.updateLocale          = updateLocale;
	hooks.locales               = listLocales;
	hooks.weekdaysShort         = listWeekdaysShort;
	hooks.normalizeUnits        = normalizeUnits;
	hooks.relativeTimeRounding = getSetRelativeTimeRounding;
	hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
	hooks.calendarFormat        = getCalendarFormat;
	hooks.prototype             = proto;

	return hooks;

	})));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(78)(module)))

/***/ }),
/* 78 */
/***/ (function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

	var map = {
		"./af": 80,
		"./af.js": 80,
		"./ar": 81,
		"./ar-dz": 82,
		"./ar-dz.js": 82,
		"./ar-kw": 83,
		"./ar-kw.js": 83,
		"./ar-ly": 84,
		"./ar-ly.js": 84,
		"./ar-ma": 85,
		"./ar-ma.js": 85,
		"./ar-sa": 86,
		"./ar-sa.js": 86,
		"./ar-tn": 87,
		"./ar-tn.js": 87,
		"./ar.js": 81,
		"./az": 88,
		"./az.js": 88,
		"./be": 89,
		"./be.js": 89,
		"./bg": 90,
		"./bg.js": 90,
		"./bn": 91,
		"./bn.js": 91,
		"./bo": 92,
		"./bo.js": 92,
		"./br": 93,
		"./br.js": 93,
		"./bs": 94,
		"./bs.js": 94,
		"./ca": 95,
		"./ca.js": 95,
		"./cs": 96,
		"./cs.js": 96,
		"./cv": 97,
		"./cv.js": 97,
		"./cy": 98,
		"./cy.js": 98,
		"./da": 99,
		"./da.js": 99,
		"./de": 100,
		"./de-at": 101,
		"./de-at.js": 101,
		"./de-ch": 102,
		"./de-ch.js": 102,
		"./de.js": 100,
		"./dv": 103,
		"./dv.js": 103,
		"./el": 104,
		"./el.js": 104,
		"./en-au": 105,
		"./en-au.js": 105,
		"./en-ca": 106,
		"./en-ca.js": 106,
		"./en-gb": 107,
		"./en-gb.js": 107,
		"./en-ie": 108,
		"./en-ie.js": 108,
		"./en-nz": 109,
		"./en-nz.js": 109,
		"./eo": 110,
		"./eo.js": 110,
		"./es": 111,
		"./es-do": 112,
		"./es-do.js": 112,
		"./es.js": 111,
		"./et": 113,
		"./et.js": 113,
		"./eu": 114,
		"./eu.js": 114,
		"./fa": 115,
		"./fa.js": 115,
		"./fi": 116,
		"./fi.js": 116,
		"./fo": 117,
		"./fo.js": 117,
		"./fr": 118,
		"./fr-ca": 119,
		"./fr-ca.js": 119,
		"./fr-ch": 120,
		"./fr-ch.js": 120,
		"./fr.js": 118,
		"./fy": 121,
		"./fy.js": 121,
		"./gd": 122,
		"./gd.js": 122,
		"./gl": 123,
		"./gl.js": 123,
		"./gom-latn": 124,
		"./gom-latn.js": 124,
		"./he": 125,
		"./he.js": 125,
		"./hi": 126,
		"./hi.js": 126,
		"./hr": 127,
		"./hr.js": 127,
		"./hu": 128,
		"./hu.js": 128,
		"./hy-am": 129,
		"./hy-am.js": 129,
		"./id": 130,
		"./id.js": 130,
		"./is": 131,
		"./is.js": 131,
		"./it": 132,
		"./it.js": 132,
		"./ja": 133,
		"./ja.js": 133,
		"./jv": 134,
		"./jv.js": 134,
		"./ka": 135,
		"./ka.js": 135,
		"./kk": 136,
		"./kk.js": 136,
		"./km": 137,
		"./km.js": 137,
		"./kn": 138,
		"./kn.js": 138,
		"./ko": 139,
		"./ko.js": 139,
		"./ky": 140,
		"./ky.js": 140,
		"./lb": 141,
		"./lb.js": 141,
		"./lo": 142,
		"./lo.js": 142,
		"./lt": 143,
		"./lt.js": 143,
		"./lv": 144,
		"./lv.js": 144,
		"./me": 145,
		"./me.js": 145,
		"./mi": 146,
		"./mi.js": 146,
		"./mk": 147,
		"./mk.js": 147,
		"./ml": 148,
		"./ml.js": 148,
		"./mr": 149,
		"./mr.js": 149,
		"./ms": 150,
		"./ms-my": 151,
		"./ms-my.js": 151,
		"./ms.js": 150,
		"./my": 152,
		"./my.js": 152,
		"./nb": 153,
		"./nb.js": 153,
		"./ne": 154,
		"./ne.js": 154,
		"./nl": 155,
		"./nl-be": 156,
		"./nl-be.js": 156,
		"./nl.js": 155,
		"./nn": 157,
		"./nn.js": 157,
		"./pa-in": 158,
		"./pa-in.js": 158,
		"./pl": 159,
		"./pl.js": 159,
		"./pt": 160,
		"./pt-br": 161,
		"./pt-br.js": 161,
		"./pt.js": 160,
		"./ro": 162,
		"./ro.js": 162,
		"./ru": 163,
		"./ru.js": 163,
		"./sd": 164,
		"./sd.js": 164,
		"./se": 165,
		"./se.js": 165,
		"./si": 166,
		"./si.js": 166,
		"./sk": 167,
		"./sk.js": 167,
		"./sl": 168,
		"./sl.js": 168,
		"./sq": 169,
		"./sq.js": 169,
		"./sr": 170,
		"./sr-cyrl": 171,
		"./sr-cyrl.js": 171,
		"./sr.js": 170,
		"./ss": 172,
		"./ss.js": 172,
		"./sv": 173,
		"./sv.js": 173,
		"./sw": 174,
		"./sw.js": 174,
		"./ta": 175,
		"./ta.js": 175,
		"./te": 176,
		"./te.js": 176,
		"./tet": 177,
		"./tet.js": 177,
		"./th": 178,
		"./th.js": 178,
		"./tl-ph": 179,
		"./tl-ph.js": 179,
		"./tlh": 180,
		"./tlh.js": 180,
		"./tr": 181,
		"./tr.js": 181,
		"./tzl": 182,
		"./tzl.js": 182,
		"./tzm": 183,
		"./tzm-latn": 184,
		"./tzm-latn.js": 184,
		"./tzm.js": 183,
		"./uk": 185,
		"./uk.js": 185,
		"./ur": 186,
		"./ur.js": 186,
		"./uz": 187,
		"./uz-latn": 188,
		"./uz-latn.js": 188,
		"./uz.js": 187,
		"./vi": 189,
		"./vi.js": 189,
		"./x-pseudo": 190,
		"./x-pseudo.js": 190,
		"./yo": 191,
		"./yo.js": 191,
		"./zh-cn": 192,
		"./zh-cn.js": 192,
		"./zh-hk": 193,
		"./zh-hk.js": 193,
		"./zh-tw": 194,
		"./zh-tw.js": 194
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 79;


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Afrikaans [af]
	//! author : Werner Mollentze : https://github.com/wernerm

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var af = moment.defineLocale('af', {
	    months : 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split('_'),
	    monthsShort : 'Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),
	    weekdays : 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split('_'),
	    weekdaysShort : 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),
	    weekdaysMin : 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),
	    meridiemParse: /vm|nm/i,
	    isPM : function (input) {
	        return /^nm$/i.test(input);
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours < 12) {
	            return isLower ? 'vm' : 'VM';
	        } else {
	            return isLower ? 'nm' : 'NM';
	        }
	    },
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[Vandag om] LT',
	        nextDay : '[Môre om] LT',
	        nextWeek : 'dddd [om] LT',
	        lastDay : '[Gister om] LT',
	        lastWeek : '[Laas] dddd [om] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'oor %s',
	        past : '%s gelede',
	        s : '\'n paar sekondes',
	        m : '\'n minuut',
	        mm : '%d minute',
	        h : '\'n uur',
	        hh : '%d ure',
	        d : '\'n dag',
	        dd : '%d dae',
	        M : '\'n maand',
	        MM : '%d maande',
	        y : '\'n jaar',
	        yy : '%d jaar'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
	    ordinal : function (number) {
	        return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de'); // Thanks to Joris Röling : https://github.com/jjupiter
	    },
	    week : {
	        dow : 1, // Maandag is die eerste dag van die week.
	        doy : 4  // Die week wat die 4de Januarie bevat is die eerste week van die jaar.
	    }
	});

	return af;

	})));


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Arabic [ar]
	//! author : Abdel Said: https://github.com/abdelsaid
	//! author : Ahmed Elkhatib
	//! author : forabi https://github.com/forabi

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var symbolMap = {
	    '1': '١',
	    '2': '٢',
	    '3': '٣',
	    '4': '٤',
	    '5': '٥',
	    '6': '٦',
	    '7': '٧',
	    '8': '٨',
	    '9': '٩',
	    '0': '٠'
	};
	var numberMap = {
	    '١': '1',
	    '٢': '2',
	    '٣': '3',
	    '٤': '4',
	    '٥': '5',
	    '٦': '6',
	    '٧': '7',
	    '٨': '8',
	    '٩': '9',
	    '٠': '0'
	};
	var pluralForm = function (n) {
	    return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
	};
	var plurals = {
	    s : ['أقل من ثانية', 'ثانية واحدة', ['ثانيتان', 'ثانيتين'], '%d ثوان', '%d ثانية', '%d ثانية'],
	    m : ['أقل من دقيقة', 'دقيقة واحدة', ['دقيقتان', 'دقيقتين'], '%d دقائق', '%d دقيقة', '%d دقيقة'],
	    h : ['أقل من ساعة', 'ساعة واحدة', ['ساعتان', 'ساعتين'], '%d ساعات', '%d ساعة', '%d ساعة'],
	    d : ['أقل من يوم', 'يوم واحد', ['يومان', 'يومين'], '%d أيام', '%d يومًا', '%d يوم'],
	    M : ['أقل من شهر', 'شهر واحد', ['شهران', 'شهرين'], '%d أشهر', '%d شهرا', '%d شهر'],
	    y : ['أقل من عام', 'عام واحد', ['عامان', 'عامين'], '%d أعوام', '%d عامًا', '%d عام']
	};
	var pluralize = function (u) {
	    return function (number, withoutSuffix, string, isFuture) {
	        var f = pluralForm(number),
	            str = plurals[u][pluralForm(number)];
	        if (f === 2) {
	            str = str[withoutSuffix ? 0 : 1];
	        }
	        return str.replace(/%d/i, number);
	    };
	};
	var months = [
	    'كانون الثاني يناير',
	    'شباط فبراير',
	    'آذار مارس',
	    'نيسان أبريل',
	    'أيار مايو',
	    'حزيران يونيو',
	    'تموز يوليو',
	    'آب أغسطس',
	    'أيلول سبتمبر',
	    'تشرين الأول أكتوبر',
	    'تشرين الثاني نوفمبر',
	    'كانون الأول ديسمبر'
	];

	var ar = moment.defineLocale('ar', {
	    months : months,
	    monthsShort : months,
	    weekdays : 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
	    weekdaysShort : 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
	    weekdaysMin : 'ح_ن_ث_ر_خ_ج_س'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'D/\u200FM/\u200FYYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    meridiemParse: /ص|م/,
	    isPM : function (input) {
	        return 'م' === input;
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 12) {
	            return 'ص';
	        } else {
	            return 'م';
	        }
	    },
	    calendar : {
	        sameDay: '[اليوم عند الساعة] LT',
	        nextDay: '[غدًا عند الساعة] LT',
	        nextWeek: 'dddd [عند الساعة] LT',
	        lastDay: '[أمس عند الساعة] LT',
	        lastWeek: 'dddd [عند الساعة] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'بعد %s',
	        past : 'منذ %s',
	        s : pluralize('s'),
	        m : pluralize('m'),
	        mm : pluralize('m'),
	        h : pluralize('h'),
	        hh : pluralize('h'),
	        d : pluralize('d'),
	        dd : pluralize('d'),
	        M : pluralize('M'),
	        MM : pluralize('M'),
	        y : pluralize('y'),
	        yy : pluralize('y')
	    },
	    preparse: function (string) {
	        return string.replace(/\u200f/g, '').replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
	            return numberMap[match];
	        }).replace(/،/g, ',');
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        }).replace(/,/g, '،');
	    },
	    week : {
	        dow : 6, // Saturday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return ar;

	})));


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Arabic (Algeria) [ar-dz]
	//! author : Noureddine LOUAHEDJ : https://github.com/noureddineme

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var arDz = moment.defineLocale('ar-dz', {
	    months : 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
	    monthsShort : 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
	    weekdays : 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
	    weekdaysShort : 'احد_اثنين_ثلاثاء_اربعاء_خميس_جمعة_سبت'.split('_'),
	    weekdaysMin : 'أح_إث_ثلا_أر_خم_جم_سب'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[اليوم على الساعة] LT',
	        nextDay: '[غدا على الساعة] LT',
	        nextWeek: 'dddd [على الساعة] LT',
	        lastDay: '[أمس على الساعة] LT',
	        lastWeek: 'dddd [على الساعة] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'في %s',
	        past : 'منذ %s',
	        s : 'ثوان',
	        m : 'دقيقة',
	        mm : '%d دقائق',
	        h : 'ساعة',
	        hh : '%d ساعات',
	        d : 'يوم',
	        dd : '%d أيام',
	        M : 'شهر',
	        MM : '%d أشهر',
	        y : 'سنة',
	        yy : '%d سنوات'
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 4  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return arDz;

	})));


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Arabic (Kuwait) [ar-kw]
	//! author : Nusret Parlak: https://github.com/nusretparlak

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var arKw = moment.defineLocale('ar-kw', {
	    months : 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split('_'),
	    monthsShort : 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split('_'),
	    weekdays : 'الأحد_الإتنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
	    weekdaysShort : 'احد_اتنين_ثلاثاء_اربعاء_خميس_جمعة_سبت'.split('_'),
	    weekdaysMin : 'ح_ن_ث_ر_خ_ج_س'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[اليوم على الساعة] LT',
	        nextDay: '[غدا على الساعة] LT',
	        nextWeek: 'dddd [على الساعة] LT',
	        lastDay: '[أمس على الساعة] LT',
	        lastWeek: 'dddd [على الساعة] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'في %s',
	        past : 'منذ %s',
	        s : 'ثوان',
	        m : 'دقيقة',
	        mm : '%d دقائق',
	        h : 'ساعة',
	        hh : '%d ساعات',
	        d : 'يوم',
	        dd : '%d أيام',
	        M : 'شهر',
	        MM : '%d أشهر',
	        y : 'سنة',
	        yy : '%d سنوات'
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return arKw;

	})));


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Arabic (Lybia) [ar-ly]
	//! author : Ali Hmer: https://github.com/kikoanis

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var symbolMap = {
	    '1': '1',
	    '2': '2',
	    '3': '3',
	    '4': '4',
	    '5': '5',
	    '6': '6',
	    '7': '7',
	    '8': '8',
	    '9': '9',
	    '0': '0'
	};
	var pluralForm = function (n) {
	    return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
	};
	var plurals = {
	    s : ['أقل من ثانية', 'ثانية واحدة', ['ثانيتان', 'ثانيتين'], '%d ثوان', '%d ثانية', '%d ثانية'],
	    m : ['أقل من دقيقة', 'دقيقة واحدة', ['دقيقتان', 'دقيقتين'], '%d دقائق', '%d دقيقة', '%d دقيقة'],
	    h : ['أقل من ساعة', 'ساعة واحدة', ['ساعتان', 'ساعتين'], '%d ساعات', '%d ساعة', '%d ساعة'],
	    d : ['أقل من يوم', 'يوم واحد', ['يومان', 'يومين'], '%d أيام', '%d يومًا', '%d يوم'],
	    M : ['أقل من شهر', 'شهر واحد', ['شهران', 'شهرين'], '%d أشهر', '%d شهرا', '%d شهر'],
	    y : ['أقل من عام', 'عام واحد', ['عامان', 'عامين'], '%d أعوام', '%d عامًا', '%d عام']
	};
	var pluralize = function (u) {
	    return function (number, withoutSuffix, string, isFuture) {
	        var f = pluralForm(number),
	            str = plurals[u][pluralForm(number)];
	        if (f === 2) {
	            str = str[withoutSuffix ? 0 : 1];
	        }
	        return str.replace(/%d/i, number);
	    };
	};
	var months = [
	    'يناير',
	    'فبراير',
	    'مارس',
	    'أبريل',
	    'مايو',
	    'يونيو',
	    'يوليو',
	    'أغسطس',
	    'سبتمبر',
	    'أكتوبر',
	    'نوفمبر',
	    'ديسمبر'
	];

	var arLy = moment.defineLocale('ar-ly', {
	    months : months,
	    monthsShort : months,
	    weekdays : 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
	    weekdaysShort : 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
	    weekdaysMin : 'ح_ن_ث_ر_خ_ج_س'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'D/\u200FM/\u200FYYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    meridiemParse: /ص|م/,
	    isPM : function (input) {
	        return 'م' === input;
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 12) {
	            return 'ص';
	        } else {
	            return 'م';
	        }
	    },
	    calendar : {
	        sameDay: '[اليوم عند الساعة] LT',
	        nextDay: '[غدًا عند الساعة] LT',
	        nextWeek: 'dddd [عند الساعة] LT',
	        lastDay: '[أمس عند الساعة] LT',
	        lastWeek: 'dddd [عند الساعة] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'بعد %s',
	        past : 'منذ %s',
	        s : pluralize('s'),
	        m : pluralize('m'),
	        mm : pluralize('m'),
	        h : pluralize('h'),
	        hh : pluralize('h'),
	        d : pluralize('d'),
	        dd : pluralize('d'),
	        M : pluralize('M'),
	        MM : pluralize('M'),
	        y : pluralize('y'),
	        yy : pluralize('y')
	    },
	    preparse: function (string) {
	        return string.replace(/\u200f/g, '').replace(/،/g, ',');
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        }).replace(/,/g, '،');
	    },
	    week : {
	        dow : 6, // Saturday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return arLy;

	})));


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Arabic (Morocco) [ar-ma]
	//! author : ElFadili Yassine : https://github.com/ElFadiliY
	//! author : Abdel Said : https://github.com/abdelsaid

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var arMa = moment.defineLocale('ar-ma', {
	    months : 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split('_'),
	    monthsShort : 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split('_'),
	    weekdays : 'الأحد_الإتنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
	    weekdaysShort : 'احد_اتنين_ثلاثاء_اربعاء_خميس_جمعة_سبت'.split('_'),
	    weekdaysMin : 'ح_ن_ث_ر_خ_ج_س'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[اليوم على الساعة] LT',
	        nextDay: '[غدا على الساعة] LT',
	        nextWeek: 'dddd [على الساعة] LT',
	        lastDay: '[أمس على الساعة] LT',
	        lastWeek: 'dddd [على الساعة] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'في %s',
	        past : 'منذ %s',
	        s : 'ثوان',
	        m : 'دقيقة',
	        mm : '%d دقائق',
	        h : 'ساعة',
	        hh : '%d ساعات',
	        d : 'يوم',
	        dd : '%d أيام',
	        M : 'شهر',
	        MM : '%d أشهر',
	        y : 'سنة',
	        yy : '%d سنوات'
	    },
	    week : {
	        dow : 6, // Saturday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return arMa;

	})));


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Arabic (Saudi Arabia) [ar-sa]
	//! author : Suhail Alkowaileet : https://github.com/xsoh

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var symbolMap = {
	    '1': '١',
	    '2': '٢',
	    '3': '٣',
	    '4': '٤',
	    '5': '٥',
	    '6': '٦',
	    '7': '٧',
	    '8': '٨',
	    '9': '٩',
	    '0': '٠'
	};
	var numberMap = {
	    '١': '1',
	    '٢': '2',
	    '٣': '3',
	    '٤': '4',
	    '٥': '5',
	    '٦': '6',
	    '٧': '7',
	    '٨': '8',
	    '٩': '9',
	    '٠': '0'
	};

	var arSa = moment.defineLocale('ar-sa', {
	    months : 'يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
	    monthsShort : 'يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
	    weekdays : 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
	    weekdaysShort : 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
	    weekdaysMin : 'ح_ن_ث_ر_خ_ج_س'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    meridiemParse: /ص|م/,
	    isPM : function (input) {
	        return 'م' === input;
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 12) {
	            return 'ص';
	        } else {
	            return 'م';
	        }
	    },
	    calendar : {
	        sameDay: '[اليوم على الساعة] LT',
	        nextDay: '[غدا على الساعة] LT',
	        nextWeek: 'dddd [على الساعة] LT',
	        lastDay: '[أمس على الساعة] LT',
	        lastWeek: 'dddd [على الساعة] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'في %s',
	        past : 'منذ %s',
	        s : 'ثوان',
	        m : 'دقيقة',
	        mm : '%d دقائق',
	        h : 'ساعة',
	        hh : '%d ساعات',
	        d : 'يوم',
	        dd : '%d أيام',
	        M : 'شهر',
	        MM : '%d أشهر',
	        y : 'سنة',
	        yy : '%d سنوات'
	    },
	    preparse: function (string) {
	        return string.replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
	            return numberMap[match];
	        }).replace(/،/g, ',');
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        }).replace(/,/g, '،');
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return arSa;

	})));


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale  :  Arabic (Tunisia) [ar-tn]
	//! author : Nader Toukabri : https://github.com/naderio

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var arTn = moment.defineLocale('ar-tn', {
	    months: 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
	    monthsShort: 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
	    weekdays: 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
	    weekdaysShort: 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
	    weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat: {
	        LT: 'HH:mm',
	        LTS: 'HH:mm:ss',
	        L: 'DD/MM/YYYY',
	        LL: 'D MMMM YYYY',
	        LLL: 'D MMMM YYYY HH:mm',
	        LLLL: 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar: {
	        sameDay: '[اليوم على الساعة] LT',
	        nextDay: '[غدا على الساعة] LT',
	        nextWeek: 'dddd [على الساعة] LT',
	        lastDay: '[أمس على الساعة] LT',
	        lastWeek: 'dddd [على الساعة] LT',
	        sameElse: 'L'
	    },
	    relativeTime: {
	        future: 'في %s',
	        past: 'منذ %s',
	        s: 'ثوان',
	        m: 'دقيقة',
	        mm: '%d دقائق',
	        h: 'ساعة',
	        hh: '%d ساعات',
	        d: 'يوم',
	        dd: '%d أيام',
	        M: 'شهر',
	        MM: '%d أشهر',
	        y: 'سنة',
	        yy: '%d سنوات'
	    },
	    week: {
	        dow: 1, // Monday is the first day of the week.
	        doy: 4 // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return arTn;

	})));


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Azerbaijani [az]
	//! author : topchiyev : https://github.com/topchiyev

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var suffixes = {
	    1: '-inci',
	    5: '-inci',
	    8: '-inci',
	    70: '-inci',
	    80: '-inci',
	    2: '-nci',
	    7: '-nci',
	    20: '-nci',
	    50: '-nci',
	    3: '-üncü',
	    4: '-üncü',
	    100: '-üncü',
	    6: '-ncı',
	    9: '-uncu',
	    10: '-uncu',
	    30: '-uncu',
	    60: '-ıncı',
	    90: '-ıncı'
	};

	var az = moment.defineLocale('az', {
	    months : 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split('_'),
	    monthsShort : 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),
	    weekdays : 'Bazar_Bazar ertəsi_Çərşənbə axşamı_Çərşənbə_Cümə axşamı_Cümə_Şənbə'.split('_'),
	    weekdaysShort : 'Baz_BzE_ÇAx_Çər_CAx_Cüm_Şən'.split('_'),
	    weekdaysMin : 'Bz_BE_ÇA_Çə_CA_Cü_Şə'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[bugün saat] LT',
	        nextDay : '[sabah saat] LT',
	        nextWeek : '[gələn həftə] dddd [saat] LT',
	        lastDay : '[dünən] LT',
	        lastWeek : '[keçən həftə] dddd [saat] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s sonra',
	        past : '%s əvvəl',
	        s : 'birneçə saniyyə',
	        m : 'bir dəqiqə',
	        mm : '%d dəqiqə',
	        h : 'bir saat',
	        hh : '%d saat',
	        d : 'bir gün',
	        dd : '%d gün',
	        M : 'bir ay',
	        MM : '%d ay',
	        y : 'bir il',
	        yy : '%d il'
	    },
	    meridiemParse: /gecə|səhər|gündüz|axşam/,
	    isPM : function (input) {
	        return /^(gündüz|axşam)$/.test(input);
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return 'gecə';
	        } else if (hour < 12) {
	            return 'səhər';
	        } else if (hour < 17) {
	            return 'gündüz';
	        } else {
	            return 'axşam';
	        }
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}-(ıncı|inci|nci|üncü|ncı|uncu)/,
	    ordinal : function (number) {
	        if (number === 0) {  // special case for zero
	            return number + '-ıncı';
	        }
	        var a = number % 10,
	            b = number % 100 - a,
	            c = number >= 100 ? 100 : null;
	        return number + (suffixes[a] || suffixes[b] || suffixes[c]);
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return az;

	})));


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Belarusian [be]
	//! author : Dmitry Demidov : https://github.com/demidov91
	//! author: Praleska: http://praleska.pro/
	//! Author : Menelion Elensúle : https://github.com/Oire

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	function plural(word, num) {
	    var forms = word.split('_');
	    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
	}
	function relativeTimeWithPlural(number, withoutSuffix, key) {
	    var format = {
	        'mm': withoutSuffix ? 'хвіліна_хвіліны_хвілін' : 'хвіліну_хвіліны_хвілін',
	        'hh': withoutSuffix ? 'гадзіна_гадзіны_гадзін' : 'гадзіну_гадзіны_гадзін',
	        'dd': 'дзень_дні_дзён',
	        'MM': 'месяц_месяцы_месяцаў',
	        'yy': 'год_гады_гадоў'
	    };
	    if (key === 'm') {
	        return withoutSuffix ? 'хвіліна' : 'хвіліну';
	    }
	    else if (key === 'h') {
	        return withoutSuffix ? 'гадзіна' : 'гадзіну';
	    }
	    else {
	        return number + ' ' + plural(format[key], +number);
	    }
	}

	var be = moment.defineLocale('be', {
	    months : {
	        format: 'студзеня_лютага_сакавіка_красавіка_траўня_чэрвеня_ліпеня_жніўня_верасня_кастрычніка_лістапада_снежня'.split('_'),
	        standalone: 'студзень_люты_сакавік_красавік_травень_чэрвень_ліпень_жнівень_верасень_кастрычнік_лістапад_снежань'.split('_')
	    },
	    monthsShort : 'студ_лют_сак_крас_трав_чэрв_ліп_жнів_вер_каст_ліст_снеж'.split('_'),
	    weekdays : {
	        format: 'нядзелю_панядзелак_аўторак_сераду_чацвер_пятніцу_суботу'.split('_'),
	        standalone: 'нядзеля_панядзелак_аўторак_серада_чацвер_пятніца_субота'.split('_'),
	        isFormat: /\[ ?[Вв] ?(?:мінулую|наступную)? ?\] ?dddd/
	    },
	    weekdaysShort : 'нд_пн_ат_ср_чц_пт_сб'.split('_'),
	    weekdaysMin : 'нд_пн_ат_ср_чц_пт_сб'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY г.',
	        LLL : 'D MMMM YYYY г., HH:mm',
	        LLLL : 'dddd, D MMMM YYYY г., HH:mm'
	    },
	    calendar : {
	        sameDay: '[Сёння ў] LT',
	        nextDay: '[Заўтра ў] LT',
	        lastDay: '[Учора ў] LT',
	        nextWeek: function () {
	            return '[У] dddd [ў] LT';
	        },
	        lastWeek: function () {
	            switch (this.day()) {
	                case 0:
	                case 3:
	                case 5:
	                case 6:
	                    return '[У мінулую] dddd [ў] LT';
	                case 1:
	                case 2:
	                case 4:
	                    return '[У мінулы] dddd [ў] LT';
	            }
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'праз %s',
	        past : '%s таму',
	        s : 'некалькі секунд',
	        m : relativeTimeWithPlural,
	        mm : relativeTimeWithPlural,
	        h : relativeTimeWithPlural,
	        hh : relativeTimeWithPlural,
	        d : 'дзень',
	        dd : relativeTimeWithPlural,
	        M : 'месяц',
	        MM : relativeTimeWithPlural,
	        y : 'год',
	        yy : relativeTimeWithPlural
	    },
	    meridiemParse: /ночы|раніцы|дня|вечара/,
	    isPM : function (input) {
	        return /^(дня|вечара)$/.test(input);
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return 'ночы';
	        } else if (hour < 12) {
	            return 'раніцы';
	        } else if (hour < 17) {
	            return 'дня';
	        } else {
	            return 'вечара';
	        }
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}-(і|ы|га)/,
	    ordinal: function (number, period) {
	        switch (period) {
	            case 'M':
	            case 'd':
	            case 'DDD':
	            case 'w':
	            case 'W':
	                return (number % 10 === 2 || number % 10 === 3) && (number % 100 !== 12 && number % 100 !== 13) ? number + '-і' : number + '-ы';
	            case 'D':
	                return number + '-га';
	            default:
	                return number;
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return be;

	})));


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Bulgarian [bg]
	//! author : Krasen Borisov : https://github.com/kraz

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var bg = moment.defineLocale('bg', {
	    months : 'януари_февруари_март_април_май_юни_юли_август_септември_октомври_ноември_декември'.split('_'),
	    monthsShort : 'янр_фев_мар_апр_май_юни_юли_авг_сеп_окт_ное_дек'.split('_'),
	    weekdays : 'неделя_понеделник_вторник_сряда_четвъртък_петък_събота'.split('_'),
	    weekdaysShort : 'нед_пон_вто_сря_чет_пет_съб'.split('_'),
	    weekdaysMin : 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'D.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY H:mm',
	        LLLL : 'dddd, D MMMM YYYY H:mm'
	    },
	    calendar : {
	        sameDay : '[Днес в] LT',
	        nextDay : '[Утре в] LT',
	        nextWeek : 'dddd [в] LT',
	        lastDay : '[Вчера в] LT',
	        lastWeek : function () {
	            switch (this.day()) {
	                case 0:
	                case 3:
	                case 6:
	                    return '[В изминалата] dddd [в] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[В изминалия] dddd [в] LT';
	            }
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'след %s',
	        past : 'преди %s',
	        s : 'няколко секунди',
	        m : 'минута',
	        mm : '%d минути',
	        h : 'час',
	        hh : '%d часа',
	        d : 'ден',
	        dd : '%d дни',
	        M : 'месец',
	        MM : '%d месеца',
	        y : 'година',
	        yy : '%d години'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/,
	    ordinal : function (number) {
	        var lastDigit = number % 10,
	            last2Digits = number % 100;
	        if (number === 0) {
	            return number + '-ев';
	        } else if (last2Digits === 0) {
	            return number + '-ен';
	        } else if (last2Digits > 10 && last2Digits < 20) {
	            return number + '-ти';
	        } else if (lastDigit === 1) {
	            return number + '-ви';
	        } else if (lastDigit === 2) {
	            return number + '-ри';
	        } else if (lastDigit === 7 || lastDigit === 8) {
	            return number + '-ми';
	        } else {
	            return number + '-ти';
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return bg;

	})));


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Bengali [bn]
	//! author : Kaushik Gandhi : https://github.com/kaushikgandhi

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var symbolMap = {
	    '1': '১',
	    '2': '২',
	    '3': '৩',
	    '4': '৪',
	    '5': '৫',
	    '6': '৬',
	    '7': '৭',
	    '8': '৮',
	    '9': '৯',
	    '0': '০'
	};
	var numberMap = {
	    '১': '1',
	    '২': '2',
	    '৩': '3',
	    '৪': '4',
	    '৫': '5',
	    '৬': '6',
	    '৭': '7',
	    '৮': '8',
	    '৯': '9',
	    '০': '0'
	};

	var bn = moment.defineLocale('bn', {
	    months : 'জানুয়ারী_ফেব্রুয়ারি_মার্চ_এপ্রিল_মে_জুন_জুলাই_আগস্ট_সেপ্টেম্বর_অক্টোবর_নভেম্বর_ডিসেম্বর'.split('_'),
	    monthsShort : 'জানু_ফেব_মার্চ_এপ্র_মে_জুন_জুল_আগ_সেপ্ট_অক্টো_নভে_ডিসে'.split('_'),
	    weekdays : 'রবিবার_সোমবার_মঙ্গলবার_বুধবার_বৃহস্পতিবার_শুক্রবার_শনিবার'.split('_'),
	    weekdaysShort : 'রবি_সোম_মঙ্গল_বুধ_বৃহস্পতি_শুক্র_শনি'.split('_'),
	    weekdaysMin : 'রবি_সোম_মঙ্গ_বুধ_বৃহঃ_শুক্র_শনি'.split('_'),
	    longDateFormat : {
	        LT : 'A h:mm সময়',
	        LTS : 'A h:mm:ss সময়',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, A h:mm সময়',
	        LLLL : 'dddd, D MMMM YYYY, A h:mm সময়'
	    },
	    calendar : {
	        sameDay : '[আজ] LT',
	        nextDay : '[আগামীকাল] LT',
	        nextWeek : 'dddd, LT',
	        lastDay : '[গতকাল] LT',
	        lastWeek : '[গত] dddd, LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s পরে',
	        past : '%s আগে',
	        s : 'কয়েক সেকেন্ড',
	        m : 'এক মিনিট',
	        mm : '%d মিনিট',
	        h : 'এক ঘন্টা',
	        hh : '%d ঘন্টা',
	        d : 'এক দিন',
	        dd : '%d দিন',
	        M : 'এক মাস',
	        MM : '%d মাস',
	        y : 'এক বছর',
	        yy : '%d বছর'
	    },
	    preparse: function (string) {
	        return string.replace(/[১২৩৪৫৬৭৮৯০]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    meridiemParse: /রাত|সকাল|দুপুর|বিকাল|রাত/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if ((meridiem === 'রাত' && hour >= 4) ||
	                (meridiem === 'দুপুর' && hour < 5) ||
	                meridiem === 'বিকাল') {
	            return hour + 12;
	        } else {
	            return hour;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return 'রাত';
	        } else if (hour < 10) {
	            return 'সকাল';
	        } else if (hour < 17) {
	            return 'দুপুর';
	        } else if (hour < 20) {
	            return 'বিকাল';
	        } else {
	            return 'রাত';
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return bn;

	})));


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Tibetan [bo]
	//! author : Thupten N. Chakrishar : https://github.com/vajradog

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var symbolMap = {
	    '1': '༡',
	    '2': '༢',
	    '3': '༣',
	    '4': '༤',
	    '5': '༥',
	    '6': '༦',
	    '7': '༧',
	    '8': '༨',
	    '9': '༩',
	    '0': '༠'
	};
	var numberMap = {
	    '༡': '1',
	    '༢': '2',
	    '༣': '3',
	    '༤': '4',
	    '༥': '5',
	    '༦': '6',
	    '༧': '7',
	    '༨': '8',
	    '༩': '9',
	    '༠': '0'
	};

	var bo = moment.defineLocale('bo', {
	    months : 'ཟླ་བ་དང་པོ_ཟླ་བ་གཉིས་པ_ཟླ་བ་གསུམ་པ_ཟླ་བ་བཞི་པ_ཟླ་བ་ལྔ་པ_ཟླ་བ་དྲུག་པ_ཟླ་བ་བདུན་པ_ཟླ་བ་བརྒྱད་པ_ཟླ་བ་དགུ་པ_ཟླ་བ་བཅུ་པ_ཟླ་བ་བཅུ་གཅིག་པ_ཟླ་བ་བཅུ་གཉིས་པ'.split('_'),
	    monthsShort : 'ཟླ་བ་དང་པོ_ཟླ་བ་གཉིས་པ_ཟླ་བ་གསུམ་པ_ཟླ་བ་བཞི་པ_ཟླ་བ་ལྔ་པ_ཟླ་བ་དྲུག་པ_ཟླ་བ་བདུན་པ_ཟླ་བ་བརྒྱད་པ_ཟླ་བ་དགུ་པ_ཟླ་བ་བཅུ་པ_ཟླ་བ་བཅུ་གཅིག་པ_ཟླ་བ་བཅུ་གཉིས་པ'.split('_'),
	    weekdays : 'གཟའ་ཉི་མ་_གཟའ་ཟླ་བ་_གཟའ་མིག་དམར་_གཟའ་ལྷག་པ་_གཟའ་ཕུར་བུ_གཟའ་པ་སངས་_གཟའ་སྤེན་པ་'.split('_'),
	    weekdaysShort : 'ཉི་མ་_ཟླ་བ་_མིག་དམར་_ལྷག་པ་_ཕུར་བུ_པ་སངས་_སྤེན་པ་'.split('_'),
	    weekdaysMin : 'ཉི་མ་_ཟླ་བ་_མིག་དམར་_ལྷག་པ་_ཕུར་བུ_པ་སངས་_སྤེན་པ་'.split('_'),
	    longDateFormat : {
	        LT : 'A h:mm',
	        LTS : 'A h:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, A h:mm',
	        LLLL : 'dddd, D MMMM YYYY, A h:mm'
	    },
	    calendar : {
	        sameDay : '[དི་རིང] LT',
	        nextDay : '[སང་ཉིན] LT',
	        nextWeek : '[བདུན་ཕྲག་རྗེས་མ], LT',
	        lastDay : '[ཁ་སང] LT',
	        lastWeek : '[བདུན་ཕྲག་མཐའ་མ] dddd, LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s ལ་',
	        past : '%s སྔན་ལ',
	        s : 'ལམ་སང',
	        m : 'སྐར་མ་གཅིག',
	        mm : '%d སྐར་མ',
	        h : 'ཆུ་ཚོད་གཅིག',
	        hh : '%d ཆུ་ཚོད',
	        d : 'ཉིན་གཅིག',
	        dd : '%d ཉིན་',
	        M : 'ཟླ་བ་གཅིག',
	        MM : '%d ཟླ་བ',
	        y : 'ལོ་གཅིག',
	        yy : '%d ལོ'
	    },
	    preparse: function (string) {
	        return string.replace(/[༡༢༣༤༥༦༧༨༩༠]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    meridiemParse: /མཚན་མོ|ཞོགས་ཀས|ཉིན་གུང|དགོང་དག|མཚན་མོ/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if ((meridiem === 'མཚན་མོ' && hour >= 4) ||
	                (meridiem === 'ཉིན་གུང' && hour < 5) ||
	                meridiem === 'དགོང་དག') {
	            return hour + 12;
	        } else {
	            return hour;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return 'མཚན་མོ';
	        } else if (hour < 10) {
	            return 'ཞོགས་ཀས';
	        } else if (hour < 17) {
	            return 'ཉིན་གུང';
	        } else if (hour < 20) {
	            return 'དགོང་དག';
	        } else {
	            return 'མཚན་མོ';
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return bo;

	})));


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Breton [br]
	//! author : Jean-Baptiste Le Duigou : https://github.com/jbleduigou

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	function relativeTimeWithMutation(number, withoutSuffix, key) {
	    var format = {
	        'mm': 'munutenn',
	        'MM': 'miz',
	        'dd': 'devezh'
	    };
	    return number + ' ' + mutation(format[key], number);
	}
	function specialMutationForYears(number) {
	    switch (lastNumber(number)) {
	        case 1:
	        case 3:
	        case 4:
	        case 5:
	        case 9:
	            return number + ' bloaz';
	        default:
	            return number + ' vloaz';
	    }
	}
	function lastNumber(number) {
	    if (number > 9) {
	        return lastNumber(number % 10);
	    }
	    return number;
	}
	function mutation(text, number) {
	    if (number === 2) {
	        return softMutation(text);
	    }
	    return text;
	}
	function softMutation(text) {
	    var mutationTable = {
	        'm': 'v',
	        'b': 'v',
	        'd': 'z'
	    };
	    if (mutationTable[text.charAt(0)] === undefined) {
	        return text;
	    }
	    return mutationTable[text.charAt(0)] + text.substring(1);
	}

	var br = moment.defineLocale('br', {
	    months : 'Genver_C\'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu'.split('_'),
	    monthsShort : 'Gen_C\'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker'.split('_'),
	    weekdays : 'Sul_Lun_Meurzh_Merc\'her_Yaou_Gwener_Sadorn'.split('_'),
	    weekdaysShort : 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),
	    weekdaysMin : 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'h[e]mm A',
	        LTS : 'h[e]mm:ss A',
	        L : 'DD/MM/YYYY',
	        LL : 'D [a viz] MMMM YYYY',
	        LLL : 'D [a viz] MMMM YYYY h[e]mm A',
	        LLLL : 'dddd, D [a viz] MMMM YYYY h[e]mm A'
	    },
	    calendar : {
	        sameDay : '[Hiziv da] LT',
	        nextDay : '[Warc\'hoazh da] LT',
	        nextWeek : 'dddd [da] LT',
	        lastDay : '[Dec\'h da] LT',
	        lastWeek : 'dddd [paset da] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'a-benn %s',
	        past : '%s \'zo',
	        s : 'un nebeud segondennoù',
	        m : 'ur vunutenn',
	        mm : relativeTimeWithMutation,
	        h : 'un eur',
	        hh : '%d eur',
	        d : 'un devezh',
	        dd : relativeTimeWithMutation,
	        M : 'ur miz',
	        MM : relativeTimeWithMutation,
	        y : 'ur bloaz',
	        yy : specialMutationForYears
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(añ|vet)/,
	    ordinal : function (number) {
	        var output = (number === 1) ? 'añ' : 'vet';
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return br;

	})));


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Bosnian [bs]
	//! author : Nedim Cholich : https://github.com/frontyard
	//! based on (hr) translation by Bojan Marković

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	function translate(number, withoutSuffix, key) {
	    var result = number + ' ';
	    switch (key) {
	        case 'm':
	            return withoutSuffix ? 'jedna minuta' : 'jedne minute';
	        case 'mm':
	            if (number === 1) {
	                result += 'minuta';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'minute';
	            } else {
	                result += 'minuta';
	            }
	            return result;
	        case 'h':
	            return withoutSuffix ? 'jedan sat' : 'jednog sata';
	        case 'hh':
	            if (number === 1) {
	                result += 'sat';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'sata';
	            } else {
	                result += 'sati';
	            }
	            return result;
	        case 'dd':
	            if (number === 1) {
	                result += 'dan';
	            } else {
	                result += 'dana';
	            }
	            return result;
	        case 'MM':
	            if (number === 1) {
	                result += 'mjesec';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'mjeseca';
	            } else {
	                result += 'mjeseci';
	            }
	            return result;
	        case 'yy':
	            if (number === 1) {
	                result += 'godina';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'godine';
	            } else {
	                result += 'godina';
	            }
	            return result;
	    }
	}

	var bs = moment.defineLocale('bs', {
	    months : 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split('_'),
	    monthsShort : 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split('_'),
	    monthsParseExact: true,
	    weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split('_'),
	    weekdaysShort : 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
	    weekdaysMin : 'ne_po_ut_sr_če_pe_su'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY H:mm',
	        LLLL : 'dddd, D. MMMM YYYY H:mm'
	    },
	    calendar : {
	        sameDay  : '[danas u] LT',
	        nextDay  : '[sutra u] LT',
	        nextWeek : function () {
	            switch (this.day()) {
	                case 0:
	                    return '[u] [nedjelju] [u] LT';
	                case 3:
	                    return '[u] [srijedu] [u] LT';
	                case 6:
	                    return '[u] [subotu] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[u] dddd [u] LT';
	            }
	        },
	        lastDay  : '[jučer u] LT',
	        lastWeek : function () {
	            switch (this.day()) {
	                case 0:
	                case 3:
	                    return '[prošlu] dddd [u] LT';
	                case 6:
	                    return '[prošle] [subote] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[prošli] dddd [u] LT';
	            }
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'za %s',
	        past   : 'prije %s',
	        s      : 'par sekundi',
	        m      : translate,
	        mm     : translate,
	        h      : translate,
	        hh     : translate,
	        d      : 'dan',
	        dd     : translate,
	        M      : 'mjesec',
	        MM     : translate,
	        y      : 'godinu',
	        yy     : translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return bs;

	})));


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Catalan [ca]
	//! author : Juan G. Hurtado : https://github.com/juanghurtado

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var ca = moment.defineLocale('ca', {
	    months : {
	        standalone: 'gener_febrer_març_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split('_'),
	        format: 'de gener_de febrer_de març_d\'abril_de maig_de juny_de juliol_d\'agost_de setembre_d\'octubre_de novembre_de desembre'.split('_'),
	        isFormat: /D[oD]?(\s)+MMMM/
	    },
	    monthsShort : 'gen._febr._març_abr._maig_juny_jul._ag._set._oct._nov._des.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split('_'),
	    weekdaysShort : 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),
	    weekdaysMin : 'Dg_Dl_Dt_Dc_Dj_Dv_Ds'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : '[el] D MMMM [de] YYYY',
	        ll : 'D MMM YYYY',
	        LLL : '[el] D MMMM [de] YYYY [a les] H:mm',
	        lll : 'D MMM YYYY, H:mm',
	        LLLL : '[el] dddd D MMMM [de] YYYY [a les] H:mm',
	        llll : 'ddd D MMM YYYY, H:mm'
	    },
	    calendar : {
	        sameDay : function () {
	            return '[avui a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	        },
	        nextDay : function () {
	            return '[demà a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	        },
	        nextWeek : function () {
	            return 'dddd [a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	        },
	        lastDay : function () {
	            return '[ahir a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	        },
	        lastWeek : function () {
	            return '[el] dddd [passat a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'd\'aquí %s',
	        past : 'fa %s',
	        s : 'uns segons',
	        m : 'un minut',
	        mm : '%d minuts',
	        h : 'una hora',
	        hh : '%d hores',
	        d : 'un dia',
	        dd : '%d dies',
	        M : 'un mes',
	        MM : '%d mesos',
	        y : 'un any',
	        yy : '%d anys'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(r|n|t|è|a)/,
	    ordinal : function (number, period) {
	        var output = (number === 1) ? 'r' :
	            (number === 2) ? 'n' :
	            (number === 3) ? 'r' :
	            (number === 4) ? 't' : 'è';
	        if (period === 'w' || period === 'W') {
	            output = 'a';
	        }
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return ca;

	})));


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Czech [cs]
	//! author : petrbela : https://github.com/petrbela

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var months = 'leden_únor_březen_duben_květen_červen_červenec_srpen_září_říjen_listopad_prosinec'.split('_');
	var monthsShort = 'led_úno_bře_dub_kvě_čvn_čvc_srp_zář_říj_lis_pro'.split('_');
	function plural(n) {
	    return (n > 1) && (n < 5) && (~~(n / 10) !== 1);
	}
	function translate(number, withoutSuffix, key, isFuture) {
	    var result = number + ' ';
	    switch (key) {
	        case 's':  // a few seconds / in a few seconds / a few seconds ago
	            return (withoutSuffix || isFuture) ? 'pár sekund' : 'pár sekundami';
	        case 'm':  // a minute / in a minute / a minute ago
	            return withoutSuffix ? 'minuta' : (isFuture ? 'minutu' : 'minutou');
	        case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'minuty' : 'minut');
	            } else {
	                return result + 'minutami';
	            }
	            break;
	        case 'h':  // an hour / in an hour / an hour ago
	            return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
	        case 'hh': // 9 hours / in 9 hours / 9 hours ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'hodiny' : 'hodin');
	            } else {
	                return result + 'hodinami';
	            }
	            break;
	        case 'd':  // a day / in a day / a day ago
	            return (withoutSuffix || isFuture) ? 'den' : 'dnem';
	        case 'dd': // 9 days / in 9 days / 9 days ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'dny' : 'dní');
	            } else {
	                return result + 'dny';
	            }
	            break;
	        case 'M':  // a month / in a month / a month ago
	            return (withoutSuffix || isFuture) ? 'měsíc' : 'měsícem';
	        case 'MM': // 9 months / in 9 months / 9 months ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'měsíce' : 'měsíců');
	            } else {
	                return result + 'měsíci';
	            }
	            break;
	        case 'y':  // a year / in a year / a year ago
	            return (withoutSuffix || isFuture) ? 'rok' : 'rokem';
	        case 'yy': // 9 years / in 9 years / 9 years ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'roky' : 'let');
	            } else {
	                return result + 'lety';
	            }
	            break;
	    }
	}

	var cs = moment.defineLocale('cs', {
	    months : months,
	    monthsShort : monthsShort,
	    monthsParse : (function (months, monthsShort) {
	        var i, _monthsParse = [];
	        for (i = 0; i < 12; i++) {
	            // use custom parser to solve problem with July (červenec)
	            _monthsParse[i] = new RegExp('^' + months[i] + '$|^' + monthsShort[i] + '$', 'i');
	        }
	        return _monthsParse;
	    }(months, monthsShort)),
	    shortMonthsParse : (function (monthsShort) {
	        var i, _shortMonthsParse = [];
	        for (i = 0; i < 12; i++) {
	            _shortMonthsParse[i] = new RegExp('^' + monthsShort[i] + '$', 'i');
	        }
	        return _shortMonthsParse;
	    }(monthsShort)),
	    longMonthsParse : (function (months) {
	        var i, _longMonthsParse = [];
	        for (i = 0; i < 12; i++) {
	            _longMonthsParse[i] = new RegExp('^' + months[i] + '$', 'i');
	        }
	        return _longMonthsParse;
	    }(months)),
	    weekdays : 'neděle_pondělí_úterý_středa_čtvrtek_pátek_sobota'.split('_'),
	    weekdaysShort : 'ne_po_út_st_čt_pá_so'.split('_'),
	    weekdaysMin : 'ne_po_út_st_čt_pá_so'.split('_'),
	    longDateFormat : {
	        LT: 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY H:mm',
	        LLLL : 'dddd D. MMMM YYYY H:mm',
	        l : 'D. M. YYYY'
	    },
	    calendar : {
	        sameDay: '[dnes v] LT',
	        nextDay: '[zítra v] LT',
	        nextWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[v neděli v] LT';
	                case 1:
	                case 2:
	                    return '[v] dddd [v] LT';
	                case 3:
	                    return '[ve středu v] LT';
	                case 4:
	                    return '[ve čtvrtek v] LT';
	                case 5:
	                    return '[v pátek v] LT';
	                case 6:
	                    return '[v sobotu v] LT';
	            }
	        },
	        lastDay: '[včera v] LT',
	        lastWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[minulou neděli v] LT';
	                case 1:
	                case 2:
	                    return '[minulé] dddd [v] LT';
	                case 3:
	                    return '[minulou středu v] LT';
	                case 4:
	                case 5:
	                    return '[minulý] dddd [v] LT';
	                case 6:
	                    return '[minulou sobotu v] LT';
	            }
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'za %s',
	        past : 'před %s',
	        s : translate,
	        m : translate,
	        mm : translate,
	        h : translate,
	        hh : translate,
	        d : translate,
	        dd : translate,
	        M : translate,
	        MM : translate,
	        y : translate,
	        yy : translate
	    },
	    dayOfMonthOrdinalParse : /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return cs;

	})));


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Chuvash [cv]
	//! author : Anatoly Mironov : https://github.com/mirontoli

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var cv = moment.defineLocale('cv', {
	    months : 'кӑрлач_нарӑс_пуш_ака_май_ҫӗртме_утӑ_ҫурла_авӑн_юпа_чӳк_раштав'.split('_'),
	    monthsShort : 'кӑр_нар_пуш_ака_май_ҫӗр_утӑ_ҫур_авн_юпа_чӳк_раш'.split('_'),
	    weekdays : 'вырсарникун_тунтикун_ытларикун_юнкун_кӗҫнерникун_эрнекун_шӑматкун'.split('_'),
	    weekdaysShort : 'выр_тун_ытл_юн_кӗҫ_эрн_шӑм'.split('_'),
	    weekdaysMin : 'вр_тн_ыт_юн_кҫ_эр_шм'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD-MM-YYYY',
	        LL : 'YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ]',
	        LLL : 'YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm',
	        LLLL : 'dddd, YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm'
	    },
	    calendar : {
	        sameDay: '[Паян] LT [сехетре]',
	        nextDay: '[Ыран] LT [сехетре]',
	        lastDay: '[Ӗнер] LT [сехетре]',
	        nextWeek: '[Ҫитес] dddd LT [сехетре]',
	        lastWeek: '[Иртнӗ] dddd LT [сехетре]',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : function (output) {
	            var affix = /сехет$/i.exec(output) ? 'рен' : /ҫул$/i.exec(output) ? 'тан' : 'ран';
	            return output + affix;
	        },
	        past : '%s каялла',
	        s : 'пӗр-ик ҫеккунт',
	        m : 'пӗр минут',
	        mm : '%d минут',
	        h : 'пӗр сехет',
	        hh : '%d сехет',
	        d : 'пӗр кун',
	        dd : '%d кун',
	        M : 'пӗр уйӑх',
	        MM : '%d уйӑх',
	        y : 'пӗр ҫул',
	        yy : '%d ҫул'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}-мӗш/,
	    ordinal : '%d-мӗш',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return cv;

	})));


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Welsh [cy]
	//! author : Robert Allen : https://github.com/robgallen
	//! author : https://github.com/ryangreaves

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var cy = moment.defineLocale('cy', {
	    months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split('_'),
	    monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split('_'),
	    weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split('_'),
	    weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),
	    weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),
	    weekdaysParseExact : true,
	    // time formats are the same as en-gb
	    longDateFormat: {
	        LT: 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L: 'DD/MM/YYYY',
	        LL: 'D MMMM YYYY',
	        LLL: 'D MMMM YYYY HH:mm',
	        LLLL: 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar: {
	        sameDay: '[Heddiw am] LT',
	        nextDay: '[Yfory am] LT',
	        nextWeek: 'dddd [am] LT',
	        lastDay: '[Ddoe am] LT',
	        lastWeek: 'dddd [diwethaf am] LT',
	        sameElse: 'L'
	    },
	    relativeTime: {
	        future: 'mewn %s',
	        past: '%s yn ôl',
	        s: 'ychydig eiliadau',
	        m: 'munud',
	        mm: '%d munud',
	        h: 'awr',
	        hh: '%d awr',
	        d: 'diwrnod',
	        dd: '%d diwrnod',
	        M: 'mis',
	        MM: '%d mis',
	        y: 'blwyddyn',
	        yy: '%d flynedd'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
	    // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
	    ordinal: function (number) {
	        var b = number,
	            output = '',
	            lookup = [
	                '', 'af', 'il', 'ydd', 'ydd', 'ed', 'ed', 'ed', 'fed', 'fed', 'fed', // 1af to 10fed
	                'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'fed' // 11eg to 20fed
	            ];
	        if (b > 20) {
	            if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
	                output = 'fed'; // not 30ain, 70ain or 90ain
	            } else {
	                output = 'ain';
	            }
	        } else if (b > 0) {
	            output = lookup[b];
	        }
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return cy;

	})));


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Danish [da]
	//! author : Ulrik Nielsen : https://github.com/mrbase

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var da = moment.defineLocale('da', {
	    months : 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split('_'),
	    monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
	    weekdays : 'søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag'.split('_'),
	    weekdaysShort : 'søn_man_tir_ons_tor_fre_lør'.split('_'),
	    weekdaysMin : 'sø_ma_ti_on_to_fr_lø'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY HH:mm',
	        LLLL : 'dddd [d.] D. MMMM YYYY [kl.] HH:mm'
	    },
	    calendar : {
	        sameDay : '[i dag kl.] LT',
	        nextDay : '[i morgen kl.] LT',
	        nextWeek : 'på dddd [kl.] LT',
	        lastDay : '[i går kl.] LT',
	        lastWeek : '[i] dddd[s kl.] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'om %s',
	        past : '%s siden',
	        s : 'få sekunder',
	        m : 'et minut',
	        mm : '%d minutter',
	        h : 'en time',
	        hh : '%d timer',
	        d : 'en dag',
	        dd : '%d dage',
	        M : 'en måned',
	        MM : '%d måneder',
	        y : 'et år',
	        yy : '%d år'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return da;

	})));


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : German [de]
	//! author : lluchs : https://github.com/lluchs
	//! author: Menelion Elensúle: https://github.com/Oire
	//! author : Mikolaj Dadela : https://github.com/mik01aj

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var format = {
	        'm': ['eine Minute', 'einer Minute'],
	        'h': ['eine Stunde', 'einer Stunde'],
	        'd': ['ein Tag', 'einem Tag'],
	        'dd': [number + ' Tage', number + ' Tagen'],
	        'M': ['ein Monat', 'einem Monat'],
	        'MM': [number + ' Monate', number + ' Monaten'],
	        'y': ['ein Jahr', 'einem Jahr'],
	        'yy': [number + ' Jahre', number + ' Jahren']
	    };
	    return withoutSuffix ? format[key][0] : format[key][1];
	}

	var de = moment.defineLocale('de', {
	    months : 'Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
	    monthsShort : 'Jan._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
	    weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
	    weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT: 'HH:mm',
	        LTS: 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY HH:mm',
	        LLLL : 'dddd, D. MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[heute um] LT [Uhr]',
	        sameElse: 'L',
	        nextDay: '[morgen um] LT [Uhr]',
	        nextWeek: 'dddd [um] LT [Uhr]',
	        lastDay: '[gestern um] LT [Uhr]',
	        lastWeek: '[letzten] dddd [um] LT [Uhr]'
	    },
	    relativeTime : {
	        future : 'in %s',
	        past : 'vor %s',
	        s : 'ein paar Sekunden',
	        m : processRelativeTime,
	        mm : '%d Minuten',
	        h : processRelativeTime,
	        hh : '%d Stunden',
	        d : processRelativeTime,
	        dd : processRelativeTime,
	        M : processRelativeTime,
	        MM : processRelativeTime,
	        y : processRelativeTime,
	        yy : processRelativeTime
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return de;

	})));


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : German (Austria) [de-at]
	//! author : lluchs : https://github.com/lluchs
	//! author: Menelion Elensúle: https://github.com/Oire
	//! author : Martin Groller : https://github.com/MadMG
	//! author : Mikolaj Dadela : https://github.com/mik01aj

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var format = {
	        'm': ['eine Minute', 'einer Minute'],
	        'h': ['eine Stunde', 'einer Stunde'],
	        'd': ['ein Tag', 'einem Tag'],
	        'dd': [number + ' Tage', number + ' Tagen'],
	        'M': ['ein Monat', 'einem Monat'],
	        'MM': [number + ' Monate', number + ' Monaten'],
	        'y': ['ein Jahr', 'einem Jahr'],
	        'yy': [number + ' Jahre', number + ' Jahren']
	    };
	    return withoutSuffix ? format[key][0] : format[key][1];
	}

	var deAt = moment.defineLocale('de-at', {
	    months : 'Jänner_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
	    monthsShort : 'Jän._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
	    weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
	    weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT: 'HH:mm',
	        LTS: 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY HH:mm',
	        LLLL : 'dddd, D. MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[heute um] LT [Uhr]',
	        sameElse: 'L',
	        nextDay: '[morgen um] LT [Uhr]',
	        nextWeek: 'dddd [um] LT [Uhr]',
	        lastDay: '[gestern um] LT [Uhr]',
	        lastWeek: '[letzten] dddd [um] LT [Uhr]'
	    },
	    relativeTime : {
	        future : 'in %s',
	        past : 'vor %s',
	        s : 'ein paar Sekunden',
	        m : processRelativeTime,
	        mm : '%d Minuten',
	        h : processRelativeTime,
	        hh : '%d Stunden',
	        d : processRelativeTime,
	        dd : processRelativeTime,
	        M : processRelativeTime,
	        MM : processRelativeTime,
	        y : processRelativeTime,
	        yy : processRelativeTime
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return deAt;

	})));


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : German (Switzerland) [de-ch]
	//! author : sschueller : https://github.com/sschueller

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	// based on: https://www.bk.admin.ch/dokumentation/sprachen/04915/05016/index.html?lang=de#

	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var format = {
	        'm': ['eine Minute', 'einer Minute'],
	        'h': ['eine Stunde', 'einer Stunde'],
	        'd': ['ein Tag', 'einem Tag'],
	        'dd': [number + ' Tage', number + ' Tagen'],
	        'M': ['ein Monat', 'einem Monat'],
	        'MM': [number + ' Monate', number + ' Monaten'],
	        'y': ['ein Jahr', 'einem Jahr'],
	        'yy': [number + ' Jahre', number + ' Jahren']
	    };
	    return withoutSuffix ? format[key][0] : format[key][1];
	}

	var deCh = moment.defineLocale('de-ch', {
	    months : 'Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
	    monthsShort : 'Jan._Febr._März_April_Mai_Juni_Juli_Aug._Sept._Okt._Nov._Dez.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
	    weekdaysShort : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
	    weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT: 'HH.mm',
	        LTS: 'HH.mm.ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY HH.mm',
	        LLLL : 'dddd, D. MMMM YYYY HH.mm'
	    },
	    calendar : {
	        sameDay: '[heute um] LT [Uhr]',
	        sameElse: 'L',
	        nextDay: '[morgen um] LT [Uhr]',
	        nextWeek: 'dddd [um] LT [Uhr]',
	        lastDay: '[gestern um] LT [Uhr]',
	        lastWeek: '[letzten] dddd [um] LT [Uhr]'
	    },
	    relativeTime : {
	        future : 'in %s',
	        past : 'vor %s',
	        s : 'ein paar Sekunden',
	        m : processRelativeTime,
	        mm : '%d Minuten',
	        h : processRelativeTime,
	        hh : '%d Stunden',
	        d : processRelativeTime,
	        dd : processRelativeTime,
	        M : processRelativeTime,
	        MM : processRelativeTime,
	        y : processRelativeTime,
	        yy : processRelativeTime
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return deCh;

	})));


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Maldivian [dv]
	//! author : Jawish Hameed : https://github.com/jawish

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var months = [
	    'ޖެނުއަރީ',
	    'ފެބްރުއަރީ',
	    'މާރިޗު',
	    'އޭޕްރީލު',
	    'މޭ',
	    'ޖޫން',
	    'ޖުލައި',
	    'އޯގަސްޓު',
	    'ސެޕްޓެމްބަރު',
	    'އޮކްޓޯބަރު',
	    'ނޮވެމްބަރު',
	    'ޑިސެމްބަރު'
	];
	var weekdays = [
	    'އާދިއްތަ',
	    'ހޯމަ',
	    'އަންގާރަ',
	    'ބުދަ',
	    'ބުރާސްފަތި',
	    'ހުކުރު',
	    'ހޮނިހިރު'
	];

	var dv = moment.defineLocale('dv', {
	    months : months,
	    monthsShort : months,
	    weekdays : weekdays,
	    weekdaysShort : weekdays,
	    weekdaysMin : 'އާދި_ހޯމަ_އަން_ބުދަ_ބުރާ_ހުކު_ހޮނި'.split('_'),
	    longDateFormat : {

	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'D/M/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    meridiemParse: /މކ|މފ/,
	    isPM : function (input) {
	        return 'މފ' === input;
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 12) {
	            return 'މކ';
	        } else {
	            return 'މފ';
	        }
	    },
	    calendar : {
	        sameDay : '[މިއަދު] LT',
	        nextDay : '[މާދަމާ] LT',
	        nextWeek : 'dddd LT',
	        lastDay : '[އިއްޔެ] LT',
	        lastWeek : '[ފާއިތުވި] dddd LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'ތެރޭގައި %s',
	        past : 'ކުރިން %s',
	        s : 'ސިކުންތުކޮޅެއް',
	        m : 'މިނިޓެއް',
	        mm : 'މިނިޓު %d',
	        h : 'ގަޑިއިރެއް',
	        hh : 'ގަޑިއިރު %d',
	        d : 'ދުވަހެއް',
	        dd : 'ދުވަސް %d',
	        M : 'މަހެއް',
	        MM : 'މަސް %d',
	        y : 'އަހަރެއް',
	        yy : 'އަހަރު %d'
	    },
	    preparse: function (string) {
	        return string.replace(/،/g, ',');
	    },
	    postformat: function (string) {
	        return string.replace(/,/g, '،');
	    },
	    week : {
	        dow : 7,  // Sunday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return dv;

	})));


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Greek [el]
	//! author : Aggelos Karalias : https://github.com/mehiel

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';

	function isFunction(input) {
	    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
	}


	var el = moment.defineLocale('el', {
	    monthsNominativeEl : 'Ιανουάριος_Φεβρουάριος_Μάρτιος_Απρίλιος_Μάιος_Ιούνιος_Ιούλιος_Αύγουστος_Σεπτέμβριος_Οκτώβριος_Νοέμβριος_Δεκέμβριος'.split('_'),
	    monthsGenitiveEl : 'Ιανουαρίου_Φεβρουαρίου_Μαρτίου_Απριλίου_Μαΐου_Ιουνίου_Ιουλίου_Αυγούστου_Σεπτεμβρίου_Οκτωβρίου_Νοεμβρίου_Δεκεμβρίου'.split('_'),
	    months : function (momentToFormat, format) {
	        if (!momentToFormat) {
	            return this._monthsNominativeEl;
	        } else if (/D/.test(format.substring(0, format.indexOf('MMMM')))) { // if there is a day number before 'MMMM'
	            return this._monthsGenitiveEl[momentToFormat.month()];
	        } else {
	            return this._monthsNominativeEl[momentToFormat.month()];
	        }
	    },
	    monthsShort : 'Ιαν_Φεβ_Μαρ_Απρ_Μαϊ_Ιουν_Ιουλ_Αυγ_Σεπ_Οκτ_Νοε_Δεκ'.split('_'),
	    weekdays : 'Κυριακή_Δευτέρα_Τρίτη_Τετάρτη_Πέμπτη_Παρασκευή_Σάββατο'.split('_'),
	    weekdaysShort : 'Κυρ_Δευ_Τρι_Τετ_Πεμ_Παρ_Σαβ'.split('_'),
	    weekdaysMin : 'Κυ_Δε_Τρ_Τε_Πε_Πα_Σα'.split('_'),
	    meridiem : function (hours, minutes, isLower) {
	        if (hours > 11) {
	            return isLower ? 'μμ' : 'ΜΜ';
	        } else {
	            return isLower ? 'πμ' : 'ΠΜ';
	        }
	    },
	    isPM : function (input) {
	        return ((input + '').toLowerCase()[0] === 'μ');
	    },
	    meridiemParse : /[ΠΜ]\.?Μ?\.?/i,
	    longDateFormat : {
	        LT : 'h:mm A',
	        LTS : 'h:mm:ss A',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY h:mm A',
	        LLLL : 'dddd, D MMMM YYYY h:mm A'
	    },
	    calendarEl : {
	        sameDay : '[Σήμερα {}] LT',
	        nextDay : '[Αύριο {}] LT',
	        nextWeek : 'dddd [{}] LT',
	        lastDay : '[Χθες {}] LT',
	        lastWeek : function () {
	            switch (this.day()) {
	                case 6:
	                    return '[το προηγούμενο] dddd [{}] LT';
	                default:
	                    return '[την προηγούμενη] dddd [{}] LT';
	            }
	        },
	        sameElse : 'L'
	    },
	    calendar : function (key, mom) {
	        var output = this._calendarEl[key],
	            hours = mom && mom.hours();
	        if (isFunction(output)) {
	            output = output.apply(mom);
	        }
	        return output.replace('{}', (hours % 12 === 1 ? 'στη' : 'στις'));
	    },
	    relativeTime : {
	        future : 'σε %s',
	        past : '%s πριν',
	        s : 'λίγα δευτερόλεπτα',
	        m : 'ένα λεπτό',
	        mm : '%d λεπτά',
	        h : 'μία ώρα',
	        hh : '%d ώρες',
	        d : 'μία μέρα',
	        dd : '%d μέρες',
	        M : 'ένας μήνας',
	        MM : '%d μήνες',
	        y : 'ένας χρόνος',
	        yy : '%d χρόνια'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}η/,
	    ordinal: '%dη',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4st is the first week of the year.
	    }
	});

	return el;

	})));


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : English (Australia) [en-au]
	//! author : Jared Morse : https://github.com/jarcoal

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var enAu = moment.defineLocale('en-au', {
	    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	    longDateFormat : {
	        LT : 'h:mm A',
	        LTS : 'h:mm:ss A',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY h:mm A',
	        LLLL : 'dddd, D MMMM YYYY h:mm A'
	    },
	    calendar : {
	        sameDay : '[Today at] LT',
	        nextDay : '[Tomorrow at] LT',
	        nextWeek : 'dddd [at] LT',
	        lastDay : '[Yesterday at] LT',
	        lastWeek : '[Last] dddd [at] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'in %s',
	        past : '%s ago',
	        s : 'a few seconds',
	        m : 'a minute',
	        mm : '%d minutes',
	        h : 'an hour',
	        hh : '%d hours',
	        d : 'a day',
	        dd : '%d days',
	        M : 'a month',
	        MM : '%d months',
	        y : 'a year',
	        yy : '%d years'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? 'th' :
	            (b === 1) ? 'st' :
	            (b === 2) ? 'nd' :
	            (b === 3) ? 'rd' : 'th';
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return enAu;

	})));


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : English (Canada) [en-ca]
	//! author : Jonathan Abourbih : https://github.com/jonbca

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var enCa = moment.defineLocale('en-ca', {
	    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	    longDateFormat : {
	        LT : 'h:mm A',
	        LTS : 'h:mm:ss A',
	        L : 'YYYY-MM-DD',
	        LL : 'MMMM D, YYYY',
	        LLL : 'MMMM D, YYYY h:mm A',
	        LLLL : 'dddd, MMMM D, YYYY h:mm A'
	    },
	    calendar : {
	        sameDay : '[Today at] LT',
	        nextDay : '[Tomorrow at] LT',
	        nextWeek : 'dddd [at] LT',
	        lastDay : '[Yesterday at] LT',
	        lastWeek : '[Last] dddd [at] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'in %s',
	        past : '%s ago',
	        s : 'a few seconds',
	        m : 'a minute',
	        mm : '%d minutes',
	        h : 'an hour',
	        hh : '%d hours',
	        d : 'a day',
	        dd : '%d days',
	        M : 'a month',
	        MM : '%d months',
	        y : 'a year',
	        yy : '%d years'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? 'th' :
	            (b === 1) ? 'st' :
	            (b === 2) ? 'nd' :
	            (b === 3) ? 'rd' : 'th';
	        return number + output;
	    }
	});

	return enCa;

	})));


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : English (United Kingdom) [en-gb]
	//! author : Chris Gedrim : https://github.com/chrisgedrim

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var enGb = moment.defineLocale('en-gb', {
	    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[Today at] LT',
	        nextDay : '[Tomorrow at] LT',
	        nextWeek : 'dddd [at] LT',
	        lastDay : '[Yesterday at] LT',
	        lastWeek : '[Last] dddd [at] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'in %s',
	        past : '%s ago',
	        s : 'a few seconds',
	        m : 'a minute',
	        mm : '%d minutes',
	        h : 'an hour',
	        hh : '%d hours',
	        d : 'a day',
	        dd : '%d days',
	        M : 'a month',
	        MM : '%d months',
	        y : 'a year',
	        yy : '%d years'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? 'th' :
	            (b === 1) ? 'st' :
	            (b === 2) ? 'nd' :
	            (b === 3) ? 'rd' : 'th';
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return enGb;

	})));


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : English (Ireland) [en-ie]
	//! author : Chris Cartlidge : https://github.com/chriscartlidge

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var enIe = moment.defineLocale('en-ie', {
	    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD-MM-YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[Today at] LT',
	        nextDay : '[Tomorrow at] LT',
	        nextWeek : 'dddd [at] LT',
	        lastDay : '[Yesterday at] LT',
	        lastWeek : '[Last] dddd [at] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'in %s',
	        past : '%s ago',
	        s : 'a few seconds',
	        m : 'a minute',
	        mm : '%d minutes',
	        h : 'an hour',
	        hh : '%d hours',
	        d : 'a day',
	        dd : '%d days',
	        M : 'a month',
	        MM : '%d months',
	        y : 'a year',
	        yy : '%d years'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? 'th' :
	            (b === 1) ? 'st' :
	            (b === 2) ? 'nd' :
	            (b === 3) ? 'rd' : 'th';
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return enIe;

	})));


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : English (New Zealand) [en-nz]
	//! author : Luke McGregor : https://github.com/lukemcgregor

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var enNz = moment.defineLocale('en-nz', {
	    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	    longDateFormat : {
	        LT : 'h:mm A',
	        LTS : 'h:mm:ss A',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY h:mm A',
	        LLLL : 'dddd, D MMMM YYYY h:mm A'
	    },
	    calendar : {
	        sameDay : '[Today at] LT',
	        nextDay : '[Tomorrow at] LT',
	        nextWeek : 'dddd [at] LT',
	        lastDay : '[Yesterday at] LT',
	        lastWeek : '[Last] dddd [at] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'in %s',
	        past : '%s ago',
	        s : 'a few seconds',
	        m : 'a minute',
	        mm : '%d minutes',
	        h : 'an hour',
	        hh : '%d hours',
	        d : 'a day',
	        dd : '%d days',
	        M : 'a month',
	        MM : '%d months',
	        y : 'a year',
	        yy : '%d years'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? 'th' :
	            (b === 1) ? 'st' :
	            (b === 2) ? 'nd' :
	            (b === 3) ? 'rd' : 'th';
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return enNz;

	})));


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Esperanto [eo]
	//! author : Colin Dean : https://github.com/colindean
	//! author : Mia Nordentoft Imperatori : https://github.com/miestasmia
	//! comment : miestasmia corrected the translation by colindean

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var eo = moment.defineLocale('eo', {
	    months : 'januaro_februaro_marto_aprilo_majo_junio_julio_aŭgusto_septembro_oktobro_novembro_decembro'.split('_'),
	    monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aŭg_sep_okt_nov_dec'.split('_'),
	    weekdays : 'dimanĉo_lundo_mardo_merkredo_ĵaŭdo_vendredo_sabato'.split('_'),
	    weekdaysShort : 'dim_lun_mard_merk_ĵaŭ_ven_sab'.split('_'),
	    weekdaysMin : 'di_lu_ma_me_ĵa_ve_sa'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'YYYY-MM-DD',
	        LL : 'D[-a de] MMMM, YYYY',
	        LLL : 'D[-a de] MMMM, YYYY HH:mm',
	        LLLL : 'dddd, [la] D[-a de] MMMM, YYYY HH:mm'
	    },
	    meridiemParse: /[ap]\.t\.m/i,
	    isPM: function (input) {
	        return input.charAt(0).toLowerCase() === 'p';
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours > 11) {
	            return isLower ? 'p.t.m.' : 'P.T.M.';
	        } else {
	            return isLower ? 'a.t.m.' : 'A.T.M.';
	        }
	    },
	    calendar : {
	        sameDay : '[Hodiaŭ je] LT',
	        nextDay : '[Morgaŭ je] LT',
	        nextWeek : 'dddd [je] LT',
	        lastDay : '[Hieraŭ je] LT',
	        lastWeek : '[pasinta] dddd [je] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'post %s',
	        past : 'antaŭ %s',
	        s : 'sekundoj',
	        m : 'minuto',
	        mm : '%d minutoj',
	        h : 'horo',
	        hh : '%d horoj',
	        d : 'tago',//ne 'diurno', ĉar estas uzita por proksimumo
	        dd : '%d tagoj',
	        M : 'monato',
	        MM : '%d monatoj',
	        y : 'jaro',
	        yy : '%d jaroj'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}a/,
	    ordinal : '%da',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return eo;

	})));


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Spanish [es]
	//! author : Julio Napurí : https://github.com/julionc

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_');
	var monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

	var es = moment.defineLocale('es', {
	    months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
	    monthsShort : function (m, format) {
	        if (!m) {
	            return monthsShortDot;
	        } else if (/-MMM-/.test(format)) {
	            return monthsShort[m.month()];
	        } else {
	            return monthsShortDot[m.month()];
	        }
	    },
	    monthsParseExact : true,
	    weekdays : 'domingo_lunes_martes_miércoles_jueves_viernes_sábado'.split('_'),
	    weekdaysShort : 'dom._lun._mar._mié._jue._vie._sáb.'.split('_'),
	    weekdaysMin : 'do_lu_ma_mi_ju_vi_sá'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D [de] MMMM [de] YYYY',
	        LLL : 'D [de] MMMM [de] YYYY H:mm',
	        LLLL : 'dddd, D [de] MMMM [de] YYYY H:mm'
	    },
	    calendar : {
	        sameDay : function () {
	            return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        nextDay : function () {
	            return '[mañana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        nextWeek : function () {
	            return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        lastDay : function () {
	            return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        lastWeek : function () {
	            return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'en %s',
	        past : 'hace %s',
	        s : 'unos segundos',
	        m : 'un minuto',
	        mm : '%d minutos',
	        h : 'una hora',
	        hh : '%d horas',
	        d : 'un día',
	        dd : '%d días',
	        M : 'un mes',
	        MM : '%d meses',
	        y : 'un año',
	        yy : '%d años'
	    },
	    dayOfMonthOrdinalParse : /\d{1,2}º/,
	    ordinal : '%dº',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return es;

	})));


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Spanish (Dominican Republic) [es-do]

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_');
	var monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

	var esDo = moment.defineLocale('es-do', {
	    months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
	    monthsShort : function (m, format) {
	        if (!m) {
	            return monthsShortDot;
	        } else if (/-MMM-/.test(format)) {
	            return monthsShort[m.month()];
	        } else {
	            return monthsShortDot[m.month()];
	        }
	    },
	    monthsParseExact : true,
	    weekdays : 'domingo_lunes_martes_miércoles_jueves_viernes_sábado'.split('_'),
	    weekdaysShort : 'dom._lun._mar._mié._jue._vie._sáb.'.split('_'),
	    weekdaysMin : 'do_lu_ma_mi_ju_vi_sá'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'h:mm A',
	        LTS : 'h:mm:ss A',
	        L : 'DD/MM/YYYY',
	        LL : 'D [de] MMMM [de] YYYY',
	        LLL : 'D [de] MMMM [de] YYYY h:mm A',
	        LLLL : 'dddd, D [de] MMMM [de] YYYY h:mm A'
	    },
	    calendar : {
	        sameDay : function () {
	            return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        nextDay : function () {
	            return '[mañana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        nextWeek : function () {
	            return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        lastDay : function () {
	            return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        lastWeek : function () {
	            return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'en %s',
	        past : 'hace %s',
	        s : 'unos segundos',
	        m : 'un minuto',
	        mm : '%d minutos',
	        h : 'una hora',
	        hh : '%d horas',
	        d : 'un día',
	        dd : '%d días',
	        M : 'un mes',
	        MM : '%d meses',
	        y : 'un año',
	        yy : '%d años'
	    },
	    dayOfMonthOrdinalParse : /\d{1,2}º/,
	    ordinal : '%dº',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return esDo;

	})));


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Estonian [et]
	//! author : Henry Kehlmann : https://github.com/madhenry
	//! improvements : Illimar Tambek : https://github.com/ragulka

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var format = {
	        's' : ['mõne sekundi', 'mõni sekund', 'paar sekundit'],
	        'm' : ['ühe minuti', 'üks minut'],
	        'mm': [number + ' minuti', number + ' minutit'],
	        'h' : ['ühe tunni', 'tund aega', 'üks tund'],
	        'hh': [number + ' tunni', number + ' tundi'],
	        'd' : ['ühe päeva', 'üks päev'],
	        'M' : ['kuu aja', 'kuu aega', 'üks kuu'],
	        'MM': [number + ' kuu', number + ' kuud'],
	        'y' : ['ühe aasta', 'aasta', 'üks aasta'],
	        'yy': [number + ' aasta', number + ' aastat']
	    };
	    if (withoutSuffix) {
	        return format[key][2] ? format[key][2] : format[key][1];
	    }
	    return isFuture ? format[key][0] : format[key][1];
	}

	var et = moment.defineLocale('et', {
	    months        : 'jaanuar_veebruar_märts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split('_'),
	    monthsShort   : 'jaan_veebr_märts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split('_'),
	    weekdays      : 'pühapäev_esmaspäev_teisipäev_kolmapäev_neljapäev_reede_laupäev'.split('_'),
	    weekdaysShort : 'P_E_T_K_N_R_L'.split('_'),
	    weekdaysMin   : 'P_E_T_K_N_R_L'.split('_'),
	    longDateFormat : {
	        LT   : 'H:mm',
	        LTS : 'H:mm:ss',
	        L    : 'DD.MM.YYYY',
	        LL   : 'D. MMMM YYYY',
	        LLL  : 'D. MMMM YYYY H:mm',
	        LLLL : 'dddd, D. MMMM YYYY H:mm'
	    },
	    calendar : {
	        sameDay  : '[Täna,] LT',
	        nextDay  : '[Homme,] LT',
	        nextWeek : '[Järgmine] dddd LT',
	        lastDay  : '[Eile,] LT',
	        lastWeek : '[Eelmine] dddd LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s pärast',
	        past   : '%s tagasi',
	        s      : processRelativeTime,
	        m      : processRelativeTime,
	        mm     : processRelativeTime,
	        h      : processRelativeTime,
	        hh     : processRelativeTime,
	        d      : processRelativeTime,
	        dd     : '%d päeva',
	        M      : processRelativeTime,
	        MM     : processRelativeTime,
	        y      : processRelativeTime,
	        yy     : processRelativeTime
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return et;

	})));


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Basque [eu]
	//! author : Eneko Illarramendi : https://github.com/eillarra

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var eu = moment.defineLocale('eu', {
	    months : 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split('_'),
	    monthsShort : 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split('_'),
	    weekdaysShort : 'ig._al._ar._az._og._ol._lr.'.split('_'),
	    weekdaysMin : 'ig_al_ar_az_og_ol_lr'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'YYYY-MM-DD',
	        LL : 'YYYY[ko] MMMM[ren] D[a]',
	        LLL : 'YYYY[ko] MMMM[ren] D[a] HH:mm',
	        LLLL : 'dddd, YYYY[ko] MMMM[ren] D[a] HH:mm',
	        l : 'YYYY-M-D',
	        ll : 'YYYY[ko] MMM D[a]',
	        lll : 'YYYY[ko] MMM D[a] HH:mm',
	        llll : 'ddd, YYYY[ko] MMM D[a] HH:mm'
	    },
	    calendar : {
	        sameDay : '[gaur] LT[etan]',
	        nextDay : '[bihar] LT[etan]',
	        nextWeek : 'dddd LT[etan]',
	        lastDay : '[atzo] LT[etan]',
	        lastWeek : '[aurreko] dddd LT[etan]',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s barru',
	        past : 'duela %s',
	        s : 'segundo batzuk',
	        m : 'minutu bat',
	        mm : '%d minutu',
	        h : 'ordu bat',
	        hh : '%d ordu',
	        d : 'egun bat',
	        dd : '%d egun',
	        M : 'hilabete bat',
	        MM : '%d hilabete',
	        y : 'urte bat',
	        yy : '%d urte'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return eu;

	})));


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Persian [fa]
	//! author : Ebrahim Byagowi : https://github.com/ebraminio

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var symbolMap = {
	    '1': '۱',
	    '2': '۲',
	    '3': '۳',
	    '4': '۴',
	    '5': '۵',
	    '6': '۶',
	    '7': '۷',
	    '8': '۸',
	    '9': '۹',
	    '0': '۰'
	};
	var numberMap = {
	    '۱': '1',
	    '۲': '2',
	    '۳': '3',
	    '۴': '4',
	    '۵': '5',
	    '۶': '6',
	    '۷': '7',
	    '۸': '8',
	    '۹': '9',
	    '۰': '0'
	};

	var fa = moment.defineLocale('fa', {
	    months : 'ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر'.split('_'),
	    monthsShort : 'ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر'.split('_'),
	    weekdays : 'یک\u200cشنبه_دوشنبه_سه\u200cشنبه_چهارشنبه_پنج\u200cشنبه_جمعه_شنبه'.split('_'),
	    weekdaysShort : 'یک\u200cشنبه_دوشنبه_سه\u200cشنبه_چهارشنبه_پنج\u200cشنبه_جمعه_شنبه'.split('_'),
	    weekdaysMin : 'ی_د_س_چ_پ_ج_ش'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    meridiemParse: /قبل از ظهر|بعد از ظهر/,
	    isPM: function (input) {
	        return /بعد از ظهر/.test(input);
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 12) {
	            return 'قبل از ظهر';
	        } else {
	            return 'بعد از ظهر';
	        }
	    },
	    calendar : {
	        sameDay : '[امروز ساعت] LT',
	        nextDay : '[فردا ساعت] LT',
	        nextWeek : 'dddd [ساعت] LT',
	        lastDay : '[دیروز ساعت] LT',
	        lastWeek : 'dddd [پیش] [ساعت] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'در %s',
	        past : '%s پیش',
	        s : 'چند ثانیه',
	        m : 'یک دقیقه',
	        mm : '%d دقیقه',
	        h : 'یک ساعت',
	        hh : '%d ساعت',
	        d : 'یک روز',
	        dd : '%d روز',
	        M : 'یک ماه',
	        MM : '%d ماه',
	        y : 'یک سال',
	        yy : '%d سال'
	    },
	    preparse: function (string) {
	        return string.replace(/[۰-۹]/g, function (match) {
	            return numberMap[match];
	        }).replace(/،/g, ',');
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        }).replace(/,/g, '،');
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}م/,
	    ordinal : '%dم',
	    week : {
	        dow : 6, // Saturday is the first day of the week.
	        doy : 12 // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return fa;

	})));


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Finnish [fi]
	//! author : Tarmo Aidantausta : https://github.com/bleadof

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var numbersPast = 'nolla yksi kaksi kolme neljä viisi kuusi seitsemän kahdeksan yhdeksän'.split(' ');
	var numbersFuture = [
	        'nolla', 'yhden', 'kahden', 'kolmen', 'neljän', 'viiden', 'kuuden',
	        numbersPast[7], numbersPast[8], numbersPast[9]
	    ];
	function translate(number, withoutSuffix, key, isFuture) {
	    var result = '';
	    switch (key) {
	        case 's':
	            return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';
	        case 'm':
	            return isFuture ? 'minuutin' : 'minuutti';
	        case 'mm':
	            result = isFuture ? 'minuutin' : 'minuuttia';
	            break;
	        case 'h':
	            return isFuture ? 'tunnin' : 'tunti';
	        case 'hh':
	            result = isFuture ? 'tunnin' : 'tuntia';
	            break;
	        case 'd':
	            return isFuture ? 'päivän' : 'päivä';
	        case 'dd':
	            result = isFuture ? 'päivän' : 'päivää';
	            break;
	        case 'M':
	            return isFuture ? 'kuukauden' : 'kuukausi';
	        case 'MM':
	            result = isFuture ? 'kuukauden' : 'kuukautta';
	            break;
	        case 'y':
	            return isFuture ? 'vuoden' : 'vuosi';
	        case 'yy':
	            result = isFuture ? 'vuoden' : 'vuotta';
	            break;
	    }
	    result = verbalNumber(number, isFuture) + ' ' + result;
	    return result;
	}
	function verbalNumber(number, isFuture) {
	    return number < 10 ? (isFuture ? numbersFuture[number] : numbersPast[number]) : number;
	}

	var fi = moment.defineLocale('fi', {
	    months : 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_kesäkuu_heinäkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split('_'),
	    monthsShort : 'tammi_helmi_maalis_huhti_touko_kesä_heinä_elo_syys_loka_marras_joulu'.split('_'),
	    weekdays : 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split('_'),
	    weekdaysShort : 'su_ma_ti_ke_to_pe_la'.split('_'),
	    weekdaysMin : 'su_ma_ti_ke_to_pe_la'.split('_'),
	    longDateFormat : {
	        LT : 'HH.mm',
	        LTS : 'HH.mm.ss',
	        L : 'DD.MM.YYYY',
	        LL : 'Do MMMM[ta] YYYY',
	        LLL : 'Do MMMM[ta] YYYY, [klo] HH.mm',
	        LLLL : 'dddd, Do MMMM[ta] YYYY, [klo] HH.mm',
	        l : 'D.M.YYYY',
	        ll : 'Do MMM YYYY',
	        lll : 'Do MMM YYYY, [klo] HH.mm',
	        llll : 'ddd, Do MMM YYYY, [klo] HH.mm'
	    },
	    calendar : {
	        sameDay : '[tänään] [klo] LT',
	        nextDay : '[huomenna] [klo] LT',
	        nextWeek : 'dddd [klo] LT',
	        lastDay : '[eilen] [klo] LT',
	        lastWeek : '[viime] dddd[na] [klo] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s päästä',
	        past : '%s sitten',
	        s : translate,
	        m : translate,
	        mm : translate,
	        h : translate,
	        hh : translate,
	        d : translate,
	        dd : translate,
	        M : translate,
	        MM : translate,
	        y : translate,
	        yy : translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return fi;

	})));


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Faroese [fo]
	//! author : Ragnar Johannesen : https://github.com/ragnar123

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var fo = moment.defineLocale('fo', {
	    months : 'januar_februar_mars_apríl_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
	    monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
	    weekdays : 'sunnudagur_mánadagur_týsdagur_mikudagur_hósdagur_fríggjadagur_leygardagur'.split('_'),
	    weekdaysShort : 'sun_mán_týs_mik_hós_frí_ley'.split('_'),
	    weekdaysMin : 'su_má_tý_mi_hó_fr_le'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D. MMMM, YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[Í dag kl.] LT',
	        nextDay : '[Í morgin kl.] LT',
	        nextWeek : 'dddd [kl.] LT',
	        lastDay : '[Í gjár kl.] LT',
	        lastWeek : '[síðstu] dddd [kl] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'um %s',
	        past : '%s síðani',
	        s : 'fá sekund',
	        m : 'ein minutt',
	        mm : '%d minuttir',
	        h : 'ein tími',
	        hh : '%d tímar',
	        d : 'ein dagur',
	        dd : '%d dagar',
	        M : 'ein mánaði',
	        MM : '%d mánaðir',
	        y : 'eitt ár',
	        yy : '%d ár'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return fo;

	})));


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : French [fr]
	//! author : John Fischer : https://github.com/jfroffice

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var fr = moment.defineLocale('fr', {
	    months : 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),
	    monthsShort : 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
	    weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
	    weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[Aujourd’hui à] LT',
	        nextDay : '[Demain à] LT',
	        nextWeek : 'dddd [à] LT',
	        lastDay : '[Hier à] LT',
	        lastWeek : 'dddd [dernier à] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'dans %s',
	        past : 'il y a %s',
	        s : 'quelques secondes',
	        m : 'une minute',
	        mm : '%d minutes',
	        h : 'une heure',
	        hh : '%d heures',
	        d : 'un jour',
	        dd : '%d jours',
	        M : 'un mois',
	        MM : '%d mois',
	        y : 'un an',
	        yy : '%d ans'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(er|)/,
	    ordinal : function (number, period) {
	        switch (period) {
	            // TODO: Return 'e' when day of month > 1. Move this case inside
	            // block for masculine words below.
	            // See https://github.com/moment/moment/issues/3375
	            case 'D':
	                return number + (number === 1 ? 'er' : '');

	            // Words with masculine grammatical gender: mois, trimestre, jour
	            default:
	            case 'M':
	            case 'Q':
	            case 'DDD':
	            case 'd':
	                return number + (number === 1 ? 'er' : 'e');

	            // Words with feminine grammatical gender: semaine
	            case 'w':
	            case 'W':
	                return number + (number === 1 ? 're' : 'e');
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return fr;

	})));


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : French (Canada) [fr-ca]
	//! author : Jonathan Abourbih : https://github.com/jonbca

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var frCa = moment.defineLocale('fr-ca', {
	    months : 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),
	    monthsShort : 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
	    weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
	    weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'YYYY-MM-DD',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[Aujourd’hui à] LT',
	        nextDay : '[Demain à] LT',
	        nextWeek : 'dddd [à] LT',
	        lastDay : '[Hier à] LT',
	        lastWeek : 'dddd [dernier à] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'dans %s',
	        past : 'il y a %s',
	        s : 'quelques secondes',
	        m : 'une minute',
	        mm : '%d minutes',
	        h : 'une heure',
	        hh : '%d heures',
	        d : 'un jour',
	        dd : '%d jours',
	        M : 'un mois',
	        MM : '%d mois',
	        y : 'un an',
	        yy : '%d ans'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
	    ordinal : function (number, period) {
	        switch (period) {
	            // Words with masculine grammatical gender: mois, trimestre, jour
	            default:
	            case 'M':
	            case 'Q':
	            case 'D':
	            case 'DDD':
	            case 'd':
	                return number + (number === 1 ? 'er' : 'e');

	            // Words with feminine grammatical gender: semaine
	            case 'w':
	            case 'W':
	                return number + (number === 1 ? 're' : 'e');
	        }
	    }
	});

	return frCa;

	})));


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : French (Switzerland) [fr-ch]
	//! author : Gaspard Bucher : https://github.com/gaspard

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var frCh = moment.defineLocale('fr-ch', {
	    months : 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),
	    monthsShort : 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
	    weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
	    weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[Aujourd’hui à] LT',
	        nextDay : '[Demain à] LT',
	        nextWeek : 'dddd [à] LT',
	        lastDay : '[Hier à] LT',
	        lastWeek : 'dddd [dernier à] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'dans %s',
	        past : 'il y a %s',
	        s : 'quelques secondes',
	        m : 'une minute',
	        mm : '%d minutes',
	        h : 'une heure',
	        hh : '%d heures',
	        d : 'un jour',
	        dd : '%d jours',
	        M : 'un mois',
	        MM : '%d mois',
	        y : 'un an',
	        yy : '%d ans'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
	    ordinal : function (number, period) {
	        switch (period) {
	            // Words with masculine grammatical gender: mois, trimestre, jour
	            default:
	            case 'M':
	            case 'Q':
	            case 'D':
	            case 'DDD':
	            case 'd':
	                return number + (number === 1 ? 'er' : 'e');

	            // Words with feminine grammatical gender: semaine
	            case 'w':
	            case 'W':
	                return number + (number === 1 ? 're' : 'e');
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return frCh;

	})));


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Frisian [fy]
	//! author : Robin van der Vliet : https://github.com/robin0van0der0v

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var monthsShortWithDots = 'jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.'.split('_');
	var monthsShortWithoutDots = 'jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_');

	var fy = moment.defineLocale('fy', {
	    months : 'jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber'.split('_'),
	    monthsShort : function (m, format) {
	        if (!m) {
	            return monthsShortWithDots;
	        } else if (/-MMM-/.test(format)) {
	            return monthsShortWithoutDots[m.month()];
	        } else {
	            return monthsShortWithDots[m.month()];
	        }
	    },
	    monthsParseExact : true,
	    weekdays : 'snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon'.split('_'),
	    weekdaysShort : 'si._mo._ti._wo._to._fr._so.'.split('_'),
	    weekdaysMin : 'Si_Mo_Ti_Wo_To_Fr_So'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD-MM-YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[hjoed om] LT',
	        nextDay: '[moarn om] LT',
	        nextWeek: 'dddd [om] LT',
	        lastDay: '[juster om] LT',
	        lastWeek: '[ôfrûne] dddd [om] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'oer %s',
	        past : '%s lyn',
	        s : 'in pear sekonden',
	        m : 'ien minút',
	        mm : '%d minuten',
	        h : 'ien oere',
	        hh : '%d oeren',
	        d : 'ien dei',
	        dd : '%d dagen',
	        M : 'ien moanne',
	        MM : '%d moannen',
	        y : 'ien jier',
	        yy : '%d jierren'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
	    ordinal : function (number) {
	        return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return fy;

	})));


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Scottish Gaelic [gd]
	//! author : Jon Ashdown : https://github.com/jonashdown

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var months = [
	    'Am Faoilleach', 'An Gearran', 'Am Màrt', 'An Giblean', 'An Cèitean', 'An t-Ògmhios', 'An t-Iuchar', 'An Lùnastal', 'An t-Sultain', 'An Dàmhair', 'An t-Samhain', 'An Dùbhlachd'
	];

	var monthsShort = ['Faoi', 'Gear', 'Màrt', 'Gibl', 'Cèit', 'Ògmh', 'Iuch', 'Lùn', 'Sult', 'Dàmh', 'Samh', 'Dùbh'];

	var weekdays = ['Didòmhnaich', 'Diluain', 'Dimàirt', 'Diciadain', 'Diardaoin', 'Dihaoine', 'Disathairne'];

	var weekdaysShort = ['Did', 'Dil', 'Dim', 'Dic', 'Dia', 'Dih', 'Dis'];

	var weekdaysMin = ['Dò', 'Lu', 'Mà', 'Ci', 'Ar', 'Ha', 'Sa'];

	var gd = moment.defineLocale('gd', {
	    months : months,
	    monthsShort : monthsShort,
	    monthsParseExact : true,
	    weekdays : weekdays,
	    weekdaysShort : weekdaysShort,
	    weekdaysMin : weekdaysMin,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[An-diugh aig] LT',
	        nextDay : '[A-màireach aig] LT',
	        nextWeek : 'dddd [aig] LT',
	        lastDay : '[An-dè aig] LT',
	        lastWeek : 'dddd [seo chaidh] [aig] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'ann an %s',
	        past : 'bho chionn %s',
	        s : 'beagan diogan',
	        m : 'mionaid',
	        mm : '%d mionaidean',
	        h : 'uair',
	        hh : '%d uairean',
	        d : 'latha',
	        dd : '%d latha',
	        M : 'mìos',
	        MM : '%d mìosan',
	        y : 'bliadhna',
	        yy : '%d bliadhna'
	    },
	    dayOfMonthOrdinalParse : /\d{1,2}(d|na|mh)/,
	    ordinal : function (number) {
	        var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return gd;

	})));


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Galician [gl]
	//! author : Juan G. Hurtado : https://github.com/juanghurtado

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var gl = moment.defineLocale('gl', {
	    months : 'xaneiro_febreiro_marzo_abril_maio_xuño_xullo_agosto_setembro_outubro_novembro_decembro'.split('_'),
	    monthsShort : 'xan._feb._mar._abr._mai._xuñ._xul._ago._set._out._nov._dec.'.split('_'),
	    monthsParseExact: true,
	    weekdays : 'domingo_luns_martes_mércores_xoves_venres_sábado'.split('_'),
	    weekdaysShort : 'dom._lun._mar._mér._xov._ven._sáb.'.split('_'),
	    weekdaysMin : 'do_lu_ma_mé_xo_ve_sá'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D [de] MMMM [de] YYYY',
	        LLL : 'D [de] MMMM [de] YYYY H:mm',
	        LLLL : 'dddd, D [de] MMMM [de] YYYY H:mm'
	    },
	    calendar : {
	        sameDay : function () {
	            return '[hoxe ' + ((this.hours() !== 1) ? 'ás' : 'á') + '] LT';
	        },
	        nextDay : function () {
	            return '[mañá ' + ((this.hours() !== 1) ? 'ás' : 'á') + '] LT';
	        },
	        nextWeek : function () {
	            return 'dddd [' + ((this.hours() !== 1) ? 'ás' : 'a') + '] LT';
	        },
	        lastDay : function () {
	            return '[onte ' + ((this.hours() !== 1) ? 'á' : 'a') + '] LT';
	        },
	        lastWeek : function () {
	            return '[o] dddd [pasado ' + ((this.hours() !== 1) ? 'ás' : 'a') + '] LT';
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : function (str) {
	            if (str.indexOf('un') === 0) {
	                return 'n' + str;
	            }
	            return 'en ' + str;
	        },
	        past : 'hai %s',
	        s : 'uns segundos',
	        m : 'un minuto',
	        mm : '%d minutos',
	        h : 'unha hora',
	        hh : '%d horas',
	        d : 'un día',
	        dd : '%d días',
	        M : 'un mes',
	        MM : '%d meses',
	        y : 'un ano',
	        yy : '%d anos'
	    },
	    dayOfMonthOrdinalParse : /\d{1,2}º/,
	    ordinal : '%dº',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return gl;

	})));


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Konkani Latin script [gom-latn]
	//! author : The Discoverer : https://github.com/WikiDiscoverer

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var format = {
	        's': ['thodde secondanim', 'thodde second'],
	        'm': ['eka mintan', 'ek minute'],
	        'mm': [number + ' mintanim', number + ' mintam'],
	        'h': ['eka horan', 'ek hor'],
	        'hh': [number + ' horanim', number + ' hor'],
	        'd': ['eka disan', 'ek dis'],
	        'dd': [number + ' disanim', number + ' dis'],
	        'M': ['eka mhoinean', 'ek mhoino'],
	        'MM': [number + ' mhoineanim', number + ' mhoine'],
	        'y': ['eka vorsan', 'ek voros'],
	        'yy': [number + ' vorsanim', number + ' vorsam']
	    };
	    return withoutSuffix ? format[key][0] : format[key][1];
	}

	var gomLatn = moment.defineLocale('gom-latn', {
	    months : 'Janer_Febrer_Mars_Abril_Mai_Jun_Julai_Agost_Setembr_Otubr_Novembr_Dezembr'.split('_'),
	    monthsShort : 'Jan._Feb._Mars_Abr._Mai_Jun_Jul._Ago._Set._Otu._Nov._Dez.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'Aitar_Somar_Mongllar_Budvar_Brestar_Sukrar_Son\'var'.split('_'),
	    weekdaysShort : 'Ait._Som._Mon._Bud._Bre._Suk._Son.'.split('_'),
	    weekdaysMin : 'Ai_Sm_Mo_Bu_Br_Su_Sn'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'A h:mm [vazta]',
	        LTS : 'A h:mm:ss [vazta]',
	        L : 'DD-MM-YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY A h:mm [vazta]',
	        LLLL : 'dddd, MMMM[achea] Do, YYYY, A h:mm [vazta]',
	        llll: 'ddd, D MMM YYYY, A h:mm [vazta]'
	    },
	    calendar : {
	        sameDay: '[Aiz] LT',
	        nextDay: '[Faleam] LT',
	        nextWeek: '[Ieta to] dddd[,] LT',
	        lastDay: '[Kal] LT',
	        lastWeek: '[Fatlo] dddd[,] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : '%s',
	        past : '%s adim',
	        s : processRelativeTime,
	        m : processRelativeTime,
	        mm : processRelativeTime,
	        h : processRelativeTime,
	        hh : processRelativeTime,
	        d : processRelativeTime,
	        dd : processRelativeTime,
	        M : processRelativeTime,
	        MM : processRelativeTime,
	        y : processRelativeTime,
	        yy : processRelativeTime
	    },
	    dayOfMonthOrdinalParse : /\d{1,2}(er)/,
	    ordinal : function (number, period) {
	        switch (period) {
	            // the ordinal 'er' only applies to day of the month
	            case 'D':
	                return number + 'er';
	            default:
	            case 'M':
	            case 'Q':
	            case 'DDD':
	            case 'd':
	            case 'w':
	            case 'W':
	                return number;
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    },
	    meridiemParse: /rati|sokalli|donparam|sanje/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === 'rati') {
	            return hour < 4 ? hour : hour + 12;
	        } else if (meridiem === 'sokalli') {
	            return hour;
	        } else if (meridiem === 'donparam') {
	            return hour > 12 ? hour : hour + 12;
	        } else if (meridiem === 'sanje') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return 'rati';
	        } else if (hour < 12) {
	            return 'sokalli';
	        } else if (hour < 16) {
	            return 'donparam';
	        } else if (hour < 20) {
	            return 'sanje';
	        } else {
	            return 'rati';
	        }
	    }
	});

	return gomLatn;

	})));


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Hebrew [he]
	//! author : Tomer Cohen : https://github.com/tomer
	//! author : Moshe Simantov : https://github.com/DevelopmentIL
	//! author : Tal Ater : https://github.com/TalAter

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var he = moment.defineLocale('he', {
	    months : 'ינואר_פברואר_מרץ_אפריל_מאי_יוני_יולי_אוגוסט_ספטמבר_אוקטובר_נובמבר_דצמבר'.split('_'),
	    monthsShort : 'ינו׳_פבר׳_מרץ_אפר׳_מאי_יוני_יולי_אוג׳_ספט׳_אוק׳_נוב׳_דצמ׳'.split('_'),
	    weekdays : 'ראשון_שני_שלישי_רביעי_חמישי_שישי_שבת'.split('_'),
	    weekdaysShort : 'א׳_ב׳_ג׳_ד׳_ה׳_ו׳_ש׳'.split('_'),
	    weekdaysMin : 'א_ב_ג_ד_ה_ו_ש'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D [ב]MMMM YYYY',
	        LLL : 'D [ב]MMMM YYYY HH:mm',
	        LLLL : 'dddd, D [ב]MMMM YYYY HH:mm',
	        l : 'D/M/YYYY',
	        ll : 'D MMM YYYY',
	        lll : 'D MMM YYYY HH:mm',
	        llll : 'ddd, D MMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[היום ב־]LT',
	        nextDay : '[מחר ב־]LT',
	        nextWeek : 'dddd [בשעה] LT',
	        lastDay : '[אתמול ב־]LT',
	        lastWeek : '[ביום] dddd [האחרון בשעה] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'בעוד %s',
	        past : 'לפני %s',
	        s : 'מספר שניות',
	        m : 'דקה',
	        mm : '%d דקות',
	        h : 'שעה',
	        hh : function (number) {
	            if (number === 2) {
	                return 'שעתיים';
	            }
	            return number + ' שעות';
	        },
	        d : 'יום',
	        dd : function (number) {
	            if (number === 2) {
	                return 'יומיים';
	            }
	            return number + ' ימים';
	        },
	        M : 'חודש',
	        MM : function (number) {
	            if (number === 2) {
	                return 'חודשיים';
	            }
	            return number + ' חודשים';
	        },
	        y : 'שנה',
	        yy : function (number) {
	            if (number === 2) {
	                return 'שנתיים';
	            } else if (number % 10 === 0 && number !== 10) {
	                return number + ' שנה';
	            }
	            return number + ' שנים';
	        }
	    },
	    meridiemParse: /אחה"צ|לפנה"צ|אחרי הצהריים|לפני הצהריים|לפנות בוקר|בבוקר|בערב/i,
	    isPM : function (input) {
	        return /^(אחה"צ|אחרי הצהריים|בערב)$/.test(input);
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 5) {
	            return 'לפנות בוקר';
	        } else if (hour < 10) {
	            return 'בבוקר';
	        } else if (hour < 12) {
	            return isLower ? 'לפנה"צ' : 'לפני הצהריים';
	        } else if (hour < 18) {
	            return isLower ? 'אחה"צ' : 'אחרי הצהריים';
	        } else {
	            return 'בערב';
	        }
	    }
	});

	return he;

	})));


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Hindi [hi]
	//! author : Mayank Singhal : https://github.com/mayanksinghal

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var symbolMap = {
	    '1': '१',
	    '2': '२',
	    '3': '३',
	    '4': '४',
	    '5': '५',
	    '6': '६',
	    '7': '७',
	    '8': '८',
	    '9': '९',
	    '0': '०'
	};
	var numberMap = {
	    '१': '1',
	    '२': '2',
	    '३': '3',
	    '४': '4',
	    '५': '5',
	    '६': '6',
	    '७': '7',
	    '८': '8',
	    '९': '9',
	    '०': '0'
	};

	var hi = moment.defineLocale('hi', {
	    months : 'जनवरी_फ़रवरी_मार्च_अप्रैल_मई_जून_जुलाई_अगस्त_सितम्बर_अक्टूबर_नवम्बर_दिसम्बर'.split('_'),
	    monthsShort : 'जन._फ़र._मार्च_अप्रै._मई_जून_जुल._अग._सित._अक्टू._नव._दिस.'.split('_'),
	    monthsParseExact: true,
	    weekdays : 'रविवार_सोमवार_मंगलवार_बुधवार_गुरूवार_शुक्रवार_शनिवार'.split('_'),
	    weekdaysShort : 'रवि_सोम_मंगल_बुध_गुरू_शुक्र_शनि'.split('_'),
	    weekdaysMin : 'र_सो_मं_बु_गु_शु_श'.split('_'),
	    longDateFormat : {
	        LT : 'A h:mm बजे',
	        LTS : 'A h:mm:ss बजे',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, A h:mm बजे',
	        LLLL : 'dddd, D MMMM YYYY, A h:mm बजे'
	    },
	    calendar : {
	        sameDay : '[आज] LT',
	        nextDay : '[कल] LT',
	        nextWeek : 'dddd, LT',
	        lastDay : '[कल] LT',
	        lastWeek : '[पिछले] dddd, LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s में',
	        past : '%s पहले',
	        s : 'कुछ ही क्षण',
	        m : 'एक मिनट',
	        mm : '%d मिनट',
	        h : 'एक घंटा',
	        hh : '%d घंटे',
	        d : 'एक दिन',
	        dd : '%d दिन',
	        M : 'एक महीने',
	        MM : '%d महीने',
	        y : 'एक वर्ष',
	        yy : '%d वर्ष'
	    },
	    preparse: function (string) {
	        return string.replace(/[१२३४५६७८९०]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    // Hindi notation for meridiems are quite fuzzy in practice. While there exists
	    // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
	    meridiemParse: /रात|सुबह|दोपहर|शाम/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === 'रात') {
	            return hour < 4 ? hour : hour + 12;
	        } else if (meridiem === 'सुबह') {
	            return hour;
	        } else if (meridiem === 'दोपहर') {
	            return hour >= 10 ? hour : hour + 12;
	        } else if (meridiem === 'शाम') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return 'रात';
	        } else if (hour < 10) {
	            return 'सुबह';
	        } else if (hour < 17) {
	            return 'दोपहर';
	        } else if (hour < 20) {
	            return 'शाम';
	        } else {
	            return 'रात';
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return hi;

	})));


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Croatian [hr]
	//! author : Bojan Marković : https://github.com/bmarkovic

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	function translate(number, withoutSuffix, key) {
	    var result = number + ' ';
	    switch (key) {
	        case 'm':
	            return withoutSuffix ? 'jedna minuta' : 'jedne minute';
	        case 'mm':
	            if (number === 1) {
	                result += 'minuta';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'minute';
	            } else {
	                result += 'minuta';
	            }
	            return result;
	        case 'h':
	            return withoutSuffix ? 'jedan sat' : 'jednog sata';
	        case 'hh':
	            if (number === 1) {
	                result += 'sat';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'sata';
	            } else {
	                result += 'sati';
	            }
	            return result;
	        case 'dd':
	            if (number === 1) {
	                result += 'dan';
	            } else {
	                result += 'dana';
	            }
	            return result;
	        case 'MM':
	            if (number === 1) {
	                result += 'mjesec';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'mjeseca';
	            } else {
	                result += 'mjeseci';
	            }
	            return result;
	        case 'yy':
	            if (number === 1) {
	                result += 'godina';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'godine';
	            } else {
	                result += 'godina';
	            }
	            return result;
	    }
	}

	var hr = moment.defineLocale('hr', {
	    months : {
	        format: 'siječnja_veljače_ožujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca'.split('_'),
	        standalone: 'siječanj_veljača_ožujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split('_')
	    },
	    monthsShort : 'sij._velj._ožu._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split('_'),
	    monthsParseExact: true,
	    weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split('_'),
	    weekdaysShort : 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
	    weekdaysMin : 'ne_po_ut_sr_če_pe_su'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY H:mm',
	        LLLL : 'dddd, D. MMMM YYYY H:mm'
	    },
	    calendar : {
	        sameDay  : '[danas u] LT',
	        nextDay  : '[sutra u] LT',
	        nextWeek : function () {
	            switch (this.day()) {
	                case 0:
	                    return '[u] [nedjelju] [u] LT';
	                case 3:
	                    return '[u] [srijedu] [u] LT';
	                case 6:
	                    return '[u] [subotu] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[u] dddd [u] LT';
	            }
	        },
	        lastDay  : '[jučer u] LT',
	        lastWeek : function () {
	            switch (this.day()) {
	                case 0:
	                case 3:
	                    return '[prošlu] dddd [u] LT';
	                case 6:
	                    return '[prošle] [subote] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[prošli] dddd [u] LT';
	            }
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'za %s',
	        past   : 'prije %s',
	        s      : 'par sekundi',
	        m      : translate,
	        mm     : translate,
	        h      : translate,
	        hh     : translate,
	        d      : 'dan',
	        dd     : translate,
	        M      : 'mjesec',
	        MM     : translate,
	        y      : 'godinu',
	        yy     : translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return hr;

	})));


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Hungarian [hu]
	//! author : Adam Brunner : https://github.com/adambrunner

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var weekEndings = 'vasárnap hétfőn kedden szerdán csütörtökön pénteken szombaton'.split(' ');
	function translate(number, withoutSuffix, key, isFuture) {
	    var num = number,
	        suffix;
	    switch (key) {
	        case 's':
	            return (isFuture || withoutSuffix) ? 'néhány másodperc' : 'néhány másodperce';
	        case 'm':
	            return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');
	        case 'mm':
	            return num + (isFuture || withoutSuffix ? ' perc' : ' perce');
	        case 'h':
	            return 'egy' + (isFuture || withoutSuffix ? ' óra' : ' órája');
	        case 'hh':
	            return num + (isFuture || withoutSuffix ? ' óra' : ' órája');
	        case 'd':
	            return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');
	        case 'dd':
	            return num + (isFuture || withoutSuffix ? ' nap' : ' napja');
	        case 'M':
	            return 'egy' + (isFuture || withoutSuffix ? ' hónap' : ' hónapja');
	        case 'MM':
	            return num + (isFuture || withoutSuffix ? ' hónap' : ' hónapja');
	        case 'y':
	            return 'egy' + (isFuture || withoutSuffix ? ' év' : ' éve');
	        case 'yy':
	            return num + (isFuture || withoutSuffix ? ' év' : ' éve');
	    }
	    return '';
	}
	function week(isFuture) {
	    return (isFuture ? '' : '[múlt] ') + '[' + weekEndings[this.day()] + '] LT[-kor]';
	}

	var hu = moment.defineLocale('hu', {
	    months : 'január_február_március_április_május_június_július_augusztus_szeptember_október_november_december'.split('_'),
	    monthsShort : 'jan_feb_márc_ápr_máj_jún_júl_aug_szept_okt_nov_dec'.split('_'),
	    weekdays : 'vasárnap_hétfő_kedd_szerda_csütörtök_péntek_szombat'.split('_'),
	    weekdaysShort : 'vas_hét_kedd_sze_csüt_pén_szo'.split('_'),
	    weekdaysMin : 'v_h_k_sze_cs_p_szo'.split('_'),
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'YYYY.MM.DD.',
	        LL : 'YYYY. MMMM D.',
	        LLL : 'YYYY. MMMM D. H:mm',
	        LLLL : 'YYYY. MMMM D., dddd H:mm'
	    },
	    meridiemParse: /de|du/i,
	    isPM: function (input) {
	        return input.charAt(1).toLowerCase() === 'u';
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours < 12) {
	            return isLower === true ? 'de' : 'DE';
	        } else {
	            return isLower === true ? 'du' : 'DU';
	        }
	    },
	    calendar : {
	        sameDay : '[ma] LT[-kor]',
	        nextDay : '[holnap] LT[-kor]',
	        nextWeek : function () {
	            return week.call(this, true);
	        },
	        lastDay : '[tegnap] LT[-kor]',
	        lastWeek : function () {
	            return week.call(this, false);
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s múlva',
	        past : '%s',
	        s : translate,
	        m : translate,
	        mm : translate,
	        h : translate,
	        hh : translate,
	        d : translate,
	        dd : translate,
	        M : translate,
	        MM : translate,
	        y : translate,
	        yy : translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return hu;

	})));


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Armenian [hy-am]
	//! author : Armendarabyan : https://github.com/armendarabyan

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var hyAm = moment.defineLocale('hy-am', {
	    months : {
	        format: 'հունվարի_փետրվարի_մարտի_ապրիլի_մայիսի_հունիսի_հուլիսի_օգոստոսի_սեպտեմբերի_հոկտեմբերի_նոյեմբերի_դեկտեմբերի'.split('_'),
	        standalone: 'հունվար_փետրվար_մարտ_ապրիլ_մայիս_հունիս_հուլիս_օգոստոս_սեպտեմբեր_հոկտեմբեր_նոյեմբեր_դեկտեմբեր'.split('_')
	    },
	    monthsShort : 'հնվ_փտր_մրտ_ապր_մյս_հնս_հլս_օգս_սպտ_հկտ_նմբ_դկտ'.split('_'),
	    weekdays : 'կիրակի_երկուշաբթի_երեքշաբթի_չորեքշաբթի_հինգշաբթի_ուրբաթ_շաբաթ'.split('_'),
	    weekdaysShort : 'կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ'.split('_'),
	    weekdaysMin : 'կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY թ.',
	        LLL : 'D MMMM YYYY թ., HH:mm',
	        LLLL : 'dddd, D MMMM YYYY թ., HH:mm'
	    },
	    calendar : {
	        sameDay: '[այսօր] LT',
	        nextDay: '[վաղը] LT',
	        lastDay: '[երեկ] LT',
	        nextWeek: function () {
	            return 'dddd [օրը ժամը] LT';
	        },
	        lastWeek: function () {
	            return '[անցած] dddd [օրը ժամը] LT';
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : '%s հետո',
	        past : '%s առաջ',
	        s : 'մի քանի վայրկյան',
	        m : 'րոպե',
	        mm : '%d րոպե',
	        h : 'ժամ',
	        hh : '%d ժամ',
	        d : 'օր',
	        dd : '%d օր',
	        M : 'ամիս',
	        MM : '%d ամիս',
	        y : 'տարի',
	        yy : '%d տարի'
	    },
	    meridiemParse: /գիշերվա|առավոտվա|ցերեկվա|երեկոյան/,
	    isPM: function (input) {
	        return /^(ցերեկվա|երեկոյան)$/.test(input);
	    },
	    meridiem : function (hour) {
	        if (hour < 4) {
	            return 'գիշերվա';
	        } else if (hour < 12) {
	            return 'առավոտվա';
	        } else if (hour < 17) {
	            return 'ցերեկվա';
	        } else {
	            return 'երեկոյան';
	        }
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}|\d{1,2}-(ին|րդ)/,
	    ordinal: function (number, period) {
	        switch (period) {
	            case 'DDD':
	            case 'w':
	            case 'W':
	            case 'DDDo':
	                if (number === 1) {
	                    return number + '-ին';
	                }
	                return number + '-րդ';
	            default:
	                return number;
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return hyAm;

	})));


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Indonesian [id]
	//! author : Mohammad Satrio Utomo : https://github.com/tyok
	//! reference: http://id.wikisource.org/wiki/Pedoman_Umum_Ejaan_Bahasa_Indonesia_yang_Disempurnakan

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var id = moment.defineLocale('id', {
	    months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split('_'),
	    monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nov_Des'.split('_'),
	    weekdays : 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),
	    weekdaysShort : 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),
	    weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),
	    longDateFormat : {
	        LT : 'HH.mm',
	        LTS : 'HH.mm.ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY [pukul] HH.mm',
	        LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
	    },
	    meridiemParse: /pagi|siang|sore|malam/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === 'pagi') {
	            return hour;
	        } else if (meridiem === 'siang') {
	            return hour >= 11 ? hour : hour + 12;
	        } else if (meridiem === 'sore' || meridiem === 'malam') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours < 11) {
	            return 'pagi';
	        } else if (hours < 15) {
	            return 'siang';
	        } else if (hours < 19) {
	            return 'sore';
	        } else {
	            return 'malam';
	        }
	    },
	    calendar : {
	        sameDay : '[Hari ini pukul] LT',
	        nextDay : '[Besok pukul] LT',
	        nextWeek : 'dddd [pukul] LT',
	        lastDay : '[Kemarin pukul] LT',
	        lastWeek : 'dddd [lalu pukul] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'dalam %s',
	        past : '%s yang lalu',
	        s : 'beberapa detik',
	        m : 'semenit',
	        mm : '%d menit',
	        h : 'sejam',
	        hh : '%d jam',
	        d : 'sehari',
	        dd : '%d hari',
	        M : 'sebulan',
	        MM : '%d bulan',
	        y : 'setahun',
	        yy : '%d tahun'
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return id;

	})));


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Icelandic [is]
	//! author : Hinrik Örn Sigurðsson : https://github.com/hinrik

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	function plural(n) {
	    if (n % 100 === 11) {
	        return true;
	    } else if (n % 10 === 1) {
	        return false;
	    }
	    return true;
	}
	function translate(number, withoutSuffix, key, isFuture) {
	    var result = number + ' ';
	    switch (key) {
	        case 's':
	            return withoutSuffix || isFuture ? 'nokkrar sekúndur' : 'nokkrum sekúndum';
	        case 'm':
	            return withoutSuffix ? 'mínúta' : 'mínútu';
	        case 'mm':
	            if (plural(number)) {
	                return result + (withoutSuffix || isFuture ? 'mínútur' : 'mínútum');
	            } else if (withoutSuffix) {
	                return result + 'mínúta';
	            }
	            return result + 'mínútu';
	        case 'hh':
	            if (plural(number)) {
	                return result + (withoutSuffix || isFuture ? 'klukkustundir' : 'klukkustundum');
	            }
	            return result + 'klukkustund';
	        case 'd':
	            if (withoutSuffix) {
	                return 'dagur';
	            }
	            return isFuture ? 'dag' : 'degi';
	        case 'dd':
	            if (plural(number)) {
	                if (withoutSuffix) {
	                    return result + 'dagar';
	                }
	                return result + (isFuture ? 'daga' : 'dögum');
	            } else if (withoutSuffix) {
	                return result + 'dagur';
	            }
	            return result + (isFuture ? 'dag' : 'degi');
	        case 'M':
	            if (withoutSuffix) {
	                return 'mánuður';
	            }
	            return isFuture ? 'mánuð' : 'mánuði';
	        case 'MM':
	            if (plural(number)) {
	                if (withoutSuffix) {
	                    return result + 'mánuðir';
	                }
	                return result + (isFuture ? 'mánuði' : 'mánuðum');
	            } else if (withoutSuffix) {
	                return result + 'mánuður';
	            }
	            return result + (isFuture ? 'mánuð' : 'mánuði');
	        case 'y':
	            return withoutSuffix || isFuture ? 'ár' : 'ári';
	        case 'yy':
	            if (plural(number)) {
	                return result + (withoutSuffix || isFuture ? 'ár' : 'árum');
	            }
	            return result + (withoutSuffix || isFuture ? 'ár' : 'ári');
	    }
	}

	var is = moment.defineLocale('is', {
	    months : 'janúar_febrúar_mars_apríl_maí_júní_júlí_ágúst_september_október_nóvember_desember'.split('_'),
	    monthsShort : 'jan_feb_mar_apr_maí_jún_júl_ágú_sep_okt_nóv_des'.split('_'),
	    weekdays : 'sunnudagur_mánudagur_þriðjudagur_miðvikudagur_fimmtudagur_föstudagur_laugardagur'.split('_'),
	    weekdaysShort : 'sun_mán_þri_mið_fim_fös_lau'.split('_'),
	    weekdaysMin : 'Su_Má_Þr_Mi_Fi_Fö_La'.split('_'),
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY [kl.] H:mm',
	        LLLL : 'dddd, D. MMMM YYYY [kl.] H:mm'
	    },
	    calendar : {
	        sameDay : '[í dag kl.] LT',
	        nextDay : '[á morgun kl.] LT',
	        nextWeek : 'dddd [kl.] LT',
	        lastDay : '[í gær kl.] LT',
	        lastWeek : '[síðasta] dddd [kl.] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'eftir %s',
	        past : 'fyrir %s síðan',
	        s : translate,
	        m : translate,
	        mm : translate,
	        h : 'klukkustund',
	        hh : translate,
	        d : translate,
	        dd : translate,
	        M : translate,
	        MM : translate,
	        y : translate,
	        yy : translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return is;

	})));


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Italian [it]
	//! author : Lorenzo : https://github.com/aliem
	//! author: Mattia Larentis: https://github.com/nostalgiaz

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var it = moment.defineLocale('it', {
	    months : 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
	    monthsShort : 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
	    weekdays : 'domenica_lunedì_martedì_mercoledì_giovedì_venerdì_sabato'.split('_'),
	    weekdaysShort : 'dom_lun_mar_mer_gio_ven_sab'.split('_'),
	    weekdaysMin : 'do_lu_ma_me_gi_ve_sa'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[Oggi alle] LT',
	        nextDay: '[Domani alle] LT',
	        nextWeek: 'dddd [alle] LT',
	        lastDay: '[Ieri alle] LT',
	        lastWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[la scorsa] dddd [alle] LT';
	                default:
	                    return '[lo scorso] dddd [alle] LT';
	            }
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : function (s) {
	            return ((/^[0-9].+$/).test(s) ? 'tra' : 'in') + ' ' + s;
	        },
	        past : '%s fa',
	        s : 'alcuni secondi',
	        m : 'un minuto',
	        mm : '%d minuti',
	        h : 'un\'ora',
	        hh : '%d ore',
	        d : 'un giorno',
	        dd : '%d giorni',
	        M : 'un mese',
	        MM : '%d mesi',
	        y : 'un anno',
	        yy : '%d anni'
	    },
	    dayOfMonthOrdinalParse : /\d{1,2}º/,
	    ordinal: '%dº',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return it;

	})));


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Japanese [ja]
	//! author : LI Long : https://github.com/baryon

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var ja = moment.defineLocale('ja', {
	    months : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
	    monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
	    weekdays : '日曜日_月曜日_火曜日_水曜日_木曜日_金曜日_土曜日'.split('_'),
	    weekdaysShort : '日_月_火_水_木_金_土'.split('_'),
	    weekdaysMin : '日_月_火_水_木_金_土'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'YYYY/MM/DD',
	        LL : 'YYYY年M月D日',
	        LLL : 'YYYY年M月D日 HH:mm',
	        LLLL : 'YYYY年M月D日 HH:mm dddd',
	        l : 'YYYY/MM/DD',
	        ll : 'YYYY年M月D日',
	        lll : 'YYYY年M月D日 HH:mm',
	        llll : 'YYYY年M月D日 HH:mm dddd'
	    },
	    meridiemParse: /午前|午後/i,
	    isPM : function (input) {
	        return input === '午後';
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 12) {
	            return '午前';
	        } else {
	            return '午後';
	        }
	    },
	    calendar : {
	        sameDay : '[今日] LT',
	        nextDay : '[明日] LT',
	        nextWeek : '[来週]dddd LT',
	        lastDay : '[昨日] LT',
	        lastWeek : '[前週]dddd LT',
	        sameElse : 'L'
	    },
	    dayOfMonthOrdinalParse : /\d{1,2}日/,
	    ordinal : function (number, period) {
	        switch (period) {
	            case 'd':
	            case 'D':
	            case 'DDD':
	                return number + '日';
	            default:
	                return number;
	        }
	    },
	    relativeTime : {
	        future : '%s後',
	        past : '%s前',
	        s : '数秒',
	        m : '1分',
	        mm : '%d分',
	        h : '1時間',
	        hh : '%d時間',
	        d : '1日',
	        dd : '%d日',
	        M : '1ヶ月',
	        MM : '%dヶ月',
	        y : '1年',
	        yy : '%d年'
	    }
	});

	return ja;

	})));


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Javanese [jv]
	//! author : Rony Lantip : https://github.com/lantip
	//! reference: http://jv.wikipedia.org/wiki/Basa_Jawa

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var jv = moment.defineLocale('jv', {
	    months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember'.split('_'),
	    monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des'.split('_'),
	    weekdays : 'Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu'.split('_'),
	    weekdaysShort : 'Min_Sen_Sel_Reb_Kem_Jem_Sep'.split('_'),
	    weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sp'.split('_'),
	    longDateFormat : {
	        LT : 'HH.mm',
	        LTS : 'HH.mm.ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY [pukul] HH.mm',
	        LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
	    },
	    meridiemParse: /enjing|siyang|sonten|ndalu/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === 'enjing') {
	            return hour;
	        } else if (meridiem === 'siyang') {
	            return hour >= 11 ? hour : hour + 12;
	        } else if (meridiem === 'sonten' || meridiem === 'ndalu') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours < 11) {
	            return 'enjing';
	        } else if (hours < 15) {
	            return 'siyang';
	        } else if (hours < 19) {
	            return 'sonten';
	        } else {
	            return 'ndalu';
	        }
	    },
	    calendar : {
	        sameDay : '[Dinten puniko pukul] LT',
	        nextDay : '[Mbenjang pukul] LT',
	        nextWeek : 'dddd [pukul] LT',
	        lastDay : '[Kala wingi pukul] LT',
	        lastWeek : 'dddd [kepengker pukul] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'wonten ing %s',
	        past : '%s ingkang kepengker',
	        s : 'sawetawis detik',
	        m : 'setunggal menit',
	        mm : '%d menit',
	        h : 'setunggal jam',
	        hh : '%d jam',
	        d : 'sedinten',
	        dd : '%d dinten',
	        M : 'sewulan',
	        MM : '%d wulan',
	        y : 'setaun',
	        yy : '%d taun'
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return jv;

	})));


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Georgian [ka]
	//! author : Irakli Janiashvili : https://github.com/irakli-janiashvili

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var ka = moment.defineLocale('ka', {
	    months : {
	        standalone: 'იანვარი_თებერვალი_მარტი_აპრილი_მაისი_ივნისი_ივლისი_აგვისტო_სექტემბერი_ოქტომბერი_ნოემბერი_დეკემბერი'.split('_'),
	        format: 'იანვარს_თებერვალს_მარტს_აპრილის_მაისს_ივნისს_ივლისს_აგვისტს_სექტემბერს_ოქტომბერს_ნოემბერს_დეკემბერს'.split('_')
	    },
	    monthsShort : 'იან_თებ_მარ_აპრ_მაი_ივნ_ივლ_აგვ_სექ_ოქტ_ნოე_დეკ'.split('_'),
	    weekdays : {
	        standalone: 'კვირა_ორშაბათი_სამშაბათი_ოთხშაბათი_ხუთშაბათი_პარასკევი_შაბათი'.split('_'),
	        format: 'კვირას_ორშაბათს_სამშაბათს_ოთხშაბათს_ხუთშაბათს_პარასკევს_შაბათს'.split('_'),
	        isFormat: /(წინა|შემდეგ)/
	    },
	    weekdaysShort : 'კვი_ორშ_სამ_ოთხ_ხუთ_პარ_შაბ'.split('_'),
	    weekdaysMin : 'კვ_ორ_სა_ოთ_ხუ_პა_შა'.split('_'),
	    longDateFormat : {
	        LT : 'h:mm A',
	        LTS : 'h:mm:ss A',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY h:mm A',
	        LLLL : 'dddd, D MMMM YYYY h:mm A'
	    },
	    calendar : {
	        sameDay : '[დღეს] LT[-ზე]',
	        nextDay : '[ხვალ] LT[-ზე]',
	        lastDay : '[გუშინ] LT[-ზე]',
	        nextWeek : '[შემდეგ] dddd LT[-ზე]',
	        lastWeek : '[წინა] dddd LT-ზე',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : function (s) {
	            return (/(წამი|წუთი|საათი|წელი)/).test(s) ?
	                s.replace(/ი$/, 'ში') :
	                s + 'ში';
	        },
	        past : function (s) {
	            if ((/(წამი|წუთი|საათი|დღე|თვე)/).test(s)) {
	                return s.replace(/(ი|ე)$/, 'ის უკან');
	            }
	            if ((/წელი/).test(s)) {
	                return s.replace(/წელი$/, 'წლის უკან');
	            }
	        },
	        s : 'რამდენიმე წამი',
	        m : 'წუთი',
	        mm : '%d წუთი',
	        h : 'საათი',
	        hh : '%d საათი',
	        d : 'დღე',
	        dd : '%d დღე',
	        M : 'თვე',
	        MM : '%d თვე',
	        y : 'წელი',
	        yy : '%d წელი'
	    },
	    dayOfMonthOrdinalParse: /0|1-ლი|მე-\d{1,2}|\d{1,2}-ე/,
	    ordinal : function (number) {
	        if (number === 0) {
	            return number;
	        }
	        if (number === 1) {
	            return number + '-ლი';
	        }
	        if ((number < 20) || (number <= 100 && (number % 20 === 0)) || (number % 100 === 0)) {
	            return 'მე-' + number;
	        }
	        return number + '-ე';
	    },
	    week : {
	        dow : 1,
	        doy : 7
	    }
	});

	return ka;

	})));


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Kazakh [kk]
	//! authors : Nurlan Rakhimzhanov : https://github.com/nurlan

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var suffixes = {
	    0: '-ші',
	    1: '-ші',
	    2: '-ші',
	    3: '-ші',
	    4: '-ші',
	    5: '-ші',
	    6: '-шы',
	    7: '-ші',
	    8: '-ші',
	    9: '-шы',
	    10: '-шы',
	    20: '-шы',
	    30: '-шы',
	    40: '-шы',
	    50: '-ші',
	    60: '-шы',
	    70: '-ші',
	    80: '-ші',
	    90: '-шы',
	    100: '-ші'
	};

	var kk = moment.defineLocale('kk', {
	    months : 'қаңтар_ақпан_наурыз_сәуір_мамыр_маусым_шілде_тамыз_қыркүйек_қазан_қараша_желтоқсан'.split('_'),
	    monthsShort : 'қаң_ақп_нау_сәу_мам_мау_шіл_там_қыр_қаз_қар_жел'.split('_'),
	    weekdays : 'жексенбі_дүйсенбі_сейсенбі_сәрсенбі_бейсенбі_жұма_сенбі'.split('_'),
	    weekdaysShort : 'жек_дүй_сей_сәр_бей_жұм_сен'.split('_'),
	    weekdaysMin : 'жк_дй_сй_ср_бй_жм_сн'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[Бүгін сағат] LT',
	        nextDay : '[Ертең сағат] LT',
	        nextWeek : 'dddd [сағат] LT',
	        lastDay : '[Кеше сағат] LT',
	        lastWeek : '[Өткен аптаның] dddd [сағат] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s ішінде',
	        past : '%s бұрын',
	        s : 'бірнеше секунд',
	        m : 'бір минут',
	        mm : '%d минут',
	        h : 'бір сағат',
	        hh : '%d сағат',
	        d : 'бір күн',
	        dd : '%d күн',
	        M : 'бір ай',
	        MM : '%d ай',
	        y : 'бір жыл',
	        yy : '%d жыл'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}-(ші|шы)/,
	    ordinal : function (number) {
	        var a = number % 10,
	            b = number >= 100 ? 100 : null;
	        return number + (suffixes[number] || suffixes[a] || suffixes[b]);
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return kk;

	})));


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Cambodian [km]
	//! author : Kruy Vanna : https://github.com/kruyvanna

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var km = moment.defineLocale('km', {
	    months: 'មករា_កុម្ភៈ_មីនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ'.split('_'),
	    monthsShort: 'មករា_កុម្ភៈ_មីនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ'.split('_'),
	    weekdays: 'អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍'.split('_'),
	    weekdaysShort: 'អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍'.split('_'),
	    weekdaysMin: 'អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍'.split('_'),
	    longDateFormat: {
	        LT: 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L: 'DD/MM/YYYY',
	        LL: 'D MMMM YYYY',
	        LLL: 'D MMMM YYYY HH:mm',
	        LLLL: 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar: {
	        sameDay: '[ថ្ងៃនេះ ម៉ោង] LT',
	        nextDay: '[ស្អែក ម៉ោង] LT',
	        nextWeek: 'dddd [ម៉ោង] LT',
	        lastDay: '[ម្សិលមិញ ម៉ោង] LT',
	        lastWeek: 'dddd [សប្តាហ៍មុន] [ម៉ោង] LT',
	        sameElse: 'L'
	    },
	    relativeTime: {
	        future: '%sទៀត',
	        past: '%sមុន',
	        s: 'ប៉ុន្មានវិនាទី',
	        m: 'មួយនាទី',
	        mm: '%d នាទី',
	        h: 'មួយម៉ោង',
	        hh: '%d ម៉ោង',
	        d: 'មួយថ្ងៃ',
	        dd: '%d ថ្ងៃ',
	        M: 'មួយខែ',
	        MM: '%d ខែ',
	        y: 'មួយឆ្នាំ',
	        yy: '%d ឆ្នាំ'
	    },
	    week: {
	        dow: 1, // Monday is the first day of the week.
	        doy: 4 // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return km;

	})));


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Kannada [kn]
	//! author : Rajeev Naik : https://github.com/rajeevnaikte

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var symbolMap = {
	    '1': '೧',
	    '2': '೨',
	    '3': '೩',
	    '4': '೪',
	    '5': '೫',
	    '6': '೬',
	    '7': '೭',
	    '8': '೮',
	    '9': '೯',
	    '0': '೦'
	};
	var numberMap = {
	    '೧': '1',
	    '೨': '2',
	    '೩': '3',
	    '೪': '4',
	    '೫': '5',
	    '೬': '6',
	    '೭': '7',
	    '೮': '8',
	    '೯': '9',
	    '೦': '0'
	};

	var kn = moment.defineLocale('kn', {
	    months : 'ಜನವರಿ_ಫೆಬ್ರವರಿ_ಮಾರ್ಚ್_ಏಪ್ರಿಲ್_ಮೇ_ಜೂನ್_ಜುಲೈ_ಆಗಸ್ಟ್_ಸೆಪ್ಟೆಂಬರ್_ಅಕ್ಟೋಬರ್_ನವೆಂಬರ್_ಡಿಸೆಂಬರ್'.split('_'),
	    monthsShort : 'ಜನ_ಫೆಬ್ರ_ಮಾರ್ಚ್_ಏಪ್ರಿಲ್_ಮೇ_ಜೂನ್_ಜುಲೈ_ಆಗಸ್ಟ್_ಸೆಪ್ಟೆಂಬ_ಅಕ್ಟೋಬ_ನವೆಂಬ_ಡಿಸೆಂಬ'.split('_'),
	    monthsParseExact: true,
	    weekdays : 'ಭಾನುವಾರ_ಸೋಮವಾರ_ಮಂಗಳವಾರ_ಬುಧವಾರ_ಗುರುವಾರ_ಶುಕ್ರವಾರ_ಶನಿವಾರ'.split('_'),
	    weekdaysShort : 'ಭಾನು_ಸೋಮ_ಮಂಗಳ_ಬುಧ_ಗುರು_ಶುಕ್ರ_ಶನಿ'.split('_'),
	    weekdaysMin : 'ಭಾ_ಸೋ_ಮಂ_ಬು_ಗು_ಶು_ಶ'.split('_'),
	    longDateFormat : {
	        LT : 'A h:mm',
	        LTS : 'A h:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, A h:mm',
	        LLLL : 'dddd, D MMMM YYYY, A h:mm'
	    },
	    calendar : {
	        sameDay : '[ಇಂದು] LT',
	        nextDay : '[ನಾಳೆ] LT',
	        nextWeek : 'dddd, LT',
	        lastDay : '[ನಿನ್ನೆ] LT',
	        lastWeek : '[ಕೊನೆಯ] dddd, LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s ನಂತರ',
	        past : '%s ಹಿಂದೆ',
	        s : 'ಕೆಲವು ಕ್ಷಣಗಳು',
	        m : 'ಒಂದು ನಿಮಿಷ',
	        mm : '%d ನಿಮಿಷ',
	        h : 'ಒಂದು ಗಂಟೆ',
	        hh : '%d ಗಂಟೆ',
	        d : 'ಒಂದು ದಿನ',
	        dd : '%d ದಿನ',
	        M : 'ಒಂದು ತಿಂಗಳು',
	        MM : '%d ತಿಂಗಳು',
	        y : 'ಒಂದು ವರ್ಷ',
	        yy : '%d ವರ್ಷ'
	    },
	    preparse: function (string) {
	        return string.replace(/[೧೨೩೪೫೬೭೮೯೦]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    meridiemParse: /ರಾತ್ರಿ|ಬೆಳಿಗ್ಗೆ|ಮಧ್ಯಾಹ್ನ|ಸಂಜೆ/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === 'ರಾತ್ರಿ') {
	            return hour < 4 ? hour : hour + 12;
	        } else if (meridiem === 'ಬೆಳಿಗ್ಗೆ') {
	            return hour;
	        } else if (meridiem === 'ಮಧ್ಯಾಹ್ನ') {
	            return hour >= 10 ? hour : hour + 12;
	        } else if (meridiem === 'ಸಂಜೆ') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return 'ರಾತ್ರಿ';
	        } else if (hour < 10) {
	            return 'ಬೆಳಿಗ್ಗೆ';
	        } else if (hour < 17) {
	            return 'ಮಧ್ಯಾಹ್ನ';
	        } else if (hour < 20) {
	            return 'ಸಂಜೆ';
	        } else {
	            return 'ರಾತ್ರಿ';
	        }
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(ನೇ)/,
	    ordinal : function (number) {
	        return number + 'ನೇ';
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return kn;

	})));


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Korean [ko]
	//! author : Kyungwook, Park : https://github.com/kyungw00k
	//! author : Jeeeyul Lee <jeeeyul@gmail.com>

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var ko = moment.defineLocale('ko', {
	    months : '1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월'.split('_'),
	    monthsShort : '1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월'.split('_'),
	    weekdays : '일요일_월요일_화요일_수요일_목요일_금요일_토요일'.split('_'),
	    weekdaysShort : '일_월_화_수_목_금_토'.split('_'),
	    weekdaysMin : '일_월_화_수_목_금_토'.split('_'),
	    longDateFormat : {
	        LT : 'A h:mm',
	        LTS : 'A h:mm:ss',
	        L : 'YYYY.MM.DD',
	        LL : 'YYYY년 MMMM D일',
	        LLL : 'YYYY년 MMMM D일 A h:mm',
	        LLLL : 'YYYY년 MMMM D일 dddd A h:mm',
	        l : 'YYYY.MM.DD',
	        ll : 'YYYY년 MMMM D일',
	        lll : 'YYYY년 MMMM D일 A h:mm',
	        llll : 'YYYY년 MMMM D일 dddd A h:mm'
	    },
	    calendar : {
	        sameDay : '오늘 LT',
	        nextDay : '내일 LT',
	        nextWeek : 'dddd LT',
	        lastDay : '어제 LT',
	        lastWeek : '지난주 dddd LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s 후',
	        past : '%s 전',
	        s : '몇 초',
	        ss : '%d초',
	        m : '1분',
	        mm : '%d분',
	        h : '한 시간',
	        hh : '%d시간',
	        d : '하루',
	        dd : '%d일',
	        M : '한 달',
	        MM : '%d달',
	        y : '일 년',
	        yy : '%d년'
	    },
	    dayOfMonthOrdinalParse : /\d{1,2}일/,
	    ordinal : '%d일',
	    meridiemParse : /오전|오후/,
	    isPM : function (token) {
	        return token === '오후';
	    },
	    meridiem : function (hour, minute, isUpper) {
	        return hour < 12 ? '오전' : '오후';
	    }
	});

	return ko;

	})));


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Kyrgyz [ky]
	//! author : Chyngyz Arystan uulu : https://github.com/chyngyz

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';



	var suffixes = {
	    0: '-чү',
	    1: '-чи',
	    2: '-чи',
	    3: '-чү',
	    4: '-чү',
	    5: '-чи',
	    6: '-чы',
	    7: '-чи',
	    8: '-чи',
	    9: '-чу',
	    10: '-чу',
	    20: '-чы',
	    30: '-чу',
	    40: '-чы',
	    50: '-чү',
	    60: '-чы',
	    70: '-чи',
	    80: '-чи',
	    90: '-чу',
	    100: '-чү'
	};

	var ky = moment.defineLocale('ky', {
	    months : 'январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь'.split('_'),
	    monthsShort : 'янв_фев_март_апр_май_июнь_июль_авг_сен_окт_ноя_дек'.split('_'),
	    weekdays : 'Жекшемби_Дүйшөмбү_Шейшемби_Шаршемби_Бейшемби_Жума_Ишемби'.split('_'),
	    weekdaysShort : 'Жек_Дүй_Шей_Шар_Бей_Жум_Ише'.split('_'),
	    weekdaysMin : 'Жк_Дй_Шй_Шр_Бй_Жм_Иш'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[Бүгүн саат] LT',
	        nextDay : '[Эртең саат] LT',
	        nextWeek : 'dddd [саат] LT',
	        lastDay : '[Кече саат] LT',
	        lastWeek : '[Өткен аптанын] dddd [күнү] [саат] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s ичинде',
	        past : '%s мурун',
	        s : 'бирнече секунд',
	        m : 'бир мүнөт',
	        mm : '%d мүнөт',
	        h : 'бир саат',
	        hh : '%d саат',
	        d : 'бир күн',
	        dd : '%d күн',
	        M : 'бир ай',
	        MM : '%d ай',
	        y : 'бир жыл',
	        yy : '%d жыл'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}-(чи|чы|чү|чу)/,
	    ordinal : function (number) {
	        var a = number % 10,
	            b = number >= 100 ? 100 : null;
	        return number + (suffixes[number] || suffixes[a] || suffixes[b]);
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return ky;

	})));


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Luxembourgish [lb]
	//! author : mweimerskirch : https://github.com/mweimerskirch
	//! author : David Raison : https://github.com/kwisatz

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var format = {
	        'm': ['eng Minutt', 'enger Minutt'],
	        'h': ['eng Stonn', 'enger Stonn'],
	        'd': ['een Dag', 'engem Dag'],
	        'M': ['ee Mount', 'engem Mount'],
	        'y': ['ee Joer', 'engem Joer']
	    };
	    return withoutSuffix ? format[key][0] : format[key][1];
	}
	function processFutureTime(string) {
	    var number = string.substr(0, string.indexOf(' '));
	    if (eifelerRegelAppliesToNumber(number)) {
	        return 'a ' + string;
	    }
	    return 'an ' + string;
	}
	function processPastTime(string) {
	    var number = string.substr(0, string.indexOf(' '));
	    if (eifelerRegelAppliesToNumber(number)) {
	        return 'viru ' + string;
	    }
	    return 'virun ' + string;
	}
	/**
	 * Returns true if the word before the given number loses the '-n' ending.
	 * e.g. 'an 10 Deeg' but 'a 5 Deeg'
	 *
	 * @param number {integer}
	 * @returns {boolean}
	 */
	function eifelerRegelAppliesToNumber(number) {
	    number = parseInt(number, 10);
	    if (isNaN(number)) {
	        return false;
	    }
	    if (number < 0) {
	        // Negative Number --> always true
	        return true;
	    } else if (number < 10) {
	        // Only 1 digit
	        if (4 <= number && number <= 7) {
	            return true;
	        }
	        return false;
	    } else if (number < 100) {
	        // 2 digits
	        var lastDigit = number % 10, firstDigit = number / 10;
	        if (lastDigit === 0) {
	            return eifelerRegelAppliesToNumber(firstDigit);
	        }
	        return eifelerRegelAppliesToNumber(lastDigit);
	    } else if (number < 10000) {
	        // 3 or 4 digits --> recursively check first digit
	        while (number >= 10) {
	            number = number / 10;
	        }
	        return eifelerRegelAppliesToNumber(number);
	    } else {
	        // Anything larger than 4 digits: recursively check first n-3 digits
	        number = number / 1000;
	        return eifelerRegelAppliesToNumber(number);
	    }
	}

	var lb = moment.defineLocale('lb', {
	    months: 'Januar_Februar_Mäerz_Abrëll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
	    monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
	    monthsParseExact : true,
	    weekdays: 'Sonndeg_Méindeg_Dënschdeg_Mëttwoch_Donneschdeg_Freideg_Samschdeg'.split('_'),
	    weekdaysShort: 'So._Mé._Dë._Më._Do._Fr._Sa.'.split('_'),
	    weekdaysMin: 'So_Mé_Dë_Më_Do_Fr_Sa'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat: {
	        LT: 'H:mm [Auer]',
	        LTS: 'H:mm:ss [Auer]',
	        L: 'DD.MM.YYYY',
	        LL: 'D. MMMM YYYY',
	        LLL: 'D. MMMM YYYY H:mm [Auer]',
	        LLLL: 'dddd, D. MMMM YYYY H:mm [Auer]'
	    },
	    calendar: {
	        sameDay: '[Haut um] LT',
	        sameElse: 'L',
	        nextDay: '[Muer um] LT',
	        nextWeek: 'dddd [um] LT',
	        lastDay: '[Gëschter um] LT',
	        lastWeek: function () {
	            // Different date string for 'Dënschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule
	            switch (this.day()) {
	                case 2:
	                case 4:
	                    return '[Leschten] dddd [um] LT';
	                default:
	                    return '[Leschte] dddd [um] LT';
	            }
	        }
	    },
	    relativeTime : {
	        future : processFutureTime,
	        past : processPastTime,
	        s : 'e puer Sekonnen',
	        m : processRelativeTime,
	        mm : '%d Minutten',
	        h : processRelativeTime,
	        hh : '%d Stonnen',
	        d : processRelativeTime,
	        dd : '%d Deeg',
	        M : processRelativeTime,
	        MM : '%d Méint',
	        y : processRelativeTime,
	        yy : '%d Joer'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal: '%d.',
	    week: {
	        dow: 1, // Monday is the first day of the week.
	        doy: 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return lb;

	})));


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Lao [lo]
	//! author : Ryan Hart : https://github.com/ryanhart2

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var lo = moment.defineLocale('lo', {
	    months : 'ມັງກອນ_ກຸມພາ_ມີນາ_ເມສາ_ພຶດສະພາ_ມິຖຸນາ_ກໍລະກົດ_ສິງຫາ_ກັນຍາ_ຕຸລາ_ພະຈິກ_ທັນວາ'.split('_'),
	    monthsShort : 'ມັງກອນ_ກຸມພາ_ມີນາ_ເມສາ_ພຶດສະພາ_ມິຖຸນາ_ກໍລະກົດ_ສິງຫາ_ກັນຍາ_ຕຸລາ_ພະຈິກ_ທັນວາ'.split('_'),
	    weekdays : 'ອາທິດ_ຈັນ_ອັງຄານ_ພຸດ_ພະຫັດ_ສຸກ_ເສົາ'.split('_'),
	    weekdaysShort : 'ທິດ_ຈັນ_ອັງຄານ_ພຸດ_ພະຫັດ_ສຸກ_ເສົາ'.split('_'),
	    weekdaysMin : 'ທ_ຈ_ອຄ_ພ_ພຫ_ສກ_ສ'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'ວັນdddd D MMMM YYYY HH:mm'
	    },
	    meridiemParse: /ຕອນເຊົ້າ|ຕອນແລງ/,
	    isPM: function (input) {
	        return input === 'ຕອນແລງ';
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 12) {
	            return 'ຕອນເຊົ້າ';
	        } else {
	            return 'ຕອນແລງ';
	        }
	    },
	    calendar : {
	        sameDay : '[ມື້ນີ້ເວລາ] LT',
	        nextDay : '[ມື້ອື່ນເວລາ] LT',
	        nextWeek : '[ວັນ]dddd[ໜ້າເວລາ] LT',
	        lastDay : '[ມື້ວານນີ້ເວລາ] LT',
	        lastWeek : '[ວັນ]dddd[ແລ້ວນີ້ເວລາ] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'ອີກ %s',
	        past : '%sຜ່ານມາ',
	        s : 'ບໍ່ເທົ່າໃດວິນາທີ',
	        m : '1 ນາທີ',
	        mm : '%d ນາທີ',
	        h : '1 ຊົ່ວໂມງ',
	        hh : '%d ຊົ່ວໂມງ',
	        d : '1 ມື້',
	        dd : '%d ມື້',
	        M : '1 ເດືອນ',
	        MM : '%d ເດືອນ',
	        y : '1 ປີ',
	        yy : '%d ປີ'
	    },
	    dayOfMonthOrdinalParse: /(ທີ່)\d{1,2}/,
	    ordinal : function (number) {
	        return 'ທີ່' + number;
	    }
	});

	return lo;

	})));


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Lithuanian [lt]
	//! author : Mindaugas Mozūras : https://github.com/mmozuras

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var units = {
	    'm' : 'minutė_minutės_minutę',
	    'mm': 'minutės_minučių_minutes',
	    'h' : 'valanda_valandos_valandą',
	    'hh': 'valandos_valandų_valandas',
	    'd' : 'diena_dienos_dieną',
	    'dd': 'dienos_dienų_dienas',
	    'M' : 'mėnuo_mėnesio_mėnesį',
	    'MM': 'mėnesiai_mėnesių_mėnesius',
	    'y' : 'metai_metų_metus',
	    'yy': 'metai_metų_metus'
	};
	function translateSeconds(number, withoutSuffix, key, isFuture) {
	    if (withoutSuffix) {
	        return 'kelios sekundės';
	    } else {
	        return isFuture ? 'kelių sekundžių' : 'kelias sekundes';
	    }
	}
	function translateSingular(number, withoutSuffix, key, isFuture) {
	    return withoutSuffix ? forms(key)[0] : (isFuture ? forms(key)[1] : forms(key)[2]);
	}
	function special(number) {
	    return number % 10 === 0 || (number > 10 && number < 20);
	}
	function forms(key) {
	    return units[key].split('_');
	}
	function translate(number, withoutSuffix, key, isFuture) {
	    var result = number + ' ';
	    if (number === 1) {
	        return result + translateSingular(number, withoutSuffix, key[0], isFuture);
	    } else if (withoutSuffix) {
	        return result + (special(number) ? forms(key)[1] : forms(key)[0]);
	    } else {
	        if (isFuture) {
	            return result + forms(key)[1];
	        } else {
	            return result + (special(number) ? forms(key)[1] : forms(key)[2]);
	        }
	    }
	}
	var lt = moment.defineLocale('lt', {
	    months : {
	        format: 'sausio_vasario_kovo_balandžio_gegužės_birželio_liepos_rugpjūčio_rugsėjo_spalio_lapkričio_gruodžio'.split('_'),
	        standalone: 'sausis_vasaris_kovas_balandis_gegužė_birželis_liepa_rugpjūtis_rugsėjis_spalis_lapkritis_gruodis'.split('_'),
	        isFormat: /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/
	    },
	    monthsShort : 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),
	    weekdays : {
	        format: 'sekmadienį_pirmadienį_antradienį_trečiadienį_ketvirtadienį_penktadienį_šeštadienį'.split('_'),
	        standalone: 'sekmadienis_pirmadienis_antradienis_trečiadienis_ketvirtadienis_penktadienis_šeštadienis'.split('_'),
	        isFormat: /dddd HH:mm/
	    },
	    weekdaysShort : 'Sek_Pir_Ant_Tre_Ket_Pen_Šeš'.split('_'),
	    weekdaysMin : 'S_P_A_T_K_Pn_Š'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'YYYY-MM-DD',
	        LL : 'YYYY [m.] MMMM D [d.]',
	        LLL : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
	        LLLL : 'YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]',
	        l : 'YYYY-MM-DD',
	        ll : 'YYYY [m.] MMMM D [d.]',
	        lll : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
	        llll : 'YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]'
	    },
	    calendar : {
	        sameDay : '[Šiandien] LT',
	        nextDay : '[Rytoj] LT',
	        nextWeek : 'dddd LT',
	        lastDay : '[Vakar] LT',
	        lastWeek : '[Praėjusį] dddd LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'po %s',
	        past : 'prieš %s',
	        s : translateSeconds,
	        m : translateSingular,
	        mm : translate,
	        h : translateSingular,
	        hh : translate,
	        d : translateSingular,
	        dd : translate,
	        M : translateSingular,
	        MM : translate,
	        y : translateSingular,
	        yy : translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}-oji/,
	    ordinal : function (number) {
	        return number + '-oji';
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return lt;

	})));


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Latvian [lv]
	//! author : Kristaps Karlsons : https://github.com/skakri
	//! author : Jānis Elmeris : https://github.com/JanisE

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var units = {
	    'm': 'minūtes_minūtēm_minūte_minūtes'.split('_'),
	    'mm': 'minūtes_minūtēm_minūte_minūtes'.split('_'),
	    'h': 'stundas_stundām_stunda_stundas'.split('_'),
	    'hh': 'stundas_stundām_stunda_stundas'.split('_'),
	    'd': 'dienas_dienām_diena_dienas'.split('_'),
	    'dd': 'dienas_dienām_diena_dienas'.split('_'),
	    'M': 'mēneša_mēnešiem_mēnesis_mēneši'.split('_'),
	    'MM': 'mēneša_mēnešiem_mēnesis_mēneši'.split('_'),
	    'y': 'gada_gadiem_gads_gadi'.split('_'),
	    'yy': 'gada_gadiem_gads_gadi'.split('_')
	};
	/**
	 * @param withoutSuffix boolean true = a length of time; false = before/after a period of time.
	 */
	function format(forms, number, withoutSuffix) {
	    if (withoutSuffix) {
	        // E.g. "21 minūte", "3 minūtes".
	        return number % 10 === 1 && number % 100 !== 11 ? forms[2] : forms[3];
	    } else {
	        // E.g. "21 minūtes" as in "pēc 21 minūtes".
	        // E.g. "3 minūtēm" as in "pēc 3 minūtēm".
	        return number % 10 === 1 && number % 100 !== 11 ? forms[0] : forms[1];
	    }
	}
	function relativeTimeWithPlural(number, withoutSuffix, key) {
	    return number + ' ' + format(units[key], number, withoutSuffix);
	}
	function relativeTimeWithSingular(number, withoutSuffix, key) {
	    return format(units[key], number, withoutSuffix);
	}
	function relativeSeconds(number, withoutSuffix) {
	    return withoutSuffix ? 'dažas sekundes' : 'dažām sekundēm';
	}

	var lv = moment.defineLocale('lv', {
	    months : 'janvāris_februāris_marts_aprīlis_maijs_jūnijs_jūlijs_augusts_septembris_oktobris_novembris_decembris'.split('_'),
	    monthsShort : 'jan_feb_mar_apr_mai_jūn_jūl_aug_sep_okt_nov_dec'.split('_'),
	    weekdays : 'svētdiena_pirmdiena_otrdiena_trešdiena_ceturtdiena_piektdiena_sestdiena'.split('_'),
	    weekdaysShort : 'Sv_P_O_T_C_Pk_S'.split('_'),
	    weekdaysMin : 'Sv_P_O_T_C_Pk_S'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY.',
	        LL : 'YYYY. [gada] D. MMMM',
	        LLL : 'YYYY. [gada] D. MMMM, HH:mm',
	        LLLL : 'YYYY. [gada] D. MMMM, dddd, HH:mm'
	    },
	    calendar : {
	        sameDay : '[Šodien pulksten] LT',
	        nextDay : '[Rīt pulksten] LT',
	        nextWeek : 'dddd [pulksten] LT',
	        lastDay : '[Vakar pulksten] LT',
	        lastWeek : '[Pagājušā] dddd [pulksten] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'pēc %s',
	        past : 'pirms %s',
	        s : relativeSeconds,
	        m : relativeTimeWithSingular,
	        mm : relativeTimeWithPlural,
	        h : relativeTimeWithSingular,
	        hh : relativeTimeWithPlural,
	        d : relativeTimeWithSingular,
	        dd : relativeTimeWithPlural,
	        M : relativeTimeWithSingular,
	        MM : relativeTimeWithPlural,
	        y : relativeTimeWithSingular,
	        yy : relativeTimeWithPlural
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return lv;

	})));


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Montenegrin [me]
	//! author : Miodrag Nikač <miodrag@restartit.me> : https://github.com/miodragnikac

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var translator = {
	    words: { //Different grammatical cases
	        m: ['jedan minut', 'jednog minuta'],
	        mm: ['minut', 'minuta', 'minuta'],
	        h: ['jedan sat', 'jednog sata'],
	        hh: ['sat', 'sata', 'sati'],
	        dd: ['dan', 'dana', 'dana'],
	        MM: ['mjesec', 'mjeseca', 'mjeseci'],
	        yy: ['godina', 'godine', 'godina']
	    },
	    correctGrammaticalCase: function (number, wordKey) {
	        return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
	    },
	    translate: function (number, withoutSuffix, key) {
	        var wordKey = translator.words[key];
	        if (key.length === 1) {
	            return withoutSuffix ? wordKey[0] : wordKey[1];
	        } else {
	            return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
	        }
	    }
	};

	var me = moment.defineLocale('me', {
	    months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
	    monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
	    monthsParseExact : true,
	    weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split('_'),
	    weekdaysShort: 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
	    weekdaysMin: 'ne_po_ut_sr_če_pe_su'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat: {
	        LT: 'H:mm',
	        LTS : 'H:mm:ss',
	        L: 'DD.MM.YYYY',
	        LL: 'D. MMMM YYYY',
	        LLL: 'D. MMMM YYYY H:mm',
	        LLLL: 'dddd, D. MMMM YYYY H:mm'
	    },
	    calendar: {
	        sameDay: '[danas u] LT',
	        nextDay: '[sjutra u] LT',

	        nextWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[u] [nedjelju] [u] LT';
	                case 3:
	                    return '[u] [srijedu] [u] LT';
	                case 6:
	                    return '[u] [subotu] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[u] dddd [u] LT';
	            }
	        },
	        lastDay  : '[juče u] LT',
	        lastWeek : function () {
	            var lastWeekDays = [
	                '[prošle] [nedjelje] [u] LT',
	                '[prošlog] [ponedjeljka] [u] LT',
	                '[prošlog] [utorka] [u] LT',
	                '[prošle] [srijede] [u] LT',
	                '[prošlog] [četvrtka] [u] LT',
	                '[prošlog] [petka] [u] LT',
	                '[prošle] [subote] [u] LT'
	            ];
	            return lastWeekDays[this.day()];
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'za %s',
	        past   : 'prije %s',
	        s      : 'nekoliko sekundi',
	        m      : translator.translate,
	        mm     : translator.translate,
	        h      : translator.translate,
	        hh     : translator.translate,
	        d      : 'dan',
	        dd     : translator.translate,
	        M      : 'mjesec',
	        MM     : translator.translate,
	        y      : 'godinu',
	        yy     : translator.translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return me;

	})));


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Maori [mi]
	//! author : John Corrigan <robbiecloset@gmail.com> : https://github.com/johnideal

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var mi = moment.defineLocale('mi', {
	    months: 'Kohi-tāte_Hui-tanguru_Poutū-te-rangi_Paenga-whāwhā_Haratua_Pipiri_Hōngoingoi_Here-turi-kōkā_Mahuru_Whiringa-ā-nuku_Whiringa-ā-rangi_Hakihea'.split('_'),
	    monthsShort: 'Kohi_Hui_Pou_Pae_Hara_Pipi_Hōngoi_Here_Mahu_Whi-nu_Whi-ra_Haki'.split('_'),
	    monthsRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
	    monthsStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
	    monthsShortRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
	    monthsShortStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i,
	    weekdays: 'Rātapu_Mane_Tūrei_Wenerei_Tāite_Paraire_Hātarei'.split('_'),
	    weekdaysShort: 'Ta_Ma_Tū_We_Tāi_Pa_Hā'.split('_'),
	    weekdaysMin: 'Ta_Ma_Tū_We_Tāi_Pa_Hā'.split('_'),
	    longDateFormat: {
	        LT: 'HH:mm',
	        LTS: 'HH:mm:ss',
	        L: 'DD/MM/YYYY',
	        LL: 'D MMMM YYYY',
	        LLL: 'D MMMM YYYY [i] HH:mm',
	        LLLL: 'dddd, D MMMM YYYY [i] HH:mm'
	    },
	    calendar: {
	        sameDay: '[i teie mahana, i] LT',
	        nextDay: '[apopo i] LT',
	        nextWeek: 'dddd [i] LT',
	        lastDay: '[inanahi i] LT',
	        lastWeek: 'dddd [whakamutunga i] LT',
	        sameElse: 'L'
	    },
	    relativeTime: {
	        future: 'i roto i %s',
	        past: '%s i mua',
	        s: 'te hēkona ruarua',
	        m: 'he meneti',
	        mm: '%d meneti',
	        h: 'te haora',
	        hh: '%d haora',
	        d: 'he ra',
	        dd: '%d ra',
	        M: 'he marama',
	        MM: '%d marama',
	        y: 'he tau',
	        yy: '%d tau'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}º/,
	    ordinal: '%dº',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return mi;

	})));


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Macedonian [mk]
	//! author : Borislav Mickov : https://github.com/B0k0

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var mk = moment.defineLocale('mk', {
	    months : 'јануари_февруари_март_април_мај_јуни_јули_август_септември_октомври_ноември_декември'.split('_'),
	    monthsShort : 'јан_фев_мар_апр_мај_јун_јул_авг_сеп_окт_ное_дек'.split('_'),
	    weekdays : 'недела_понеделник_вторник_среда_четврток_петок_сабота'.split('_'),
	    weekdaysShort : 'нед_пон_вто_сре_чет_пет_саб'.split('_'),
	    weekdaysMin : 'нe_пo_вт_ср_че_пе_сa'.split('_'),
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'D.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY H:mm',
	        LLLL : 'dddd, D MMMM YYYY H:mm'
	    },
	    calendar : {
	        sameDay : '[Денес во] LT',
	        nextDay : '[Утре во] LT',
	        nextWeek : '[Во] dddd [во] LT',
	        lastDay : '[Вчера во] LT',
	        lastWeek : function () {
	            switch (this.day()) {
	                case 0:
	                case 3:
	                case 6:
	                    return '[Изминатата] dddd [во] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[Изминатиот] dddd [во] LT';
	            }
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'после %s',
	        past : 'пред %s',
	        s : 'неколку секунди',
	        m : 'минута',
	        mm : '%d минути',
	        h : 'час',
	        hh : '%d часа',
	        d : 'ден',
	        dd : '%d дена',
	        M : 'месец',
	        MM : '%d месеци',
	        y : 'година',
	        yy : '%d години'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/,
	    ordinal : function (number) {
	        var lastDigit = number % 10,
	            last2Digits = number % 100;
	        if (number === 0) {
	            return number + '-ев';
	        } else if (last2Digits === 0) {
	            return number + '-ен';
	        } else if (last2Digits > 10 && last2Digits < 20) {
	            return number + '-ти';
	        } else if (lastDigit === 1) {
	            return number + '-ви';
	        } else if (lastDigit === 2) {
	            return number + '-ри';
	        } else if (lastDigit === 7 || lastDigit === 8) {
	            return number + '-ми';
	        } else {
	            return number + '-ти';
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return mk;

	})));


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Malayalam [ml]
	//! author : Floyd Pink : https://github.com/floydpink

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var ml = moment.defineLocale('ml', {
	    months : 'ജനുവരി_ഫെബ്രുവരി_മാർച്ച്_ഏപ്രിൽ_മേയ്_ജൂൺ_ജൂലൈ_ഓഗസ്റ്റ്_സെപ്റ്റംബർ_ഒക്ടോബർ_നവംബർ_ഡിസംബർ'.split('_'),
	    monthsShort : 'ജനു._ഫെബ്രു._മാർ._ഏപ്രി._മേയ്_ജൂൺ_ജൂലൈ._ഓഗ._സെപ്റ്റ._ഒക്ടോ._നവം._ഡിസം.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'ഞായറാഴ്ച_തിങ്കളാഴ്ച_ചൊവ്വാഴ്ച_ബുധനാഴ്ച_വ്യാഴാഴ്ച_വെള്ളിയാഴ്ച_ശനിയാഴ്ച'.split('_'),
	    weekdaysShort : 'ഞായർ_തിങ്കൾ_ചൊവ്വ_ബുധൻ_വ്യാഴം_വെള്ളി_ശനി'.split('_'),
	    weekdaysMin : 'ഞാ_തി_ചൊ_ബു_വ്യാ_വെ_ശ'.split('_'),
	    longDateFormat : {
	        LT : 'A h:mm -നു',
	        LTS : 'A h:mm:ss -നു',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, A h:mm -നു',
	        LLLL : 'dddd, D MMMM YYYY, A h:mm -നു'
	    },
	    calendar : {
	        sameDay : '[ഇന്ന്] LT',
	        nextDay : '[നാളെ] LT',
	        nextWeek : 'dddd, LT',
	        lastDay : '[ഇന്നലെ] LT',
	        lastWeek : '[കഴിഞ്ഞ] dddd, LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s കഴിഞ്ഞ്',
	        past : '%s മുൻപ്',
	        s : 'അൽപ നിമിഷങ്ങൾ',
	        m : 'ഒരു മിനിറ്റ്',
	        mm : '%d മിനിറ്റ്',
	        h : 'ഒരു മണിക്കൂർ',
	        hh : '%d മണിക്കൂർ',
	        d : 'ഒരു ദിവസം',
	        dd : '%d ദിവസം',
	        M : 'ഒരു മാസം',
	        MM : '%d മാസം',
	        y : 'ഒരു വർഷം',
	        yy : '%d വർഷം'
	    },
	    meridiemParse: /രാത്രി|രാവിലെ|ഉച്ച കഴിഞ്ഞ്|വൈകുന്നേരം|രാത്രി/i,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if ((meridiem === 'രാത്രി' && hour >= 4) ||
	                meridiem === 'ഉച്ച കഴിഞ്ഞ്' ||
	                meridiem === 'വൈകുന്നേരം') {
	            return hour + 12;
	        } else {
	            return hour;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return 'രാത്രി';
	        } else if (hour < 12) {
	            return 'രാവിലെ';
	        } else if (hour < 17) {
	            return 'ഉച്ച കഴിഞ്ഞ്';
	        } else if (hour < 20) {
	            return 'വൈകുന്നേരം';
	        } else {
	            return 'രാത്രി';
	        }
	    }
	});

	return ml;

	})));


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Marathi [mr]
	//! author : Harshad Kale : https://github.com/kalehv
	//! author : Vivek Athalye : https://github.com/vnathalye

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var symbolMap = {
	    '1': '१',
	    '2': '२',
	    '3': '३',
	    '4': '४',
	    '5': '५',
	    '6': '६',
	    '7': '७',
	    '8': '८',
	    '9': '९',
	    '0': '०'
	};
	var numberMap = {
	    '१': '1',
	    '२': '2',
	    '३': '3',
	    '४': '4',
	    '५': '5',
	    '६': '6',
	    '७': '7',
	    '८': '8',
	    '९': '9',
	    '०': '0'
	};

	function relativeTimeMr(number, withoutSuffix, string, isFuture)
	{
	    var output = '';
	    if (withoutSuffix) {
	        switch (string) {
	            case 's': output = 'काही सेकंद'; break;
	            case 'm': output = 'एक मिनिट'; break;
	            case 'mm': output = '%d मिनिटे'; break;
	            case 'h': output = 'एक तास'; break;
	            case 'hh': output = '%d तास'; break;
	            case 'd': output = 'एक दिवस'; break;
	            case 'dd': output = '%d दिवस'; break;
	            case 'M': output = 'एक महिना'; break;
	            case 'MM': output = '%d महिने'; break;
	            case 'y': output = 'एक वर्ष'; break;
	            case 'yy': output = '%d वर्षे'; break;
	        }
	    }
	    else {
	        switch (string) {
	            case 's': output = 'काही सेकंदां'; break;
	            case 'm': output = 'एका मिनिटा'; break;
	            case 'mm': output = '%d मिनिटां'; break;
	            case 'h': output = 'एका तासा'; break;
	            case 'hh': output = '%d तासां'; break;
	            case 'd': output = 'एका दिवसा'; break;
	            case 'dd': output = '%d दिवसां'; break;
	            case 'M': output = 'एका महिन्या'; break;
	            case 'MM': output = '%d महिन्यां'; break;
	            case 'y': output = 'एका वर्षा'; break;
	            case 'yy': output = '%d वर्षां'; break;
	        }
	    }
	    return output.replace(/%d/i, number);
	}

	var mr = moment.defineLocale('mr', {
	    months : 'जानेवारी_फेब्रुवारी_मार्च_एप्रिल_मे_जून_जुलै_ऑगस्ट_सप्टेंबर_ऑक्टोबर_नोव्हेंबर_डिसेंबर'.split('_'),
	    monthsShort: 'जाने._फेब्रु._मार्च._एप्रि._मे._जून._जुलै._ऑग._सप्टें._ऑक्टो._नोव्हें._डिसें.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'रविवार_सोमवार_मंगळवार_बुधवार_गुरूवार_शुक्रवार_शनिवार'.split('_'),
	    weekdaysShort : 'रवि_सोम_मंगळ_बुध_गुरू_शुक्र_शनि'.split('_'),
	    weekdaysMin : 'र_सो_मं_बु_गु_शु_श'.split('_'),
	    longDateFormat : {
	        LT : 'A h:mm वाजता',
	        LTS : 'A h:mm:ss वाजता',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, A h:mm वाजता',
	        LLLL : 'dddd, D MMMM YYYY, A h:mm वाजता'
	    },
	    calendar : {
	        sameDay : '[आज] LT',
	        nextDay : '[उद्या] LT',
	        nextWeek : 'dddd, LT',
	        lastDay : '[काल] LT',
	        lastWeek: '[मागील] dddd, LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future: '%sमध्ये',
	        past: '%sपूर्वी',
	        s: relativeTimeMr,
	        m: relativeTimeMr,
	        mm: relativeTimeMr,
	        h: relativeTimeMr,
	        hh: relativeTimeMr,
	        d: relativeTimeMr,
	        dd: relativeTimeMr,
	        M: relativeTimeMr,
	        MM: relativeTimeMr,
	        y: relativeTimeMr,
	        yy: relativeTimeMr
	    },
	    preparse: function (string) {
	        return string.replace(/[१२३४५६७८९०]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    meridiemParse: /रात्री|सकाळी|दुपारी|सायंकाळी/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === 'रात्री') {
	            return hour < 4 ? hour : hour + 12;
	        } else if (meridiem === 'सकाळी') {
	            return hour;
	        } else if (meridiem === 'दुपारी') {
	            return hour >= 10 ? hour : hour + 12;
	        } else if (meridiem === 'सायंकाळी') {
	            return hour + 12;
	        }
	    },
	    meridiem: function (hour, minute, isLower) {
	        if (hour < 4) {
	            return 'रात्री';
	        } else if (hour < 10) {
	            return 'सकाळी';
	        } else if (hour < 17) {
	            return 'दुपारी';
	        } else if (hour < 20) {
	            return 'सायंकाळी';
	        } else {
	            return 'रात्री';
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return mr;

	})));


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Malay [ms]
	//! author : Weldan Jamili : https://github.com/weldan

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var ms = moment.defineLocale('ms', {
	    months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
	    monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
	    weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
	    weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
	    weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
	    longDateFormat : {
	        LT : 'HH.mm',
	        LTS : 'HH.mm.ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY [pukul] HH.mm',
	        LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
	    },
	    meridiemParse: /pagi|tengahari|petang|malam/,
	    meridiemHour: function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === 'pagi') {
	            return hour;
	        } else if (meridiem === 'tengahari') {
	            return hour >= 11 ? hour : hour + 12;
	        } else if (meridiem === 'petang' || meridiem === 'malam') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours < 11) {
	            return 'pagi';
	        } else if (hours < 15) {
	            return 'tengahari';
	        } else if (hours < 19) {
	            return 'petang';
	        } else {
	            return 'malam';
	        }
	    },
	    calendar : {
	        sameDay : '[Hari ini pukul] LT',
	        nextDay : '[Esok pukul] LT',
	        nextWeek : 'dddd [pukul] LT',
	        lastDay : '[Kelmarin pukul] LT',
	        lastWeek : 'dddd [lepas pukul] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'dalam %s',
	        past : '%s yang lepas',
	        s : 'beberapa saat',
	        m : 'seminit',
	        mm : '%d minit',
	        h : 'sejam',
	        hh : '%d jam',
	        d : 'sehari',
	        dd : '%d hari',
	        M : 'sebulan',
	        MM : '%d bulan',
	        y : 'setahun',
	        yy : '%d tahun'
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return ms;

	})));


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Malay [ms-my]
	//! note : DEPRECATED, the correct one is [ms]
	//! author : Weldan Jamili : https://github.com/weldan

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var msMy = moment.defineLocale('ms-my', {
	    months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
	    monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
	    weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
	    weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
	    weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
	    longDateFormat : {
	        LT : 'HH.mm',
	        LTS : 'HH.mm.ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY [pukul] HH.mm',
	        LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
	    },
	    meridiemParse: /pagi|tengahari|petang|malam/,
	    meridiemHour: function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === 'pagi') {
	            return hour;
	        } else if (meridiem === 'tengahari') {
	            return hour >= 11 ? hour : hour + 12;
	        } else if (meridiem === 'petang' || meridiem === 'malam') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours < 11) {
	            return 'pagi';
	        } else if (hours < 15) {
	            return 'tengahari';
	        } else if (hours < 19) {
	            return 'petang';
	        } else {
	            return 'malam';
	        }
	    },
	    calendar : {
	        sameDay : '[Hari ini pukul] LT',
	        nextDay : '[Esok pukul] LT',
	        nextWeek : 'dddd [pukul] LT',
	        lastDay : '[Kelmarin pukul] LT',
	        lastWeek : 'dddd [lepas pukul] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'dalam %s',
	        past : '%s yang lepas',
	        s : 'beberapa saat',
	        m : 'seminit',
	        mm : '%d minit',
	        h : 'sejam',
	        hh : '%d jam',
	        d : 'sehari',
	        dd : '%d hari',
	        M : 'sebulan',
	        MM : '%d bulan',
	        y : 'setahun',
	        yy : '%d tahun'
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return msMy;

	})));


/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Burmese [my]
	//! author : Squar team, mysquar.com
	//! author : David Rossellat : https://github.com/gholadr
	//! author : Tin Aung Lin : https://github.com/thanyawzinmin

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var symbolMap = {
	    '1': '၁',
	    '2': '၂',
	    '3': '၃',
	    '4': '၄',
	    '5': '၅',
	    '6': '၆',
	    '7': '၇',
	    '8': '၈',
	    '9': '၉',
	    '0': '၀'
	};
	var numberMap = {
	    '၁': '1',
	    '၂': '2',
	    '၃': '3',
	    '၄': '4',
	    '၅': '5',
	    '၆': '6',
	    '၇': '7',
	    '၈': '8',
	    '၉': '9',
	    '၀': '0'
	};

	var my = moment.defineLocale('my', {
	    months: 'ဇန်နဝါရီ_ဖေဖော်ဝါရီ_မတ်_ဧပြီ_မေ_ဇွန်_ဇူလိုင်_သြဂုတ်_စက်တင်ဘာ_အောက်တိုဘာ_နိုဝင်ဘာ_ဒီဇင်ဘာ'.split('_'),
	    monthsShort: 'ဇန်_ဖေ_မတ်_ပြီ_မေ_ဇွန်_လိုင်_သြ_စက်_အောက်_နို_ဒီ'.split('_'),
	    weekdays: 'တနင်္ဂနွေ_တနင်္လာ_အင်္ဂါ_ဗုဒ္ဓဟူး_ကြာသပတေး_သောကြာ_စနေ'.split('_'),
	    weekdaysShort: 'နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ'.split('_'),
	    weekdaysMin: 'နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ'.split('_'),

	    longDateFormat: {
	        LT: 'HH:mm',
	        LTS: 'HH:mm:ss',
	        L: 'DD/MM/YYYY',
	        LL: 'D MMMM YYYY',
	        LLL: 'D MMMM YYYY HH:mm',
	        LLLL: 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar: {
	        sameDay: '[ယနေ.] LT [မှာ]',
	        nextDay: '[မနက်ဖြန်] LT [မှာ]',
	        nextWeek: 'dddd LT [မှာ]',
	        lastDay: '[မနေ.က] LT [မှာ]',
	        lastWeek: '[ပြီးခဲ့သော] dddd LT [မှာ]',
	        sameElse: 'L'
	    },
	    relativeTime: {
	        future: 'လာမည့် %s မှာ',
	        past: 'လွန်ခဲ့သော %s က',
	        s: 'စက္ကန်.အနည်းငယ်',
	        m: 'တစ်မိနစ်',
	        mm: '%d မိနစ်',
	        h: 'တစ်နာရီ',
	        hh: '%d နာရီ',
	        d: 'တစ်ရက်',
	        dd: '%d ရက်',
	        M: 'တစ်လ',
	        MM: '%d လ',
	        y: 'တစ်နှစ်',
	        yy: '%d နှစ်'
	    },
	    preparse: function (string) {
	        return string.replace(/[၁၂၃၄၅၆၇၈၉၀]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    week: {
	        dow: 1, // Monday is the first day of the week.
	        doy: 4 // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return my;

	})));


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Norwegian Bokmål [nb]
	//! authors : Espen Hovlandsdal : https://github.com/rexxars
	//!           Sigurd Gartmann : https://github.com/sigurdga

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var nb = moment.defineLocale('nb', {
	    months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
	    monthsShort : 'jan._feb._mars_april_mai_juni_juli_aug._sep._okt._nov._des.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag'.split('_'),
	    weekdaysShort : 'sø._ma._ti._on._to._fr._lø.'.split('_'),
	    weekdaysMin : 'sø_ma_ti_on_to_fr_lø'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY [kl.] HH:mm',
	        LLLL : 'dddd D. MMMM YYYY [kl.] HH:mm'
	    },
	    calendar : {
	        sameDay: '[i dag kl.] LT',
	        nextDay: '[i morgen kl.] LT',
	        nextWeek: 'dddd [kl.] LT',
	        lastDay: '[i går kl.] LT',
	        lastWeek: '[forrige] dddd [kl.] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'om %s',
	        past : '%s siden',
	        s : 'noen sekunder',
	        m : 'ett minutt',
	        mm : '%d minutter',
	        h : 'en time',
	        hh : '%d timer',
	        d : 'en dag',
	        dd : '%d dager',
	        M : 'en måned',
	        MM : '%d måneder',
	        y : 'ett år',
	        yy : '%d år'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return nb;

	})));


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Nepalese [ne]
	//! author : suvash : https://github.com/suvash

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var symbolMap = {
	    '1': '१',
	    '2': '२',
	    '3': '३',
	    '4': '४',
	    '5': '५',
	    '6': '६',
	    '7': '७',
	    '8': '८',
	    '9': '९',
	    '0': '०'
	};
	var numberMap = {
	    '१': '1',
	    '२': '2',
	    '३': '3',
	    '४': '4',
	    '५': '5',
	    '६': '6',
	    '७': '7',
	    '८': '8',
	    '९': '9',
	    '०': '0'
	};

	var ne = moment.defineLocale('ne', {
	    months : 'जनवरी_फेब्रुवरी_मार्च_अप्रिल_मई_जुन_जुलाई_अगष्ट_सेप्टेम्बर_अक्टोबर_नोभेम्बर_डिसेम्बर'.split('_'),
	    monthsShort : 'जन._फेब्रु._मार्च_अप्रि._मई_जुन_जुलाई._अग._सेप्ट._अक्टो._नोभे._डिसे.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'आइतबार_सोमबार_मङ्गलबार_बुधबार_बिहिबार_शुक्रबार_शनिबार'.split('_'),
	    weekdaysShort : 'आइत._सोम._मङ्गल._बुध._बिहि._शुक्र._शनि.'.split('_'),
	    weekdaysMin : 'आ._सो._मं._बु._बि._शु._श.'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'Aको h:mm बजे',
	        LTS : 'Aको h:mm:ss बजे',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, Aको h:mm बजे',
	        LLLL : 'dddd, D MMMM YYYY, Aको h:mm बजे'
	    },
	    preparse: function (string) {
	        return string.replace(/[१२३४५६७८९०]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    meridiemParse: /राति|बिहान|दिउँसो|साँझ/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === 'राति') {
	            return hour < 4 ? hour : hour + 12;
	        } else if (meridiem === 'बिहान') {
	            return hour;
	        } else if (meridiem === 'दिउँसो') {
	            return hour >= 10 ? hour : hour + 12;
	        } else if (meridiem === 'साँझ') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 3) {
	            return 'राति';
	        } else if (hour < 12) {
	            return 'बिहान';
	        } else if (hour < 16) {
	            return 'दिउँसो';
	        } else if (hour < 20) {
	            return 'साँझ';
	        } else {
	            return 'राति';
	        }
	    },
	    calendar : {
	        sameDay : '[आज] LT',
	        nextDay : '[भोलि] LT',
	        nextWeek : '[आउँदो] dddd[,] LT',
	        lastDay : '[हिजो] LT',
	        lastWeek : '[गएको] dddd[,] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%sमा',
	        past : '%s अगाडि',
	        s : 'केही क्षण',
	        m : 'एक मिनेट',
	        mm : '%d मिनेट',
	        h : 'एक घण्टा',
	        hh : '%d घण्टा',
	        d : 'एक दिन',
	        dd : '%d दिन',
	        M : 'एक महिना',
	        MM : '%d महिना',
	        y : 'एक बर्ष',
	        yy : '%d बर्ष'
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return ne;

	})));


/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Dutch [nl]
	//! author : Joris Röling : https://github.com/jorisroling
	//! author : Jacob Middag : https://github.com/middagj

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_');
	var monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');

	var monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
	var monthsRegex = /^(januari|februari|maart|april|mei|april|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;

	var nl = moment.defineLocale('nl', {
	    months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
	    monthsShort : function (m, format) {
	        if (!m) {
	            return monthsShortWithDots;
	        } else if (/-MMM-/.test(format)) {
	            return monthsShortWithoutDots[m.month()];
	        } else {
	            return monthsShortWithDots[m.month()];
	        }
	    },

	    monthsRegex: monthsRegex,
	    monthsShortRegex: monthsRegex,
	    monthsStrictRegex: /^(januari|februari|maart|mei|ju[nl]i|april|augustus|september|oktober|november|december)/i,
	    monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,

	    monthsParse : monthsParse,
	    longMonthsParse : monthsParse,
	    shortMonthsParse : monthsParse,

	    weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
	    weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),
	    weekdaysMin : 'Zo_Ma_Di_Wo_Do_Vr_Za'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD-MM-YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[vandaag om] LT',
	        nextDay: '[morgen om] LT',
	        nextWeek: 'dddd [om] LT',
	        lastDay: '[gisteren om] LT',
	        lastWeek: '[afgelopen] dddd [om] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'over %s',
	        past : '%s geleden',
	        s : 'een paar seconden',
	        m : 'één minuut',
	        mm : '%d minuten',
	        h : 'één uur',
	        hh : '%d uur',
	        d : 'één dag',
	        dd : '%d dagen',
	        M : 'één maand',
	        MM : '%d maanden',
	        y : 'één jaar',
	        yy : '%d jaar'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
	    ordinal : function (number) {
	        return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return nl;

	})));


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Dutch (Belgium) [nl-be]
	//! author : Joris Röling : https://github.com/jorisroling
	//! author : Jacob Middag : https://github.com/middagj

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_');
	var monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');

	var monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
	var monthsRegex = /^(januari|februari|maart|april|mei|april|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;

	var nlBe = moment.defineLocale('nl-be', {
	    months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
	    monthsShort : function (m, format) {
	        if (!m) {
	            return monthsShortWithDots;
	        } else if (/-MMM-/.test(format)) {
	            return monthsShortWithoutDots[m.month()];
	        } else {
	            return monthsShortWithDots[m.month()];
	        }
	    },

	    monthsRegex: monthsRegex,
	    monthsShortRegex: monthsRegex,
	    monthsStrictRegex: /^(januari|februari|maart|mei|ju[nl]i|april|augustus|september|oktober|november|december)/i,
	    monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,

	    monthsParse : monthsParse,
	    longMonthsParse : monthsParse,
	    shortMonthsParse : monthsParse,

	    weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
	    weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),
	    weekdaysMin : 'Zo_Ma_Di_Wo_Do_Vr_Za'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[vandaag om] LT',
	        nextDay: '[morgen om] LT',
	        nextWeek: 'dddd [om] LT',
	        lastDay: '[gisteren om] LT',
	        lastWeek: '[afgelopen] dddd [om] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'over %s',
	        past : '%s geleden',
	        s : 'een paar seconden',
	        m : 'één minuut',
	        mm : '%d minuten',
	        h : 'één uur',
	        hh : '%d uur',
	        d : 'één dag',
	        dd : '%d dagen',
	        M : 'één maand',
	        MM : '%d maanden',
	        y : 'één jaar',
	        yy : '%d jaar'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
	    ordinal : function (number) {
	        return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return nlBe;

	})));


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Nynorsk [nn]
	//! author : https://github.com/mechuwind

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var nn = moment.defineLocale('nn', {
	    months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
	    monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
	    weekdays : 'sundag_måndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),
	    weekdaysShort : 'sun_mån_tys_ons_tor_fre_lau'.split('_'),
	    weekdaysMin : 'su_må_ty_on_to_fr_lø'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY [kl.] H:mm',
	        LLLL : 'dddd D. MMMM YYYY [kl.] HH:mm'
	    },
	    calendar : {
	        sameDay: '[I dag klokka] LT',
	        nextDay: '[I morgon klokka] LT',
	        nextWeek: 'dddd [klokka] LT',
	        lastDay: '[I går klokka] LT',
	        lastWeek: '[Føregåande] dddd [klokka] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'om %s',
	        past : '%s sidan',
	        s : 'nokre sekund',
	        m : 'eit minutt',
	        mm : '%d minutt',
	        h : 'ein time',
	        hh : '%d timar',
	        d : 'ein dag',
	        dd : '%d dagar',
	        M : 'ein månad',
	        MM : '%d månader',
	        y : 'eit år',
	        yy : '%d år'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return nn;

	})));


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Punjabi (India) [pa-in]
	//! author : Harpreet Singh : https://github.com/harpreetkhalsagtbit

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var symbolMap = {
	    '1': '੧',
	    '2': '੨',
	    '3': '੩',
	    '4': '੪',
	    '5': '੫',
	    '6': '੬',
	    '7': '੭',
	    '8': '੮',
	    '9': '੯',
	    '0': '੦'
	};
	var numberMap = {
	    '੧': '1',
	    '੨': '2',
	    '੩': '3',
	    '੪': '4',
	    '੫': '5',
	    '੬': '6',
	    '੭': '7',
	    '੮': '8',
	    '੯': '9',
	    '੦': '0'
	};

	var paIn = moment.defineLocale('pa-in', {
	    // There are months name as per Nanakshahi Calender but they are not used as rigidly in modern Punjabi.
	    months : 'ਜਨਵਰੀ_ਫ਼ਰਵਰੀ_ਮਾਰਚ_ਅਪ੍ਰੈਲ_ਮਈ_ਜੂਨ_ਜੁਲਾਈ_ਅਗਸਤ_ਸਤੰਬਰ_ਅਕਤੂਬਰ_ਨਵੰਬਰ_ਦਸੰਬਰ'.split('_'),
	    monthsShort : 'ਜਨਵਰੀ_ਫ਼ਰਵਰੀ_ਮਾਰਚ_ਅਪ੍ਰੈਲ_ਮਈ_ਜੂਨ_ਜੁਲਾਈ_ਅਗਸਤ_ਸਤੰਬਰ_ਅਕਤੂਬਰ_ਨਵੰਬਰ_ਦਸੰਬਰ'.split('_'),
	    weekdays : 'ਐਤਵਾਰ_ਸੋਮਵਾਰ_ਮੰਗਲਵਾਰ_ਬੁਧਵਾਰ_ਵੀਰਵਾਰ_ਸ਼ੁੱਕਰਵਾਰ_ਸ਼ਨੀਚਰਵਾਰ'.split('_'),
	    weekdaysShort : 'ਐਤ_ਸੋਮ_ਮੰਗਲ_ਬੁਧ_ਵੀਰ_ਸ਼ੁਕਰ_ਸ਼ਨੀ'.split('_'),
	    weekdaysMin : 'ਐਤ_ਸੋਮ_ਮੰਗਲ_ਬੁਧ_ਵੀਰ_ਸ਼ੁਕਰ_ਸ਼ਨੀ'.split('_'),
	    longDateFormat : {
	        LT : 'A h:mm ਵਜੇ',
	        LTS : 'A h:mm:ss ਵਜੇ',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, A h:mm ਵਜੇ',
	        LLLL : 'dddd, D MMMM YYYY, A h:mm ਵਜੇ'
	    },
	    calendar : {
	        sameDay : '[ਅਜ] LT',
	        nextDay : '[ਕਲ] LT',
	        nextWeek : 'dddd, LT',
	        lastDay : '[ਕਲ] LT',
	        lastWeek : '[ਪਿਛਲੇ] dddd, LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s ਵਿੱਚ',
	        past : '%s ਪਿਛਲੇ',
	        s : 'ਕੁਝ ਸਕਿੰਟ',
	        m : 'ਇਕ ਮਿੰਟ',
	        mm : '%d ਮਿੰਟ',
	        h : 'ਇੱਕ ਘੰਟਾ',
	        hh : '%d ਘੰਟੇ',
	        d : 'ਇੱਕ ਦਿਨ',
	        dd : '%d ਦਿਨ',
	        M : 'ਇੱਕ ਮਹੀਨਾ',
	        MM : '%d ਮਹੀਨੇ',
	        y : 'ਇੱਕ ਸਾਲ',
	        yy : '%d ਸਾਲ'
	    },
	    preparse: function (string) {
	        return string.replace(/[੧੨੩੪੫੬੭੮੯੦]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    // Punjabi notation for meridiems are quite fuzzy in practice. While there exists
	    // a rigid notion of a 'Pahar' it is not used as rigidly in modern Punjabi.
	    meridiemParse: /ਰਾਤ|ਸਵੇਰ|ਦੁਪਹਿਰ|ਸ਼ਾਮ/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === 'ਰਾਤ') {
	            return hour < 4 ? hour : hour + 12;
	        } else if (meridiem === 'ਸਵੇਰ') {
	            return hour;
	        } else if (meridiem === 'ਦੁਪਹਿਰ') {
	            return hour >= 10 ? hour : hour + 12;
	        } else if (meridiem === 'ਸ਼ਾਮ') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return 'ਰਾਤ';
	        } else if (hour < 10) {
	            return 'ਸਵੇਰ';
	        } else if (hour < 17) {
	            return 'ਦੁਪਹਿਰ';
	        } else if (hour < 20) {
	            return 'ਸ਼ਾਮ';
	        } else {
	            return 'ਰਾਤ';
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return paIn;

	})));


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Polish [pl]
	//! author : Rafal Hirsz : https://github.com/evoL

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var monthsNominative = 'styczeń_luty_marzec_kwiecień_maj_czerwiec_lipiec_sierpień_wrzesień_październik_listopad_grudzień'.split('_');
	var monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_września_października_listopada_grudnia'.split('_');
	function plural(n) {
	    return (n % 10 < 5) && (n % 10 > 1) && ((~~(n / 10) % 10) !== 1);
	}
	function translate(number, withoutSuffix, key) {
	    var result = number + ' ';
	    switch (key) {
	        case 'm':
	            return withoutSuffix ? 'minuta' : 'minutę';
	        case 'mm':
	            return result + (plural(number) ? 'minuty' : 'minut');
	        case 'h':
	            return withoutSuffix  ? 'godzina'  : 'godzinę';
	        case 'hh':
	            return result + (plural(number) ? 'godziny' : 'godzin');
	        case 'MM':
	            return result + (plural(number) ? 'miesiące' : 'miesięcy');
	        case 'yy':
	            return result + (plural(number) ? 'lata' : 'lat');
	    }
	}

	var pl = moment.defineLocale('pl', {
	    months : function (momentToFormat, format) {
	        if (!momentToFormat) {
	            return monthsNominative;
	        } else if (format === '') {
	            // Hack: if format empty we know this is used to generate
	            // RegExp by moment. Give then back both valid forms of months
	            // in RegExp ready format.
	            return '(' + monthsSubjective[momentToFormat.month()] + '|' + monthsNominative[momentToFormat.month()] + ')';
	        } else if (/D MMMM/.test(format)) {
	            return monthsSubjective[momentToFormat.month()];
	        } else {
	            return monthsNominative[momentToFormat.month()];
	        }
	    },
	    monthsShort : 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_paź_lis_gru'.split('_'),
	    weekdays : 'niedziela_poniedziałek_wtorek_środa_czwartek_piątek_sobota'.split('_'),
	    weekdaysShort : 'ndz_pon_wt_śr_czw_pt_sob'.split('_'),
	    weekdaysMin : 'Nd_Pn_Wt_Śr_Cz_Pt_So'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[Dziś o] LT',
	        nextDay: '[Jutro o] LT',
	        nextWeek: '[W] dddd [o] LT',
	        lastDay: '[Wczoraj o] LT',
	        lastWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[W zeszłą niedzielę o] LT';
	                case 3:
	                    return '[W zeszłą środę o] LT';
	                case 6:
	                    return '[W zeszłą sobotę o] LT';
	                default:
	                    return '[W zeszły] dddd [o] LT';
	            }
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'za %s',
	        past : '%s temu',
	        s : 'kilka sekund',
	        m : translate,
	        mm : translate,
	        h : translate,
	        hh : translate,
	        d : '1 dzień',
	        dd : '%d dni',
	        M : 'miesiąc',
	        MM : translate,
	        y : 'rok',
	        yy : translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return pl;

	})));


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Portuguese [pt]
	//! author : Jefferson : https://github.com/jalex79

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var pt = moment.defineLocale('pt', {
	    months : 'Janeiro_Fevereiro_Março_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
	    monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
	    weekdays : 'Domingo_Segunda-Feira_Terça-Feira_Quarta-Feira_Quinta-Feira_Sexta-Feira_Sábado'.split('_'),
	    weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sáb'.split('_'),
	    weekdaysMin : 'Do_2ª_3ª_4ª_5ª_6ª_Sá'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D [de] MMMM [de] YYYY',
	        LLL : 'D [de] MMMM [de] YYYY HH:mm',
	        LLLL : 'dddd, D [de] MMMM [de] YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[Hoje às] LT',
	        nextDay: '[Amanhã às] LT',
	        nextWeek: 'dddd [às] LT',
	        lastDay: '[Ontem às] LT',
	        lastWeek: function () {
	            return (this.day() === 0 || this.day() === 6) ?
	                '[Último] dddd [às] LT' : // Saturday + Sunday
	                '[Última] dddd [às] LT'; // Monday - Friday
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'em %s',
	        past : 'há %s',
	        s : 'segundos',
	        m : 'um minuto',
	        mm : '%d minutos',
	        h : 'uma hora',
	        hh : '%d horas',
	        d : 'um dia',
	        dd : '%d dias',
	        M : 'um mês',
	        MM : '%d meses',
	        y : 'um ano',
	        yy : '%d anos'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}º/,
	    ordinal : '%dº',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return pt;

	})));


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Portuguese (Brazil) [pt-br]
	//! author : Caio Ribeiro Pereira : https://github.com/caio-ribeiro-pereira

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var ptBr = moment.defineLocale('pt-br', {
	    months : 'Janeiro_Fevereiro_Março_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
	    monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
	    weekdays : 'Domingo_Segunda-feira_Terça-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sábado'.split('_'),
	    weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sáb'.split('_'),
	    weekdaysMin : 'Do_2ª_3ª_4ª_5ª_6ª_Sá'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D [de] MMMM [de] YYYY',
	        LLL : 'D [de] MMMM [de] YYYY [às] HH:mm',
	        LLLL : 'dddd, D [de] MMMM [de] YYYY [às] HH:mm'
	    },
	    calendar : {
	        sameDay: '[Hoje às] LT',
	        nextDay: '[Amanhã às] LT',
	        nextWeek: 'dddd [às] LT',
	        lastDay: '[Ontem às] LT',
	        lastWeek: function () {
	            return (this.day() === 0 || this.day() === 6) ?
	                '[Último] dddd [às] LT' : // Saturday + Sunday
	                '[Última] dddd [às] LT'; // Monday - Friday
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'em %s',
	        past : '%s atrás',
	        s : 'poucos segundos',
	        m : 'um minuto',
	        mm : '%d minutos',
	        h : 'uma hora',
	        hh : '%d horas',
	        d : 'um dia',
	        dd : '%d dias',
	        M : 'um mês',
	        MM : '%d meses',
	        y : 'um ano',
	        yy : '%d anos'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}º/,
	    ordinal : '%dº'
	});

	return ptBr;

	})));


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Romanian [ro]
	//! author : Vlad Gurdiga : https://github.com/gurdiga
	//! author : Valentin Agachi : https://github.com/avaly

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	function relativeTimeWithPlural(number, withoutSuffix, key) {
	    var format = {
	            'mm': 'minute',
	            'hh': 'ore',
	            'dd': 'zile',
	            'MM': 'luni',
	            'yy': 'ani'
	        },
	        separator = ' ';
	    if (number % 100 >= 20 || (number >= 100 && number % 100 === 0)) {
	        separator = ' de ';
	    }
	    return number + separator + format[key];
	}

	var ro = moment.defineLocale('ro', {
	    months : 'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split('_'),
	    monthsShort : 'ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split('_'),
	    monthsParseExact: true,
	    weekdays : 'duminică_luni_marți_miercuri_joi_vineri_sâmbătă'.split('_'),
	    weekdaysShort : 'Dum_Lun_Mar_Mie_Joi_Vin_Sâm'.split('_'),
	    weekdaysMin : 'Du_Lu_Ma_Mi_Jo_Vi_Sâ'.split('_'),
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY H:mm',
	        LLLL : 'dddd, D MMMM YYYY H:mm'
	    },
	    calendar : {
	        sameDay: '[azi la] LT',
	        nextDay: '[mâine la] LT',
	        nextWeek: 'dddd [la] LT',
	        lastDay: '[ieri la] LT',
	        lastWeek: '[fosta] dddd [la] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'peste %s',
	        past : '%s în urmă',
	        s : 'câteva secunde',
	        m : 'un minut',
	        mm : relativeTimeWithPlural,
	        h : 'o oră',
	        hh : relativeTimeWithPlural,
	        d : 'o zi',
	        dd : relativeTimeWithPlural,
	        M : 'o lună',
	        MM : relativeTimeWithPlural,
	        y : 'un an',
	        yy : relativeTimeWithPlural
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return ro;

	})));


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Russian [ru]
	//! author : Viktorminator : https://github.com/Viktorminator
	//! Author : Menelion Elensúle : https://github.com/Oire
	//! author : Коренберг Марк : https://github.com/socketpair

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	function plural(word, num) {
	    var forms = word.split('_');
	    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
	}
	function relativeTimeWithPlural(number, withoutSuffix, key) {
	    var format = {
	        'mm': withoutSuffix ? 'минута_минуты_минут' : 'минуту_минуты_минут',
	        'hh': 'час_часа_часов',
	        'dd': 'день_дня_дней',
	        'MM': 'месяц_месяца_месяцев',
	        'yy': 'год_года_лет'
	    };
	    if (key === 'm') {
	        return withoutSuffix ? 'минута' : 'минуту';
	    }
	    else {
	        return number + ' ' + plural(format[key], +number);
	    }
	}
	var monthsParse = [/^янв/i, /^фев/i, /^мар/i, /^апр/i, /^ма[йя]/i, /^июн/i, /^июл/i, /^авг/i, /^сен/i, /^окт/i, /^ноя/i, /^дек/i];

	// http://new.gramota.ru/spravka/rules/139-prop : § 103
	// Сокращения месяцев: http://new.gramota.ru/spravka/buro/search-answer?s=242637
	// CLDR data:          http://www.unicode.org/cldr/charts/28/summary/ru.html#1753
	var ru = moment.defineLocale('ru', {
	    months : {
	        format: 'января_февраля_марта_апреля_мая_июня_июля_августа_сентября_октября_ноября_декабря'.split('_'),
	        standalone: 'январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь'.split('_')
	    },
	    monthsShort : {
	        // по CLDR именно "июл." и "июн.", но какой смысл менять букву на точку ?
	        format: 'янв._февр._мар._апр._мая_июня_июля_авг._сент._окт._нояб._дек.'.split('_'),
	        standalone: 'янв._февр._март_апр._май_июнь_июль_авг._сент._окт._нояб._дек.'.split('_')
	    },
	    weekdays : {
	        standalone: 'воскресенье_понедельник_вторник_среда_четверг_пятница_суббота'.split('_'),
	        format: 'воскресенье_понедельник_вторник_среду_четверг_пятницу_субботу'.split('_'),
	        isFormat: /\[ ?[Вв] ?(?:прошлую|следующую|эту)? ?\] ?dddd/
	    },
	    weekdaysShort : 'вс_пн_вт_ср_чт_пт_сб'.split('_'),
	    weekdaysMin : 'вс_пн_вт_ср_чт_пт_сб'.split('_'),
	    monthsParse : monthsParse,
	    longMonthsParse : monthsParse,
	    shortMonthsParse : monthsParse,

	    // полные названия с падежами, по три буквы, для некоторых, по 4 буквы, сокращения с точкой и без точки
	    monthsRegex: /^(январ[ья]|янв\.?|феврал[ья]|февр?\.?|марта?|мар\.?|апрел[ья]|апр\.?|ма[йя]|июн[ья]|июн\.?|июл[ья]|июл\.?|августа?|авг\.?|сентябр[ья]|сент?\.?|октябр[ья]|окт\.?|ноябр[ья]|нояб?\.?|декабр[ья]|дек\.?)/i,

	    // копия предыдущего
	    monthsShortRegex: /^(январ[ья]|янв\.?|феврал[ья]|февр?\.?|марта?|мар\.?|апрел[ья]|апр\.?|ма[йя]|июн[ья]|июн\.?|июл[ья]|июл\.?|августа?|авг\.?|сентябр[ья]|сент?\.?|октябр[ья]|окт\.?|ноябр[ья]|нояб?\.?|декабр[ья]|дек\.?)/i,

	    // полные названия с падежами
	    monthsStrictRegex: /^(январ[яь]|феврал[яь]|марта?|апрел[яь]|ма[яй]|июн[яь]|июл[яь]|августа?|сентябр[яь]|октябр[яь]|ноябр[яь]|декабр[яь])/i,

	    // Выражение, которое соотвествует только сокращённым формам
	    monthsShortStrictRegex: /^(янв\.|февр?\.|мар[т.]|апр\.|ма[яй]|июн[ья.]|июл[ья.]|авг\.|сент?\.|окт\.|нояб?\.|дек\.)/i,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY г.',
	        LLL : 'D MMMM YYYY г., HH:mm',
	        LLLL : 'dddd, D MMMM YYYY г., HH:mm'
	    },
	    calendar : {
	        sameDay: '[Сегодня в] LT',
	        nextDay: '[Завтра в] LT',
	        lastDay: '[Вчера в] LT',
	        nextWeek: function (now) {
	            if (now.week() !== this.week()) {
	                switch (this.day()) {
	                    case 0:
	                        return '[В следующее] dddd [в] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                        return '[В следующий] dddd [в] LT';
	                    case 3:
	                    case 5:
	                    case 6:
	                        return '[В следующую] dddd [в] LT';
	                }
	            } else {
	                if (this.day() === 2) {
	                    return '[Во] dddd [в] LT';
	                } else {
	                    return '[В] dddd [в] LT';
	                }
	            }
	        },
	        lastWeek: function (now) {
	            if (now.week() !== this.week()) {
	                switch (this.day()) {
	                    case 0:
	                        return '[В прошлое] dddd [в] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                        return '[В прошлый] dddd [в] LT';
	                    case 3:
	                    case 5:
	                    case 6:
	                        return '[В прошлую] dddd [в] LT';
	                }
	            } else {
	                if (this.day() === 2) {
	                    return '[Во] dddd [в] LT';
	                } else {
	                    return '[В] dddd [в] LT';
	                }
	            }
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'через %s',
	        past : '%s назад',
	        s : 'несколько секунд',
	        m : relativeTimeWithPlural,
	        mm : relativeTimeWithPlural,
	        h : 'час',
	        hh : relativeTimeWithPlural,
	        d : 'день',
	        dd : relativeTimeWithPlural,
	        M : 'месяц',
	        MM : relativeTimeWithPlural,
	        y : 'год',
	        yy : relativeTimeWithPlural
	    },
	    meridiemParse: /ночи|утра|дня|вечера/i,
	    isPM : function (input) {
	        return /^(дня|вечера)$/.test(input);
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return 'ночи';
	        } else if (hour < 12) {
	            return 'утра';
	        } else if (hour < 17) {
	            return 'дня';
	        } else {
	            return 'вечера';
	        }
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}-(й|го|я)/,
	    ordinal: function (number, period) {
	        switch (period) {
	            case 'M':
	            case 'd':
	            case 'DDD':
	                return number + '-й';
	            case 'D':
	                return number + '-го';
	            case 'w':
	            case 'W':
	                return number + '-я';
	            default:
	                return number;
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return ru;

	})));


/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Sindhi [sd]
	//! author : Narain Sagar : https://github.com/narainsagar

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var months = [
	    'جنوري',
	    'فيبروري',
	    'مارچ',
	    'اپريل',
	    'مئي',
	    'جون',
	    'جولاءِ',
	    'آگسٽ',
	    'سيپٽمبر',
	    'آڪٽوبر',
	    'نومبر',
	    'ڊسمبر'
	];
	var days = [
	    'آچر',
	    'سومر',
	    'اڱارو',
	    'اربع',
	    'خميس',
	    'جمع',
	    'ڇنڇر'
	];

	var sd = moment.defineLocale('sd', {
	    months : months,
	    monthsShort : months,
	    weekdays : days,
	    weekdaysShort : days,
	    weekdaysMin : days,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd، D MMMM YYYY HH:mm'
	    },
	    meridiemParse: /صبح|شام/,
	    isPM : function (input) {
	        return 'شام' === input;
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 12) {
	            return 'صبح';
	        }
	        return 'شام';
	    },
	    calendar : {
	        sameDay : '[اڄ] LT',
	        nextDay : '[سڀاڻي] LT',
	        nextWeek : 'dddd [اڳين هفتي تي] LT',
	        lastDay : '[ڪالهه] LT',
	        lastWeek : '[گزريل هفتي] dddd [تي] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s پوء',
	        past : '%s اڳ',
	        s : 'چند سيڪنڊ',
	        m : 'هڪ منٽ',
	        mm : '%d منٽ',
	        h : 'هڪ ڪلاڪ',
	        hh : '%d ڪلاڪ',
	        d : 'هڪ ڏينهن',
	        dd : '%d ڏينهن',
	        M : 'هڪ مهينو',
	        MM : '%d مهينا',
	        y : 'هڪ سال',
	        yy : '%d سال'
	    },
	    preparse: function (string) {
	        return string.replace(/،/g, ',');
	    },
	    postformat: function (string) {
	        return string.replace(/,/g, '،');
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return sd;

	})));


/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Northern Sami [se]
	//! authors : Bård Rolstad Henriksen : https://github.com/karamell

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';



	var se = moment.defineLocale('se', {
	    months : 'ođđajagemánnu_guovvamánnu_njukčamánnu_cuoŋománnu_miessemánnu_geassemánnu_suoidnemánnu_borgemánnu_čakčamánnu_golggotmánnu_skábmamánnu_juovlamánnu'.split('_'),
	    monthsShort : 'ođđj_guov_njuk_cuo_mies_geas_suoi_borg_čakč_golg_skáb_juov'.split('_'),
	    weekdays : 'sotnabeaivi_vuossárga_maŋŋebárga_gaskavahkku_duorastat_bearjadat_lávvardat'.split('_'),
	    weekdaysShort : 'sotn_vuos_maŋ_gask_duor_bear_láv'.split('_'),
	    weekdaysMin : 's_v_m_g_d_b_L'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'MMMM D. [b.] YYYY',
	        LLL : 'MMMM D. [b.] YYYY [ti.] HH:mm',
	        LLLL : 'dddd, MMMM D. [b.] YYYY [ti.] HH:mm'
	    },
	    calendar : {
	        sameDay: '[otne ti] LT',
	        nextDay: '[ihttin ti] LT',
	        nextWeek: 'dddd [ti] LT',
	        lastDay: '[ikte ti] LT',
	        lastWeek: '[ovddit] dddd [ti] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : '%s geažes',
	        past : 'maŋit %s',
	        s : 'moadde sekunddat',
	        m : 'okta minuhta',
	        mm : '%d minuhtat',
	        h : 'okta diimmu',
	        hh : '%d diimmut',
	        d : 'okta beaivi',
	        dd : '%d beaivvit',
	        M : 'okta mánnu',
	        MM : '%d mánut',
	        y : 'okta jahki',
	        yy : '%d jagit'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return se;

	})));


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Sinhalese [si]
	//! author : Sampath Sitinamaluwa : https://github.com/sampathsris

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	/*jshint -W100*/
	var si = moment.defineLocale('si', {
	    months : 'ජනවාරි_පෙබරවාරි_මාර්තු_අප්‍රේල්_මැයි_ජූනි_ජූලි_අගෝස්තු_සැප්තැම්බර්_ඔක්තෝබර්_නොවැම්බර්_දෙසැම්බර්'.split('_'),
	    monthsShort : 'ජන_පෙබ_මාර්_අප්_මැයි_ජූනි_ජූලි_අගෝ_සැප්_ඔක්_නොවැ_දෙසැ'.split('_'),
	    weekdays : 'ඉරිදා_සඳුදා_අඟහරුවාදා_බදාදා_බ්‍රහස්පතින්දා_සිකුරාදා_සෙනසුරාදා'.split('_'),
	    weekdaysShort : 'ඉරි_සඳු_අඟ_බදා_බ්‍රහ_සිකු_සෙන'.split('_'),
	    weekdaysMin : 'ඉ_ස_අ_බ_බ්‍ර_සි_සෙ'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'a h:mm',
	        LTS : 'a h:mm:ss',
	        L : 'YYYY/MM/DD',
	        LL : 'YYYY MMMM D',
	        LLL : 'YYYY MMMM D, a h:mm',
	        LLLL : 'YYYY MMMM D [වැනි] dddd, a h:mm:ss'
	    },
	    calendar : {
	        sameDay : '[අද] LT[ට]',
	        nextDay : '[හෙට] LT[ට]',
	        nextWeek : 'dddd LT[ට]',
	        lastDay : '[ඊයේ] LT[ට]',
	        lastWeek : '[පසුගිය] dddd LT[ට]',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%sකින්',
	        past : '%sකට පෙර',
	        s : 'තත්පර කිහිපය',
	        m : 'මිනිත්තුව',
	        mm : 'මිනිත්තු %d',
	        h : 'පැය',
	        hh : 'පැය %d',
	        d : 'දිනය',
	        dd : 'දින %d',
	        M : 'මාසය',
	        MM : 'මාස %d',
	        y : 'වසර',
	        yy : 'වසර %d'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2} වැනි/,
	    ordinal : function (number) {
	        return number + ' වැනි';
	    },
	    meridiemParse : /පෙර වරු|පස් වරු|පෙ.ව|ප.ව./,
	    isPM : function (input) {
	        return input === 'ප.ව.' || input === 'පස් වරු';
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours > 11) {
	            return isLower ? 'ප.ව.' : 'පස් වරු';
	        } else {
	            return isLower ? 'පෙ.ව.' : 'පෙර වරු';
	        }
	    }
	});

	return si;

	})));


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Slovak [sk]
	//! author : Martin Minka : https://github.com/k2s
	//! based on work of petrbela : https://github.com/petrbela

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var months = 'január_február_marec_apríl_máj_jún_júl_august_september_október_november_december'.split('_');
	var monthsShort = 'jan_feb_mar_apr_máj_jún_júl_aug_sep_okt_nov_dec'.split('_');
	function plural(n) {
	    return (n > 1) && (n < 5);
	}
	function translate(number, withoutSuffix, key, isFuture) {
	    var result = number + ' ';
	    switch (key) {
	        case 's':  // a few seconds / in a few seconds / a few seconds ago
	            return (withoutSuffix || isFuture) ? 'pár sekúnd' : 'pár sekundami';
	        case 'm':  // a minute / in a minute / a minute ago
	            return withoutSuffix ? 'minúta' : (isFuture ? 'minútu' : 'minútou');
	        case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'minúty' : 'minút');
	            } else {
	                return result + 'minútami';
	            }
	            break;
	        case 'h':  // an hour / in an hour / an hour ago
	            return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
	        case 'hh': // 9 hours / in 9 hours / 9 hours ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'hodiny' : 'hodín');
	            } else {
	                return result + 'hodinami';
	            }
	            break;
	        case 'd':  // a day / in a day / a day ago
	            return (withoutSuffix || isFuture) ? 'deň' : 'dňom';
	        case 'dd': // 9 days / in 9 days / 9 days ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'dni' : 'dní');
	            } else {
	                return result + 'dňami';
	            }
	            break;
	        case 'M':  // a month / in a month / a month ago
	            return (withoutSuffix || isFuture) ? 'mesiac' : 'mesiacom';
	        case 'MM': // 9 months / in 9 months / 9 months ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'mesiace' : 'mesiacov');
	            } else {
	                return result + 'mesiacmi';
	            }
	            break;
	        case 'y':  // a year / in a year / a year ago
	            return (withoutSuffix || isFuture) ? 'rok' : 'rokom';
	        case 'yy': // 9 years / in 9 years / 9 years ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'roky' : 'rokov');
	            } else {
	                return result + 'rokmi';
	            }
	            break;
	    }
	}

	var sk = moment.defineLocale('sk', {
	    months : months,
	    monthsShort : monthsShort,
	    weekdays : 'nedeľa_pondelok_utorok_streda_štvrtok_piatok_sobota'.split('_'),
	    weekdaysShort : 'ne_po_ut_st_št_pi_so'.split('_'),
	    weekdaysMin : 'ne_po_ut_st_št_pi_so'.split('_'),
	    longDateFormat : {
	        LT: 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY H:mm',
	        LLLL : 'dddd D. MMMM YYYY H:mm'
	    },
	    calendar : {
	        sameDay: '[dnes o] LT',
	        nextDay: '[zajtra o] LT',
	        nextWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[v nedeľu o] LT';
	                case 1:
	                case 2:
	                    return '[v] dddd [o] LT';
	                case 3:
	                    return '[v stredu o] LT';
	                case 4:
	                    return '[vo štvrtok o] LT';
	                case 5:
	                    return '[v piatok o] LT';
	                case 6:
	                    return '[v sobotu o] LT';
	            }
	        },
	        lastDay: '[včera o] LT',
	        lastWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[minulú nedeľu o] LT';
	                case 1:
	                case 2:
	                    return '[minulý] dddd [o] LT';
	                case 3:
	                    return '[minulú stredu o] LT';
	                case 4:
	                case 5:
	                    return '[minulý] dddd [o] LT';
	                case 6:
	                    return '[minulú sobotu o] LT';
	            }
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'za %s',
	        past : 'pred %s',
	        s : translate,
	        m : translate,
	        mm : translate,
	        h : translate,
	        hh : translate,
	        d : translate,
	        dd : translate,
	        M : translate,
	        MM : translate,
	        y : translate,
	        yy : translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return sk;

	})));


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Slovenian [sl]
	//! author : Robert Sedovšek : https://github.com/sedovsek

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var result = number + ' ';
	    switch (key) {
	        case 's':
	            return withoutSuffix || isFuture ? 'nekaj sekund' : 'nekaj sekundami';
	        case 'm':
	            return withoutSuffix ? 'ena minuta' : 'eno minuto';
	        case 'mm':
	            if (number === 1) {
	                result += withoutSuffix ? 'minuta' : 'minuto';
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? 'minuti' : 'minutama';
	            } else if (number < 5) {
	                result += withoutSuffix || isFuture ? 'minute' : 'minutami';
	            } else {
	                result += withoutSuffix || isFuture ? 'minut' : 'minutami';
	            }
	            return result;
	        case 'h':
	            return withoutSuffix ? 'ena ura' : 'eno uro';
	        case 'hh':
	            if (number === 1) {
	                result += withoutSuffix ? 'ura' : 'uro';
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? 'uri' : 'urama';
	            } else if (number < 5) {
	                result += withoutSuffix || isFuture ? 'ure' : 'urami';
	            } else {
	                result += withoutSuffix || isFuture ? 'ur' : 'urami';
	            }
	            return result;
	        case 'd':
	            return withoutSuffix || isFuture ? 'en dan' : 'enim dnem';
	        case 'dd':
	            if (number === 1) {
	                result += withoutSuffix || isFuture ? 'dan' : 'dnem';
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? 'dni' : 'dnevoma';
	            } else {
	                result += withoutSuffix || isFuture ? 'dni' : 'dnevi';
	            }
	            return result;
	        case 'M':
	            return withoutSuffix || isFuture ? 'en mesec' : 'enim mesecem';
	        case 'MM':
	            if (number === 1) {
	                result += withoutSuffix || isFuture ? 'mesec' : 'mesecem';
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? 'meseca' : 'mesecema';
	            } else if (number < 5) {
	                result += withoutSuffix || isFuture ? 'mesece' : 'meseci';
	            } else {
	                result += withoutSuffix || isFuture ? 'mesecev' : 'meseci';
	            }
	            return result;
	        case 'y':
	            return withoutSuffix || isFuture ? 'eno leto' : 'enim letom';
	        case 'yy':
	            if (number === 1) {
	                result += withoutSuffix || isFuture ? 'leto' : 'letom';
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? 'leti' : 'letoma';
	            } else if (number < 5) {
	                result += withoutSuffix || isFuture ? 'leta' : 'leti';
	            } else {
	                result += withoutSuffix || isFuture ? 'let' : 'leti';
	            }
	            return result;
	    }
	}

	var sl = moment.defineLocale('sl', {
	    months : 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split('_'),
	    monthsShort : 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split('_'),
	    monthsParseExact: true,
	    weekdays : 'nedelja_ponedeljek_torek_sreda_četrtek_petek_sobota'.split('_'),
	    weekdaysShort : 'ned._pon._tor._sre._čet._pet._sob.'.split('_'),
	    weekdaysMin : 'ne_po_to_sr_če_pe_so'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY H:mm',
	        LLLL : 'dddd, D. MMMM YYYY H:mm'
	    },
	    calendar : {
	        sameDay  : '[danes ob] LT',
	        nextDay  : '[jutri ob] LT',

	        nextWeek : function () {
	            switch (this.day()) {
	                case 0:
	                    return '[v] [nedeljo] [ob] LT';
	                case 3:
	                    return '[v] [sredo] [ob] LT';
	                case 6:
	                    return '[v] [soboto] [ob] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[v] dddd [ob] LT';
	            }
	        },
	        lastDay  : '[včeraj ob] LT',
	        lastWeek : function () {
	            switch (this.day()) {
	                case 0:
	                    return '[prejšnjo] [nedeljo] [ob] LT';
	                case 3:
	                    return '[prejšnjo] [sredo] [ob] LT';
	                case 6:
	                    return '[prejšnjo] [soboto] [ob] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[prejšnji] dddd [ob] LT';
	            }
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'čez %s',
	        past   : 'pred %s',
	        s      : processRelativeTime,
	        m      : processRelativeTime,
	        mm     : processRelativeTime,
	        h      : processRelativeTime,
	        hh     : processRelativeTime,
	        d      : processRelativeTime,
	        dd     : processRelativeTime,
	        M      : processRelativeTime,
	        MM     : processRelativeTime,
	        y      : processRelativeTime,
	        yy     : processRelativeTime
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return sl;

	})));


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Albanian [sq]
	//! author : Flakërim Ismani : https://github.com/flakerimi
	//! author : Menelion Elensúle : https://github.com/Oire
	//! author : Oerd Cukalla : https://github.com/oerd

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var sq = moment.defineLocale('sq', {
	    months : 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nëntor_Dhjetor'.split('_'),
	    monthsShort : 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nën_Dhj'.split('_'),
	    weekdays : 'E Diel_E Hënë_E Martë_E Mërkurë_E Enjte_E Premte_E Shtunë'.split('_'),
	    weekdaysShort : 'Die_Hën_Mar_Mër_Enj_Pre_Sht'.split('_'),
	    weekdaysMin : 'D_H_Ma_Më_E_P_Sh'.split('_'),
	    weekdaysParseExact : true,
	    meridiemParse: /PD|MD/,
	    isPM: function (input) {
	        return input.charAt(0) === 'M';
	    },
	    meridiem : function (hours, minutes, isLower) {
	        return hours < 12 ? 'PD' : 'MD';
	    },
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[Sot në] LT',
	        nextDay : '[Nesër në] LT',
	        nextWeek : 'dddd [në] LT',
	        lastDay : '[Dje në] LT',
	        lastWeek : 'dddd [e kaluar në] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'në %s',
	        past : '%s më parë',
	        s : 'disa sekonda',
	        m : 'një minutë',
	        mm : '%d minuta',
	        h : 'një orë',
	        hh : '%d orë',
	        d : 'një ditë',
	        dd : '%d ditë',
	        M : 'një muaj',
	        MM : '%d muaj',
	        y : 'një vit',
	        yy : '%d vite'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return sq;

	})));


/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Serbian [sr]
	//! author : Milan Janačković<milanjanackovic@gmail.com> : https://github.com/milan-j

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var translator = {
	    words: { //Different grammatical cases
	        m: ['jedan minut', 'jedne minute'],
	        mm: ['minut', 'minute', 'minuta'],
	        h: ['jedan sat', 'jednog sata'],
	        hh: ['sat', 'sata', 'sati'],
	        dd: ['dan', 'dana', 'dana'],
	        MM: ['mesec', 'meseca', 'meseci'],
	        yy: ['godina', 'godine', 'godina']
	    },
	    correctGrammaticalCase: function (number, wordKey) {
	        return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
	    },
	    translate: function (number, withoutSuffix, key) {
	        var wordKey = translator.words[key];
	        if (key.length === 1) {
	            return withoutSuffix ? wordKey[0] : wordKey[1];
	        } else {
	            return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
	        }
	    }
	};

	var sr = moment.defineLocale('sr', {
	    months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
	    monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
	    monthsParseExact: true,
	    weekdays: 'nedelja_ponedeljak_utorak_sreda_četvrtak_petak_subota'.split('_'),
	    weekdaysShort: 'ned._pon._uto._sre._čet._pet._sub.'.split('_'),
	    weekdaysMin: 'ne_po_ut_sr_če_pe_su'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat: {
	        LT: 'H:mm',
	        LTS : 'H:mm:ss',
	        L: 'DD.MM.YYYY',
	        LL: 'D. MMMM YYYY',
	        LLL: 'D. MMMM YYYY H:mm',
	        LLLL: 'dddd, D. MMMM YYYY H:mm'
	    },
	    calendar: {
	        sameDay: '[danas u] LT',
	        nextDay: '[sutra u] LT',
	        nextWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[u] [nedelju] [u] LT';
	                case 3:
	                    return '[u] [sredu] [u] LT';
	                case 6:
	                    return '[u] [subotu] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[u] dddd [u] LT';
	            }
	        },
	        lastDay  : '[juče u] LT',
	        lastWeek : function () {
	            var lastWeekDays = [
	                '[prošle] [nedelje] [u] LT',
	                '[prošlog] [ponedeljka] [u] LT',
	                '[prošlog] [utorka] [u] LT',
	                '[prošle] [srede] [u] LT',
	                '[prošlog] [četvrtka] [u] LT',
	                '[prošlog] [petka] [u] LT',
	                '[prošle] [subote] [u] LT'
	            ];
	            return lastWeekDays[this.day()];
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'za %s',
	        past   : 'pre %s',
	        s      : 'nekoliko sekundi',
	        m      : translator.translate,
	        mm     : translator.translate,
	        h      : translator.translate,
	        hh     : translator.translate,
	        d      : 'dan',
	        dd     : translator.translate,
	        M      : 'mesec',
	        MM     : translator.translate,
	        y      : 'godinu',
	        yy     : translator.translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return sr;

	})));


/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Serbian Cyrillic [sr-cyrl]
	//! author : Milan Janačković<milanjanackovic@gmail.com> : https://github.com/milan-j

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var translator = {
	    words: { //Different grammatical cases
	        m: ['један минут', 'једне минуте'],
	        mm: ['минут', 'минуте', 'минута'],
	        h: ['један сат', 'једног сата'],
	        hh: ['сат', 'сата', 'сати'],
	        dd: ['дан', 'дана', 'дана'],
	        MM: ['месец', 'месеца', 'месеци'],
	        yy: ['година', 'године', 'година']
	    },
	    correctGrammaticalCase: function (number, wordKey) {
	        return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
	    },
	    translate: function (number, withoutSuffix, key) {
	        var wordKey = translator.words[key];
	        if (key.length === 1) {
	            return withoutSuffix ? wordKey[0] : wordKey[1];
	        } else {
	            return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
	        }
	    }
	};

	var srCyrl = moment.defineLocale('sr-cyrl', {
	    months: 'јануар_фебруар_март_април_мај_јун_јул_август_септембар_октобар_новембар_децембар'.split('_'),
	    monthsShort: 'јан._феб._мар._апр._мај_јун_јул_авг._сеп._окт._нов._дец.'.split('_'),
	    monthsParseExact: true,
	    weekdays: 'недеља_понедељак_уторак_среда_четвртак_петак_субота'.split('_'),
	    weekdaysShort: 'нед._пон._уто._сре._чет._пет._суб.'.split('_'),
	    weekdaysMin: 'не_по_ут_ср_че_пе_су'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat: {
	        LT: 'H:mm',
	        LTS : 'H:mm:ss',
	        L: 'DD.MM.YYYY',
	        LL: 'D. MMMM YYYY',
	        LLL: 'D. MMMM YYYY H:mm',
	        LLLL: 'dddd, D. MMMM YYYY H:mm'
	    },
	    calendar: {
	        sameDay: '[данас у] LT',
	        nextDay: '[сутра у] LT',
	        nextWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[у] [недељу] [у] LT';
	                case 3:
	                    return '[у] [среду] [у] LT';
	                case 6:
	                    return '[у] [суботу] [у] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[у] dddd [у] LT';
	            }
	        },
	        lastDay  : '[јуче у] LT',
	        lastWeek : function () {
	            var lastWeekDays = [
	                '[прошле] [недеље] [у] LT',
	                '[прошлог] [понедељка] [у] LT',
	                '[прошлог] [уторка] [у] LT',
	                '[прошле] [среде] [у] LT',
	                '[прошлог] [четвртка] [у] LT',
	                '[прошлог] [петка] [у] LT',
	                '[прошле] [суботе] [у] LT'
	            ];
	            return lastWeekDays[this.day()];
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'за %s',
	        past   : 'пре %s',
	        s      : 'неколико секунди',
	        m      : translator.translate,
	        mm     : translator.translate,
	        h      : translator.translate,
	        hh     : translator.translate,
	        d      : 'дан',
	        dd     : translator.translate,
	        M      : 'месец',
	        MM     : translator.translate,
	        y      : 'годину',
	        yy     : translator.translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return srCyrl;

	})));


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : siSwati [ss]
	//! author : Nicolai Davies<mail@nicolai.io> : https://github.com/nicolaidavies

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';



	var ss = moment.defineLocale('ss', {
	    months : "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split('_'),
	    monthsShort : 'Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo'.split('_'),
	    weekdays : 'Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo'.split('_'),
	    weekdaysShort : 'Lis_Umb_Lsb_Les_Lsi_Lsh_Umg'.split('_'),
	    weekdaysMin : 'Li_Us_Lb_Lt_Ls_Lh_Ug'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'h:mm A',
	        LTS : 'h:mm:ss A',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY h:mm A',
	        LLLL : 'dddd, D MMMM YYYY h:mm A'
	    },
	    calendar : {
	        sameDay : '[Namuhla nga] LT',
	        nextDay : '[Kusasa nga] LT',
	        nextWeek : 'dddd [nga] LT',
	        lastDay : '[Itolo nga] LT',
	        lastWeek : 'dddd [leliphelile] [nga] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'nga %s',
	        past : 'wenteka nga %s',
	        s : 'emizuzwana lomcane',
	        m : 'umzuzu',
	        mm : '%d emizuzu',
	        h : 'lihora',
	        hh : '%d emahora',
	        d : 'lilanga',
	        dd : '%d emalanga',
	        M : 'inyanga',
	        MM : '%d tinyanga',
	        y : 'umnyaka',
	        yy : '%d iminyaka'
	    },
	    meridiemParse: /ekuseni|emini|entsambama|ebusuku/,
	    meridiem : function (hours, minutes, isLower) {
	        if (hours < 11) {
	            return 'ekuseni';
	        } else if (hours < 15) {
	            return 'emini';
	        } else if (hours < 19) {
	            return 'entsambama';
	        } else {
	            return 'ebusuku';
	        }
	    },
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === 'ekuseni') {
	            return hour;
	        } else if (meridiem === 'emini') {
	            return hour >= 11 ? hour : hour + 12;
	        } else if (meridiem === 'entsambama' || meridiem === 'ebusuku') {
	            if (hour === 0) {
	                return 0;
	            }
	            return hour + 12;
	        }
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}/,
	    ordinal : '%d',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return ss;

	})));


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Swedish [sv]
	//! author : Jens Alm : https://github.com/ulmus

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var sv = moment.defineLocale('sv', {
	    months : 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split('_'),
	    monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
	    weekdays : 'söndag_måndag_tisdag_onsdag_torsdag_fredag_lördag'.split('_'),
	    weekdaysShort : 'sön_mån_tis_ons_tor_fre_lör'.split('_'),
	    weekdaysMin : 'sö_må_ti_on_to_fr_lö'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'YYYY-MM-DD',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY [kl.] HH:mm',
	        LLLL : 'dddd D MMMM YYYY [kl.] HH:mm',
	        lll : 'D MMM YYYY HH:mm',
	        llll : 'ddd D MMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[Idag] LT',
	        nextDay: '[Imorgon] LT',
	        lastDay: '[Igår] LT',
	        nextWeek: '[På] dddd LT',
	        lastWeek: '[I] dddd[s] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'om %s',
	        past : 'för %s sedan',
	        s : 'några sekunder',
	        m : 'en minut',
	        mm : '%d minuter',
	        h : 'en timme',
	        hh : '%d timmar',
	        d : 'en dag',
	        dd : '%d dagar',
	        M : 'en månad',
	        MM : '%d månader',
	        y : 'ett år',
	        yy : '%d år'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(e|a)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? 'e' :
	            (b === 1) ? 'a' :
	            (b === 2) ? 'a' :
	            (b === 3) ? 'e' : 'e';
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return sv;

	})));


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Swahili [sw]
	//! author : Fahad Kassim : https://github.com/fadsel

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var sw = moment.defineLocale('sw', {
	    months : 'Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba'.split('_'),
	    monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des'.split('_'),
	    weekdays : 'Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi'.split('_'),
	    weekdaysShort : 'Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos'.split('_'),
	    weekdaysMin : 'J2_J3_J4_J5_Al_Ij_J1'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[leo saa] LT',
	        nextDay : '[kesho saa] LT',
	        nextWeek : '[wiki ijayo] dddd [saat] LT',
	        lastDay : '[jana] LT',
	        lastWeek : '[wiki iliyopita] dddd [saat] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s baadaye',
	        past : 'tokea %s',
	        s : 'hivi punde',
	        m : 'dakika moja',
	        mm : 'dakika %d',
	        h : 'saa limoja',
	        hh : 'masaa %d',
	        d : 'siku moja',
	        dd : 'masiku %d',
	        M : 'mwezi mmoja',
	        MM : 'miezi %d',
	        y : 'mwaka mmoja',
	        yy : 'miaka %d'
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return sw;

	})));


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Tamil [ta]
	//! author : Arjunkumar Krishnamoorthy : https://github.com/tk120404

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var symbolMap = {
	    '1': '௧',
	    '2': '௨',
	    '3': '௩',
	    '4': '௪',
	    '5': '௫',
	    '6': '௬',
	    '7': '௭',
	    '8': '௮',
	    '9': '௯',
	    '0': '௦'
	};
	var numberMap = {
	    '௧': '1',
	    '௨': '2',
	    '௩': '3',
	    '௪': '4',
	    '௫': '5',
	    '௬': '6',
	    '௭': '7',
	    '௮': '8',
	    '௯': '9',
	    '௦': '0'
	};

	var ta = moment.defineLocale('ta', {
	    months : 'ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்'.split('_'),
	    monthsShort : 'ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்'.split('_'),
	    weekdays : 'ஞாயிற்றுக்கிழமை_திங்கட்கிழமை_செவ்வாய்கிழமை_புதன்கிழமை_வியாழக்கிழமை_வெள்ளிக்கிழமை_சனிக்கிழமை'.split('_'),
	    weekdaysShort : 'ஞாயிறு_திங்கள்_செவ்வாய்_புதன்_வியாழன்_வெள்ளி_சனி'.split('_'),
	    weekdaysMin : 'ஞா_தி_செ_பு_வி_வெ_ச'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, HH:mm',
	        LLLL : 'dddd, D MMMM YYYY, HH:mm'
	    },
	    calendar : {
	        sameDay : '[இன்று] LT',
	        nextDay : '[நாளை] LT',
	        nextWeek : 'dddd, LT',
	        lastDay : '[நேற்று] LT',
	        lastWeek : '[கடந்த வாரம்] dddd, LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s இல்',
	        past : '%s முன்',
	        s : 'ஒரு சில விநாடிகள்',
	        m : 'ஒரு நிமிடம்',
	        mm : '%d நிமிடங்கள்',
	        h : 'ஒரு மணி நேரம்',
	        hh : '%d மணி நேரம்',
	        d : 'ஒரு நாள்',
	        dd : '%d நாட்கள்',
	        M : 'ஒரு மாதம்',
	        MM : '%d மாதங்கள்',
	        y : 'ஒரு வருடம்',
	        yy : '%d ஆண்டுகள்'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}வது/,
	    ordinal : function (number) {
	        return number + 'வது';
	    },
	    preparse: function (string) {
	        return string.replace(/[௧௨௩௪௫௬௭௮௯௦]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    // refer http://ta.wikipedia.org/s/1er1
	    meridiemParse: /யாமம்|வைகறை|காலை|நண்பகல்|எற்பாடு|மாலை/,
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 2) {
	            return ' யாமம்';
	        } else if (hour < 6) {
	            return ' வைகறை';  // வைகறை
	        } else if (hour < 10) {
	            return ' காலை'; // காலை
	        } else if (hour < 14) {
	            return ' நண்பகல்'; // நண்பகல்
	        } else if (hour < 18) {
	            return ' எற்பாடு'; // எற்பாடு
	        } else if (hour < 22) {
	            return ' மாலை'; // மாலை
	        } else {
	            return ' யாமம்';
	        }
	    },
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === 'யாமம்') {
	            return hour < 2 ? hour : hour + 12;
	        } else if (meridiem === 'வைகறை' || meridiem === 'காலை') {
	            return hour;
	        } else if (meridiem === 'நண்பகல்') {
	            return hour >= 10 ? hour : hour + 12;
	        } else {
	            return hour + 12;
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return ta;

	})));


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Telugu [te]
	//! author : Krishna Chaitanya Thota : https://github.com/kcthota

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var te = moment.defineLocale('te', {
	    months : 'జనవరి_ఫిబ్రవరి_మార్చి_ఏప్రిల్_మే_జూన్_జూలై_ఆగస్టు_సెప్టెంబర్_అక్టోబర్_నవంబర్_డిసెంబర్'.split('_'),
	    monthsShort : 'జన._ఫిబ్ర._మార్చి_ఏప్రి._మే_జూన్_జూలై_ఆగ._సెప్._అక్టో._నవ._డిసె.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'ఆదివారం_సోమవారం_మంగళవారం_బుధవారం_గురువారం_శుక్రవారం_శనివారం'.split('_'),
	    weekdaysShort : 'ఆది_సోమ_మంగళ_బుధ_గురు_శుక్ర_శని'.split('_'),
	    weekdaysMin : 'ఆ_సో_మం_బు_గు_శు_శ'.split('_'),
	    longDateFormat : {
	        LT : 'A h:mm',
	        LTS : 'A h:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, A h:mm',
	        LLLL : 'dddd, D MMMM YYYY, A h:mm'
	    },
	    calendar : {
	        sameDay : '[నేడు] LT',
	        nextDay : '[రేపు] LT',
	        nextWeek : 'dddd, LT',
	        lastDay : '[నిన్న] LT',
	        lastWeek : '[గత] dddd, LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s లో',
	        past : '%s క్రితం',
	        s : 'కొన్ని క్షణాలు',
	        m : 'ఒక నిమిషం',
	        mm : '%d నిమిషాలు',
	        h : 'ఒక గంట',
	        hh : '%d గంటలు',
	        d : 'ఒక రోజు',
	        dd : '%d రోజులు',
	        M : 'ఒక నెల',
	        MM : '%d నెలలు',
	        y : 'ఒక సంవత్సరం',
	        yy : '%d సంవత్సరాలు'
	    },
	    dayOfMonthOrdinalParse : /\d{1,2}వ/,
	    ordinal : '%dవ',
	    meridiemParse: /రాత్రి|ఉదయం|మధ్యాహ్నం|సాయంత్రం/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === 'రాత్రి') {
	            return hour < 4 ? hour : hour + 12;
	        } else if (meridiem === 'ఉదయం') {
	            return hour;
	        } else if (meridiem === 'మధ్యాహ్నం') {
	            return hour >= 10 ? hour : hour + 12;
	        } else if (meridiem === 'సాయంత్రం') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return 'రాత్రి';
	        } else if (hour < 10) {
	            return 'ఉదయం';
	        } else if (hour < 17) {
	            return 'మధ్యాహ్నం';
	        } else if (hour < 20) {
	            return 'సాయంత్రం';
	        } else {
	            return 'రాత్రి';
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return te;

	})));


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Tetun Dili (East Timor) [tet]
	//! author : Joshua Brooks : https://github.com/joshbrooks
	//! author : Onorio De J. Afonso : https://github.com/marobo

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var tet = moment.defineLocale('tet', {
	    months : 'Janeiru_Fevereiru_Marsu_Abril_Maiu_Juniu_Juliu_Augustu_Setembru_Outubru_Novembru_Dezembru'.split('_'),
	    monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Aug_Set_Out_Nov_Dez'.split('_'),
	    weekdays : 'Domingu_Segunda_Tersa_Kuarta_Kinta_Sexta_Sabadu'.split('_'),
	    weekdaysShort : 'Dom_Seg_Ters_Kua_Kint_Sext_Sab'.split('_'),
	    weekdaysMin : 'Do_Seg_Te_Ku_Ki_Sex_Sa'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[Ohin iha] LT',
	        nextDay: '[Aban iha] LT',
	        nextWeek: 'dddd [iha] LT',
	        lastDay: '[Horiseik iha] LT',
	        lastWeek: 'dddd [semana kotuk] [iha] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'iha %s',
	        past : '%s liuba',
	        s : 'minutu balun',
	        m : 'minutu ida',
	        mm : 'minutus %d',
	        h : 'horas ida',
	        hh : 'horas %d',
	        d : 'loron ida',
	        dd : 'loron %d',
	        M : 'fulan ida',
	        MM : 'fulan %d',
	        y : 'tinan ida',
	        yy : 'tinan %d'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? 'th' :
	            (b === 1) ? 'st' :
	            (b === 2) ? 'nd' :
	            (b === 3) ? 'rd' : 'th';
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return tet;

	})));


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Thai [th]
	//! author : Kridsada Thanabulpong : https://github.com/sirn

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var th = moment.defineLocale('th', {
	    months : 'มกราคม_กุมภาพันธ์_มีนาคม_เมษายน_พฤษภาคม_มิถุนายน_กรกฎาคม_สิงหาคม_กันยายน_ตุลาคม_พฤศจิกายน_ธันวาคม'.split('_'),
	    monthsShort : 'ม.ค._ก.พ._มี.ค._เม.ย._พ.ค._มิ.ย._ก.ค._ส.ค._ก.ย._ต.ค._พ.ย._ธ.ค.'.split('_'),
	    monthsParseExact: true,
	    weekdays : 'อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัสบดี_ศุกร์_เสาร์'.split('_'),
	    weekdaysShort : 'อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัส_ศุกร์_เสาร์'.split('_'), // yes, three characters difference
	    weekdaysMin : 'อา._จ._อ._พ._พฤ._ศ._ส.'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY เวลา H:mm',
	        LLLL : 'วันddddที่ D MMMM YYYY เวลา H:mm'
	    },
	    meridiemParse: /ก่อนเที่ยง|หลังเที่ยง/,
	    isPM: function (input) {
	        return input === 'หลังเที่ยง';
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 12) {
	            return 'ก่อนเที่ยง';
	        } else {
	            return 'หลังเที่ยง';
	        }
	    },
	    calendar : {
	        sameDay : '[วันนี้ เวลา] LT',
	        nextDay : '[พรุ่งนี้ เวลา] LT',
	        nextWeek : 'dddd[หน้า เวลา] LT',
	        lastDay : '[เมื่อวานนี้ เวลา] LT',
	        lastWeek : '[วัน]dddd[ที่แล้ว เวลา] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'อีก %s',
	        past : '%sที่แล้ว',
	        s : 'ไม่กี่วินาที',
	        m : '1 นาที',
	        mm : '%d นาที',
	        h : '1 ชั่วโมง',
	        hh : '%d ชั่วโมง',
	        d : '1 วัน',
	        dd : '%d วัน',
	        M : '1 เดือน',
	        MM : '%d เดือน',
	        y : '1 ปี',
	        yy : '%d ปี'
	    }
	});

	return th;

	})));


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Tagalog (Philippines) [tl-ph]
	//! author : Dan Hagman : https://github.com/hagmandan

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var tlPh = moment.defineLocale('tl-ph', {
	    months : 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),
	    monthsShort : 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
	    weekdays : 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),
	    weekdaysShort : 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
	    weekdaysMin : 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'MM/D/YYYY',
	        LL : 'MMMM D, YYYY',
	        LLL : 'MMMM D, YYYY HH:mm',
	        LLLL : 'dddd, MMMM DD, YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: 'LT [ngayong araw]',
	        nextDay: '[Bukas ng] LT',
	        nextWeek: 'LT [sa susunod na] dddd',
	        lastDay: 'LT [kahapon]',
	        lastWeek: 'LT [noong nakaraang] dddd',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'sa loob ng %s',
	        past : '%s ang nakalipas',
	        s : 'ilang segundo',
	        m : 'isang minuto',
	        mm : '%d minuto',
	        h : 'isang oras',
	        hh : '%d oras',
	        d : 'isang araw',
	        dd : '%d araw',
	        M : 'isang buwan',
	        MM : '%d buwan',
	        y : 'isang taon',
	        yy : '%d taon'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}/,
	    ordinal : function (number) {
	        return number;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return tlPh;

	})));


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Klingon [tlh]
	//! author : Dominika Kruk : https://github.com/amaranthrose

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var numbersNouns = 'pagh_wa’_cha’_wej_loS_vagh_jav_Soch_chorgh_Hut'.split('_');

	function translateFuture(output) {
	    var time = output;
	    time = (output.indexOf('jaj') !== -1) ?
	    time.slice(0, -3) + 'leS' :
	    (output.indexOf('jar') !== -1) ?
	    time.slice(0, -3) + 'waQ' :
	    (output.indexOf('DIS') !== -1) ?
	    time.slice(0, -3) + 'nem' :
	    time + ' pIq';
	    return time;
	}

	function translatePast(output) {
	    var time = output;
	    time = (output.indexOf('jaj') !== -1) ?
	    time.slice(0, -3) + 'Hu’' :
	    (output.indexOf('jar') !== -1) ?
	    time.slice(0, -3) + 'wen' :
	    (output.indexOf('DIS') !== -1) ?
	    time.slice(0, -3) + 'ben' :
	    time + ' ret';
	    return time;
	}

	function translate(number, withoutSuffix, string, isFuture) {
	    var numberNoun = numberAsNoun(number);
	    switch (string) {
	        case 'mm':
	            return numberNoun + ' tup';
	        case 'hh':
	            return numberNoun + ' rep';
	        case 'dd':
	            return numberNoun + ' jaj';
	        case 'MM':
	            return numberNoun + ' jar';
	        case 'yy':
	            return numberNoun + ' DIS';
	    }
	}

	function numberAsNoun(number) {
	    var hundred = Math.floor((number % 1000) / 100),
	    ten = Math.floor((number % 100) / 10),
	    one = number % 10,
	    word = '';
	    if (hundred > 0) {
	        word += numbersNouns[hundred] + 'vatlh';
	    }
	    if (ten > 0) {
	        word += ((word !== '') ? ' ' : '') + numbersNouns[ten] + 'maH';
	    }
	    if (one > 0) {
	        word += ((word !== '') ? ' ' : '') + numbersNouns[one];
	    }
	    return (word === '') ? 'pagh' : word;
	}

	var tlh = moment.defineLocale('tlh', {
	    months : 'tera’ jar wa’_tera’ jar cha’_tera’ jar wej_tera’ jar loS_tera’ jar vagh_tera’ jar jav_tera’ jar Soch_tera’ jar chorgh_tera’ jar Hut_tera’ jar wa’maH_tera’ jar wa’maH wa’_tera’ jar wa’maH cha’'.split('_'),
	    monthsShort : 'jar wa’_jar cha’_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wa’maH_jar wa’maH wa’_jar wa’maH cha’'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
	    weekdaysShort : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
	    weekdaysMin : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[DaHjaj] LT',
	        nextDay: '[wa’leS] LT',
	        nextWeek: 'LLL',
	        lastDay: '[wa’Hu’] LT',
	        lastWeek: 'LLL',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : translateFuture,
	        past : translatePast,
	        s : 'puS lup',
	        m : 'wa’ tup',
	        mm : translate,
	        h : 'wa’ rep',
	        hh : translate,
	        d : 'wa’ jaj',
	        dd : translate,
	        M : 'wa’ jar',
	        MM : translate,
	        y : 'wa’ DIS',
	        yy : translate
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return tlh;

	})));


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Turkish [tr]
	//! authors : Erhan Gundogan : https://github.com/erhangundogan,
	//!           Burak Yiğit Kaya: https://github.com/BYK

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var suffixes = {
	    1: '\'inci',
	    5: '\'inci',
	    8: '\'inci',
	    70: '\'inci',
	    80: '\'inci',
	    2: '\'nci',
	    7: '\'nci',
	    20: '\'nci',
	    50: '\'nci',
	    3: '\'üncü',
	    4: '\'üncü',
	    100: '\'üncü',
	    6: '\'ncı',
	    9: '\'uncu',
	    10: '\'uncu',
	    30: '\'uncu',
	    60: '\'ıncı',
	    90: '\'ıncı'
	};

	var tr = moment.defineLocale('tr', {
	    months : 'Ocak_Şubat_Mart_Nisan_Mayıs_Haziran_Temmuz_Ağustos_Eylül_Ekim_Kasım_Aralık'.split('_'),
	    monthsShort : 'Oca_Şub_Mar_Nis_May_Haz_Tem_Ağu_Eyl_Eki_Kas_Ara'.split('_'),
	    weekdays : 'Pazar_Pazartesi_Salı_Çarşamba_Perşembe_Cuma_Cumartesi'.split('_'),
	    weekdaysShort : 'Paz_Pts_Sal_Çar_Per_Cum_Cts'.split('_'),
	    weekdaysMin : 'Pz_Pt_Sa_Ça_Pe_Cu_Ct'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[bugün saat] LT',
	        nextDay : '[yarın saat] LT',
	        nextWeek : '[haftaya] dddd [saat] LT',
	        lastDay : '[dün] LT',
	        lastWeek : '[geçen hafta] dddd [saat] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s sonra',
	        past : '%s önce',
	        s : 'birkaç saniye',
	        m : 'bir dakika',
	        mm : '%d dakika',
	        h : 'bir saat',
	        hh : '%d saat',
	        d : 'bir gün',
	        dd : '%d gün',
	        M : 'bir ay',
	        MM : '%d ay',
	        y : 'bir yıl',
	        yy : '%d yıl'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}'(inci|nci|üncü|ncı|uncu|ıncı)/,
	    ordinal : function (number) {
	        if (number === 0) {  // special case for zero
	            return number + '\'ıncı';
	        }
	        var a = number % 10,
	            b = number % 100 - a,
	            c = number >= 100 ? 100 : null;
	        return number + (suffixes[a] || suffixes[b] || suffixes[c]);
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return tr;

	})));


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Talossan [tzl]
	//! author : Robin van der Vliet : https://github.com/robin0van0der0v
	//! author : Iustì Canun

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	// After the year there should be a slash and the amount of years since December 26, 1979 in Roman numerals.
	// This is currently too difficult (maybe even impossible) to add.
	var tzl = moment.defineLocale('tzl', {
	    months : 'Januar_Fevraglh_Març_Avrïu_Mai_Gün_Julia_Guscht_Setemvar_Listopäts_Noemvar_Zecemvar'.split('_'),
	    monthsShort : 'Jan_Fev_Mar_Avr_Mai_Gün_Jul_Gus_Set_Lis_Noe_Zec'.split('_'),
	    weekdays : 'Súladi_Lúneçi_Maitzi_Márcuri_Xhúadi_Viénerçi_Sáturi'.split('_'),
	    weekdaysShort : 'Súl_Lún_Mai_Már_Xhú_Vié_Sát'.split('_'),
	    weekdaysMin : 'Sú_Lú_Ma_Má_Xh_Vi_Sá'.split('_'),
	    longDateFormat : {
	        LT : 'HH.mm',
	        LTS : 'HH.mm.ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM [dallas] YYYY',
	        LLL : 'D. MMMM [dallas] YYYY HH.mm',
	        LLLL : 'dddd, [li] D. MMMM [dallas] YYYY HH.mm'
	    },
	    meridiemParse: /d\'o|d\'a/i,
	    isPM : function (input) {
	        return 'd\'o' === input.toLowerCase();
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours > 11) {
	            return isLower ? 'd\'o' : 'D\'O';
	        } else {
	            return isLower ? 'd\'a' : 'D\'A';
	        }
	    },
	    calendar : {
	        sameDay : '[oxhi à] LT',
	        nextDay : '[demà à] LT',
	        nextWeek : 'dddd [à] LT',
	        lastDay : '[ieiri à] LT',
	        lastWeek : '[sür el] dddd [lasteu à] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'osprei %s',
	        past : 'ja%s',
	        s : processRelativeTime,
	        m : processRelativeTime,
	        mm : processRelativeTime,
	        h : processRelativeTime,
	        hh : processRelativeTime,
	        d : processRelativeTime,
	        dd : processRelativeTime,
	        M : processRelativeTime,
	        MM : processRelativeTime,
	        y : processRelativeTime,
	        yy : processRelativeTime
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var format = {
	        's': ['viensas secunds', '\'iensas secunds'],
	        'm': ['\'n míut', '\'iens míut'],
	        'mm': [number + ' míuts', '' + number + ' míuts'],
	        'h': ['\'n þora', '\'iensa þora'],
	        'hh': [number + ' þoras', '' + number + ' þoras'],
	        'd': ['\'n ziua', '\'iensa ziua'],
	        'dd': [number + ' ziuas', '' + number + ' ziuas'],
	        'M': ['\'n mes', '\'iens mes'],
	        'MM': [number + ' mesen', '' + number + ' mesen'],
	        'y': ['\'n ar', '\'iens ar'],
	        'yy': [number + ' ars', '' + number + ' ars']
	    };
	    return isFuture ? format[key][0] : (withoutSuffix ? format[key][0] : format[key][1]);
	}

	return tzl;

	})));


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Central Atlas Tamazight [tzm]
	//! author : Abdel Said : https://github.com/abdelsaid

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var tzm = moment.defineLocale('tzm', {
	    months : 'ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ'.split('_'),
	    monthsShort : 'ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ'.split('_'),
	    weekdays : 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
	    weekdaysShort : 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
	    weekdaysMin : 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS: 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[ⴰⵙⴷⵅ ⴴ] LT',
	        nextDay: '[ⴰⵙⴽⴰ ⴴ] LT',
	        nextWeek: 'dddd [ⴴ] LT',
	        lastDay: '[ⴰⵚⴰⵏⵜ ⴴ] LT',
	        lastWeek: 'dddd [ⴴ] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'ⴷⴰⴷⵅ ⵙ ⵢⴰⵏ %s',
	        past : 'ⵢⴰⵏ %s',
	        s : 'ⵉⵎⵉⴽ',
	        m : 'ⵎⵉⵏⵓⴺ',
	        mm : '%d ⵎⵉⵏⵓⴺ',
	        h : 'ⵙⴰⵄⴰ',
	        hh : '%d ⵜⴰⵙⵙⴰⵄⵉⵏ',
	        d : 'ⴰⵙⵙ',
	        dd : '%d oⵙⵙⴰⵏ',
	        M : 'ⴰⵢoⵓⵔ',
	        MM : '%d ⵉⵢⵢⵉⵔⵏ',
	        y : 'ⴰⵙⴳⴰⵙ',
	        yy : '%d ⵉⵙⴳⴰⵙⵏ'
	    },
	    week : {
	        dow : 6, // Saturday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return tzm;

	})));


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Central Atlas Tamazight Latin [tzm-latn]
	//! author : Abdel Said : https://github.com/abdelsaid

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var tzmLatn = moment.defineLocale('tzm-latn', {
	    months : 'innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir'.split('_'),
	    monthsShort : 'innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir'.split('_'),
	    weekdays : 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
	    weekdaysShort : 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
	    weekdaysMin : 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[asdkh g] LT',
	        nextDay: '[aska g] LT',
	        nextWeek: 'dddd [g] LT',
	        lastDay: '[assant g] LT',
	        lastWeek: 'dddd [g] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'dadkh s yan %s',
	        past : 'yan %s',
	        s : 'imik',
	        m : 'minuḍ',
	        mm : '%d minuḍ',
	        h : 'saɛa',
	        hh : '%d tassaɛin',
	        d : 'ass',
	        dd : '%d ossan',
	        M : 'ayowr',
	        MM : '%d iyyirn',
	        y : 'asgas',
	        yy : '%d isgasn'
	    },
	    week : {
	        dow : 6, // Saturday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return tzmLatn;

	})));


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Ukrainian [uk]
	//! author : zemlanin : https://github.com/zemlanin
	//! Author : Menelion Elensúle : https://github.com/Oire

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	function plural(word, num) {
	    var forms = word.split('_');
	    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
	}
	function relativeTimeWithPlural(number, withoutSuffix, key) {
	    var format = {
	        'mm': withoutSuffix ? 'хвилина_хвилини_хвилин' : 'хвилину_хвилини_хвилин',
	        'hh': withoutSuffix ? 'година_години_годин' : 'годину_години_годин',
	        'dd': 'день_дні_днів',
	        'MM': 'місяць_місяці_місяців',
	        'yy': 'рік_роки_років'
	    };
	    if (key === 'm') {
	        return withoutSuffix ? 'хвилина' : 'хвилину';
	    }
	    else if (key === 'h') {
	        return withoutSuffix ? 'година' : 'годину';
	    }
	    else {
	        return number + ' ' + plural(format[key], +number);
	    }
	}
	function weekdaysCaseReplace(m, format) {
	    var weekdays = {
	        'nominative': 'неділя_понеділок_вівторок_середа_четвер_п’ятниця_субота'.split('_'),
	        'accusative': 'неділю_понеділок_вівторок_середу_четвер_п’ятницю_суботу'.split('_'),
	        'genitive': 'неділі_понеділка_вівторка_середи_четверга_п’ятниці_суботи'.split('_')
	    };

	    if (!m) {
	        return weekdays['nominative'];
	    }

	    var nounCase = (/(\[[ВвУу]\]) ?dddd/).test(format) ?
	        'accusative' :
	        ((/\[?(?:минулої|наступної)? ?\] ?dddd/).test(format) ?
	            'genitive' :
	            'nominative');
	    return weekdays[nounCase][m.day()];
	}
	function processHoursFunction(str) {
	    return function () {
	        return str + 'о' + (this.hours() === 11 ? 'б' : '') + '] LT';
	    };
	}

	var uk = moment.defineLocale('uk', {
	    months : {
	        'format': 'січня_лютого_березня_квітня_травня_червня_липня_серпня_вересня_жовтня_листопада_грудня'.split('_'),
	        'standalone': 'січень_лютий_березень_квітень_травень_червень_липень_серпень_вересень_жовтень_листопад_грудень'.split('_')
	    },
	    monthsShort : 'січ_лют_бер_квіт_трав_черв_лип_серп_вер_жовт_лист_груд'.split('_'),
	    weekdays : weekdaysCaseReplace,
	    weekdaysShort : 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
	    weekdaysMin : 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY р.',
	        LLL : 'D MMMM YYYY р., HH:mm',
	        LLLL : 'dddd, D MMMM YYYY р., HH:mm'
	    },
	    calendar : {
	        sameDay: processHoursFunction('[Сьогодні '),
	        nextDay: processHoursFunction('[Завтра '),
	        lastDay: processHoursFunction('[Вчора '),
	        nextWeek: processHoursFunction('[У] dddd ['),
	        lastWeek: function () {
	            switch (this.day()) {
	                case 0:
	                case 3:
	                case 5:
	                case 6:
	                    return processHoursFunction('[Минулої] dddd [').call(this);
	                case 1:
	                case 2:
	                case 4:
	                    return processHoursFunction('[Минулого] dddd [').call(this);
	            }
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'за %s',
	        past : '%s тому',
	        s : 'декілька секунд',
	        m : relativeTimeWithPlural,
	        mm : relativeTimeWithPlural,
	        h : 'годину',
	        hh : relativeTimeWithPlural,
	        d : 'день',
	        dd : relativeTimeWithPlural,
	        M : 'місяць',
	        MM : relativeTimeWithPlural,
	        y : 'рік',
	        yy : relativeTimeWithPlural
	    },
	    // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
	    meridiemParse: /ночі|ранку|дня|вечора/,
	    isPM: function (input) {
	        return /^(дня|вечора)$/.test(input);
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return 'ночі';
	        } else if (hour < 12) {
	            return 'ранку';
	        } else if (hour < 17) {
	            return 'дня';
	        } else {
	            return 'вечора';
	        }
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}-(й|го)/,
	    ordinal: function (number, period) {
	        switch (period) {
	            case 'M':
	            case 'd':
	            case 'DDD':
	            case 'w':
	            case 'W':
	                return number + '-й';
	            case 'D':
	                return number + '-го';
	            default:
	                return number;
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return uk;

	})));


/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Urdu [ur]
	//! author : Sawood Alam : https://github.com/ibnesayeed
	//! author : Zack : https://github.com/ZackVision

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var months = [
	    'جنوری',
	    'فروری',
	    'مارچ',
	    'اپریل',
	    'مئی',
	    'جون',
	    'جولائی',
	    'اگست',
	    'ستمبر',
	    'اکتوبر',
	    'نومبر',
	    'دسمبر'
	];
	var days = [
	    'اتوار',
	    'پیر',
	    'منگل',
	    'بدھ',
	    'جمعرات',
	    'جمعہ',
	    'ہفتہ'
	];

	var ur = moment.defineLocale('ur', {
	    months : months,
	    monthsShort : months,
	    weekdays : days,
	    weekdaysShort : days,
	    weekdaysMin : days,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd، D MMMM YYYY HH:mm'
	    },
	    meridiemParse: /صبح|شام/,
	    isPM : function (input) {
	        return 'شام' === input;
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 12) {
	            return 'صبح';
	        }
	        return 'شام';
	    },
	    calendar : {
	        sameDay : '[آج بوقت] LT',
	        nextDay : '[کل بوقت] LT',
	        nextWeek : 'dddd [بوقت] LT',
	        lastDay : '[گذشتہ روز بوقت] LT',
	        lastWeek : '[گذشتہ] dddd [بوقت] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s بعد',
	        past : '%s قبل',
	        s : 'چند سیکنڈ',
	        m : 'ایک منٹ',
	        mm : '%d منٹ',
	        h : 'ایک گھنٹہ',
	        hh : '%d گھنٹے',
	        d : 'ایک دن',
	        dd : '%d دن',
	        M : 'ایک ماہ',
	        MM : '%d ماہ',
	        y : 'ایک سال',
	        yy : '%d سال'
	    },
	    preparse: function (string) {
	        return string.replace(/،/g, ',');
	    },
	    postformat: function (string) {
	        return string.replace(/,/g, '،');
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return ur;

	})));


/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Uzbek [uz]
	//! author : Sardor Muminov : https://github.com/muminoff

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var uz = moment.defineLocale('uz', {
	    months : 'январ_феврал_март_апрел_май_июн_июл_август_сентябр_октябр_ноябр_декабр'.split('_'),
	    monthsShort : 'янв_фев_мар_апр_май_июн_июл_авг_сен_окт_ноя_дек'.split('_'),
	    weekdays : 'Якшанба_Душанба_Сешанба_Чоршанба_Пайшанба_Жума_Шанба'.split('_'),
	    weekdaysShort : 'Якш_Душ_Сеш_Чор_Пай_Жум_Шан'.split('_'),
	    weekdaysMin : 'Як_Ду_Се_Чо_Па_Жу_Ша'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'D MMMM YYYY, dddd HH:mm'
	    },
	    calendar : {
	        sameDay : '[Бугун соат] LT [да]',
	        nextDay : '[Эртага] LT [да]',
	        nextWeek : 'dddd [куни соат] LT [да]',
	        lastDay : '[Кеча соат] LT [да]',
	        lastWeek : '[Утган] dddd [куни соат] LT [да]',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'Якин %s ичида',
	        past : 'Бир неча %s олдин',
	        s : 'фурсат',
	        m : 'бир дакика',
	        mm : '%d дакика',
	        h : 'бир соат',
	        hh : '%d соат',
	        d : 'бир кун',
	        dd : '%d кун',
	        M : 'бир ой',
	        MM : '%d ой',
	        y : 'бир йил',
	        yy : '%d йил'
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return uz;

	})));


/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Uzbek Latin [uz-latn]
	//! author : Rasulbek Mirzayev : github.com/Rasulbeeek

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var uzLatn = moment.defineLocale('uz-latn', {
	    months : 'Yanvar_Fevral_Mart_Aprel_May_Iyun_Iyul_Avgust_Sentabr_Oktabr_Noyabr_Dekabr'.split('_'),
	    monthsShort : 'Yan_Fev_Mar_Apr_May_Iyun_Iyul_Avg_Sen_Okt_Noy_Dek'.split('_'),
	    weekdays : 'Yakshanba_Dushanba_Seshanba_Chorshanba_Payshanba_Juma_Shanba'.split('_'),
	    weekdaysShort : 'Yak_Dush_Sesh_Chor_Pay_Jum_Shan'.split('_'),
	    weekdaysMin : 'Ya_Du_Se_Cho_Pa_Ju_Sha'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'D MMMM YYYY, dddd HH:mm'
	    },
	    calendar : {
	        sameDay : '[Bugun soat] LT [da]',
	        nextDay : '[Ertaga] LT [da]',
	        nextWeek : 'dddd [kuni soat] LT [da]',
	        lastDay : '[Kecha soat] LT [da]',
	        lastWeek : '[O\'tgan] dddd [kuni soat] LT [da]',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'Yaqin %s ichida',
	        past : 'Bir necha %s oldin',
	        s : 'soniya',
	        m : 'bir daqiqa',
	        mm : '%d daqiqa',
	        h : 'bir soat',
	        hh : '%d soat',
	        d : 'bir kun',
	        dd : '%d kun',
	        M : 'bir oy',
	        MM : '%d oy',
	        y : 'bir yil',
	        yy : '%d yil'
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});

	return uzLatn;

	})));


/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Vietnamese [vi]
	//! author : Bang Nguyen : https://github.com/bangnk

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var vi = moment.defineLocale('vi', {
	    months : 'tháng 1_tháng 2_tháng 3_tháng 4_tháng 5_tháng 6_tháng 7_tháng 8_tháng 9_tháng 10_tháng 11_tháng 12'.split('_'),
	    monthsShort : 'Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'chủ nhật_thứ hai_thứ ba_thứ tư_thứ năm_thứ sáu_thứ bảy'.split('_'),
	    weekdaysShort : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
	    weekdaysMin : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
	    weekdaysParseExact : true,
	    meridiemParse: /sa|ch/i,
	    isPM : function (input) {
	        return /^ch$/i.test(input);
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours < 12) {
	            return isLower ? 'sa' : 'SA';
	        } else {
	            return isLower ? 'ch' : 'CH';
	        }
	    },
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM [năm] YYYY',
	        LLL : 'D MMMM [năm] YYYY HH:mm',
	        LLLL : 'dddd, D MMMM [năm] YYYY HH:mm',
	        l : 'DD/M/YYYY',
	        ll : 'D MMM YYYY',
	        lll : 'D MMM YYYY HH:mm',
	        llll : 'ddd, D MMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[Hôm nay lúc] LT',
	        nextDay: '[Ngày mai lúc] LT',
	        nextWeek: 'dddd [tuần tới lúc] LT',
	        lastDay: '[Hôm qua lúc] LT',
	        lastWeek: 'dddd [tuần rồi lúc] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : '%s tới',
	        past : '%s trước',
	        s : 'vài giây',
	        m : 'một phút',
	        mm : '%d phút',
	        h : 'một giờ',
	        hh : '%d giờ',
	        d : 'một ngày',
	        dd : '%d ngày',
	        M : 'một tháng',
	        MM : '%d tháng',
	        y : 'một năm',
	        yy : '%d năm'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}/,
	    ordinal : function (number) {
	        return number;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return vi;

	})));


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Pseudo [x-pseudo]
	//! author : Andrew Hood : https://github.com/andrewhood125

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var xPseudo = moment.defineLocale('x-pseudo', {
	    months : 'J~áñúá~rý_F~ébrú~árý_~Márc~h_Áp~ríl_~Máý_~Júñé~_Júl~ý_Áú~gúst~_Sép~témb~ér_Ó~ctób~ér_Ñ~óvém~bér_~Décé~mbér'.split('_'),
	    monthsShort : 'J~áñ_~Féb_~Már_~Ápr_~Máý_~Júñ_~Júl_~Áúg_~Sép_~Óct_~Ñóv_~Déc'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'S~úñdá~ý_Mó~ñdáý~_Túé~sdáý~_Wéd~ñésd~áý_T~húrs~dáý_~Fríd~áý_S~átúr~dáý'.split('_'),
	    weekdaysShort : 'S~úñ_~Móñ_~Túé_~Wéd_~Thú_~Frí_~Sát'.split('_'),
	    weekdaysMin : 'S~ú_Mó~_Tú_~Wé_T~h_Fr~_Sá'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[T~ódá~ý át] LT',
	        nextDay : '[T~ómó~rró~w át] LT',
	        nextWeek : 'dddd [át] LT',
	        lastDay : '[Ý~ést~érdá~ý át] LT',
	        lastWeek : '[L~ást] dddd [át] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'í~ñ %s',
	        past : '%s á~gó',
	        s : 'á ~féw ~sécó~ñds',
	        m : 'á ~míñ~úté',
	        mm : '%d m~íñú~tés',
	        h : 'á~ñ hó~úr',
	        hh : '%d h~óúrs',
	        d : 'á ~dáý',
	        dd : '%d d~áýs',
	        M : 'á ~móñ~th',
	        MM : '%d m~óñt~hs',
	        y : 'á ~ýéár',
	        yy : '%d ý~éárs'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? 'th' :
	            (b === 1) ? 'st' :
	            (b === 2) ? 'nd' :
	            (b === 3) ? 'rd' : 'th';
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return xPseudo;

	})));


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Yoruba Nigeria [yo]
	//! author : Atolagbe Abisoye : https://github.com/andela-batolagbe

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var yo = moment.defineLocale('yo', {
	    months : 'Sẹ́rẹ́_Èrèlè_Ẹrẹ̀nà_Ìgbé_Èbibi_Òkùdu_Agẹmo_Ògún_Owewe_Ọ̀wàrà_Bélú_Ọ̀pẹ̀̀'.split('_'),
	    monthsShort : 'Sẹ́r_Èrl_Ẹrn_Ìgb_Èbi_Òkù_Agẹ_Ògú_Owe_Ọ̀wà_Bél_Ọ̀pẹ̀̀'.split('_'),
	    weekdays : 'Àìkú_Ajé_Ìsẹ́gun_Ọjọ́rú_Ọjọ́bọ_Ẹtì_Àbámẹ́ta'.split('_'),
	    weekdaysShort : 'Àìk_Ajé_Ìsẹ́_Ọjr_Ọjb_Ẹtì_Àbá'.split('_'),
	    weekdaysMin : 'Àì_Aj_Ìs_Ọr_Ọb_Ẹt_Àb'.split('_'),
	    longDateFormat : {
	        LT : 'h:mm A',
	        LTS : 'h:mm:ss A',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY h:mm A',
	        LLLL : 'dddd, D MMMM YYYY h:mm A'
	    },
	    calendar : {
	        sameDay : '[Ònì ni] LT',
	        nextDay : '[Ọ̀la ni] LT',
	        nextWeek : 'dddd [Ọsẹ̀ tón\'bọ] [ni] LT',
	        lastDay : '[Àna ni] LT',
	        lastWeek : 'dddd [Ọsẹ̀ tólọ́] [ni] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'ní %s',
	        past : '%s kọjá',
	        s : 'ìsẹjú aayá die',
	        m : 'ìsẹjú kan',
	        mm : 'ìsẹjú %d',
	        h : 'wákati kan',
	        hh : 'wákati %d',
	        d : 'ọjọ́ kan',
	        dd : 'ọjọ́ %d',
	        M : 'osù kan',
	        MM : 'osù %d',
	        y : 'ọdún kan',
	        yy : 'ọdún %d'
	    },
	    dayOfMonthOrdinalParse : /ọjọ́\s\d{1,2}/,
	    ordinal : 'ọjọ́ %d',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4 // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return yo;

	})));


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Chinese (China) [zh-cn]
	//! author : suupic : https://github.com/suupic
	//! author : Zeno Zeng : https://github.com/zenozeng

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var zhCn = moment.defineLocale('zh-cn', {
	    months : '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
	    monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
	    weekdays : '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
	    weekdaysShort : '周日_周一_周二_周三_周四_周五_周六'.split('_'),
	    weekdaysMin : '日_一_二_三_四_五_六'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'YYYY年MMMD日',
	        LL : 'YYYY年MMMD日',
	        LLL : 'YYYY年MMMD日Ah点mm分',
	        LLLL : 'YYYY年MMMD日ddddAh点mm分',
	        l : 'YYYY年MMMD日',
	        ll : 'YYYY年MMMD日',
	        lll : 'YYYY年MMMD日 HH:mm',
	        llll : 'YYYY年MMMD日dddd HH:mm'
	    },
	    meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
	    meridiemHour: function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === '凌晨' || meridiem === '早上' ||
	                meridiem === '上午') {
	            return hour;
	        } else if (meridiem === '下午' || meridiem === '晚上') {
	            return hour + 12;
	        } else {
	            // '中午'
	            return hour >= 11 ? hour : hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        var hm = hour * 100 + minute;
	        if (hm < 600) {
	            return '凌晨';
	        } else if (hm < 900) {
	            return '早上';
	        } else if (hm < 1130) {
	            return '上午';
	        } else if (hm < 1230) {
	            return '中午';
	        } else if (hm < 1800) {
	            return '下午';
	        } else {
	            return '晚上';
	        }
	    },
	    calendar : {
	        sameDay : '[今天]LT',
	        nextDay : '[明天]LT',
	        nextWeek : '[下]ddddLT',
	        lastDay : '[昨天]LT',
	        lastWeek : '[上]ddddLT',
	        sameElse : 'L'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(日|月|周)/,
	    ordinal : function (number, period) {
	        switch (period) {
	            case 'd':
	            case 'D':
	            case 'DDD':
	                return number + '日';
	            case 'M':
	                return number + '月';
	            case 'w':
	            case 'W':
	                return number + '周';
	            default:
	                return number;
	        }
	    },
	    relativeTime : {
	        future : '%s内',
	        past : '%s前',
	        s : '几秒',
	        m : '1 分钟',
	        mm : '%d 分钟',
	        h : '1 小时',
	        hh : '%d 小时',
	        d : '1 天',
	        dd : '%d 天',
	        M : '1 个月',
	        MM : '%d 个月',
	        y : '1 年',
	        yy : '%d 年'
	    },
	    week : {
	        // GB/T 7408-1994《数据元和交换格式·信息交换·日期和时间表示法》与ISO 8601:1988等效
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});

	return zhCn;

	})));


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Chinese (Hong Kong) [zh-hk]
	//! author : Ben : https://github.com/ben-lin
	//! author : Chris Lam : https://github.com/hehachris
	//! author : Konstantin : https://github.com/skfd

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var zhHk = moment.defineLocale('zh-hk', {
	    months : '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
	    monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
	    weekdays : '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
	    weekdaysShort : '週日_週一_週二_週三_週四_週五_週六'.split('_'),
	    weekdaysMin : '日_一_二_三_四_五_六'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'YYYY年MMMD日',
	        LL : 'YYYY年MMMD日',
	        LLL : 'YYYY年MMMD日 HH:mm',
	        LLLL : 'YYYY年MMMD日dddd HH:mm',
	        l : 'YYYY年MMMD日',
	        ll : 'YYYY年MMMD日',
	        lll : 'YYYY年MMMD日 HH:mm',
	        llll : 'YYYY年MMMD日dddd HH:mm'
	    },
	    meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === '凌晨' || meridiem === '早上' || meridiem === '上午') {
	            return hour;
	        } else if (meridiem === '中午') {
	            return hour >= 11 ? hour : hour + 12;
	        } else if (meridiem === '下午' || meridiem === '晚上') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        var hm = hour * 100 + minute;
	        if (hm < 600) {
	            return '凌晨';
	        } else if (hm < 900) {
	            return '早上';
	        } else if (hm < 1130) {
	            return '上午';
	        } else if (hm < 1230) {
	            return '中午';
	        } else if (hm < 1800) {
	            return '下午';
	        } else {
	            return '晚上';
	        }
	    },
	    calendar : {
	        sameDay : '[今天]LT',
	        nextDay : '[明天]LT',
	        nextWeek : '[下]ddddLT',
	        lastDay : '[昨天]LT',
	        lastWeek : '[上]ddddLT',
	        sameElse : 'L'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(日|月|週)/,
	    ordinal : function (number, period) {
	        switch (period) {
	            case 'd' :
	            case 'D' :
	            case 'DDD' :
	                return number + '日';
	            case 'M' :
	                return number + '月';
	            case 'w' :
	            case 'W' :
	                return number + '週';
	            default :
	                return number;
	        }
	    },
	    relativeTime : {
	        future : '%s內',
	        past : '%s前',
	        s : '幾秒',
	        m : '1 分鐘',
	        mm : '%d 分鐘',
	        h : '1 小時',
	        hh : '%d 小時',
	        d : '1 天',
	        dd : '%d 天',
	        M : '1 個月',
	        MM : '%d 個月',
	        y : '1 年',
	        yy : '%d 年'
	    }
	});

	return zhHk;

	})));


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Chinese (Taiwan) [zh-tw]
	//! author : Ben : https://github.com/ben-lin
	//! author : Chris Lam : https://github.com/hehachris

	;(function (global, factory) {
	    true ? factory(__webpack_require__(77)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';


	var zhTw = moment.defineLocale('zh-tw', {
	    months : '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
	    monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
	    weekdays : '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
	    weekdaysShort : '週日_週一_週二_週三_週四_週五_週六'.split('_'),
	    weekdaysMin : '日_一_二_三_四_五_六'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'YYYY年MMMD日',
	        LL : 'YYYY年MMMD日',
	        LLL : 'YYYY年MMMD日 HH:mm',
	        LLLL : 'YYYY年MMMD日dddd HH:mm',
	        l : 'YYYY年MMMD日',
	        ll : 'YYYY年MMMD日',
	        lll : 'YYYY年MMMD日 HH:mm',
	        llll : 'YYYY年MMMD日dddd HH:mm'
	    },
	    meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === '凌晨' || meridiem === '早上' || meridiem === '上午') {
	            return hour;
	        } else if (meridiem === '中午') {
	            return hour >= 11 ? hour : hour + 12;
	        } else if (meridiem === '下午' || meridiem === '晚上') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        var hm = hour * 100 + minute;
	        if (hm < 600) {
	            return '凌晨';
	        } else if (hm < 900) {
	            return '早上';
	        } else if (hm < 1130) {
	            return '上午';
	        } else if (hm < 1230) {
	            return '中午';
	        } else if (hm < 1800) {
	            return '下午';
	        } else {
	            return '晚上';
	        }
	    },
	    calendar : {
	        sameDay : '[今天]LT',
	        nextDay : '[明天]LT',
	        nextWeek : '[下]ddddLT',
	        lastDay : '[昨天]LT',
	        lastWeek : '[上]ddddLT',
	        sameElse : 'L'
	    },
	    dayOfMonthOrdinalParse: /\d{1,2}(日|月|週)/,
	    ordinal : function (number, period) {
	        switch (period) {
	            case 'd' :
	            case 'D' :
	            case 'DDD' :
	                return number + '日';
	            case 'M' :
	                return number + '月';
	            case 'w' :
	            case 'W' :
	                return number + '週';
	            default :
	                return number;
	        }
	    },
	    relativeTime : {
	        future : '%s內',
	        past : '%s前',
	        s : '幾秒',
	        m : '1 分鐘',
	        mm : '%d 分鐘',
	        h : '1 小時',
	        hh : '%d 小時',
	        d : '1 天',
	        dd : '%d 天',
	        M : '1 個月',
	        MM : '%d 個月',
	        y : '1 年',
	        yy : '%d 年'
	    }
	});

	return zhTw;

	})));


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var defaults = __webpack_require__(40);
	var elements = __webpack_require__(53);
	var helpers = __webpack_require__(41);

	defaults._set('bar', {
		hover: {
			mode: 'label'
		},

		scales: {
			xAxes: [{
				type: 'category',

				// Specific to Bar Controller
				categoryPercentage: 0.8,
				barPercentage: 0.9,

				// offset settings
				offset: true,

				// grid line settings
				gridLines: {
					offsetGridLines: true
				}
			}],

			yAxes: [{
				type: 'linear'
			}]
		}
	});

	defaults._set('horizontalBar', {
		hover: {
			mode: 'index',
			axis: 'y'
		},

		scales: {
			xAxes: [{
				type: 'linear',
				position: 'bottom'
			}],

			yAxes: [{
				position: 'left',
				type: 'category',

				// Specific to Horizontal Bar Controller
				categoryPercentage: 0.8,
				barPercentage: 0.9,

				// offset settings
				offset: true,

				// grid line settings
				gridLines: {
					offsetGridLines: true
				}
			}]
		},

		elements: {
			rectangle: {
				borderSkipped: 'left'
			}
		},

		tooltips: {
			callbacks: {
				title: function(item, data) {
					// Pick first xLabel for now
					var title = '';

					if (item.length > 0) {
						if (item[0].yLabel) {
							title = item[0].yLabel;
						} else if (data.labels.length > 0 && item[0].index < data.labels.length) {
							title = data.labels[item[0].index];
						}
					}

					return title;
				},

				label: function(item, data) {
					var datasetLabel = data.datasets[item.datasetIndex].label || '';
					return datasetLabel + ': ' + item.xLabel;
				}
			},
			mode: 'index',
			axis: 'y'
		}
	});

	module.exports = function(Chart) {

		Chart.controllers.bar = Chart.DatasetController.extend({

			dataElementType: elements.Rectangle,

			initialize: function() {
				var me = this;
				var meta;

				Chart.DatasetController.prototype.initialize.apply(me, arguments);

				meta = me.getMeta();
				meta.stack = me.getDataset().stack;
				meta.bar = true;
			},

			update: function(reset) {
				var me = this;
				var rects = me.getMeta().data;
				var i, ilen;

				me._ruler = me.getRuler();

				for (i = 0, ilen = rects.length; i < ilen; ++i) {
					me.updateElement(rects[i], i, reset);
				}
			},

			updateElement: function(rectangle, index, reset) {
				var me = this;
				var chart = me.chart;
				var meta = me.getMeta();
				var dataset = me.getDataset();
				var custom = rectangle.custom || {};
				var rectangleOptions = chart.options.elements.rectangle;

				rectangle._xScale = me.getScaleForId(meta.xAxisID);
				rectangle._yScale = me.getScaleForId(meta.yAxisID);
				rectangle._datasetIndex = me.index;
				rectangle._index = index;

				rectangle._model = {
					datasetLabel: dataset.label,
					label: chart.data.labels[index],
					borderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleOptions.borderSkipped,
					backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.backgroundColor, index, rectangleOptions.backgroundColor),
					borderColor: custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.borderColor, index, rectangleOptions.borderColor),
					borderWidth: custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.borderWidth, index, rectangleOptions.borderWidth)
				};

				me.updateElementGeometry(rectangle, index, reset);

				rectangle.pivot();
			},

			/**
			 * @private
			 */
			updateElementGeometry: function(rectangle, index, reset) {
				var me = this;
				var model = rectangle._model;
				var vscale = me.getValueScale();
				var base = vscale.getBasePixel();
				var horizontal = vscale.isHorizontal();
				var ruler = me._ruler || me.getRuler();
				var vpixels = me.calculateBarValuePixels(me.index, index);
				var ipixels = me.calculateBarIndexPixels(me.index, index, ruler);

				model.horizontal = horizontal;
				model.base = reset ? base : vpixels.base;
				model.x = horizontal ? reset ? base : vpixels.head : ipixels.center;
				model.y = horizontal ? ipixels.center : reset ? base : vpixels.head;
				model.height = horizontal ? ipixels.size : undefined;
				model.width = horizontal ? undefined : ipixels.size;
			},

			/**
			 * @private
			 */
			getValueScaleId: function() {
				return this.getMeta().yAxisID;
			},

			/**
			 * @private
			 */
			getIndexScaleId: function() {
				return this.getMeta().xAxisID;
			},

			/**
			 * @private
			 */
			getValueScale: function() {
				return this.getScaleForId(this.getValueScaleId());
			},

			/**
			 * @private
			 */
			getIndexScale: function() {
				return this.getScaleForId(this.getIndexScaleId());
			},

			/**
			 * Returns the effective number of stacks based on groups and bar visibility.
			 * @private
			 */
			getStackCount: function(last) {
				var me = this;
				var chart = me.chart;
				var scale = me.getIndexScale();
				var stacked = scale.options.stacked;
				var ilen = last === undefined ? chart.data.datasets.length : last + 1;
				var stacks = [];
				var i, meta;

				for (i = 0; i < ilen; ++i) {
					meta = chart.getDatasetMeta(i);
					if (meta.bar && chart.isDatasetVisible(i) &&
						(stacked === false ||
						(stacked === true && stacks.indexOf(meta.stack) === -1) ||
						(stacked === undefined && (meta.stack === undefined || stacks.indexOf(meta.stack) === -1)))) {
						stacks.push(meta.stack);
					}
				}

				return stacks.length;
			},

			/**
			 * Returns the stack index for the given dataset based on groups and bar visibility.
			 * @private
			 */
			getStackIndex: function(datasetIndex) {
				return this.getStackCount(datasetIndex) - 1;
			},

			/**
			 * @private
			 */
			getRuler: function() {
				var me = this;
				var scale = me.getIndexScale();
				var stackCount = me.getStackCount();
				var datasetIndex = me.index;
				var pixels = [];
				var isHorizontal = scale.isHorizontal();
				var start = isHorizontal ? scale.left : scale.top;
				var end = start + (isHorizontal ? scale.width : scale.height);
				var i, ilen;

				for (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {
					pixels.push(scale.getPixelForValue(null, i, datasetIndex));
				}

				return {
					pixels: pixels,
					start: start,
					end: end,
					stackCount: stackCount,
					scale: scale
				};
			},

			/**
			 * Note: pixel values are not clamped to the scale area.
			 * @private
			 */
			calculateBarValuePixels: function(datasetIndex, index) {
				var me = this;
				var chart = me.chart;
				var meta = me.getMeta();
				var scale = me.getValueScale();
				var datasets = chart.data.datasets;
				var value = scale.getRightValue(datasets[datasetIndex].data[index]);
				var stacked = scale.options.stacked;
				var stack = meta.stack;
				var start = 0;
				var i, imeta, ivalue, base, head, size;

				if (stacked || (stacked === undefined && stack !== undefined)) {
					for (i = 0; i < datasetIndex; ++i) {
						imeta = chart.getDatasetMeta(i);

						if (imeta.bar &&
							imeta.stack === stack &&
							imeta.controller.getValueScaleId() === scale.id &&
							chart.isDatasetVisible(i)) {

							ivalue = scale.getRightValue(datasets[i].data[index]);
							if ((value < 0 && ivalue < 0) || (value >= 0 && ivalue > 0)) {
								start += ivalue;
							}
						}
					}
				}

				base = scale.getPixelForValue(start);
				head = scale.getPixelForValue(start + value);
				size = (head - base) / 2;

				return {
					size: size,
					base: base,
					head: head,
					center: head + size / 2
				};
			},

			/**
			 * @private
			 */
			calculateBarIndexPixels: function(datasetIndex, index, ruler) {
				var me = this;
				var options = ruler.scale.options;
				var stackIndex = me.getStackIndex(datasetIndex);
				var pixels = ruler.pixels;
				var base = pixels[index];
				var length = pixels.length;
				var start = ruler.start;
				var end = ruler.end;
				var leftSampleSize, rightSampleSize, leftCategorySize, rightCategorySize, fullBarSize, size;

				if (length === 1) {
					leftSampleSize = base > start ? base - start : end - base;
					rightSampleSize = base < end ? end - base : base - start;
				} else {
					if (index > 0) {
						leftSampleSize = (base - pixels[index - 1]) / 2;
						if (index === length - 1) {
							rightSampleSize = leftSampleSize;
						}
					}
					if (index < length - 1) {
						rightSampleSize = (pixels[index + 1] - base) / 2;
						if (index === 0) {
							leftSampleSize = rightSampleSize;
						}
					}
				}

				leftCategorySize = leftSampleSize * options.categoryPercentage;
				rightCategorySize = rightSampleSize * options.categoryPercentage;
				fullBarSize = (leftCategorySize + rightCategorySize) / ruler.stackCount;
				size = fullBarSize * options.barPercentage;

				size = Math.min(
					helpers.valueOrDefault(options.barThickness, size),
					helpers.valueOrDefault(options.maxBarThickness, Infinity));

				base -= leftCategorySize;
				base += fullBarSize * stackIndex;
				base += (fullBarSize - size) / 2;

				return {
					size: size,
					base: base,
					head: base + size,
					center: base + size / 2
				};
			},

			draw: function() {
				var me = this;
				var chart = me.chart;
				var scale = me.getValueScale();
				var rects = me.getMeta().data;
				var dataset = me.getDataset();
				var ilen = rects.length;
				var i = 0;

				helpers.canvas.clipArea(chart.ctx, chart.chartArea);

				for (; i < ilen; ++i) {
					if (!isNaN(scale.getRightValue(dataset.data[i]))) {
						rects[i].draw();
					}
				}

				helpers.canvas.unclipArea(chart.ctx);
			},

			setHoverStyle: function(rectangle) {
				var dataset = this.chart.data.datasets[rectangle._datasetIndex];
				var index = rectangle._index;
				var custom = rectangle.custom || {};
				var model = rectangle._model;

				model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.valueAtIndexOrDefault(dataset.hoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
				model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.valueAtIndexOrDefault(dataset.hoverBorderColor, index, helpers.getHoverColor(model.borderColor));
				model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.valueAtIndexOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);
			},

			removeHoverStyle: function(rectangle) {
				var dataset = this.chart.data.datasets[rectangle._datasetIndex];
				var index = rectangle._index;
				var custom = rectangle.custom || {};
				var model = rectangle._model;
				var rectangleElementOptions = this.chart.options.elements.rectangle;

				model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor);
				model.borderColor = custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor);
				model.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth);
			}
		});

		Chart.controllers.horizontalBar = Chart.controllers.bar.extend({
			/**
			 * @private
			 */
			getValueScaleId: function() {
				return this.getMeta().xAxisID;
			},

			/**
			 * @private
			 */
			getIndexScaleId: function() {
				return this.getMeta().yAxisID;
			}
		});
	};


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var defaults = __webpack_require__(40);
	var elements = __webpack_require__(53);
	var helpers = __webpack_require__(41);

	defaults._set('bubble', {
		hover: {
			mode: 'single'
		},

		scales: {
			xAxes: [{
				type: 'linear', // bubble should probably use a linear scale by default
				position: 'bottom',
				id: 'x-axis-0' // need an ID so datasets can reference the scale
			}],
			yAxes: [{
				type: 'linear',
				position: 'left',
				id: 'y-axis-0'
			}]
		},

		tooltips: {
			callbacks: {
				title: function() {
					// Title doesn't make sense for scatter since we format the data as a point
					return '';
				},
				label: function(item, data) {
					var datasetLabel = data.datasets[item.datasetIndex].label || '';
					var dataPoint = data.datasets[item.datasetIndex].data[item.index];
					return datasetLabel + ': (' + item.xLabel + ', ' + item.yLabel + ', ' + dataPoint.r + ')';
				}
			}
		}
	});


	module.exports = function(Chart) {

		Chart.controllers.bubble = Chart.DatasetController.extend({
			/**
			 * @protected
			 */
			dataElementType: elements.Point,

			/**
			 * @protected
			 */
			update: function(reset) {
				var me = this;
				var meta = me.getMeta();
				var points = meta.data;

				// Update Points
				helpers.each(points, function(point, index) {
					me.updateElement(point, index, reset);
				});
			},

			/**
			 * @protected
			 */
			updateElement: function(point, index, reset) {
				var me = this;
				var meta = me.getMeta();
				var custom = point.custom || {};
				var xScale = me.getScaleForId(meta.xAxisID);
				var yScale = me.getScaleForId(meta.yAxisID);
				var options = me._resolveElementOptions(point, index);
				var data = me.getDataset().data[index];
				var dsIndex = me.index;

				var x = reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === 'object' ? data : NaN, index, dsIndex);
				var y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex);

				point._xScale = xScale;
				point._yScale = yScale;
				point._options = options;
				point._datasetIndex = dsIndex;
				point._index = index;
				point._model = {
					backgroundColor: options.backgroundColor,
					borderColor: options.borderColor,
					borderWidth: options.borderWidth,
					hitRadius: options.hitRadius,
					pointStyle: options.pointStyle,
					radius: reset ? 0 : options.radius,
					skip: custom.skip || isNaN(x) || isNaN(y),
					x: x,
					y: y,
				};

				point.pivot();
			},

			/**
			 * @protected
			 */
			setHoverStyle: function(point) {
				var model = point._model;
				var options = point._options;

				model.backgroundColor = helpers.valueOrDefault(options.hoverBackgroundColor, helpers.getHoverColor(options.backgroundColor));
				model.borderColor = helpers.valueOrDefault(options.hoverBorderColor, helpers.getHoverColor(options.borderColor));
				model.borderWidth = helpers.valueOrDefault(options.hoverBorderWidth, options.borderWidth);
				model.radius = options.radius + options.hoverRadius;
			},

			/**
			 * @protected
			 */
			removeHoverStyle: function(point) {
				var model = point._model;
				var options = point._options;

				model.backgroundColor = options.backgroundColor;
				model.borderColor = options.borderColor;
				model.borderWidth = options.borderWidth;
				model.radius = options.radius;
			},

			/**
			 * @private
			 */
			_resolveElementOptions: function(point, index) {
				var me = this;
				var chart = me.chart;
				var datasets = chart.data.datasets;
				var dataset = datasets[me.index];
				var custom = point.custom || {};
				var options = chart.options.elements.point;
				var resolve = helpers.options.resolve;
				var data = dataset.data[index];
				var values = {};
				var i, ilen, key;

				// Scriptable options
				var context = {
					chart: chart,
					dataIndex: index,
					dataset: dataset,
					datasetIndex: me.index
				};

				var keys = [
					'backgroundColor',
					'borderColor',
					'borderWidth',
					'hoverBackgroundColor',
					'hoverBorderColor',
					'hoverBorderWidth',
					'hoverRadius',
					'hitRadius',
					'pointStyle'
				];

				for (i = 0, ilen = keys.length; i < ilen; ++i) {
					key = keys[i];
					values[key] = resolve([
						custom[key],
						dataset[key],
						options[key]
					], context, index);
				}

				// Custom radius resolution
				values.radius = resolve([
					custom.radius,
					data ? data.r : undefined,
					dataset.radius,
					options.radius
				], context, index);

				return values;
			}
		});
	};


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var defaults = __webpack_require__(40);
	var elements = __webpack_require__(53);
	var helpers = __webpack_require__(41);

	defaults._set('doughnut', {
		animation: {
			// Boolean - Whether we animate the rotation of the Doughnut
			animateRotate: true,
			// Boolean - Whether we animate scaling the Doughnut from the centre
			animateScale: false
		},
		hover: {
			mode: 'single'
		},
		legendCallback: function(chart) {
			var text = [];
			text.push('<ul class="' + chart.id + '-legend">');

			var data = chart.data;
			var datasets = data.datasets;
			var labels = data.labels;

			if (datasets.length) {
				for (var i = 0; i < datasets[0].data.length; ++i) {
					text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');
					if (labels[i]) {
						text.push(labels[i]);
					}
					text.push('</li>');
				}
			}

			text.push('</ul>');
			return text.join('');
		},
		legend: {
			labels: {
				generateLabels: function(chart) {
					var data = chart.data;
					if (data.labels.length && data.datasets.length) {
						return data.labels.map(function(label, i) {
							var meta = chart.getDatasetMeta(0);
							var ds = data.datasets[0];
							var arc = meta.data[i];
							var custom = arc && arc.custom || {};
							var valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
							var arcOpts = chart.options.elements.arc;
							var fill = custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);
							var stroke = custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);
							var bw = custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);

							return {
								text: label,
								fillStyle: fill,
								strokeStyle: stroke,
								lineWidth: bw,
								hidden: isNaN(ds.data[i]) || meta.data[i].hidden,

								// Extra data used for toggling the correct item
								index: i
							};
						});
					}
					return [];
				}
			},

			onClick: function(e, legendItem) {
				var index = legendItem.index;
				var chart = this.chart;
				var i, ilen, meta;

				for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
					meta = chart.getDatasetMeta(i);
					// toggle visibility of index if exists
					if (meta.data[index]) {
						meta.data[index].hidden = !meta.data[index].hidden;
					}
				}

				chart.update();
			}
		},

		// The percentage of the chart that we cut out of the middle.
		cutoutPercentage: 50,

		// The rotation of the chart, where the first data arc begins.
		rotation: Math.PI * -0.5,

		// The total circumference of the chart.
		circumference: Math.PI * 2.0,

		// Need to override these to give a nice default
		tooltips: {
			callbacks: {
				title: function() {
					return '';
				},
				label: function(tooltipItem, data) {
					var dataLabel = data.labels[tooltipItem.index];
					var value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];

					if (helpers.isArray(dataLabel)) {
						// show value on first line of multiline label
						// need to clone because we are changing the value
						dataLabel = dataLabel.slice();
						dataLabel[0] += value;
					} else {
						dataLabel += value;
					}

					return dataLabel;
				}
			}
		}
	});

	defaults._set('pie', helpers.clone(defaults.doughnut));
	defaults._set('pie', {
		cutoutPercentage: 0
	});

	module.exports = function(Chart) {

		Chart.controllers.doughnut = Chart.controllers.pie = Chart.DatasetController.extend({

			dataElementType: elements.Arc,

			linkScales: helpers.noop,

			// Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly
			getRingIndex: function(datasetIndex) {
				var ringIndex = 0;

				for (var j = 0; j < datasetIndex; ++j) {
					if (this.chart.isDatasetVisible(j)) {
						++ringIndex;
					}
				}

				return ringIndex;
			},

			update: function(reset) {
				var me = this;
				var chart = me.chart;
				var chartArea = chart.chartArea;
				var opts = chart.options;
				var arcOpts = opts.elements.arc;
				var availableWidth = chartArea.right - chartArea.left - arcOpts.borderWidth;
				var availableHeight = chartArea.bottom - chartArea.top - arcOpts.borderWidth;
				var minSize = Math.min(availableWidth, availableHeight);
				var offset = {x: 0, y: 0};
				var meta = me.getMeta();
				var cutoutPercentage = opts.cutoutPercentage;
				var circumference = opts.circumference;

				// If the chart's circumference isn't a full circle, calculate minSize as a ratio of the width/height of the arc
				if (circumference < Math.PI * 2.0) {
					var startAngle = opts.rotation % (Math.PI * 2.0);
					startAngle += Math.PI * 2.0 * (startAngle >= Math.PI ? -1 : startAngle < -Math.PI ? 1 : 0);
					var endAngle = startAngle + circumference;
					var start = {x: Math.cos(startAngle), y: Math.sin(startAngle)};
					var end = {x: Math.cos(endAngle), y: Math.sin(endAngle)};
					var contains0 = (startAngle <= 0 && endAngle >= 0) || (startAngle <= Math.PI * 2.0 && Math.PI * 2.0 <= endAngle);
					var contains90 = (startAngle <= Math.PI * 0.5 && Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 2.5 && Math.PI * 2.5 <= endAngle);
					var contains180 = (startAngle <= -Math.PI && -Math.PI <= endAngle) || (startAngle <= Math.PI && Math.PI <= endAngle);
					var contains270 = (startAngle <= -Math.PI * 0.5 && -Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 1.5 && Math.PI * 1.5 <= endAngle);
					var cutout = cutoutPercentage / 100.0;
					var min = {x: contains180 ? -1 : Math.min(start.x * (start.x < 0 ? 1 : cutout), end.x * (end.x < 0 ? 1 : cutout)), y: contains270 ? -1 : Math.min(start.y * (start.y < 0 ? 1 : cutout), end.y * (end.y < 0 ? 1 : cutout))};
					var max = {x: contains0 ? 1 : Math.max(start.x * (start.x > 0 ? 1 : cutout), end.x * (end.x > 0 ? 1 : cutout)), y: contains90 ? 1 : Math.max(start.y * (start.y > 0 ? 1 : cutout), end.y * (end.y > 0 ? 1 : cutout))};
					var size = {width: (max.x - min.x) * 0.5, height: (max.y - min.y) * 0.5};
					minSize = Math.min(availableWidth / size.width, availableHeight / size.height);
					offset = {x: (max.x + min.x) * -0.5, y: (max.y + min.y) * -0.5};
				}

				chart.borderWidth = me.getMaxBorderWidth(meta.data);
				chart.outerRadius = Math.max((minSize - chart.borderWidth) / 2, 0);
				chart.innerRadius = Math.max(cutoutPercentage ? (chart.outerRadius / 100) * (cutoutPercentage) : 0, 0);
				chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
				chart.offsetX = offset.x * chart.outerRadius;
				chart.offsetY = offset.y * chart.outerRadius;

				meta.total = me.calculateTotal();

				me.outerRadius = chart.outerRadius - (chart.radiusLength * me.getRingIndex(me.index));
				me.innerRadius = Math.max(me.outerRadius - chart.radiusLength, 0);

				helpers.each(meta.data, function(arc, index) {
					me.updateElement(arc, index, reset);
				});
			},

			updateElement: function(arc, index, reset) {
				var me = this;
				var chart = me.chart;
				var chartArea = chart.chartArea;
				var opts = chart.options;
				var animationOpts = opts.animation;
				var centerX = (chartArea.left + chartArea.right) / 2;
				var centerY = (chartArea.top + chartArea.bottom) / 2;
				var startAngle = opts.rotation; // non reset case handled later
				var endAngle = opts.rotation; // non reset case handled later
				var dataset = me.getDataset();
				var circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI));
				var innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius;
				var outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius;
				var valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;

				helpers.extend(arc, {
					// Utility
					_datasetIndex: me.index,
					_index: index,

					// Desired view properties
					_model: {
						x: centerX + chart.offsetX,
						y: centerY + chart.offsetY,
						startAngle: startAngle,
						endAngle: endAngle,
						circumference: circumference,
						outerRadius: outerRadius,
						innerRadius: innerRadius,
						label: valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])
					}
				});

				var model = arc._model;
				// Resets the visual styles
				this.removeHoverStyle(arc);

				// Set correct angles if not resetting
				if (!reset || !animationOpts.animateRotate) {
					if (index === 0) {
						model.startAngle = opts.rotation;
					} else {
						model.startAngle = me.getMeta().data[index - 1]._model.endAngle;
					}

					model.endAngle = model.startAngle + model.circumference;
				}

				arc.pivot();
			},

			removeHoverStyle: function(arc) {
				Chart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);
			},

			calculateTotal: function() {
				var dataset = this.getDataset();
				var meta = this.getMeta();
				var total = 0;
				var value;

				helpers.each(meta.data, function(element, index) {
					value = dataset.data[index];
					if (!isNaN(value) && !element.hidden) {
						total += Math.abs(value);
					}
				});

				/* if (total === 0) {
					total = NaN;
				}*/

				return total;
			},

			calculateCircumference: function(value) {
				var total = this.getMeta().total;
				if (total > 0 && !isNaN(value)) {
					return (Math.PI * 2.0) * (value / total);
				}
				return 0;
			},

			// gets the max border or hover width to properly scale pie charts
			getMaxBorderWidth: function(arcs) {
				var max = 0;
				var index = this.index;
				var length = arcs.length;
				var borderWidth;
				var hoverWidth;

				for (var i = 0; i < length; i++) {
					borderWidth = arcs[i]._model ? arcs[i]._model.borderWidth : 0;
					hoverWidth = arcs[i]._chart ? arcs[i]._chart.config.data.datasets[index].hoverBorderWidth : 0;

					max = borderWidth > max ? borderWidth : max;
					max = hoverWidth > max ? hoverWidth : max;
				}
				return max;
			}
		});
	};


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var defaults = __webpack_require__(40);
	var elements = __webpack_require__(53);
	var helpers = __webpack_require__(41);

	defaults._set('line', {
		showLines: true,
		spanGaps: false,

		hover: {
			mode: 'label'
		},

		scales: {
			xAxes: [{
				type: 'category',
				id: 'x-axis-0'
			}],
			yAxes: [{
				type: 'linear',
				id: 'y-axis-0'
			}]
		}
	});

	module.exports = function(Chart) {

		function lineEnabled(dataset, options) {
			return helpers.valueOrDefault(dataset.showLine, options.showLines);
		}

		Chart.controllers.line = Chart.DatasetController.extend({

			datasetElementType: elements.Line,

			dataElementType: elements.Point,

			update: function(reset) {
				var me = this;
				var meta = me.getMeta();
				var line = meta.dataset;
				var points = meta.data || [];
				var options = me.chart.options;
				var lineElementOptions = options.elements.line;
				var scale = me.getScaleForId(meta.yAxisID);
				var i, ilen, custom;
				var dataset = me.getDataset();
				var showLine = lineEnabled(dataset, options);

				// Update Line
				if (showLine) {
					custom = line.custom || {};

					// Compatibility: If the properties are defined with only the old name, use those values
					if ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {
						dataset.lineTension = dataset.tension;
					}

					// Utility
					line._scale = scale;
					line._datasetIndex = me.index;
					// Data
					line._children = points;
					// Model
					line._model = {
						// Appearance
						// The default behavior of lines is to break at null values, according
						// to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158
						// This option gives lines the ability to span gaps
						spanGaps: dataset.spanGaps ? dataset.spanGaps : options.spanGaps,
						tension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, lineElementOptions.tension),
						backgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),
						borderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),
						borderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),
						borderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),
						borderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),
						borderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),
						borderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),
						fill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),
						steppedLine: custom.steppedLine ? custom.steppedLine : helpers.valueOrDefault(dataset.steppedLine, lineElementOptions.stepped),
						cubicInterpolationMode: custom.cubicInterpolationMode ? custom.cubicInterpolationMode : helpers.valueOrDefault(dataset.cubicInterpolationMode, lineElementOptions.cubicInterpolationMode),
					};

					line.pivot();
				}

				// Update Points
				for (i = 0, ilen = points.length; i < ilen; ++i) {
					me.updateElement(points[i], i, reset);
				}

				if (showLine && line._model.tension !== 0) {
					me.updateBezierControlPoints();
				}

				// Now pivot the point for animation
				for (i = 0, ilen = points.length; i < ilen; ++i) {
					points[i].pivot();
				}
			},

			getPointBackgroundColor: function(point, index) {
				var backgroundColor = this.chart.options.elements.point.backgroundColor;
				var dataset = this.getDataset();
				var custom = point.custom || {};

				if (custom.backgroundColor) {
					backgroundColor = custom.backgroundColor;
				} else if (dataset.pointBackgroundColor) {
					backgroundColor = helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, backgroundColor);
				} else if (dataset.backgroundColor) {
					backgroundColor = dataset.backgroundColor;
				}

				return backgroundColor;
			},

			getPointBorderColor: function(point, index) {
				var borderColor = this.chart.options.elements.point.borderColor;
				var dataset = this.getDataset();
				var custom = point.custom || {};

				if (custom.borderColor) {
					borderColor = custom.borderColor;
				} else if (dataset.pointBorderColor) {
					borderColor = helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, borderColor);
				} else if (dataset.borderColor) {
					borderColor = dataset.borderColor;
				}

				return borderColor;
			},

			getPointBorderWidth: function(point, index) {
				var borderWidth = this.chart.options.elements.point.borderWidth;
				var dataset = this.getDataset();
				var custom = point.custom || {};

				if (!isNaN(custom.borderWidth)) {
					borderWidth = custom.borderWidth;
				} else if (!isNaN(dataset.pointBorderWidth) || helpers.isArray(dataset.pointBorderWidth)) {
					borderWidth = helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, borderWidth);
				} else if (!isNaN(dataset.borderWidth)) {
					borderWidth = dataset.borderWidth;
				}

				return borderWidth;
			},

			updateElement: function(point, index, reset) {
				var me = this;
				var meta = me.getMeta();
				var custom = point.custom || {};
				var dataset = me.getDataset();
				var datasetIndex = me.index;
				var value = dataset.data[index];
				var yScale = me.getScaleForId(meta.yAxisID);
				var xScale = me.getScaleForId(meta.xAxisID);
				var pointOptions = me.chart.options.elements.point;
				var x, y;

				// Compatibility: If the properties are defined with only the old name, use those values
				if ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {
					dataset.pointRadius = dataset.radius;
				}
				if ((dataset.hitRadius !== undefined) && (dataset.pointHitRadius === undefined)) {
					dataset.pointHitRadius = dataset.hitRadius;
				}

				x = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex);
				y = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);

				// Utility
				point._xScale = xScale;
				point._yScale = yScale;
				point._datasetIndex = datasetIndex;
				point._index = index;

				// Desired view properties
				point._model = {
					x: x,
					y: y,
					skip: custom.skip || isNaN(x) || isNaN(y),
					// Appearance
					radius: custom.radius || helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointOptions.radius),
					pointStyle: custom.pointStyle || helpers.valueAtIndexOrDefault(dataset.pointStyle, index, pointOptions.pointStyle),
					backgroundColor: me.getPointBackgroundColor(point, index),
					borderColor: me.getPointBorderColor(point, index),
					borderWidth: me.getPointBorderWidth(point, index),
					tension: meta.dataset._model ? meta.dataset._model.tension : 0,
					steppedLine: meta.dataset._model ? meta.dataset._model.steppedLine : false,
					// Tooltip
					hitRadius: custom.hitRadius || helpers.valueAtIndexOrDefault(dataset.pointHitRadius, index, pointOptions.hitRadius)
				};
			},

			calculatePointY: function(value, index, datasetIndex) {
				var me = this;
				var chart = me.chart;
				var meta = me.getMeta();
				var yScale = me.getScaleForId(meta.yAxisID);
				var sumPos = 0;
				var sumNeg = 0;
				var i, ds, dsMeta;

				if (yScale.options.stacked) {
					for (i = 0; i < datasetIndex; i++) {
						ds = chart.data.datasets[i];
						dsMeta = chart.getDatasetMeta(i);
						if (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {
							var stackedRightValue = Number(yScale.getRightValue(ds.data[index]));
							if (stackedRightValue < 0) {
								sumNeg += stackedRightValue || 0;
							} else {
								sumPos += stackedRightValue || 0;
							}
						}
					}

					var rightValue = Number(yScale.getRightValue(value));
					if (rightValue < 0) {
						return yScale.getPixelForValue(sumNeg + rightValue);
					}
					return yScale.getPixelForValue(sumPos + rightValue);
				}

				return yScale.getPixelForValue(value);
			},

			updateBezierControlPoints: function() {
				var me = this;
				var meta = me.getMeta();
				var area = me.chart.chartArea;
				var points = (meta.data || []);
				var i, ilen, point, model, controlPoints;

				// Only consider points that are drawn in case the spanGaps option is used
				if (meta.dataset._model.spanGaps) {
					points = points.filter(function(pt) {
						return !pt._model.skip;
					});
				}

				function capControlPoint(pt, min, max) {
					return Math.max(Math.min(pt, max), min);
				}

				if (meta.dataset._model.cubicInterpolationMode === 'monotone') {
					helpers.splineCurveMonotone(points);
				} else {
					for (i = 0, ilen = points.length; i < ilen; ++i) {
						point = points[i];
						model = point._model;
						controlPoints = helpers.splineCurve(
							helpers.previousItem(points, i)._model,
							model,
							helpers.nextItem(points, i)._model,
							meta.dataset._model.tension
						);
						model.controlPointPreviousX = controlPoints.previous.x;
						model.controlPointPreviousY = controlPoints.previous.y;
						model.controlPointNextX = controlPoints.next.x;
						model.controlPointNextY = controlPoints.next.y;
					}
				}

				if (me.chart.options.elements.line.capBezierPoints) {
					for (i = 0, ilen = points.length; i < ilen; ++i) {
						model = points[i]._model;
						model.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);
						model.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);
						model.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);
						model.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);
					}
				}
			},

			draw: function() {
				var me = this;
				var chart = me.chart;
				var meta = me.getMeta();
				var points = meta.data || [];
				var area = chart.chartArea;
				var ilen = points.length;
				var i = 0;

				helpers.canvas.clipArea(chart.ctx, area);

				if (lineEnabled(me.getDataset(), chart.options)) {
					meta.dataset.draw();
				}

				helpers.canvas.unclipArea(chart.ctx);

				// Draw the points
				for (; i < ilen; ++i) {
					points[i].draw(area);
				}
			},

			setHoverStyle: function(point) {
				// Point
				var dataset = this.chart.data.datasets[point._datasetIndex];
				var index = point._index;
				var custom = point.custom || {};
				var model = point._model;

				model.radius = custom.hoverRadius || helpers.valueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);
				model.backgroundColor = custom.hoverBackgroundColor || helpers.valueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
				model.borderColor = custom.hoverBorderColor || helpers.valueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));
				model.borderWidth = custom.hoverBorderWidth || helpers.valueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);
			},

			removeHoverStyle: function(point) {
				var me = this;
				var dataset = me.chart.data.datasets[point._datasetIndex];
				var index = point._index;
				var custom = point.custom || {};
				var model = point._model;

				// Compatibility: If the properties are defined with only the old name, use those values
				if ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {
					dataset.pointRadius = dataset.radius;
				}

				model.radius = custom.radius || helpers.valueAtIndexOrDefault(dataset.pointRadius, index, me.chart.options.elements.point.radius);
				model.backgroundColor = me.getPointBackgroundColor(point, index);
				model.borderColor = me.getPointBorderColor(point, index);
				model.borderWidth = me.getPointBorderWidth(point, index);
			}
		});
	};


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var defaults = __webpack_require__(40);
	var elements = __webpack_require__(53);
	var helpers = __webpack_require__(41);

	defaults._set('polarArea', {
		scale: {
			type: 'radialLinear',
			angleLines: {
				display: false
			},
			gridLines: {
				circular: true
			},
			pointLabels: {
				display: false
			},
			ticks: {
				beginAtZero: true
			}
		},

		// Boolean - Whether to animate the rotation of the chart
		animation: {
			animateRotate: true,
			animateScale: true
		},

		startAngle: -0.5 * Math.PI,
		legendCallback: function(chart) {
			var text = [];
			text.push('<ul class="' + chart.id + '-legend">');

			var data = chart.data;
			var datasets = data.datasets;
			var labels = data.labels;

			if (datasets.length) {
				for (var i = 0; i < datasets[0].data.length; ++i) {
					text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');
					if (labels[i]) {
						text.push(labels[i]);
					}
					text.push('</li>');
				}
			}

			text.push('</ul>');
			return text.join('');
		},
		legend: {
			labels: {
				generateLabels: function(chart) {
					var data = chart.data;
					if (data.labels.length && data.datasets.length) {
						return data.labels.map(function(label, i) {
							var meta = chart.getDatasetMeta(0);
							var ds = data.datasets[0];
							var arc = meta.data[i];
							var custom = arc.custom || {};
							var valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
							var arcOpts = chart.options.elements.arc;
							var fill = custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);
							var stroke = custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);
							var bw = custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);

							return {
								text: label,
								fillStyle: fill,
								strokeStyle: stroke,
								lineWidth: bw,
								hidden: isNaN(ds.data[i]) || meta.data[i].hidden,

								// Extra data used for toggling the correct item
								index: i
							};
						});
					}
					return [];
				}
			},

			onClick: function(e, legendItem) {
				var index = legendItem.index;
				var chart = this.chart;
				var i, ilen, meta;

				for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
					meta = chart.getDatasetMeta(i);
					meta.data[index].hidden = !meta.data[index].hidden;
				}

				chart.update();
			}
		},

		// Need to override these to give a nice default
		tooltips: {
			callbacks: {
				title: function() {
					return '';
				},
				label: function(item, data) {
					return data.labels[item.index] + ': ' + item.yLabel;
				}
			}
		}
	});

	module.exports = function(Chart) {

		Chart.controllers.polarArea = Chart.DatasetController.extend({

			dataElementType: elements.Arc,

			linkScales: helpers.noop,

			update: function(reset) {
				var me = this;
				var chart = me.chart;
				var chartArea = chart.chartArea;
				var meta = me.getMeta();
				var opts = chart.options;
				var arcOpts = opts.elements.arc;
				var minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
				chart.outerRadius = Math.max((minSize - arcOpts.borderWidth / 2) / 2, 0);
				chart.innerRadius = Math.max(opts.cutoutPercentage ? (chart.outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);
				chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();

				me.outerRadius = chart.outerRadius - (chart.radiusLength * me.index);
				me.innerRadius = me.outerRadius - chart.radiusLength;

				meta.count = me.countVisibleElements();

				helpers.each(meta.data, function(arc, index) {
					me.updateElement(arc, index, reset);
				});
			},

			updateElement: function(arc, index, reset) {
				var me = this;
				var chart = me.chart;
				var dataset = me.getDataset();
				var opts = chart.options;
				var animationOpts = opts.animation;
				var scale = chart.scale;
				var labels = chart.data.labels;

				var circumference = me.calculateCircumference(dataset.data[index]);
				var centerX = scale.xCenter;
				var centerY = scale.yCenter;

				// If there is NaN data before us, we need to calculate the starting angle correctly.
				// We could be way more efficient here, but its unlikely that the polar area chart will have a lot of data
				var visibleCount = 0;
				var meta = me.getMeta();
				for (var i = 0; i < index; ++i) {
					if (!isNaN(dataset.data[i]) && !meta.data[i].hidden) {
						++visibleCount;
					}
				}

				// var negHalfPI = -0.5 * Math.PI;
				var datasetStartAngle = opts.startAngle;
				var distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
				var startAngle = datasetStartAngle + (circumference * visibleCount);
				var endAngle = startAngle + (arc.hidden ? 0 : circumference);

				var resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);

				helpers.extend(arc, {
					// Utility
					_datasetIndex: me.index,
					_index: index,
					_scale: scale,

					// Desired view properties
					_model: {
						x: centerX,
						y: centerY,
						innerRadius: 0,
						outerRadius: reset ? resetRadius : distance,
						startAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,
						endAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,
						label: helpers.valueAtIndexOrDefault(labels, index, labels[index])
					}
				});

				// Apply border and fill style
				me.removeHoverStyle(arc);

				arc.pivot();
			},

			removeHoverStyle: function(arc) {
				Chart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);
			},

			countVisibleElements: function() {
				var dataset = this.getDataset();
				var meta = this.getMeta();
				var count = 0;

				helpers.each(meta.data, function(element, index) {
					if (!isNaN(dataset.data[index]) && !element.hidden) {
						count++;
					}
				});

				return count;
			},

			calculateCircumference: function(value) {
				var count = this.getMeta().count;
				if (count > 0 && !isNaN(value)) {
					return (2 * Math.PI) / count;
				}
				return 0;
			}
		});
	};


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var defaults = __webpack_require__(40);
	var elements = __webpack_require__(53);
	var helpers = __webpack_require__(41);

	defaults._set('radar', {
		scale: {
			type: 'radialLinear'
		},
		elements: {
			line: {
				tension: 0 // no bezier in radar
			}
		}
	});

	module.exports = function(Chart) {

		Chart.controllers.radar = Chart.DatasetController.extend({

			datasetElementType: elements.Line,

			dataElementType: elements.Point,

			linkScales: helpers.noop,

			update: function(reset) {
				var me = this;
				var meta = me.getMeta();
				var line = meta.dataset;
				var points = meta.data;
				var custom = line.custom || {};
				var dataset = me.getDataset();
				var lineElementOptions = me.chart.options.elements.line;
				var scale = me.chart.scale;

				// Compatibility: If the properties are defined with only the old name, use those values
				if ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {
					dataset.lineTension = dataset.tension;
				}

				helpers.extend(meta.dataset, {
					// Utility
					_datasetIndex: me.index,
					_scale: scale,
					// Data
					_children: points,
					_loop: true,
					// Model
					_model: {
						// Appearance
						tension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, lineElementOptions.tension),
						backgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),
						borderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),
						borderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),
						fill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),
						borderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),
						borderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),
						borderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),
						borderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),
					}
				});

				meta.dataset.pivot();

				// Update Points
				helpers.each(points, function(point, index) {
					me.updateElement(point, index, reset);
				}, me);

				// Update bezier control points
				me.updateBezierControlPoints();
			},
			updateElement: function(point, index, reset) {
				var me = this;
				var custom = point.custom || {};
				var dataset = me.getDataset();
				var scale = me.chart.scale;
				var pointElementOptions = me.chart.options.elements.point;
				var pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);

				// Compatibility: If the properties are defined with only the old name, use those values
				if ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {
					dataset.pointRadius = dataset.radius;
				}
				if ((dataset.hitRadius !== undefined) && (dataset.pointHitRadius === undefined)) {
					dataset.pointHitRadius = dataset.hitRadius;
				}

				helpers.extend(point, {
					// Utility
					_datasetIndex: me.index,
					_index: index,
					_scale: scale,

					// Desired view properties
					_model: {
						x: reset ? scale.xCenter : pointPosition.x, // value not used in dataset scale, but we want a consistent API between scales
						y: reset ? scale.yCenter : pointPosition.y,

						// Appearance
						tension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, me.chart.options.elements.line.tension),
						radius: custom.radius ? custom.radius : helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius),
						backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor),
						borderColor: custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor),
						borderWidth: custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth),
						pointStyle: custom.pointStyle ? custom.pointStyle : helpers.valueAtIndexOrDefault(dataset.pointStyle, index, pointElementOptions.pointStyle),

						// Tooltip
						hitRadius: custom.hitRadius ? custom.hitRadius : helpers.valueAtIndexOrDefault(dataset.pointHitRadius, index, pointElementOptions.hitRadius)
					}
				});

				point._model.skip = custom.skip ? custom.skip : (isNaN(point._model.x) || isNaN(point._model.y));
			},
			updateBezierControlPoints: function() {
				var chartArea = this.chart.chartArea;
				var meta = this.getMeta();

				helpers.each(meta.data, function(point, index) {
					var model = point._model;
					var controlPoints = helpers.splineCurve(
						helpers.previousItem(meta.data, index, true)._model,
						model,
						helpers.nextItem(meta.data, index, true)._model,
						model.tension
					);

					// Prevent the bezier going outside of the bounds of the graph
					model.controlPointPreviousX = Math.max(Math.min(controlPoints.previous.x, chartArea.right), chartArea.left);
					model.controlPointPreviousY = Math.max(Math.min(controlPoints.previous.y, chartArea.bottom), chartArea.top);

					model.controlPointNextX = Math.max(Math.min(controlPoints.next.x, chartArea.right), chartArea.left);
					model.controlPointNextY = Math.max(Math.min(controlPoints.next.y, chartArea.bottom), chartArea.top);

					// Now pivot the point for animation
					point.pivot();
				});
			},

			setHoverStyle: function(point) {
				// Point
				var dataset = this.chart.data.datasets[point._datasetIndex];
				var custom = point.custom || {};
				var index = point._index;
				var model = point._model;

				model.radius = custom.hoverRadius ? custom.hoverRadius : helpers.valueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);
				model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.valueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
				model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.valueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));
				model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.valueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);
			},

			removeHoverStyle: function(point) {
				var dataset = this.chart.data.datasets[point._datasetIndex];
				var custom = point.custom || {};
				var index = point._index;
				var model = point._model;
				var pointElementOptions = this.chart.options.elements.point;

				model.radius = custom.radius ? custom.radius : helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius);
				model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor);
				model.borderColor = custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor);
				model.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth);
			}
		});
	};


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var defaults = __webpack_require__(40);

	defaults._set('scatter', {
		hover: {
			mode: 'single'
		},

		scales: {
			xAxes: [{
				id: 'x-axis-1',    // need an ID so datasets can reference the scale
				type: 'linear',    // scatter should not use a category axis
				position: 'bottom'
			}],
			yAxes: [{
				id: 'y-axis-1',
				type: 'linear',
				position: 'left'
			}]
		},

		showLines: false,

		tooltips: {
			callbacks: {
				title: function() {
					return '';     // doesn't make sense for scatter since data are formatted as a point
				},
				label: function(item) {
					return '(' + item.xLabel + ', ' + item.yLabel + ')';
				}
			}
		}
	});

	module.exports = function(Chart) {

		// Scatter charts use line controllers
		Chart.controllers.scatter = Chart.controllers.line;

	};


/***/ }),
/* 202 */
/***/ (function(module, exports) {

	'use strict';

	module.exports = function(Chart) {

		Chart.Bar = function(context, config) {
			config.type = 'bar';

			return new Chart(context, config);
		};

	};


/***/ }),
/* 203 */
/***/ (function(module, exports) {

	'use strict';

	module.exports = function(Chart) {

		Chart.Bubble = function(context, config) {
			config.type = 'bubble';
			return new Chart(context, config);
		};

	};


/***/ }),
/* 204 */
/***/ (function(module, exports) {

	'use strict';

	module.exports = function(Chart) {

		Chart.Doughnut = function(context, config) {
			config.type = 'doughnut';

			return new Chart(context, config);
		};

	};


/***/ }),
/* 205 */
/***/ (function(module, exports) {

	'use strict';

	module.exports = function(Chart) {

		Chart.Line = function(context, config) {
			config.type = 'line';

			return new Chart(context, config);
		};

	};


/***/ }),
/* 206 */
/***/ (function(module, exports) {

	'use strict';

	module.exports = function(Chart) {

		Chart.PolarArea = function(context, config) {
			config.type = 'polarArea';

			return new Chart(context, config);
		};

	};


/***/ }),
/* 207 */
/***/ (function(module, exports) {

	'use strict';

	module.exports = function(Chart) {

		Chart.Radar = function(context, config) {
			config.type = 'radar';

			return new Chart(context, config);
		};

	};


/***/ }),
/* 208 */
/***/ (function(module, exports) {

	'use strict';

	module.exports = function(Chart) {
		Chart.Scatter = function(context, config) {
			config.type = 'scatter';
			return new Chart(context, config);
		};
	};


/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Plugin based on discussion from the following Chart.js issues:
	 * @see https://github.com/chartjs/Chart.js/issues/2380#issuecomment-279961569
	 * @see https://github.com/chartjs/Chart.js/issues/2440#issuecomment-256461897
	 */

	'use strict';

	var defaults = __webpack_require__(40);
	var elements = __webpack_require__(53);
	var helpers = __webpack_require__(41);

	defaults._set('global', {
		plugins: {
			filler: {
				propagate: true
			}
		}
	});

	module.exports = function() {

		var mappers = {
			dataset: function(source) {
				var index = source.fill;
				var chart = source.chart;
				var meta = chart.getDatasetMeta(index);
				var visible = meta && chart.isDatasetVisible(index);
				var points = (visible && meta.dataset._children) || [];
				var length = points.length || 0;

				return !length ? null : function(point, i) {
					return (i < length && points[i]._view) || null;
				};
			},

			boundary: function(source) {
				var boundary = source.boundary;
				var x = boundary ? boundary.x : null;
				var y = boundary ? boundary.y : null;

				return function(point) {
					return {
						x: x === null ? point.x : x,
						y: y === null ? point.y : y,
					};
				};
			}
		};

		// @todo if (fill[0] === '#')
		function decodeFill(el, index, count) {
			var model = el._model || {};
			var fill = model.fill;
			var target;

			if (fill === undefined) {
				fill = !!model.backgroundColor;
			}

			if (fill === false || fill === null) {
				return false;
			}

			if (fill === true) {
				return 'origin';
			}

			target = parseFloat(fill, 10);
			if (isFinite(target) && Math.floor(target) === target) {
				if (fill[0] === '-' || fill[0] === '+') {
					target = index + target;
				}

				if (target === index || target < 0 || target >= count) {
					return false;
				}

				return target;
			}

			switch (fill) {
			// compatibility
			case 'bottom':
				return 'start';
			case 'top':
				return 'end';
			case 'zero':
				return 'origin';
			// supported boundaries
			case 'origin':
			case 'start':
			case 'end':
				return fill;
			// invalid fill values
			default:
				return false;
			}
		}

		function computeBoundary(source) {
			var model = source.el._model || {};
			var scale = source.el._scale || {};
			var fill = source.fill;
			var target = null;
			var horizontal;

			if (isFinite(fill)) {
				return null;
			}

			// Backward compatibility: until v3, we still need to support boundary values set on
			// the model (scaleTop, scaleBottom and scaleZero) because some external plugins and
			// controllers might still use it (e.g. the Smith chart).

			if (fill === 'start') {
				target = model.scaleBottom === undefined ? scale.bottom : model.scaleBottom;
			} else if (fill === 'end') {
				target = model.scaleTop === undefined ? scale.top : model.scaleTop;
			} else if (model.scaleZero !== undefined) {
				target = model.scaleZero;
			} else if (scale.getBasePosition) {
				target = scale.getBasePosition();
			} else if (scale.getBasePixel) {
				target = scale.getBasePixel();
			}

			if (target !== undefined && target !== null) {
				if (target.x !== undefined && target.y !== undefined) {
					return target;
				}

				if (typeof target === 'number' && isFinite(target)) {
					horizontal = scale.isHorizontal();
					return {
						x: horizontal ? target : null,
						y: horizontal ? null : target
					};
				}
			}

			return null;
		}

		function resolveTarget(sources, index, propagate) {
			var source = sources[index];
			var fill = source.fill;
			var visited = [index];
			var target;

			if (!propagate) {
				return fill;
			}

			while (fill !== false && visited.indexOf(fill) === -1) {
				if (!isFinite(fill)) {
					return fill;
				}

				target = sources[fill];
				if (!target) {
					return false;
				}

				if (target.visible) {
					return fill;
				}

				visited.push(fill);
				fill = target.fill;
			}

			return false;
		}

		function createMapper(source) {
			var fill = source.fill;
			var type = 'dataset';

			if (fill === false) {
				return null;
			}

			if (!isFinite(fill)) {
				type = 'boundary';
			}

			return mappers[type](source);
		}

		function isDrawable(point) {
			return point && !point.skip;
		}

		function drawArea(ctx, curve0, curve1, len0, len1) {
			var i;

			if (!len0 || !len1) {
				return;
			}

			// building first area curve (normal)
			ctx.moveTo(curve0[0].x, curve0[0].y);
			for (i = 1; i < len0; ++i) {
				helpers.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);
			}

			// joining the two area curves
			ctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y);

			// building opposite area curve (reverse)
			for (i = len1 - 1; i > 0; --i) {
				helpers.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);
			}
		}

		function doFill(ctx, points, mapper, view, color, loop) {
			var count = points.length;
			var span = view.spanGaps;
			var curve0 = [];
			var curve1 = [];
			var len0 = 0;
			var len1 = 0;
			var i, ilen, index, p0, p1, d0, d1;

			ctx.beginPath();

			for (i = 0, ilen = (count + !!loop); i < ilen; ++i) {
				index = i % count;
				p0 = points[index]._view;
				p1 = mapper(p0, index, view);
				d0 = isDrawable(p0);
				d1 = isDrawable(p1);

				if (d0 && d1) {
					len0 = curve0.push(p0);
					len1 = curve1.push(p1);
				} else if (len0 && len1) {
					if (!span) {
						drawArea(ctx, curve0, curve1, len0, len1);
						len0 = len1 = 0;
						curve0 = [];
						curve1 = [];
					} else {
						if (d0) {
							curve0.push(p0);
						}
						if (d1) {
							curve1.push(p1);
						}
					}
				}
			}

			drawArea(ctx, curve0, curve1, len0, len1);

			ctx.closePath();
			ctx.fillStyle = color;
			ctx.fill();
		}

		return {
			id: 'filler',

			afterDatasetsUpdate: function(chart, options) {
				var count = (chart.data.datasets || []).length;
				var propagate = options.propagate;
				var sources = [];
				var meta, i, el, source;

				for (i = 0; i < count; ++i) {
					meta = chart.getDatasetMeta(i);
					el = meta.dataset;
					source = null;

					if (el && el._model && el instanceof elements.Line) {
						source = {
							visible: chart.isDatasetVisible(i),
							fill: decodeFill(el, i, count),
							chart: chart,
							el: el
						};
					}

					meta.$filler = source;
					sources.push(source);
				}

				for (i = 0; i < count; ++i) {
					source = sources[i];
					if (!source) {
						continue;
					}

					source.fill = resolveTarget(sources, i, propagate);
					source.boundary = computeBoundary(source);
					source.mapper = createMapper(source);
				}
			},

			beforeDatasetDraw: function(chart, args) {
				var meta = args.meta.$filler;
				if (!meta) {
					return;
				}

				var ctx = chart.ctx;
				var el = meta.el;
				var view = el._view;
				var points = el._children || [];
				var mapper = meta.mapper;
				var color = view.backgroundColor || defaults.global.defaultColor;

				if (mapper && color && points.length) {
					helpers.canvas.clipArea(ctx, chart.chartArea);
					doFill(ctx, points, mapper, view, color, el._loop);
					helpers.canvas.unclipArea(ctx);
				}
			}
		};
	};


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var defaults = __webpack_require__(40);
	var Element = __webpack_require__(52);
	var helpers = __webpack_require__(41);

	defaults._set('global', {
		legend: {
			display: true,
			position: 'top',
			fullWidth: true,
			reverse: false,
			weight: 1000,

			// a callback that will handle
			onClick: function(e, legendItem) {
				var index = legendItem.datasetIndex;
				var ci = this.chart;
				var meta = ci.getDatasetMeta(index);

				// See controller.isDatasetVisible comment
				meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null;

				// We hid a dataset ... rerender the chart
				ci.update();
			},

			onHover: null,

			labels: {
				boxWidth: 40,
				padding: 10,
				// Generates labels shown in the legend
				// Valid properties to return:
				// text : text to display
				// fillStyle : fill of coloured box
				// strokeStyle: stroke of coloured box
				// hidden : if this legend item refers to a hidden item
				// lineCap : cap style for line
				// lineDash
				// lineDashOffset :
				// lineJoin :
				// lineWidth :
				generateLabels: function(chart) {
					var data = chart.data;
					return helpers.isArray(data.datasets) ? data.datasets.map(function(dataset, i) {
						return {
							text: dataset.label,
							fillStyle: (!helpers.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0]),
							hidden: !chart.isDatasetVisible(i),
							lineCap: dataset.borderCapStyle,
							lineDash: dataset.borderDash,
							lineDashOffset: dataset.borderDashOffset,
							lineJoin: dataset.borderJoinStyle,
							lineWidth: dataset.borderWidth,
							strokeStyle: dataset.borderColor,
							pointStyle: dataset.pointStyle,

							// Below is extra data used for toggling the datasets
							datasetIndex: i
						};
					}, this) : [];
				}
			}
		},

		legendCallback: function(chart) {
			var text = [];
			text.push('<ul class="' + chart.id + '-legend">');
			for (var i = 0; i < chart.data.datasets.length; i++) {
				text.push('<li><span style="background-color:' + chart.data.datasets[i].backgroundColor + '"></span>');
				if (chart.data.datasets[i].label) {
					text.push(chart.data.datasets[i].label);
				}
				text.push('</li>');
			}
			text.push('</ul>');
			return text.join('');
		}
	});

	module.exports = function(Chart) {

		var layout = Chart.layoutService;
		var noop = helpers.noop;

		/**
		 * Helper function to get the box width based on the usePointStyle option
		 * @param labelopts {Object} the label options on the legend
		 * @param fontSize {Number} the label font size
		 * @return {Number} width of the color box area
		 */
		function getBoxWidth(labelOpts, fontSize) {
			return labelOpts.usePointStyle ?
				fontSize * Math.SQRT2 :
				labelOpts.boxWidth;
		}

		Chart.Legend = Element.extend({

			initialize: function(config) {
				helpers.extend(this, config);

				// Contains hit boxes for each dataset (in dataset order)
				this.legendHitBoxes = [];

				// Are we in doughnut mode which has a different data type
				this.doughnutMode = false;
			},

			// These methods are ordered by lifecycle. Utilities then follow.
			// Any function defined here is inherited by all legend types.
			// Any function can be extended by the legend type

			beforeUpdate: noop,
			update: function(maxWidth, maxHeight, margins) {
				var me = this;

				// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
				me.beforeUpdate();

				// Absorb the master measurements
				me.maxWidth = maxWidth;
				me.maxHeight = maxHeight;
				me.margins = margins;

				// Dimensions
				me.beforeSetDimensions();
				me.setDimensions();
				me.afterSetDimensions();
				// Labels
				me.beforeBuildLabels();
				me.buildLabels();
				me.afterBuildLabels();

				// Fit
				me.beforeFit();
				me.fit();
				me.afterFit();
				//
				me.afterUpdate();

				return me.minSize;
			},
			afterUpdate: noop,

			//

			beforeSetDimensions: noop,
			setDimensions: function() {
				var me = this;
				// Set the unconstrained dimension before label rotation
				if (me.isHorizontal()) {
					// Reset position before calculating rotation
					me.width = me.maxWidth;
					me.left = 0;
					me.right = me.width;
				} else {
					me.height = me.maxHeight;

					// Reset position before calculating rotation
					me.top = 0;
					me.bottom = me.height;
				}

				// Reset padding
				me.paddingLeft = 0;
				me.paddingTop = 0;
				me.paddingRight = 0;
				me.paddingBottom = 0;

				// Reset minSize
				me.minSize = {
					width: 0,
					height: 0
				};
			},
			afterSetDimensions: noop,

			//

			beforeBuildLabels: noop,
			buildLabels: function() {
				var me = this;
				var labelOpts = me.options.labels || {};
				var legendItems = helpers.callback(labelOpts.generateLabels, [me.chart], me) || [];

				if (labelOpts.filter) {
					legendItems = legendItems.filter(function(item) {
						return labelOpts.filter(item, me.chart.data);
					});
				}

				if (me.options.reverse) {
					legendItems.reverse();
				}

				me.legendItems = legendItems;
			},
			afterBuildLabels: noop,

			//

			beforeFit: noop,
			fit: function() {
				var me = this;
				var opts = me.options;
				var labelOpts = opts.labels;
				var display = opts.display;

				var ctx = me.ctx;

				var globalDefault = defaults.global;
				var valueOrDefault = helpers.valueOrDefault;
				var fontSize = valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);
				var fontStyle = valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);
				var fontFamily = valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);
				var labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);

				// Reset hit boxes
				var hitboxes = me.legendHitBoxes = [];

				var minSize = me.minSize;
				var isHorizontal = me.isHorizontal();

				if (isHorizontal) {
					minSize.width = me.maxWidth; // fill all the width
					minSize.height = display ? 10 : 0;
				} else {
					minSize.width = display ? 10 : 0;
					minSize.height = me.maxHeight; // fill all the height
				}

				// Increase sizes here
				if (display) {
					ctx.font = labelFont;

					if (isHorizontal) {
						// Labels

						// Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one
						var lineWidths = me.lineWidths = [0];
						var totalHeight = me.legendItems.length ? fontSize + (labelOpts.padding) : 0;

						ctx.textAlign = 'left';
						ctx.textBaseline = 'top';

						helpers.each(me.legendItems, function(legendItem, i) {
							var boxWidth = getBoxWidth(labelOpts, fontSize);
							var width = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;

							if (lineWidths[lineWidths.length - 1] + width + labelOpts.padding >= me.width) {
								totalHeight += fontSize + (labelOpts.padding);
								lineWidths[lineWidths.length] = me.left;
							}

							// Store the hitbox width and height here. Final position will be updated in `draw`
							hitboxes[i] = {
								left: 0,
								top: 0,
								width: width,
								height: fontSize
							};

							lineWidths[lineWidths.length - 1] += width + labelOpts.padding;
						});

						minSize.height += totalHeight;

					} else {
						var vPadding = labelOpts.padding;
						var columnWidths = me.columnWidths = [];
						var totalWidth = labelOpts.padding;
						var currentColWidth = 0;
						var currentColHeight = 0;
						var itemHeight = fontSize + vPadding;

						helpers.each(me.legendItems, function(legendItem, i) {
							var boxWidth = getBoxWidth(labelOpts, fontSize);
							var itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;

							// If too tall, go to new column
							if (currentColHeight + itemHeight > minSize.height) {
								totalWidth += currentColWidth + labelOpts.padding;
								columnWidths.push(currentColWidth); // previous column width

								currentColWidth = 0;
								currentColHeight = 0;
							}

							// Get max width
							currentColWidth = Math.max(currentColWidth, itemWidth);
							currentColHeight += itemHeight;

							// Store the hitbox width and height here. Final position will be updated in `draw`
							hitboxes[i] = {
								left: 0,
								top: 0,
								width: itemWidth,
								height: fontSize
							};
						});

						totalWidth += currentColWidth;
						columnWidths.push(currentColWidth);
						minSize.width += totalWidth;
					}
				}

				me.width = minSize.width;
				me.height = minSize.height;
			},
			afterFit: noop,

			// Shared Methods
			isHorizontal: function() {
				return this.options.position === 'top' || this.options.position === 'bottom';
			},

			// Actually draw the legend on the canvas
			draw: function() {
				var me = this;
				var opts = me.options;
				var labelOpts = opts.labels;
				var globalDefault = defaults.global;
				var lineDefault = globalDefault.elements.line;
				var legendWidth = me.width;
				var lineWidths = me.lineWidths;

				if (opts.display) {
					var ctx = me.ctx;
					var valueOrDefault = helpers.valueOrDefault;
					var fontColor = valueOrDefault(labelOpts.fontColor, globalDefault.defaultFontColor);
					var fontSize = valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);
					var fontStyle = valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);
					var fontFamily = valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);
					var labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);
					var cursor;

					// Canvas setup
					ctx.textAlign = 'left';
					ctx.textBaseline = 'middle';
					ctx.lineWidth = 0.5;
					ctx.strokeStyle = fontColor; // for strikethrough effect
					ctx.fillStyle = fontColor; // render in correct colour
					ctx.font = labelFont;

					var boxWidth = getBoxWidth(labelOpts, fontSize);
					var hitboxes = me.legendHitBoxes;

					// current position
					var drawLegendBox = function(x, y, legendItem) {
						if (isNaN(boxWidth) || boxWidth <= 0) {
							return;
						}

						// Set the ctx for the box
						ctx.save();

						ctx.fillStyle = valueOrDefault(legendItem.fillStyle, globalDefault.defaultColor);
						ctx.lineCap = valueOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);
						ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);
						ctx.lineJoin = valueOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);
						ctx.lineWidth = valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth);
						ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, globalDefault.defaultColor);
						var isLineWidthZero = (valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth) === 0);

						if (ctx.setLineDash) {
							// IE 9 and 10 do not support line dash
							ctx.setLineDash(valueOrDefault(legendItem.lineDash, lineDefault.borderDash));
						}

						if (opts.labels && opts.labels.usePointStyle) {
							// Recalculate x and y for drawPoint() because its expecting
							// x and y to be center of figure (instead of top left)
							var radius = fontSize * Math.SQRT2 / 2;
							var offSet = radius / Math.SQRT2;
							var centerX = x + offSet;
							var centerY = y + offSet;

							// Draw pointStyle as legend symbol
							helpers.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);
						} else {
							// Draw box as legend symbol
							if (!isLineWidthZero) {
								ctx.strokeRect(x, y, boxWidth, fontSize);
							}
							ctx.fillRect(x, y, boxWidth, fontSize);
						}

						ctx.restore();
					};
					var fillText = function(x, y, legendItem, textWidth) {
						var halfFontSize = fontSize / 2;
						var xLeft = boxWidth + halfFontSize + x;
						var yMiddle = y + halfFontSize;

						ctx.fillText(legendItem.text, xLeft, yMiddle);

						if (legendItem.hidden) {
							// Strikethrough the text if hidden
							ctx.beginPath();
							ctx.lineWidth = 2;
							ctx.moveTo(xLeft, yMiddle);
							ctx.lineTo(xLeft + textWidth, yMiddle);
							ctx.stroke();
						}
					};

					// Horizontal
					var isHorizontal = me.isHorizontal();
					if (isHorizontal) {
						cursor = {
							x: me.left + ((legendWidth - lineWidths[0]) / 2),
							y: me.top + labelOpts.padding,
							line: 0
						};
					} else {
						cursor = {
							x: me.left + labelOpts.padding,
							y: me.top + labelOpts.padding,
							line: 0
						};
					}

					var itemHeight = fontSize + labelOpts.padding;
					helpers.each(me.legendItems, function(legendItem, i) {
						var textWidth = ctx.measureText(legendItem.text).width;
						var width = boxWidth + (fontSize / 2) + textWidth;
						var x = cursor.x;
						var y = cursor.y;

						if (isHorizontal) {
							if (x + width >= legendWidth) {
								y = cursor.y += itemHeight;
								cursor.line++;
								x = cursor.x = me.left + ((legendWidth - lineWidths[cursor.line]) / 2);
							}
						} else if (y + itemHeight > me.bottom) {
							x = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;
							y = cursor.y = me.top + labelOpts.padding;
							cursor.line++;
						}

						drawLegendBox(x, y, legendItem);

						hitboxes[i].left = x;
						hitboxes[i].top = y;

						// Fill the actual label
						fillText(x, y, legendItem, textWidth);

						if (isHorizontal) {
							cursor.x += width + (labelOpts.padding);
						} else {
							cursor.y += itemHeight;
						}

					});
				}
			},

			/**
			 * Handle an event
			 * @private
			 * @param {IEvent} event - The event to handle
			 * @return {Boolean} true if a change occured
			 */
			handleEvent: function(e) {
				var me = this;
				var opts = me.options;
				var type = e.type === 'mouseup' ? 'click' : e.type;
				var changed = false;

				if (type === 'mousemove') {
					if (!opts.onHover) {
						return;
					}
				} else if (type === 'click') {
					if (!opts.onClick) {
						return;
					}
				} else {
					return;
				}

				// Chart event already has relative position in it
				var x = e.x;
				var y = e.y;

				if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {
					// See if we are touching one of the dataset boxes
					var lh = me.legendHitBoxes;
					for (var i = 0; i < lh.length; ++i) {
						var hitBox = lh[i];

						if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {
							// Touching an element
							if (type === 'click') {
								// use e.native for backwards compatibility
								opts.onClick.call(me, e.native, me.legendItems[i]);
								changed = true;
								break;
							} else if (type === 'mousemove') {
								// use e.native for backwards compatibility
								opts.onHover.call(me, e.native, me.legendItems[i]);
								changed = true;
								break;
							}
						}
					}
				}

				return changed;
			}
		});

		function createNewLegendAndAttach(chart, legendOpts) {
			var legend = new Chart.Legend({
				ctx: chart.ctx,
				options: legendOpts,
				chart: chart
			});

			layout.configure(chart, legend, legendOpts);
			layout.addBox(chart, legend);
			chart.legend = legend;
		}

		return {
			id: 'legend',

			beforeInit: function(chart) {
				var legendOpts = chart.options.legend;

				if (legendOpts) {
					createNewLegendAndAttach(chart, legendOpts);
				}
			},

			beforeUpdate: function(chart) {
				var legendOpts = chart.options.legend;
				var legend = chart.legend;

				if (legendOpts) {
					helpers.mergeIf(legendOpts, defaults.global.legend);

					if (legend) {
						layout.configure(chart, legend, legendOpts);
						legend.options = legendOpts;
					} else {
						createNewLegendAndAttach(chart, legendOpts);
					}
				} else if (legend) {
					layout.removeBox(chart, legend);
					delete chart.legend;
				}
			},

			afterEvent: function(chart, e) {
				var legend = chart.legend;
				if (legend) {
					legend.handleEvent(e);
				}
			}
		};
	};


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var defaults = __webpack_require__(40);
	var Element = __webpack_require__(52);
	var helpers = __webpack_require__(41);

	defaults._set('global', {
		title: {
			display: false,
			fontStyle: 'bold',
			fullWidth: true,
			lineHeight: 1.2,
			padding: 10,
			position: 'top',
			text: '',
			weight: 2000         // by default greater than legend (1000) to be above
		}
	});

	module.exports = function(Chart) {

		var layout = Chart.layoutService;
		var noop = helpers.noop;

		Chart.Title = Element.extend({
			initialize: function(config) {
				var me = this;
				helpers.extend(me, config);

				// Contains hit boxes for each dataset (in dataset order)
				me.legendHitBoxes = [];
			},

			// These methods are ordered by lifecycle. Utilities then follow.

			beforeUpdate: noop,
			update: function(maxWidth, maxHeight, margins) {
				var me = this;

				// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
				me.beforeUpdate();

				// Absorb the master measurements
				me.maxWidth = maxWidth;
				me.maxHeight = maxHeight;
				me.margins = margins;

				// Dimensions
				me.beforeSetDimensions();
				me.setDimensions();
				me.afterSetDimensions();
				// Labels
				me.beforeBuildLabels();
				me.buildLabels();
				me.afterBuildLabels();

				// Fit
				me.beforeFit();
				me.fit();
				me.afterFit();
				//
				me.afterUpdate();

				return me.minSize;

			},
			afterUpdate: noop,

			//

			beforeSetDimensions: noop,
			setDimensions: function() {
				var me = this;
				// Set the unconstrained dimension before label rotation
				if (me.isHorizontal()) {
					// Reset position before calculating rotation
					me.width = me.maxWidth;
					me.left = 0;
					me.right = me.width;
				} else {
					me.height = me.maxHeight;

					// Reset position before calculating rotation
					me.top = 0;
					me.bottom = me.height;
				}

				// Reset padding
				me.paddingLeft = 0;
				me.paddingTop = 0;
				me.paddingRight = 0;
				me.paddingBottom = 0;

				// Reset minSize
				me.minSize = {
					width: 0,
					height: 0
				};
			},
			afterSetDimensions: noop,

			//

			beforeBuildLabels: noop,
			buildLabels: noop,
			afterBuildLabels: noop,

			//

			beforeFit: noop,
			fit: function() {
				var me = this;
				var valueOrDefault = helpers.valueOrDefault;
				var opts = me.options;
				var display = opts.display;
				var fontSize = valueOrDefault(opts.fontSize, defaults.global.defaultFontSize);
				var minSize = me.minSize;
				var lineCount = helpers.isArray(opts.text) ? opts.text.length : 1;
				var lineHeight = helpers.options.toLineHeight(opts.lineHeight, fontSize);
				var textSize = display ? (lineCount * lineHeight) + (opts.padding * 2) : 0;

				if (me.isHorizontal()) {
					minSize.width = me.maxWidth; // fill all the width
					minSize.height = textSize;
				} else {
					minSize.width = textSize;
					minSize.height = me.maxHeight; // fill all the height
				}

				me.width = minSize.width;
				me.height = minSize.height;

			},
			afterFit: noop,

			// Shared Methods
			isHorizontal: function() {
				var pos = this.options.position;
				return pos === 'top' || pos === 'bottom';
			},

			// Actually draw the title block on the canvas
			draw: function() {
				var me = this;
				var ctx = me.ctx;
				var valueOrDefault = helpers.valueOrDefault;
				var opts = me.options;
				var globalDefaults = defaults.global;

				if (opts.display) {
					var fontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize);
					var fontStyle = valueOrDefault(opts.fontStyle, globalDefaults.defaultFontStyle);
					var fontFamily = valueOrDefault(opts.fontFamily, globalDefaults.defaultFontFamily);
					var titleFont = helpers.fontString(fontSize, fontStyle, fontFamily);
					var lineHeight = helpers.options.toLineHeight(opts.lineHeight, fontSize);
					var offset = lineHeight / 2 + opts.padding;
					var rotation = 0;
					var top = me.top;
					var left = me.left;
					var bottom = me.bottom;
					var right = me.right;
					var maxWidth, titleX, titleY;

					ctx.fillStyle = valueOrDefault(opts.fontColor, globalDefaults.defaultFontColor); // render in correct colour
					ctx.font = titleFont;

					// Horizontal
					if (me.isHorizontal()) {
						titleX = left + ((right - left) / 2); // midpoint of the width
						titleY = top + offset;
						maxWidth = right - left;
					} else {
						titleX = opts.position === 'left' ? left + offset : right - offset;
						titleY = top + ((bottom - top) / 2);
						maxWidth = bottom - top;
						rotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);
					}

					ctx.save();
					ctx.translate(titleX, titleY);
					ctx.rotate(rotation);
					ctx.textAlign = 'center';
					ctx.textBaseline = 'middle';

					var text = opts.text;
					if (helpers.isArray(text)) {
						var y = 0;
						for (var i = 0; i < text.length; ++i) {
							ctx.fillText(text[i], 0, y, maxWidth);
							y += lineHeight;
						}
					} else {
						ctx.fillText(text, 0, 0, maxWidth);
					}

					ctx.restore();
				}
			}
		});

		function createNewTitleBlockAndAttach(chart, titleOpts) {
			var title = new Chart.Title({
				ctx: chart.ctx,
				options: titleOpts,
				chart: chart
			});

			layout.configure(chart, title, titleOpts);
			layout.addBox(chart, title);
			chart.titleBlock = title;
		}

		return {
			id: 'title',

			beforeInit: function(chart) {
				var titleOpts = chart.options.title;

				if (titleOpts) {
					createNewTitleBlockAndAttach(chart, titleOpts);
				}
			},

			beforeUpdate: function(chart) {
				var titleOpts = chart.options.title;
				var titleBlock = chart.titleBlock;

				if (titleOpts) {
					helpers.mergeIf(titleOpts, defaults.global.title);

					if (titleBlock) {
						layout.configure(chart, titleBlock, titleOpts);
						titleBlock.options = titleOpts;
					} else {
						createNewTitleBlockAndAttach(chart, titleOpts);
					}
				} else if (titleBlock) {
					Chart.layoutService.removeBox(chart, titleBlock);
					delete chart.titleBlock;
				}
			}
		};
	};


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(213);
	jQuery(function ($) {
	    "use strict";
	    $('.parallax').stellar({
	        horizontalScrolling: false,
	        verticalOffset: 40,
	        responsive: true
	    });
	});

/***/ }),
/* 213 */
/***/ (function(module, exports) {

	/*! Stellar.js v0.6.2 | Copyright 2014, Mark Dalgleish | http://markdalgleish.com/projects/stellar.js | http://markdalgleish.mit-license.org */
	!function(a,b,c,d){function e(b,c){this.element=b,this.options=a.extend({},g,c),this._defaults=g,this._name=f,this.init()}var f="stellar",g={scrollProperty:"scroll",positionProperty:"position",horizontalScrolling:!0,verticalScrolling:!0,horizontalOffset:0,verticalOffset:0,responsive:!1,parallaxBackgrounds:!0,parallaxElements:!0,hideDistantElements:!0,hideElement:function(a){a.hide()},showElement:function(a){a.show()}},h={scroll:{getLeft:function(a){return a.scrollLeft()},setLeft:function(a,b){a.scrollLeft(b)},getTop:function(a){return a.scrollTop()},setTop:function(a,b){a.scrollTop(b)}},position:{getLeft:function(a){return-1*parseInt(a.css("left"),10)},getTop:function(a){return-1*parseInt(a.css("top"),10)}},margin:{getLeft:function(a){return-1*parseInt(a.css("margin-left"),10)},getTop:function(a){return-1*parseInt(a.css("margin-top"),10)}},transform:{getLeft:function(a){var b=getComputedStyle(a[0])[k];return"none"!==b?-1*parseInt(b.match(/(-?[0-9]+)/g)[4],10):0},getTop:function(a){var b=getComputedStyle(a[0])[k];return"none"!==b?-1*parseInt(b.match(/(-?[0-9]+)/g)[5],10):0}}},i={position:{setLeft:function(a,b){a.css("left",b)},setTop:function(a,b){a.css("top",b)}},transform:{setPosition:function(a,b,c,d,e){a[0].style[k]="translate3d("+(b-c)+"px, "+(d-e)+"px, 0)"}}},j=function(){var b,c=/^(Moz|Webkit|Khtml|O|ms|Icab)(?=[A-Z])/,d=a("script")[0].style,e="";for(b in d)if(c.test(b)){e=b.match(c)[0];break}return"WebkitOpacity"in d&&(e="Webkit"),"KhtmlOpacity"in d&&(e="Khtml"),function(a){return e+(e.length>0?a.charAt(0).toUpperCase()+a.slice(1):a)}}(),k=j("transform"),l=a("<div />",{style:"background:#fff"}).css("background-position-x")!==d,m=l?function(a,b,c){a.css({"background-position-x":b,"background-position-y":c})}:function(a,b,c){a.css("background-position",b+" "+c)},n=l?function(a){return[a.css("background-position-x"),a.css("background-position-y")]}:function(a){return a.css("background-position").split(" ")},o=b.requestAnimationFrame||b.webkitRequestAnimationFrame||b.mozRequestAnimationFrame||b.oRequestAnimationFrame||b.msRequestAnimationFrame||function(a){setTimeout(a,1e3/60)};e.prototype={init:function(){this.options.name=f+"_"+Math.floor(1e9*Math.random()),this._defineElements(),this._defineGetters(),this._defineSetters(),this._handleWindowLoadAndResize(),this._detectViewport(),this.refresh({firstLoad:!0}),"scroll"===this.options.scrollProperty?this._handleScrollEvent():this._startAnimationLoop()},_defineElements:function(){this.element===c.body&&(this.element=b),this.$scrollElement=a(this.element),this.$element=this.element===b?a("body"):this.$scrollElement,this.$viewportElement=this.options.viewportElement!==d?a(this.options.viewportElement):this.$scrollElement[0]===b||"scroll"===this.options.scrollProperty?this.$scrollElement:this.$scrollElement.parent()},_defineGetters:function(){var a=this,b=h[a.options.scrollProperty];this._getScrollLeft=function(){return b.getLeft(a.$scrollElement)},this._getScrollTop=function(){return b.getTop(a.$scrollElement)}},_defineSetters:function(){var b=this,c=h[b.options.scrollProperty],d=i[b.options.positionProperty],e=c.setLeft,f=c.setTop;this._setScrollLeft="function"==typeof e?function(a){e(b.$scrollElement,a)}:a.noop,this._setScrollTop="function"==typeof f?function(a){f(b.$scrollElement,a)}:a.noop,this._setPosition=d.setPosition||function(a,c,e,f,g){b.options.horizontalScrolling&&d.setLeft(a,c,e),b.options.verticalScrolling&&d.setTop(a,f,g)}},_handleWindowLoadAndResize:function(){var c=this,d=a(b);c.options.responsive&&d.bind("load."+this.name,function(){c.refresh()}),d.bind("resize."+this.name,function(){c._detectViewport(),c.options.responsive&&c.refresh()})},refresh:function(c){var d=this,e=d._getScrollLeft(),f=d._getScrollTop();c&&c.firstLoad||this._reset(),this._setScrollLeft(0),this._setScrollTop(0),this._setOffsets(),this._findParticles(),this._findBackgrounds(),c&&c.firstLoad&&/WebKit/.test(navigator.userAgent)&&a(b).load(function(){var a=d._getScrollLeft(),b=d._getScrollTop();d._setScrollLeft(a+1),d._setScrollTop(b+1),d._setScrollLeft(a),d._setScrollTop(b)}),this._setScrollLeft(e),this._setScrollTop(f)},_detectViewport:function(){var a=this.$viewportElement.offset(),b=null!==a&&a!==d;this.viewportWidth=this.$viewportElement.width(),this.viewportHeight=this.$viewportElement.height(),this.viewportOffsetTop=b?a.top:0,this.viewportOffsetLeft=b?a.left:0},_findParticles:function(){{var b=this;this._getScrollLeft(),this._getScrollTop()}if(this.particles!==d)for(var c=this.particles.length-1;c>=0;c--)this.particles[c].$element.data("stellar-elementIsActive",d);this.particles=[],this.options.parallaxElements&&this.$element.find("[data-stellar-ratio]").each(function(){var c,e,f,g,h,i,j,k,l,m=a(this),n=0,o=0,p=0,q=0;if(m.data("stellar-elementIsActive")){if(m.data("stellar-elementIsActive")!==this)return}else m.data("stellar-elementIsActive",this);b.options.showElement(m),m.data("stellar-startingLeft")?(m.css("left",m.data("stellar-startingLeft")),m.css("top",m.data("stellar-startingTop"))):(m.data("stellar-startingLeft",m.css("left")),m.data("stellar-startingTop",m.css("top"))),f=m.position().left,g=m.position().top,h="auto"===m.css("margin-left")?0:parseInt(m.css("margin-left"),10),i="auto"===m.css("margin-top")?0:parseInt(m.css("margin-top"),10),k=m.offset().left-h,l=m.offset().top-i,m.parents().each(function(){var b=a(this);return b.data("stellar-offset-parent")===!0?(n=p,o=q,j=b,!1):(p+=b.position().left,void(q+=b.position().top))}),c=m.data("stellar-horizontal-offset")!==d?m.data("stellar-horizontal-offset"):j!==d&&j.data("stellar-horizontal-offset")!==d?j.data("stellar-horizontal-offset"):b.horizontalOffset,e=m.data("stellar-vertical-offset")!==d?m.data("stellar-vertical-offset"):j!==d&&j.data("stellar-vertical-offset")!==d?j.data("stellar-vertical-offset"):b.verticalOffset,b.particles.push({$element:m,$offsetParent:j,isFixed:"fixed"===m.css("position"),horizontalOffset:c,verticalOffset:e,startingPositionLeft:f,startingPositionTop:g,startingOffsetLeft:k,startingOffsetTop:l,parentOffsetLeft:n,parentOffsetTop:o,stellarRatio:m.data("stellar-ratio")!==d?m.data("stellar-ratio"):1,width:m.outerWidth(!0),height:m.outerHeight(!0),isHidden:!1})})},_findBackgrounds:function(){var b,c=this,e=this._getScrollLeft(),f=this._getScrollTop();this.backgrounds=[],this.options.parallaxBackgrounds&&(b=this.$element.find("[data-stellar-background-ratio]"),this.$element.data("stellar-background-ratio")&&(b=b.add(this.$element)),b.each(function(){var b,g,h,i,j,k,l,o=a(this),p=n(o),q=0,r=0,s=0,t=0;if(o.data("stellar-backgroundIsActive")){if(o.data("stellar-backgroundIsActive")!==this)return}else o.data("stellar-backgroundIsActive",this);o.data("stellar-backgroundStartingLeft")?m(o,o.data("stellar-backgroundStartingLeft"),o.data("stellar-backgroundStartingTop")):(o.data("stellar-backgroundStartingLeft",p[0]),o.data("stellar-backgroundStartingTop",p[1])),h="auto"===o.css("margin-left")?0:parseInt(o.css("margin-left"),10),i="auto"===o.css("margin-top")?0:parseInt(o.css("margin-top"),10),j=o.offset().left-h-e,k=o.offset().top-i-f,o.parents().each(function(){var b=a(this);return b.data("stellar-offset-parent")===!0?(q=s,r=t,l=b,!1):(s+=b.position().left,void(t+=b.position().top))}),b=o.data("stellar-horizontal-offset")!==d?o.data("stellar-horizontal-offset"):l!==d&&l.data("stellar-horizontal-offset")!==d?l.data("stellar-horizontal-offset"):c.horizontalOffset,g=o.data("stellar-vertical-offset")!==d?o.data("stellar-vertical-offset"):l!==d&&l.data("stellar-vertical-offset")!==d?l.data("stellar-vertical-offset"):c.verticalOffset,c.backgrounds.push({$element:o,$offsetParent:l,isFixed:"fixed"===o.css("background-attachment"),horizontalOffset:b,verticalOffset:g,startingValueLeft:p[0],startingValueTop:p[1],startingBackgroundPositionLeft:isNaN(parseInt(p[0],10))?0:parseInt(p[0],10),startingBackgroundPositionTop:isNaN(parseInt(p[1],10))?0:parseInt(p[1],10),startingPositionLeft:o.position().left,startingPositionTop:o.position().top,startingOffsetLeft:j,startingOffsetTop:k,parentOffsetLeft:q,parentOffsetTop:r,stellarRatio:o.data("stellar-background-ratio")===d?1:o.data("stellar-background-ratio")})}))},_reset:function(){var a,b,c,d,e;for(e=this.particles.length-1;e>=0;e--)a=this.particles[e],b=a.$element.data("stellar-startingLeft"),c=a.$element.data("stellar-startingTop"),this._setPosition(a.$element,b,b,c,c),this.options.showElement(a.$element),a.$element.data("stellar-startingLeft",null).data("stellar-elementIsActive",null).data("stellar-backgroundIsActive",null);for(e=this.backgrounds.length-1;e>=0;e--)d=this.backgrounds[e],d.$element.data("stellar-backgroundStartingLeft",null).data("stellar-backgroundStartingTop",null),m(d.$element,d.startingValueLeft,d.startingValueTop)},destroy:function(){this._reset(),this.$scrollElement.unbind("resize."+this.name).unbind("scroll."+this.name),this._animationLoop=a.noop,a(b).unbind("load."+this.name).unbind("resize."+this.name)},_setOffsets:function(){var c=this,d=a(b);d.unbind("resize.horizontal-"+this.name).unbind("resize.vertical-"+this.name),"function"==typeof this.options.horizontalOffset?(this.horizontalOffset=this.options.horizontalOffset(),d.bind("resize.horizontal-"+this.name,function(){c.horizontalOffset=c.options.horizontalOffset()})):this.horizontalOffset=this.options.horizontalOffset,"function"==typeof this.options.verticalOffset?(this.verticalOffset=this.options.verticalOffset(),d.bind("resize.vertical-"+this.name,function(){c.verticalOffset=c.options.verticalOffset()})):this.verticalOffset=this.options.verticalOffset},_repositionElements:function(){var a,b,c,d,e,f,g,h,i,j,k=this._getScrollLeft(),l=this._getScrollTop(),n=!0,o=!0;if(this.currentScrollLeft!==k||this.currentScrollTop!==l||this.currentWidth!==this.viewportWidth||this.currentHeight!==this.viewportHeight){for(this.currentScrollLeft=k,this.currentScrollTop=l,this.currentWidth=this.viewportWidth,this.currentHeight=this.viewportHeight,j=this.particles.length-1;j>=0;j--)a=this.particles[j],b=a.isFixed?1:0,this.options.horizontalScrolling?(f=(k+a.horizontalOffset+this.viewportOffsetLeft+a.startingPositionLeft-a.startingOffsetLeft+a.parentOffsetLeft)*-(a.stellarRatio+b-1)+a.startingPositionLeft,h=f-a.startingPositionLeft+a.startingOffsetLeft):(f=a.startingPositionLeft,h=a.startingOffsetLeft),this.options.verticalScrolling?(g=(l+a.verticalOffset+this.viewportOffsetTop+a.startingPositionTop-a.startingOffsetTop+a.parentOffsetTop)*-(a.stellarRatio+b-1)+a.startingPositionTop,i=g-a.startingPositionTop+a.startingOffsetTop):(g=a.startingPositionTop,i=a.startingOffsetTop),this.options.hideDistantElements&&(o=!this.options.horizontalScrolling||h+a.width>(a.isFixed?0:k)&&h<(a.isFixed?0:k)+this.viewportWidth+this.viewportOffsetLeft,n=!this.options.verticalScrolling||i+a.height>(a.isFixed?0:l)&&i<(a.isFixed?0:l)+this.viewportHeight+this.viewportOffsetTop),o&&n?(a.isHidden&&(this.options.showElement(a.$element),a.isHidden=!1),this._setPosition(a.$element,f,a.startingPositionLeft,g,a.startingPositionTop)):a.isHidden||(this.options.hideElement(a.$element),a.isHidden=!0);for(j=this.backgrounds.length-1;j>=0;j--)c=this.backgrounds[j],b=c.isFixed?0:1,d=this.options.horizontalScrolling?(k+c.horizontalOffset-this.viewportOffsetLeft-c.startingOffsetLeft+c.parentOffsetLeft-c.startingBackgroundPositionLeft)*(b-c.stellarRatio)+"px":c.startingValueLeft,e=this.options.verticalScrolling?(l+c.verticalOffset-this.viewportOffsetTop-c.startingOffsetTop+c.parentOffsetTop-c.startingBackgroundPositionTop)*(b-c.stellarRatio)+"px":c.startingValueTop,m(c.$element,d,e)}},_handleScrollEvent:function(){var a=this,b=!1,c=function(){a._repositionElements(),b=!1},d=function(){b||(o(c),b=!0)};this.$scrollElement.bind("scroll."+this.name,d),d()},_startAnimationLoop:function(){var a=this;this._animationLoop=function(){o(a._animationLoop),a._repositionElements()},this._animationLoop()}},a.fn[f]=function(b){var c=arguments;return b===d||"object"==typeof b?this.each(function(){a.data(this,"plugin_"+f)||a.data(this,"plugin_"+f,new e(this,b))}):"string"==typeof b&&"_"!==b[0]&&"init"!==b?this.each(function(){var d=a.data(this,"plugin_"+f);d instanceof e&&"function"==typeof d[b]&&d[b].apply(d,Array.prototype.slice.call(c,1)),"destroy"===b&&a.data(this,"plugin_"+f,null)}):void 0},a[f]=function(){var c=a(b);return c.stellar.apply(c,Array.prototype.slice.call(arguments,0))},a[f].scrollProperty=h,a[f].positionProperty=i,b.Stellar=e}(jQuery,this,document);

/***/ }),
/* 214 */
/***/ (function(module, exports) {

	jQuery(function ($) {
	    "use strict";
	    if ($("#contactform").length != 0) {
	        $("#contactform").submit(function (e) {
	            e.preventDefault();
	            var name = $("#name").val(),
	                email = $("#email").val(),
	                subject = $("#subject").val(),
	                message = $("#message").val(),
	                dataString = 'name=' + name + '&email=' + email + '&subject=' + subject + '&message=' + message;

	            if (name === '' || !IsEmail(email) || message === '') {
	                $('#valid-issue').addClass('alert-danger').html('Please Provide Valid Information').slideDown();
	            } else {
	                $.ajax({
	                    type: "POST",
	                    url: "assets/php/submit.php",
	                    data: dataString,
	                    success: function () {
	                        $('#contactform').slideUp();
	                        $('#valid-issue').addClass('alert-success').html('Your message has been sent,<BR> We will contact you back with in next 24 hours.').show();
	                    }
	                });
	            }
	        });
	    }
	});


	function IsEmail(email) {
	    var regex = /^([a-zA-Z0-9_\.\-\+])+\@(([a-zA-Z0-9\-])+\.)+([a-zA-Z0-9]{2,4})+$/;
	    return regex.test(email);
	}




/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(216);

	jQuery(function ($) {
	    "use strict";
	    if ($('.circular-progressbar').length) {
	        enableCircularProgressbars();
	        // Check If Knob Is In Viewport
	        $(window).bind('scroll load resize', function () {
	            enableCircularProgressbars();
	        });
	    }
	});


	// Enable Circular Progressbars
	function enableCircularProgressbars() {

	    // Initialize Circular Progressbars
	    initCircularProgressbars();

	    $('.circular-progressbar').each(function () {
	        /* Knob Elements */
	        var knob = $(this).find('.circular-progressbar-inner input');
	        var knob_percent = knob.parents('.circular-progressbar-inner').find('span.knob-percent');

	        /* Knob Variables */
	        var value = knob.data('value');
	        var knob_val = knob.data('value');
	        var knob_animated = knob.hasClass('knob-animated');

	        // Animate Knob If In Viewport
	        if (isElementInViewport(knob) && !knob_animated) {

	            knob.addClass('knob-animated');
	            $({startVal: 0}).animate({startVal: knob_val},
	                {
	                    duration: 1000,
	                    easing: 'swing',
	                    step: function () {
	                        knob.val(Math.ceil(this.startVal)).trigger('change');
	                        knob_percent.html(Math.ceil(this.startVal) + '<span>%</span>');
	                    }
	                }
	            );

	        }

	    });
	}

	// init Circular ProgressBars
	function initCircularProgressbars() {
	    $('.circular-progressbar>input').each(function () {
	        var knob = $(this);
	        knob.wrap('<div class="circular-progressbar-inner"></div>');
	        knob.parent().append('<span class="knob-percent"></span>');

	        // Set the value
	        var value = $(this).val();
	        $(this).data('value', value);

	        var size = 120;
	        if ($(this).data('size')) {
	            size = $(this).data('size');
	        }
	        // Initialize Knob
	        $(this).knob({
	            min: 0,
	            max: 100,
	            width: size,
	            height: size,
	            readOnly: true,
	            displayInput: false
	        });

	        // Set The Start Value to 0
	        $(this).val(0).trigger('change');

	    });
	}


/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(e){if(true){!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(3)], __WEBPACK_AMD_DEFINE_FACTORY__ = (e), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))}else{e(jQuery)}})(function(e){"use strict";var t={},n=Math.max,r=Math.min;t.c={};t.c.d=e(document);t.c.t=function(e){return e.originalEvent.touches.length-1};t.o=function(){var n=this;this.o=null;this.$=null;this.i=null;this.g=null;this.v=null;this.cv=null;this.x=0;this.y=0;this.w=0;this.h=0;this.$c=null;this.c=null;this.t=0;this.isInit=false;this.fgColor=null;this.pColor=null;this.dH=null;this.cH=null;this.eH=null;this.rH=null;this.scale=1;this.relative=false;this.relativeWidth=false;this.relativeHeight=false;this.$div=null;this.run=function(){var t=function(e,t){var r;for(r in t){n.o[r]=t[r]}n._carve().init();n._configure()._draw()};if(this.$.data("kontroled"))return;this.$.data("kontroled",true);this.extend();this.o=e.extend({min:this.$.data("min")!==undefined?this.$.data("min"):0,max:this.$.data("max")!==undefined?this.$.data("max"):100,stopper:true,readOnly:this.$.data("readonly")||this.$.attr("readonly")==="readonly",cursor:this.$.data("cursor")===true&&30||this.$.data("cursor")||0,thickness:this.$.data("thickness")&&Math.max(Math.min(this.$.data("thickness"),1),.01)||.35,lineCap:this.$.data("linecap")||"butt",width:this.$.data("width")||200,height:this.$.data("height")||200,displayInput:this.$.data("displayinput")==null||this.$.data("displayinput"),displayPrevious:this.$.data("displayprevious"),fgColor:this.$.data("fgcolor")||"#87CEEB",inputColor:this.$.data("inputcolor"),font:this.$.data("font")||"Arial",fontWeight:this.$.data("font-weight")||"bold",inline:false,step:this.$.data("step")||1,rotation:this.$.data("rotation"),draw:null,change:null,cancel:null,release:null,format:function(e){return e},parse:function(e){return parseFloat(e)}},this.o);this.o.flip=this.o.rotation==="anticlockwise"||this.o.rotation==="acw";if(!this.o.inputColor){this.o.inputColor=this.o.fgColor}if(this.$.is("fieldset")){this.v={};this.i=this.$.find("input");this.i.each(function(t){var r=e(this);n.i[t]=r;n.v[t]=n.o.parse(r.val());r.bind("change blur",function(){var e={};e[t]=r.val();n.val(n._validate(e))})});this.$.find("legend").remove()}else{this.i=this.$;this.v=this.o.parse(this.$.val());this.v===""&&(this.v=this.o.min);this.$.bind("change blur",function(){n.val(n._validate(n.o.parse(n.$.val())))})}!this.o.displayInput&&this.$.hide();this.$c=e(document.createElement("canvas")).attr({width:this.o.width,height:this.o.height});this.$div=e('<div style="'+(this.o.inline?"display:inline;":"")+"width:"+this.o.width+"px;height:"+this.o.height+"px;"+'"></div>');this.$.wrap(this.$div).before(this.$c);this.$div=this.$.parent();if(typeof G_vmlCanvasManager!=="undefined"){G_vmlCanvasManager.initElement(this.$c[0])}this.c=this.$c[0].getContext?this.$c[0].getContext("2d"):null;if(!this.c){throw{name:"CanvasNotSupportedException",message:"Canvas not supported. Please use excanvas on IE8.0.",toString:function(){return this.name+": "+this.message}}}this.scale=(window.devicePixelRatio||1)/(this.c.webkitBackingStorePixelRatio||this.c.mozBackingStorePixelRatio||this.c.msBackingStorePixelRatio||this.c.oBackingStorePixelRatio||this.c.backingStorePixelRatio||1);this.relativeWidth=this.o.width%1!==0&&this.o.width.indexOf("%");this.relativeHeight=this.o.height%1!==0&&this.o.height.indexOf("%");this.relative=this.relativeWidth||this.relativeHeight;this._carve();if(this.v instanceof Object){this.cv={};this.copy(this.v,this.cv)}else{this.cv=this.v}this.$.bind("configure",t).parent().bind("configure",t);this._listen()._configure()._xy().init();this.isInit=true;this.$.val(this.o.format(this.v));this._draw();return this};this._carve=function(){if(this.relative){var e=this.relativeWidth?this.$div.parent().width()*parseInt(this.o.width)/100:this.$div.parent().width(),t=this.relativeHeight?this.$div.parent().height()*parseInt(this.o.height)/100:this.$div.parent().height();this.w=this.h=Math.min(e,t)}else{this.w=this.o.width;this.h=this.o.height}this.$div.css({width:this.w+"px",height:this.h+"px"});this.$c.attr({width:this.w,height:this.h});if(this.scale!==1){this.$c[0].width=this.$c[0].width*this.scale;this.$c[0].height=this.$c[0].height*this.scale;this.$c.width(this.w);this.$c.height(this.h)}return this};this._draw=function(){var e=true;n.g=n.c;n.clear();n.dH&&(e=n.dH());e!==false&&n.draw()};this._touch=function(e){var r=function(e){var t=n.xy2val(e.originalEvent.touches[n.t].pageX,e.originalEvent.touches[n.t].pageY);if(t==n.cv)return;if(n.cH&&n.cH(t)===false)return;n.change(n._validate(t));n._draw()};this.t=t.c.t(e);r(e);t.c.d.bind("touchmove.k",r).bind("touchend.k",function(){t.c.d.unbind("touchmove.k touchend.k");n.val(n.cv)});return this};this._mouse=function(e){var r=function(e){var t=n.xy2val(e.pageX,e.pageY);if(t==n.cv)return;if(n.cH&&n.cH(t)===false)return;n.change(n._validate(t));n._draw()};r(e);t.c.d.bind("mousemove.k",r).bind("keyup.k",function(e){if(e.keyCode===27){t.c.d.unbind("mouseup.k mousemove.k keyup.k");if(n.eH&&n.eH()===false)return;n.cancel()}}).bind("mouseup.k",function(e){t.c.d.unbind("mousemove.k mouseup.k keyup.k");n.val(n.cv)});return this};this._xy=function(){var e=this.$c.offset();this.x=e.left;this.y=e.top;return this};this._listen=function(){if(!this.o.readOnly){this.$c.bind("mousedown",function(e){e.preventDefault();n._xy()._mouse(e)}).bind("touchstart",function(e){e.preventDefault();n._xy()._touch(e)});this.listen()}else{this.$.attr("readonly","readonly")}if(this.relative){e(window).resize(function(){n._carve().init();n._draw()})}return this};this._configure=function(){if(this.o.draw)this.dH=this.o.draw;if(this.o.change)this.cH=this.o.change;if(this.o.cancel)this.eH=this.o.cancel;if(this.o.release)this.rH=this.o.release;if(this.o.displayPrevious){this.pColor=this.h2rgba(this.o.fgColor,"0.4");this.fgColor=this.h2rgba(this.o.fgColor,"0.6")}else{this.fgColor=this.o.fgColor}return this};this._clear=function(){this.$c[0].width=this.$c[0].width};this._validate=function(e){var t=~~((e<0?-.5:.5)+e/this.o.step)*this.o.step;return Math.round(t*100)/100};this.listen=function(){};this.extend=function(){};this.init=function(){};this.change=function(e){};this.val=function(e){};this.xy2val=function(e,t){};this.draw=function(){};this.clear=function(){this._clear()};this.h2rgba=function(e,t){var n;e=e.substring(1,7);n=[parseInt(e.substring(0,2),16),parseInt(e.substring(2,4),16),parseInt(e.substring(4,6),16)];return"rgba("+n[0]+","+n[1]+","+n[2]+","+t+")"};this.copy=function(e,t){for(var n in e){t[n]=e[n]}}};t.Dial=function(){t.o.call(this);this.startAngle=null;this.xy=null;this.radius=null;this.lineWidth=null;this.cursorExt=null;this.w2=null;this.PI2=2*Math.PI;this.extend=function(){this.o=e.extend({bgColor:this.$.data("bgcolor")||"#EEEEEE",angleOffset:this.$.data("angleoffset")||0,angleArc:this.$.data("anglearc")||360,inline:true},this.o)};this.val=function(e,t){if(null!=e){e=this.o.parse(e);if(t!==false&&e!=this.v&&this.rH&&this.rH(e)===false){return}this.cv=this.o.stopper?n(r(e,this.o.max),this.o.min):e;this.v=this.cv;this.$.val(this.o.format(this.v));this._draw()}else{return this.v}};this.xy2val=function(e,t){var i,s;i=Math.atan2(e-(this.x+this.w2),-(t-this.y-this.w2))-this.angleOffset;if(this.o.flip){i=this.angleArc-i-this.PI2}if(this.angleArc!=this.PI2&&i<0&&i>-.5){i=0}else if(i<0){i+=this.PI2}s=i*(this.o.max-this.o.min)/this.angleArc+this.o.min;this.o.stopper&&(s=n(r(s,this.o.max),this.o.min));return s};this.listen=function(){var t=this,i,s,o=function(e){e.preventDefault();var o=e.originalEvent,u=o.detail||o.wheelDeltaX,a=o.detail||o.wheelDeltaY,f=t._validate(t.o.parse(t.$.val()))+(u>0||a>0?t.o.step:u<0||a<0?-t.o.step:0);f=n(r(f,t.o.max),t.o.min);t.val(f,false);if(t.rH){clearTimeout(i);i=setTimeout(function(){t.rH(f);i=null},100);if(!s){s=setTimeout(function(){if(i)t.rH(f);s=null},200)}}},u,a,f=1,l={37:-t.o.step,38:t.o.step,39:t.o.step,40:-t.o.step};this.$.bind("keydown",function(i){var s=i.keyCode;if(s>=96&&s<=105){s=i.keyCode=s-48}u=parseInt(String.fromCharCode(s));if(isNaN(u)){s!==13&&s!==8&&s!==9&&s!==189&&(s!==190||t.$.val().match(/\./))&&i.preventDefault();if(e.inArray(s,[37,38,39,40])>-1){i.preventDefault();var o=t.o.parse(t.$.val())+l[s]*f;t.o.stopper&&(o=n(r(o,t.o.max),t.o.min));t.change(t._validate(o));t._draw();a=window.setTimeout(function(){f*=2},30)}}}).bind("keyup",function(e){if(isNaN(u)){if(a){window.clearTimeout(a);a=null;f=1;t.val(t.$.val())}}else{t.$.val()>t.o.max&&t.$.val(t.o.max)||t.$.val()<t.o.min&&t.$.val(t.o.min)}});this.$c.bind("mousewheel DOMMouseScroll",o);this.$.bind("mousewheel DOMMouseScroll",o)};this.init=function(){if(this.v<this.o.min||this.v>this.o.max){this.v=this.o.min}this.$.val(this.v);this.w2=this.w/2;this.cursorExt=this.o.cursor/100;this.xy=this.w2*this.scale;this.lineWidth=this.xy*this.o.thickness;this.lineCap=this.o.lineCap;this.radius=this.xy-this.lineWidth/2;this.o.angleOffset&&(this.o.angleOffset=isNaN(this.o.angleOffset)?0:this.o.angleOffset);this.o.angleArc&&(this.o.angleArc=isNaN(this.o.angleArc)?this.PI2:this.o.angleArc);this.angleOffset=this.o.angleOffset*Math.PI/180;this.angleArc=this.o.angleArc*Math.PI/180;this.startAngle=1.5*Math.PI+this.angleOffset;this.endAngle=1.5*Math.PI+this.angleOffset+this.angleArc;var e=n(String(Math.abs(this.o.max)).length,String(Math.abs(this.o.min)).length,2)+2;this.o.displayInput&&this.i.css({width:(this.w/2+4>>0)+"px",height:(this.w/3>>0)+"px",position:"absolute","vertical-align":"middle","margin-top":(this.w/3>>0)+"px","margin-left":"-"+(this.w*3/4+2>>0)+"px",border:0,background:"none",font:this.o.fontWeight+" "+(this.w/e>>0)+"px "+this.o.font,"text-align":"center",color:this.o.inputColor||this.o.fgColor,padding:"0px","-webkit-appearance":"none"})||this.i.css({width:"0px",visibility:"hidden"})};this.change=function(e){this.cv=e;this.$.val(this.o.format(e))};this.angle=function(e){return(e-this.o.min)*this.angleArc/(this.o.max-this.o.min)};this.arc=function(e){var t,n;e=this.angle(e);if(this.o.flip){t=this.endAngle+1e-5;n=t-e-1e-5}else{t=this.startAngle-1e-5;n=t+e+1e-5}this.o.cursor&&(t=n-this.cursorExt)&&(n=n+this.cursorExt);return{s:t,e:n,d:this.o.flip&&!this.o.cursor}};this.draw=function(){var e=this.g,t=this.arc(this.cv),n,r=1;e.lineWidth=this.lineWidth;e.lineCap=this.lineCap;if(this.o.bgColor!=="none"){e.beginPath();e.strokeStyle=this.o.bgColor;e.arc(this.xy,this.xy,this.radius,this.endAngle-1e-5,this.startAngle+1e-5,true);e.stroke()}if(this.o.displayPrevious){n=this.arc(this.v);e.beginPath();e.strokeStyle=this.pColor;e.arc(this.xy,this.xy,this.radius,n.s,n.e,n.d);e.stroke();r=this.cv==this.v}e.beginPath();e.strokeStyle=r?this.o.fgColor:this.fgColor;e.arc(this.xy,this.xy,this.radius,t.s,t.e,t.d);e.stroke()};this.cancel=function(){this.val(this.v)}};e.fn.dial=e.fn.knob=function(n){return this.each(function(){var r=new t.Dial;r.o=n;r.$=e(this);r.run()}).parent()}})

/***/ }),
/* 217 */
/***/ (function(module, exports) {

	jQuery(function ($) {

	    var $logoSticky, $logo;
	    $logo = $('.navbar-brand img').attr('src');

	    window.onscroll = function () {
	        var $ele = $('.nav-sticky');
	        var $classes;
	        if ($ele.length > 0) {
	            $classes = ($ele.data('nav-sticky-classes')) ? $ele.data('nav-sticky-classes') : 'white';
	            if ($(window).scrollTop() > 50) {
	                if ($logoSticky = $ele.data('nav-sticky-logo')) {
	                    $('.navbar-brand img').attr('src', $logoSticky)
	                }
	                $ele.addClass('sticky shadow ' + $classes);
	            } else {
	                $ele.removeClass('sticky shadow ' + $classes);
	                $('.navbar-brand img').attr('src', $logo);
	            }
	        }
	    };
	});

/***/ }),
/* 218 */
/***/ (function(module, exports) {

	jQuery(function ($) {
	    "use strict";
	    if ($('.g-map').length) {
	        $('.g-map').each(function (index, element) {
	            var map_selector = $(this).data('id'),
	                mapAddress = $(this).data('address'),
	                mapType = $(this).data('maptype'),
	                zoomLvl = $(this).data('zoomlvl');
	            $(this).attr('id', map_selector);
	            contactemaps(map_selector, mapAddress, mapType, zoomLvl);
	        });

	    }

	    function contactemaps(selector, address, type, zoom_lvl) {
	        // Specify features and elements to define styles.
	        var styleArray = [{
	            featureType: "all",
	            stylers: [{
	                saturation: -80
	            }]
	        }, {
	            featureType: "road.arterial",
	            elementType: "geometry",
	            stylers: [{
	                hue: "#00ffee"
	            }, {
	                saturation: 50
	            }]
	        }, {
	            featureType: "poi.business",
	            elementType: "labels",
	            stylers: [{
	                visibility: "off"
	            }]
	        }];
	        var map = new google.maps.Map(document.getElementById(selector), {
	            mapTypeId: google.maps.MapTypeId.type,
	            styles: styleArray,
	            scrollwheel: false,
	            draggable: false,
	            zoom: zoom_lvl,
	            mapTypeControl: false,
	        });

	        var map_pin = "assets/img/basic/pin.png";
	        var geocoder = new google.maps.Geocoder();
	        geocoder.geocode({
	                'address': address
	            },
	            function (results, status) {
	                if (status === google.maps.GeocoderStatus.OK) {
	                    new google.maps.Marker({
	                        position: results[0].geometry.location,
	                        map: map,
	                        icon: map_pin
	                    });
	                    map.setCenter(results[0].geometry.location);
	                }
	            });
	    }
	});

/***/ }),
/* 219 */
/***/ (function(module, exports) {

	(function () {
	    'use strict';
	    $("body").on("click", ".closePromotions", function (e) {
	        e.preventDefault();
	        var $this = $(this);
	        $this.parent().slideUp();
	    });
	}());

/***/ })
/******/ ]);